.TH "Mesh" 3 "27 Oct 2006" "Version 0.1.9" "Antargis" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Mesh \- 
.SH SYNOPSIS
.br
.PP
\fC#include <mesh.h>\fP
.PP
Inherits \fBSceneNode\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMesh\fP (\fBScene\fP *pScene)"
.br
.ti -1c
.RI "\fBMesh\fP (\fBScene\fP *pScene, \fBMeshData\fP &data, const \fBAGVector4\fP &pPos, float pRot)"
.br
.ti -1c
.RI "virtual \fB~Mesh\fP ()"
.br
.ti -1c
.RI "void \fBdraw\fP ()"
.br
.ti -1c
.RI "void \fBdrawDepth\fP ()"
.br
.ti -1c
.RI "void \fBdrawShadow\fP ()"
.br
.ti -1c
.RI "void \fBdrawPick\fP ()"
.br
.ti -1c
.RI "virtual \fBAGVector4\fP \fBlineHit\fP (const \fBAGLine3\fP &pLine) const "
.br
.ti -1c
.RI "virtual size_t \fBgetTriangles\fP () const "
.br
.ti -1c
.RI "void \fBsetRotation\fP (float r)"
.br
.RI "\fIset rotation around y-axis (e.g. turn people) \fP"
.ti -1c
.RI "void \fBsetColor\fP (const \fBAGVector4\fP &pColor)"
.br
.RI "\fIset color (for rings) \fP"
.ti -1c
.RI "void \fBsetVisible\fP (bool v)"
.br
.ti -1c
.RI "\fBMeshData\fP * \fBgetData\fP ()"
.br
.ti -1c
.RI "void \fBmark\fP ()"
.br
.RI "\fIoverride this function to mark your children \fP"
.ti -1c
.RI "virtual bool \fBtransparent\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
A mesh is a scenenode, that displays a mesh ;) ok, now for the real info. it contains a \fBMeshData\fP object, color and positional information. Actual drawing is done by \fBMeshData\fP. 
.PP
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Mesh::Mesh (\fBScene\fP * pScene)"
.PP
.SS "Mesh::Mesh (\fBScene\fP * pScene, \fBMeshData\fP & data, const \fBAGVector4\fP & pPos, float pRot)"
.PP
.SS "Mesh::~Mesh ()\fC [virtual]\fP"
.PP
.SH "Member Function Documentation"
.PP 
.SS "void Mesh::draw ()\fC [virtual]\fP"
.PP
Reimplemented from \fBSceneNode\fP.
.SS "void Mesh::drawDepth ()\fC [virtual]\fP"
.PP
This functions is used in the 1st depth-drawing render-pass, so you should not use colors or textures, when not needed 
.PP
Reimplemented from \fBSceneNode\fP.
.SS "void Mesh::drawPick ()\fC [virtual]\fP"
.PP
this function is used for picking objects. Picking is done one CPU, so shader-animated models are out of place here. 
.PP
Reimplemented from \fBSceneNode\fP.
.SS "void Mesh::drawShadow ()\fC [virtual]\fP"
.PP
this function is deprecated. It was once used for drawing shadow in a 3rd render-pass. 
.PP
Reimplemented from \fBSceneNode\fP.
.SS "\fBMeshData\fP * Mesh::getData ()"
.PP
.SS "size_t Mesh::getTriangles () const\fC [virtual]\fP"
.PP
Reimplemented from \fBSceneNode\fP.
.SS "\fBAGVector4\fP Mesh::lineHit (const \fBAGLine3\fP & pLine) const\fC [virtual]\fP"
.PP
Reimplemented from \fBSceneNode\fP.
.SS "void Mesh::mark ()\fC [virtual]\fP"
.PP
override this function to mark your children 
.PP
Reimplemented from \fBAGRubyObject\fP.
.SS "void Mesh::setColor (const \fBAGVector4\fP & pColor)"
.PP
set color (for rings) 
.PP
.SS "void Mesh::setRotation (float r)\fC [virtual]\fP"
.PP
set rotation around y-axis (e.g. turn people) 
.PP
Reimplemented from \fBSceneNode\fP.
.SS "void Mesh::setVisible (bool v)"
.PP
Reimplemented from \fBSceneNode\fP.
.SS "bool Mesh::transparent ()\fC [virtual]\fP"
.PP
indicates, if this object is transparent. if that's the case, it will be drawn later. drawing goes like this:1)draw all opaque objects from front to back; 2)draw transparent from back to front this is the fastest way to do this 
.PP
Reimplemented from \fBSceneNode\fP.

.SH "Author"
.PP 
Generated automatically by Doxygen for Antargis from the source code.

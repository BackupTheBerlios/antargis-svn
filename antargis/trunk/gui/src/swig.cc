/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.27
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIG_DIRECTORS

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif

/***********************************************************************
 *
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 *
 ************************************************************************/

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
#  if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#    define SWIGTEMPLATEDISAMBIGUATOR template
#  else
#    define SWIGTEMPLATEDISAMBIGUATOR 
#  endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__) || defined(__ICC)
#   define SWIGUNUSED __attribute__ ((unused)) 
# else
#   define SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods for Windows DLLs */
#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   define SWIGEXPORT
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif


/* ruby.swg */
/* Implementation : RUBY */
#define SWIGRUBY 1

#include "ruby.h"

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_OWN           0x1
#define SWIG_POINTER_DISOWN        0x2
#define SWIG_TRACK_OBJECTS	        0x4

#define NUM2USHRT(n) (\
    (0 <= NUM2UINT(n) && NUM2UINT(n) <= USHRT_MAX)\
    ? (unsigned short) NUM2UINT(n) \
    : (rb_raise(rb_eArgError, "integer %d out of range of `unsigned short'",\
               NUM2UINT(n)), (short)0)\
)

#define NUM2SHRT(n) (\
    (SHRT_MIN <= NUM2INT(n) && NUM2INT(n) <= SHRT_MAX)\
    ? (short)NUM2INT(n)\
    : (rb_raise(rb_eArgError, "integer %d out of range of `short'",\
               NUM2INT(n)), (short)0)\
)

/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
} swig_class;

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING(RB_STRING_VALUE(s))->ptr
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING(RB_STRING_VALUE(s))->len
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

/* Contract support */

#define SWIG_contract_assert(expr, msg) if (!(expr)) { rb_raise(rb_eRuntimeError, (char *) msg ); } else


/***********************************************************************
 * swigrun.swg
 *
 *     This file contains generic CAPI SWIG runtime support for pointer
 *     type checking.
 *
 ************************************************************************/

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "2"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store inforomation on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;


/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (int)(*f1 - *f2);
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/* think of this as a c++ template<> or a scheme macro */
#define SWIG_TypeCheck_Template(comparison, ty)         \
  if (ty) {                                             \
    swig_cast_info *iter = ty->cast;                    \
    while (iter) {                                      \
      if (comparison) {                                 \
        if (iter == ty->cast) return iter;              \
        /* Move iter to the top of the linked list */   \
        iter->prev->next = iter->next;                  \
        if (iter->next)                                 \
          iter->next->prev = iter->prev;                \
        iter->next = ty->cast;                          \
        iter->prev = 0;                                 \
        if (ty->cast) ty->cast->prev = iter;            \
        ty->cast = iter;                                \
        return iter;                                    \
      }                                                 \
      iter = iter->next;                                \
    }                                                   \
  }                                                     \
  return 0

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
}

/* Same as previous function, except strcmp is replaced with a pointer comparison */
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
  SWIG_TypeCheck_Template(iter->type == from, into);
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}


/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu = 0;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from 
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 ************************************************************************/

/* Global Ruby hash table to store Trackings from C/C++
   structs to Ruby Objects. */
static VALUE swig_ruby_trackings;

/* Setup a Ruby hash table to store Trackings */
static void SWIG_RubyInitializeTrackings() {
	/* Create a ruby hash table to store Trackings from C++ 
	objects to Ruby objects.  Also make sure to tell
	the garabage collector about the hash table. */
	swig_ruby_trackings = rb_hash_new();
	rb_gc_register_address(&swig_ruby_trackings);
}

/* Get a Ruby number to reference a pointer */
static VALUE SWIG_RubyPtrToReference(void* ptr) {
	/* We cast the pointer to an unsigned long
	 and then store a reference to it using
	 a Ruby number object. */

	/* Convert the pointer to a Ruby number */
	unsigned long value = (unsigned long) ptr;
	return LONG2NUM(value);
}

/* Get a Ruby number to reference an object */
static VALUE SWIG_RubyObjectToReference(VALUE object) {
	/* We cast the object to an unsigned long
	 and then store a reference to it using
	 a Ruby number object. */

	/* Convert the Object to a Ruby number */
	unsigned long value = (unsigned long) object;
	return LONG2NUM(value);
}

/* Get a Ruby object from a previously stored reference */
static VALUE SWIG_RubyReferenceToObject(VALUE reference) {
	/* The provided Ruby number object is a reference
	to the Ruby object we want.*/

	/* First convert the Ruby number to a C number */
	unsigned long value = NUM2LONG(reference);
	return (VALUE) value;
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
static void SWIG_RubyAddTracking(void* ptr, VALUE object) {
	/* In a Ruby hash table we store the pointer and
	the associated Ruby object.  The trick here is
	that we cannot store the Ruby object directly - if
	we do then it cannot be garbage collected.  So
	instead we typecast it as a unsigned long and
	convert it to a Ruby number object.*/

	/* Get a reference to the pointer as a Ruby number */
	VALUE key = SWIG_RubyPtrToReference(ptr);

	/* Get a reference to the Ruby object as a Ruby number */
	VALUE value = SWIG_RubyObjectToReference(object);

  /* Store the mapping to the global hash table. */
	rb_hash_aset(swig_ruby_trackings, key, value);
}

/* Get the Ruby object that owns the specified C/C++ struct */
static VALUE SWIG_RubyInstanceFor(void* ptr) {
	/* Get a reference to the pointer as a Ruby number */
	VALUE key = SWIG_RubyPtrToReference(ptr);

	/* Now lookup the value stored in the global hash table */
	VALUE value = rb_hash_aref(swig_ruby_trackings, key);
	
	if (value == Qnil) {
	  /* No object exists - return nil. */
		return Qnil;
	}
	else {
		/* Convert this value to Ruby object */
		return SWIG_RubyReferenceToObject(value);
	}
}

/* Remove a Tracking from a C/C++ struct to a Ruby object */
static void SWIG_RubyRemoveTracking(void* ptr) {
	/* Get a reference to the pointer as a Ruby number */
	VALUE key = SWIG_RubyPtrToReference(ptr);

	/* Define delete method - in C++ this could be marked as
	   static but unfortunately not in C. */
	VALUE delete_function = rb_intern("delete");

	/* Delete the object from the hash table by calling Ruby's
	   do this we need to call the Hash.delete method.*/
	rb_funcall(swig_ruby_trackings, delete_function, 1, key);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object */
static void SWIG_RubyUnlinkObjects(void* ptr) {
	VALUE object = SWIG_RubyInstanceFor(ptr);

	if (object != Qnil) {
		DATA_PTR(object) = 0;
	}
}

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags) \
  SWIG_Ruby_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags) \
  SWIG_Ruby_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags) \
  SWIG_Ruby_MustGetPtr(p, type, argnum, flags)
#define SWIG_GetModule(clientdata) \
  SWIG_Ruby_GetModule()
#define SWIG_SetModule(clientdata, pointer) \
  SWIG_Ruby_SetModule(pointer)

/* Ruby-specific SWIG API */

#define SWIG_InitRuntime() \
  SWIG_Ruby_InitRuntime()
#define SWIG_define_class(ty) \
  SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty) \
  SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value) \
  SWIG_Ruby_MangleStr(value)
#define SWIG_CheckConvert(value, ty) \
  SWIG_Ruby_CheckConvert(value, ty)
#define SWIG_NewPackedObj(ptr, sz, ty) \
  SWIG_Ruby_NewPackedObj(ptr, sz, ty)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)

/* rubydef.swg */
#ifdef __cplusplus
extern "C" {
#endif

static VALUE _mSWIG = Qnil;
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Initialize Ruby runtime support */
static void
SWIG_Ruby_InitRuntime(void)
{
    if (_mSWIG == Qnil) {
        _mSWIG = rb_define_module("SWIG");
    }
}

/* Define Ruby class for C type */
static void
SWIG_Ruby_define_class(swig_type_info *type)
{
    VALUE klass;
    char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    if (NIL_P(_cSWIG_Pointer)) {
	_cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
	rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
    }
    klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
    free((void *) klass_name);
}

/* Create a new pointer object */
static VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
	 int own = flags & SWIG_POINTER_OWN;
	 int track = flags & SWIG_TRACK_OBJECTS;
	 
    char *klass_name;
    swig_class *sklass;
    VALUE klass;
    VALUE obj;
    
    if (!ptr)
      return Qnil;
    
    /* Have we already wrapped this pointer? */
    if (track) {
	    obj = SWIG_RubyInstanceFor(ptr);
   	 if (obj != Qnil) {
      	return obj;
    	}
    }
		
    if (type->clientdata) {
      sklass = (swig_class *) type->clientdata;
      obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);
    } else {
      klass_name = (char *) malloc(4 + strlen(type->name) + 1);
      sprintf(klass_name, "TYPE%s", type->name);
      klass = rb_const_get(_mSWIG, rb_intern(klass_name));
      free((void *) klass_name);
      obj = Data_Wrap_Struct(klass, 0, 0, ptr);
    }
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    
    /* Keep track of this object if necessary */
    if (track) {
	   SWIG_RubyAddTracking(ptr, obj);
    }
   
    return obj;
}

/* Create a new class instance (always owned) */
static VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
    VALUE obj;
    swig_class *sklass = (swig_class *) type->clientdata;
    obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Get type mangle from class name */
static SWIGINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "__swigtype__");
  return StringValuePtr(stype);
}

/* Convert a pointer value */
static int
SWIG_Ruby_ConvertPtr(VALUE obj, void **ptr, swig_type_info *ty, int flags)
{
  char *c;
  swig_cast_info *tc;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return 0;
  } else {
    Data_Get_Struct(obj, void, *ptr);
  }
  
  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
	 if (flags & SWIG_TRACK_OBJECTS) {
      /* We are tracking objects.  Thus we change the destructor
		 * to SWIG_RubyRemoveTracking.  This allows us to
		 * remove the mapping from the C++ to Ruby object
		 * when the Ruby object is garbage collected.  If we don't
		 * do this, then it is possible we will return a reference 
		 * to a Ruby object that no longer exists thereby crashing Ruby. */
		RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
  	 } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
        if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
          if (*ptr == 0)
            rb_raise(rb_eRuntimeError, "This %s already released", ty->str);
          return 0;
        }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      if (flags & SWIG_POINTER_EXCEPTION)
        rb_raise(rb_eTypeError, "Expected %s", ty->str);
      else
        return -1;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      if (flags & SWIG_POINTER_EXCEPTION)
        rb_raise(rb_eTypeError, "Expected %s", ty->str);
      else
        return -1;
    }
    *ptr = SWIG_TypeCast(tc, *ptr);
  }
  return 0;
}

/* Convert a pointer value, signal an exception on a type mismatch */
static SWIGINLINE void *
SWIG_Ruby_MustGetPtr(VALUE obj, swig_type_info *ty, int argnum, int flags)
{
  void *result;
  SWIG_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
  return result;
}

/* Check convert */
static SWIGINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c)
    return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

static VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
static void
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return;

type_error:

  if (flags) {
    if (ty) {
      rb_raise(rb_eTypeError, "Type error. Expected %s", ty->name);
    } else {
      rb_raise(rb_eTypeError, "Expected a pointer");
    }
  }
}

static swig_module_info *SWIG_Ruby_GetModule() {
    VALUE pointer;
    swig_module_info *ret = 0;

   /* first check if pointer already created */
    pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
    if (pointer != Qnil) {
      Data_Get_Struct(pointer, swig_module_info, ret);
    }
    return ret;
}

static void SWIG_Ruby_SetModule(swig_module_info *pointer) {
      /* register a new class */
      VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
      /* create and store the structure pointer to a global variable */
      swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
      rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

#ifdef __cplusplus
}
#endif



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_AGAngle swig_types[0]
#define SWIGTYPE_p_AGApplication swig_types[1]
#define SWIGTYPE_p_AGBackground swig_types[2]
#define SWIGTYPE_p_AGBorder swig_types[3]
#define SWIGTYPE_p_AGBox3 swig_types[4]
#define SWIGTYPE_p_AGButton swig_types[5]
#define SWIGTYPE_p_AGCPPListener swig_types[6]
#define SWIGTYPE_p_AGCaption swig_types[7]
#define SWIGTYPE_p_AGCheckBox swig_types[8]
#define SWIGTYPE_p_AGCircle2 swig_types[9]
#define SWIGTYPE_p_AGCollisionData swig_types[10]
#define SWIGTYPE_p_AGColor swig_types[11]
#define SWIGTYPE_p_AGColorButton swig_types[12]
#define SWIGTYPE_p_AGDialog swig_types[13]
#define SWIGTYPE_p_AGEdit swig_types[14]
#define SWIGTYPE_p_AGEditLine swig_types[15]
#define SWIGTYPE_p_AGEvent swig_types[16]
#define SWIGTYPE_p_AGFont swig_types[17]
#define SWIGTYPE_p_AGFontEngine swig_types[18]
#define SWIGTYPE_p_AGFragProgram swig_types[19]
#define SWIGTYPE_p_AGFrame swig_types[20]
#define SWIGTYPE_p_AGGLTexture swig_types[21]
#define SWIGTYPE_p_AGGLWidget swig_types[22]
#define SWIGTYPE_p_AGHTiler swig_types[23]
#define SWIGTYPE_p_AGImage swig_types[24]
#define SWIGTYPE_p_AGInternalSurface swig_types[25]
#define SWIGTYPE_p_AGLayout swig_types[26]
#define SWIGTYPE_p_AGLayoutCreator swig_types[27]
#define SWIGTYPE_p_AGLayoutFactory swig_types[28]
#define SWIGTYPE_p_AGLine2 swig_types[29]
#define SWIGTYPE_p_AGLine3 swig_types[30]
#define SWIGTYPE_p_AGListBox swig_types[31]
#define SWIGTYPE_p_AGListBoxItem swig_types[32]
#define SWIGTYPE_p_AGListener swig_types[33]
#define SWIGTYPE_p_AGMain swig_types[34]
#define SWIGTYPE_p_AGMatrix3 swig_types[35]
#define SWIGTYPE_p_AGMatrix4 swig_types[36]
#define SWIGTYPE_p_AGMenu swig_types[37]
#define SWIGTYPE_p_AGMenuItem swig_types[38]
#define SWIGTYPE_p_AGMessageObject swig_types[39]
#define SWIGTYPE_p_AGMutex swig_types[40]
#define SWIGTYPE_p_AGPaintTarget swig_types[41]
#define SWIGTYPE_p_AGPainter swig_types[42]
#define SWIGTYPE_p_AGPoint3 swig_types[43]
#define SWIGTYPE_p_AGProjection swig_types[44]
#define SWIGTYPE_p_AGRadio swig_types[45]
#define SWIGTYPE_p_AGRadioGroup swig_types[46]
#define SWIGTYPE_p_AGRect2 swig_types[47]
#define SWIGTYPE_p_AGRect3 swig_types[48]
#define SWIGTYPE_p_AGRubyObject swig_types[49]
#define SWIGTYPE_p_AGScreen swig_types[50]
#define SWIGTYPE_p_AGScreenWidget swig_types[51]
#define SWIGTYPE_p_AGShaderParameter swig_types[52]
#define SWIGTYPE_p_AGShaderProgram swig_types[53]
#define SWIGTYPE_p_AGSignal swig_types[54]
#define SWIGTYPE_p_AGSound swig_types[55]
#define SWIGTYPE_p_AGSubMenu swig_types[56]
#define SWIGTYPE_p_AGSurface swig_types[57]
#define SWIGTYPE_p_AGTable swig_types[58]
#define SWIGTYPE_p_AGText swig_types[59]
#define SWIGTYPE_p_AGTexture swig_types[60]
#define SWIGTYPE_p_AGTextureCache swig_types[61]
#define SWIGTYPE_p_AGTheme swig_types[62]
#define SWIGTYPE_p_AGTriangle2 swig_types[63]
#define SWIGTYPE_p_AGTriangle3 swig_types[64]
#define SWIGTYPE_p_AGVTiler swig_types[65]
#define SWIGTYPE_p_AGVector2 swig_types[66]
#define SWIGTYPE_p_AGVector3 swig_types[67]
#define SWIGTYPE_p_AGVector4 swig_types[68]
#define SWIGTYPE_p_AGVertexProgram swig_types[69]
#define SWIGTYPE_p_AGWidget swig_types[70]
#define SWIGTYPE_p_AGWindow swig_types[71]
#define SWIGTYPE_p_Attributes swig_types[72]
#define SWIGTYPE_p_Document swig_types[73]
#define SWIGTYPE_p_DomParser swig_types[74]
#define SWIGTYPE_p_GLint swig_types[75]
#define SWIGTYPE_p_GLuint swig_types[76]
#define SWIGTYPE_p_Node swig_types[77]
#define SWIGTYPE_p_NodeVector swig_types[78]
#define SWIGTYPE_p_Node__NodeVector__const_iterator swig_types[79]
#define SWIGTYPE_p_Node__NodeVector__iterator swig_types[80]
#define SWIGTYPE_p_Parser swig_types[81]
#define SWIGTYPE_p_SDLKey swig_types[82]
#define SWIGTYPE_p_SDLMod swig_types[83]
#define SWIGTYPE_p_SDL_Event swig_types[84]
#define SWIGTYPE_p_SDL_PixelFormat swig_types[85]
#define SWIGTYPE_p_SDL_Rect swig_types[86]
#define SWIGTYPE_p_SDL_Surface swig_types[87]
#define SWIGTYPE_p_Uint32 swig_types[88]
#define SWIGTYPE_p_Uint8 swig_types[89]
#define SWIGTYPE_p_const_iterator swig_types[90]
#define SWIGTYPE_p_float swig_types[91]
#define SWIGTYPE_p_iterator swig_types[92]
#define SWIGTYPE_p_p_Node swig_types[93]
#define SWIGTYPE_p_std__listTAGRect2_t swig_types[94]
#define SWIGTYPE_p_std__mapTstd__string_std__string_t swig_types[95]
#define SWIGTYPE_p_std__ostringstream swig_types[96]
#define SWIGTYPE_p_std__pairTAGRect2_AGRect2_t swig_types[97]
#define SWIGTYPE_p_std__pairTstd__string_bool_t swig_types[98]
#define SWIGTYPE_p_std__string swig_types[99]
#define SWIGTYPE_p_std__vectorTAGBox3_t swig_types[100]
#define SWIGTYPE_p_std__vectorTAGLine2_t swig_types[101]
#define SWIGTYPE_p_std__vectorTAGMatrix4_t swig_types[102]
#define SWIGTYPE_p_std__vectorTAGRect3_t swig_types[103]
#define SWIGTYPE_p_std__vectorTAGVector2_t swig_types[104]
#define SWIGTYPE_p_std__vectorTAGVector4_t swig_types[105]
#define SWIGTYPE_p_std__vectorTNode_p_t swig_types[106]
#define SWIGTYPE_p_std__vectorTfloat_t swig_types[107]
#define SWIGTYPE_p_std__vectorTstd__string_t swig_types[108]
#define SWIGTYPE_p_unsigned_long swig_types[109]
static swig_type_info *swig_types[111];
static swig_module_info swig_module = {swig_types, 110, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_libantargisgui
#define SWIG_name    "Libantargisgui"

static VALUE mLibantargisgui;

static void SWIG_AsVal(VALUE obj, int *val)
{
    *val = (int) NUM2INT(obj);
}


#ifdef __cplusplus
extern "C" {
#endif
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
struct timeval rb_time_timeval(VALUE);
#endif
#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
#include "rubyio.h"
#ifdef __cplusplus
}
#endif


#include "antargisgui.h"


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


SWIGINTERN void SWIG_exception_(int code, const char *msg) {
    switch (code) {
        case SWIG_MemoryError:
            rb_raise(rb_eNoMemError, msg);
            break;
        case SWIG_IOError:
            rb_raise(rb_eIOError, msg);
            break;
        case SWIG_RuntimeError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        case SWIG_IndexError:
            rb_raise(rb_eIndexError, msg);
            break;
        case SWIG_TypeError:
            rb_raise(rb_eTypeError, msg);
            break;
        case SWIG_DivisionByZero:
            rb_raise(rb_eZeroDivError, msg);
            break;
        case SWIG_OverflowError:
            rb_raise(rb_eRangeError, msg);
            break;
        case SWIG_SyntaxError:
            rb_raise(rb_eSyntaxError, msg);
            break;
        case SWIG_ValueError:
            rb_raise(rb_eArgError, msg);
            break;
        case SWIG_SystemError:
            rb_raise(rb_eFatal, msg);
            break;
        case SWIG_UnknownError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        default:
            break;
    }
}

#define SWIG_exception(a, b) SWIG_exception_((a), (b))


#include <stdexcept>


#include <string>


#include <string>

#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))

bool SWIG_BOOL_P(VALUE) {
    // dummy test, RTEST should take care of everything
    return true;
}
bool SWIG_RB2BOOL(VALUE x) {
    return RTEST(x);
}
VALUE SWIG_BOOL2RB(bool b) {
    return b ? Qtrue : Qfalse;
}
double SWIG_NUM2DBL(VALUE x) {
    return (FIXNUM_P(x) ? FIX2INT(x) : NUM2DBL(x));
}
bool SWIG_STRING_P(VALUE x) {
    return TYPE(x) == T_STRING;
}
std::string SWIG_RB2STR(VALUE x) {
    return std::string(StringValuePtr(x));
}
VALUE SWIG_STR2RB(const std::string& s) {
    return rb_str_new2(s.c_str());
}


#include <vector>
#include <algorithm>
#include <stdexcept>


#include <map>
#include <algorithm>
#include <stdexcept>

static std::string std_vector_Sl_std_string_Sg__pop(std::vector<std::string > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                std::string x = self->back();
                self->pop_back();
                return x;
            }
static std::string std_vector_Sl_std_string_Sg____getitem__(std::vector<std::string > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_std_string_Sg____setitem__(std::vector<std::string > *self,int i,std::string x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_std_string_Sg__each(std::vector<std::string > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(SWIG_STR2RB((*self)[i]));
            }
static Node *std_vector_Sl_Node_Sm__Sg__pop(std::vector<Node * > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                Node* x = self->back();
                self->pop_back();
                return x;
            }
static Node *std_vector_Sl_Node_Sm__Sg____getitem__(std::vector<Node * > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sm__Sg____setitem__(std::vector<Node * > *self,int i,Node *x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sm__Sg__each(std::vector<Node * > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    Node* x = (*self)[i];
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_Node, 0));
                }
            }
/***********************************************************************
 * director.swg
 *
 * This file contains support for director classes that proxy
 * method calls from C++ to Ruby extensions.
 *
 * Author : Lyle Johnson (lyle@users.sourceforge.net)
 *          Based on the original Python implementation by
 *          Mark Rose (mrose@stm.lbl.gov).
 ************************************************************************/

#ifdef __cplusplus

#include <string>

namespace Swig {
  struct body_args {
    VALUE recv;
    ID id;
    int argc;
    VALUE *argv;
  };

  /* Base class for director exceptions */
  class DirectorException {
    protected:
      VALUE swig_error;
    protected:
      DirectorException(VALUE error=Qnil) : swig_error(error) {}
    public:
      VALUE getType() const  { 
        return CLASS_OF(swig_error); 
      }
      VALUE getError() const {
        return swig_error;
      }
      virtual ~DirectorException() {}
  };

  /* Type mismatch in the return value from a Ruby method call */
  class DirectorTypeMismatchException : public Swig::DirectorException {
    public:
      DirectorTypeMismatchException(const char *msg="") {
        VALUE str = rb_str_new2("Swig director type mismatch: ");
        rb_str_concat(str, rb_str_new2(msg));
        swig_error = rb_exc_new3(rb_eTypeError, str);
      }
  };

  /* Any Ruby exception that occurs during a director method call */
  class DirectorMethodException : public Swig::DirectorException {
    public:
      DirectorMethodException(VALUE error) : Swig::DirectorException(error) {}
  };

  /* Attempted to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public Swig::DirectorException {};


  /* Simple thread abstraction for pthreads on win32 */
#ifdef __THREAD__
#define __PTHREAD__
#if defined(_WIN32) || defined(__WIN32__)
#define pthread_mutex_lock EnterCriticalSection
#define pthread_mutex_unlock LeaveCriticalSection
#define pthread_mutex_t CRITICAL_SECTION
#define MUTEX_INIT(var) CRITICAL_SECTION var
#else
#include <pthread.h>
#define MUTEX_INIT(var) pthread_mutex_t var = PTHREAD_MUTEX_INITIALIZER 
#endif
#endif

  /* director base class */
  class Director {
    private:
      /* pointer to the wrapped Ruby object */
      VALUE swig_self;
      /* flag indicating whether the object is owned by Ruby or c++ */
      mutable bool swig_disown_flag;
      /* shared flag for breaking recursive director calls */
      static bool swig_up;

#ifdef __PTHREAD__
      /* locks for sharing the swig_up flag in a threaded environment */
      static pthread_mutex_t swig_mutex_up;
      static bool swig_mutex_active;
      static pthread_t swig_mutex_thread;
#endif

      /* reset the swig_up flag once the routing direction has been determined */
#ifdef __PTHREAD__
      void swig_clear_up() const { 
        Swig::Director::swig_up = false; 
        Swig::Director::swig_mutex_active = false;
        pthread_mutex_unlock(&swig_mutex_up);
      }
#else
      void swig_clear_up() const { 
        Swig::Director::swig_up = false; 
      }
#endif

    public:
      /* wrap a Ruby object, optionally taking ownership */
      Director(VALUE self) : swig_self(self), swig_disown_flag(false) {
      }

      /* discard our reference at destruction */
      virtual ~Director() {
      }

      /* return a pointer to the wrapped Ruby object */
      VALUE swig_get_self() const { 
        return swig_self; 
      }

      /* get the swig_up flag to determine if the method call should be routed
       * to the c++ base class or through the wrapped Ruby object
       */
#ifdef __PTHREAD__
      bool swig_get_up() const { 
        if (Swig::Director::swig_mutex_active) {
          if (pthread_equal(Swig::Director::swig_mutex_thread, pthread_self())) {
            bool up = swig_up;
            swig_clear_up();
            return up;
          }
        }
        return false;
      }
#else 
      bool swig_get_up() const { 
        bool up = swig_up;
        swig_up = false;
        return up;
      }
#endif

      /* set the swig_up flag if the next method call should be directed to
       * the c++ base class rather than the wrapped Ruby object
       */
#ifdef __PTHREAD__
      void swig_set_up() const { 
        pthread_mutex_lock(&Swig::Director::swig_mutex_up);
        Swig::Director::swig_mutex_thread = pthread_self();
        Swig::Director::swig_mutex_active = true;
        Swig::Director::swig_up = true;
      }
#else 
      void swig_set_up() const { 
        Swig::Director::swig_up = true; 
      }
#endif

      /* acquire ownership of the wrapped Ruby object (the sense of "disown"
       * is from Ruby) */
      void swig_disown() const { 
        if (!swig_disown_flag) { 
          swig_disown_flag = true;
        } 
      }
  };

  bool Swig::Director::swig_up = false;

#ifdef __PTHREAD__
  MUTEX_INIT(Swig::Director::swig_mutex_up);
  pthread_t Swig::Director::swig_mutex_thread;
  bool Swig::Director::swig_mutex_active = false;
#endif

}

#endif /* __cplusplus */




/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "swig.h"

SwigDirector_AGRubyObject::SwigDirector_AGRubyObject(VALUE self): AGRubyObject(), Swig::Director(self) {
    
}



void SwigDirector_AGRubyObject::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGRubyObject::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


SwigDirector_AGRubyObject::~SwigDirector_AGRubyObject() {
}

SwigDirector_AGEvent::SwigDirector_AGEvent(VALUE self, AGListener *pCaller, std::string const &pName, SDL_Event const *pEvent): AGEvent(pCaller, pName, pEvent), Swig::Director(self) {
    
}



SwigDirector_AGEvent::~SwigDirector_AGEvent() {
}

SwigDirector_AGListener::SwigDirector_AGListener(VALUE self): AGListener(), Swig::Director(self) {
    
}



void SwigDirector_AGListener::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGRubyObject::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


SwigDirector_AGListener::~SwigDirector_AGListener() {
}

bool SwigDirector_AGListener::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCPPListener::SwigDirector_AGCPPListener(VALUE self) : Swig::Director(self) {
    
}



SwigDirector_AGCPPListener::~SwigDirector_AGCPPListener() {
}

bool SwigDirector_AGCPPListener::signal(AGEvent *m) const {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        throw Swig::DirectorPureVirtualException();
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self): AGSignal(), Swig::Director(self) {
    
}



SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self, AGMessageObject *pCaller): AGSignal(pCaller), Swig::Director(self) {
    
}



SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self, AGMessageObject *pCaller, std::string const &pName): AGSignal(pCaller, pName), Swig::Director(self) {
    
}



SwigDirector_AGSignal::~SwigDirector_AGSignal() {
}

SwigDirector_AGMessageObject::SwigDirector_AGMessageObject(VALUE self): AGMessageObject(), Swig::Director(self) {
    
}



bool SwigDirector_AGMessageObject::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMessageObject::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGRubyObject::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


SwigDirector_AGMessageObject::~SwigDirector_AGMessageObject() {
}

Uint8 SwigDirector_AGMessageObject::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


AGPoint SwigDirector_AGMessageObject::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


SwigDirector_AGWidget::SwigDirector_AGWidget(VALUE self, AGWidget *pParent, AGRect const &r): AGWidget(pParent, r), Swig::Director(self) {
    
}



bool SwigDirector_AGWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGWidget::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGWidget::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGWidget::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGWidget::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGWidget::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGWidget::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGWidget::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGWidget::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGWidget::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGWidget::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGWidget::~SwigDirector_AGWidget() {
}

bool SwigDirector_AGWidget::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGWidget::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGWidget::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGWidget::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGWidget::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGColorButton::SwigDirector_AGColorButton(VALUE self, AGWidget *pParent, AGRect const &r, int x, int y): AGColorButton(pParent, r, x, y), Swig::Director(self) {
    
}



bool SwigDirector_AGColorButton::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGColorButton::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGColorButton::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGColorButton::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGColorButton::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGColorButton::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGColorButton::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGColorButton::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGColorButton::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGColorButton::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGColorButton::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGColorButton::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGColorButton::~SwigDirector_AGColorButton() {
}

bool SwigDirector_AGColorButton::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGColorButton::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGColorButton::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGColorButton::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGColorButton::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGColorButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGColorButton::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGColorButton::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGColorButton::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGColorButton::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGGLWidget::SwigDirector_AGGLWidget(VALUE self, AGWidget *pParent, AGRect const &r): AGGLWidget(pParent, r), Swig::Director(self) {
    
}



bool SwigDirector_AGGLWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGGLWidget::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGGLWidget::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGGLWidget::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGGLWidget::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGGLWidget::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGGLWidget::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGGLWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGGLWidget::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGGLWidget::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGGLWidget::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGGLWidget::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGGLWidget::~SwigDirector_AGGLWidget() {
}

bool SwigDirector_AGGLWidget::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGGLWidget::drawGL() {
    VALUE result;
    
    if (swig_get_up()) {
        AGGLWidget::drawGL();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawGL"), 0, NULL);
}


void SwigDirector_AGGLWidget::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGGLWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGGLWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGGLWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


bool SwigDirector_AGGLWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGGLWidget::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGGLWidget::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGGLWidget::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_Parser::SwigDirector_Parser(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_Parser::simpleTag(std::string const &pName, Node::Attributes const &pAttributes) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::simpleTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj((void *) &pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("simpleTag"), 2,obj0,obj1);
}


SwigDirector_Parser::~SwigDirector_Parser() {
}

void SwigDirector_Parser::startTag(std::string const &pName, Node::Attributes const &pAttributes) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::startTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj((void *) &pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("startTag"), 2,obj0,obj1);
}


void SwigDirector_Parser::endTag(std::string const &pName) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::endTag(pName);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("endTag"), 1,obj0);
}


void SwigDirector_Parser::text(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::text(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("text"), 1,obj0);
}


void SwigDirector_Parser::comment(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::comment(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("comment"), 1,obj0);
}


void SwigDirector_Parser::header(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::header(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("header"), 1,obj0);
}


SwigDirector_DomParser::SwigDirector_DomParser(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_DomParser::simpleTag(std::string const &pName, Node::Attributes const &pAttributes) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::simpleTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj((void *) &pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("simpleTag"), 2,obj0,obj1);
}


SwigDirector_DomParser::~SwigDirector_DomParser() {
}

void SwigDirector_DomParser::startTag(std::string const &pName, Node::Attributes const &pAttributes) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::startTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj((void *) &pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("startTag"), 2,obj0,obj1);
}


void SwigDirector_DomParser::endTag(std::string const &pName) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::endTag(pName);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("endTag"), 1,obj0);
}


void SwigDirector_DomParser::text(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::text(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("text"), 1,obj0);
}


void SwigDirector_DomParser::comment(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::comment(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("comment"), 1,obj0);
}


void SwigDirector_DomParser::header(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::header(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("header"), 1,obj0);
}


SwigDirector_AGLayout::SwigDirector_AGLayout(VALUE self, AGWidget *pgParent, std::string const &pXMLData): AGLayout(pgParent, pXMLData), Swig::Director(self) {
    
}



bool SwigDirector_AGLayout::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGLayout::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGLayout::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGLayout::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGLayout::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGLayout::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGLayout::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGLayout::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGLayout::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGLayout::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGLayout::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGLayout::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGLayout::~SwigDirector_AGLayout() {
}

bool SwigDirector_AGLayout::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGLayout::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGLayout::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGLayout::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGLayout::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGLayout::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGLayout::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGLayout::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGDialog::SwigDirector_AGDialog(VALUE self, AGWidget *pgParent, std::string const &pXMLData): AGDialog(pgParent, pXMLData), Swig::Director(self) {
    
}



bool SwigDirector_AGDialog::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGDialog::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGDialog::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGDialog::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGDialog::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGDialog::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGDialog::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGDialog::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGDialog::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGDialog::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGDialog::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGDialog::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGDialog::~SwigDirector_AGDialog() {
}

bool SwigDirector_AGDialog::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventOk(AGEvent *event) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventOk(event);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventOk"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventCancel(AGEvent *event) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventCancel(event);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventCancel"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventClose(AGEvent *event) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventClose(event);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventClose"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGDialog::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGDialog::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGDialog::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGDialog::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGDialog::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGDialog::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGDialog::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGApplication::SwigDirector_AGApplication(VALUE self): AGApplication(), Swig::Director(self) {
    
}



bool SwigDirector_AGApplication::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventKeyDown(AGEvent *m2) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventKeyDown(m2);
    }
    obj0 = SWIG_NewPointerObj((void *) m2, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


void SwigDirector_AGApplication::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGRubyObject::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_AGApplication::eventFrame(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrame(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrame"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventFrameEnd(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrameEnd(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrameEnd"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::eventChangedRes() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::eventChangedRes();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventChangedRes"), 0, NULL);
}


SwigDirector_AGApplication::~SwigDirector_AGApplication() {
}

bool SwigDirector_AGApplication::eventIdle() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventIdle();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventIdle"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::tryQuit() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::tryQuit();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("tryQuit"), 0, NULL);
}


Uint8 SwigDirector_AGApplication::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


AGPoint SwigDirector_AGApplication::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


void SwigDirector_AGApplication::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_AGApplication::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


SwigDirector_AGButton::SwigDirector_AGButton(VALUE self, AGWidget *pParent, AGRect const &r, std::string const &pText, int id): AGButton(pParent, r, pText, id), Swig::Director(self) {
    
}



bool SwigDirector_AGButton::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGButton::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGButton::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGButton::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGButton::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGButton::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGButton::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGButton::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


AGRect SwigDirector_AGButton::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGButton::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGButton::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGButton::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


std::string SwigDirector_AGButton::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGButton::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGButton::~SwigDirector_AGButton() {
}

bool SwigDirector_AGButton::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_AGButton::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGButton::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGButton::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGButton::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGButton::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGButton::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGButton::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGButton::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGButton::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGText::SwigDirector_AGText(VALUE self, AGWidget *pParent, AGRect const &pRect, std::string const &pText, AGFont const &pFont): AGText(pParent, pRect, pText, pFont), Swig::Director(self) {
    
}



bool SwigDirector_AGText::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGText::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGText::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGText::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGText::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGText::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGText::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGText::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGText::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGText::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGText::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGText::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGText::~SwigDirector_AGText() {
}

bool SwigDirector_AGText::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGText::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGText::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGText::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGText::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGText::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGText::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGText::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGText::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGCaption::SwigDirector_AGCaption(VALUE self, AGWidget *pParent, AGRect const &pRect, std::string const &pText, AGFont const &pFont, AGBackground const &pBG): AGCaption(pParent, pRect, pText, pFont, pBG), Swig::Director(self) {
    
}



bool SwigDirector_AGCaption::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGCaption::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGCaption::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGCaption::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGCaption::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGCaption::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGCaption::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGCaption::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGCaption::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGCaption::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGCaption::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGCaption::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCaption::~SwigDirector_AGCaption() {
}

bool SwigDirector_AGCaption::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGCaption::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGCaption::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGCaption::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGCaption::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGCaption::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGCaption::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGCaption::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGCaption::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGCheckBox::SwigDirector_AGCheckBox(VALUE self, AGWidget *pParent, AGRect pRect): AGCheckBox(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGCheckBox::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGCheckBox::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGCheckBox::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGCheckBox::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGCheckBox::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGCheckBox::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGCheckBox::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGCheckBox::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


AGRect SwigDirector_AGCheckBox::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGCheckBox::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGCheckBox::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGCheckBox::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


std::string SwigDirector_AGCheckBox::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGCheckBox::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCheckBox::~SwigDirector_AGCheckBox() {
}

bool SwigDirector_AGCheckBox::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGCheckBox::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_AGCheckBox::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGCheckBox::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGCheckBox::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGCheckBox::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGCheckBox::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGCheckBox::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGCheckBox::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGCheckBox::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGCheckBox::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGEditLine::SwigDirector_AGEditLine(VALUE self, std::string const &pText, AGFont pFont, bool pHardEnd): AGEditLine(pText, pFont, pHardEnd), Swig::Director(self) {
    
}



SwigDirector_AGEditLine::~SwigDirector_AGEditLine() {
}

void SwigDirector_AGEditLine::draw(AGPainter &p, AGPoint const &pPoint, AGRect const &pClip) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEditLine::draw(p,pPoint,pClip);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    obj1 = SWIG_NewPointerObj((void *) &pPoint, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &pClip, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGEditLine::drawCursor(AGPainter &p, int cx, AGPoint const &pPoint, AGRect const &pClip, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEditLine::drawCursor(p,cx,pPoint,pClip,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    obj1 = INT2NUM(cx);
    obj2 = SWIG_NewPointerObj((void *) &pPoint, SWIGTYPE_p_AGVector2,0);
    obj3 = SWIG_NewPointerObj((void *) &pClip, SWIGTYPE_p_AGRect2,0);
    obj4 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawCursor"), 5,obj0,obj1,obj2,obj3,obj4);
}


SwigDirector_AGEdit::SwigDirector_AGEdit(VALUE self, AGWidget *pParent, AGRect const &pRect): AGEdit(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGEdit::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGEdit::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGEdit::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGEdit::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGEdit::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGEdit::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGEdit::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


AGRect SwigDirector_AGEdit::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGEdit::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGEdit::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGEdit::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGEdit::~SwigDirector_AGEdit() {
}

bool SwigDirector_AGEdit::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGEdit::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGEdit::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGEdit::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGEdit::drawBackground(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::drawBackground(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawBackground"), 1,obj0);
}


bool SwigDirector_AGEdit::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGEdit::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGEdit::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGEdit::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGPaintTarget::SwigDirector_AGPaintTarget(VALUE self) : Swig::Director(self) {
    
}



AGRect SwigDirector_AGPaintTarget::getRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGPaintTarget::getRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


SwigDirector_AGPaintTarget::~SwigDirector_AGPaintTarget() {
}

void SwigDirector_AGPaintTarget::drawLine(AGPoint const &p0, AGPoint const &p1, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p0, SWIGTYPE_p_AGVector2,0);
    obj1 = SWIG_NewPointerObj((void *) &p1, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPaintTarget::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGTriangle2,0);
    obj2 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGTriangle2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPaintTarget::fillRect(AGRect const &pr, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRect(pr,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRect"), 2,obj0,obj1);
}


void SwigDirector_AGPaintTarget::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


AGColor SwigDirector_AGPaintTarget::getPixel(int x, int y) const {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGPaintTarget::getPixel(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("getPixel"), 2,obj0,obj1);
    {
        AGColor *b;
        Data_Get_Struct(result,AGColor,b);
        c_result=*b;
    }
    return (AGColor) c_result;
}


void SwigDirector_AGPaintTarget::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGPaintTarget::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPaintTarget::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPaintTarget::beginPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::beginPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("beginPaint"), 0, NULL);
}


void SwigDirector_AGPaintTarget::endPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::endPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("endPaint"), 0, NULL);
}


SwigDirector_AGTexture::SwigDirector_AGTexture(VALUE self): AGTexture(), Swig::Director(self) {
    
}



SwigDirector_AGTexture::SwigDirector_AGTexture(VALUE self, AGSurface const &pSurface, bool p3d): AGTexture(pSurface, p3d), Swig::Director(self) {
    
}



SwigDirector_AGTexture::SwigDirector_AGTexture(VALUE self, AGTexture const &t): AGTexture(t), Swig::Director(self) {
    
}



SwigDirector_AGTexture::SwigDirector_AGTexture(VALUE self, int W, int H): AGTexture(W, H), Swig::Director(self) {
    
}



AGRect SwigDirector_AGTexture::getRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGTexture::getRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


SwigDirector_AGTexture::~SwigDirector_AGTexture() {
}

void SwigDirector_AGTexture::drawLine(AGPoint const &p0, AGPoint const &p1, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p0, SWIGTYPE_p_AGVector2,0);
    obj1 = SWIG_NewPointerObj((void *) &p1, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGTexture::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGTriangle2,0);
    obj2 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGTriangle2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


AGColor SwigDirector_AGTexture::getPixel(int x, int y) const {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGTexture::getPixel(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("getPixel"), 2,obj0,obj1);
    {
        AGColor *b;
        Data_Get_Struct(result,AGColor,b);
        c_result=*b;
    }
    return (AGColor) c_result;
}


void SwigDirector_AGTexture::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGTexture::fillRect(AGRect const &pRect, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::fillRect(pRect,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pRect, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRect"), 2,obj0,obj1);
}


void SwigDirector_AGTexture::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGTexture::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGTexture::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGTexture::beginPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::beginPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("beginPaint"), 0, NULL);
}


void SwigDirector_AGTexture::endPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::endPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("endPaint"), 0, NULL);
}


SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self): AGSurface(), Swig::Director(self) {
    
}



SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self, int w, int h): AGSurface(w, h), Swig::Director(self) {
    
}



SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self, AGSurface const &p): AGSurface(p), Swig::Director(self) {
    
}



AGRect SwigDirector_AGSurface::getRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSurface::getRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


void SwigDirector_AGSurface::drawLine(AGPoint const &p0, AGPoint const &p1, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p0, SWIGTYPE_p_AGVector2,0);
    obj1 = SWIG_NewPointerObj((void *) &p1, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


SwigDirector_AGSurface::~SwigDirector_AGSurface() {
}

void SwigDirector_AGSurface::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGTriangle2,0);
    obj2 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGTriangle2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::fillRect(AGRect const &pr, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRect(pr,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRect"), 2,obj0,obj1);
}


void SwigDirector_AGSurface::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


AGColor SwigDirector_AGSurface::getPixel(int x, int y) const {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSurface::getPixel(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("getPixel"), 2,obj0,obj1);
    {
        AGColor *b;
        Data_Get_Struct(result,AGColor,b);
        c_result=*b;
    }
    return (AGColor) c_result;
}


void SwigDirector_AGSurface::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGSurface::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGSurface::beginPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::beginPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("beginPaint"), 0, NULL);
}


void SwigDirector_AGSurface::endPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::endPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("endPaint"), 0, NULL);
}


SwigDirector_AGImage::SwigDirector_AGImage(VALUE self, AGWidget *pParent, AGRect const &r, AGSurface pSurface, bool pTile, AGRect const &pRect): AGImage(pParent, r, pSurface, pTile, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGImage::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGImage::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGImage::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGImage::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGImage::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGImage::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGImage::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGImage::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGImage::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGImage::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGImage::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGImage::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGImage::~SwigDirector_AGImage() {
}

bool SwigDirector_AGImage::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGImage::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGImage::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGImage::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGImage::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGImage::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGImage::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGImage::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGImage::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGLayoutCreator::SwigDirector_AGLayoutCreator(VALUE self, std::string const &pName): AGLayoutCreator(pName), Swig::Director(self) {
    
}



SwigDirector_AGLayoutCreator::~SwigDirector_AGLayoutCreator() {
}

AGWidget *SwigDirector_AGLayoutCreator::create(AGWidget *pParent, AGRect const &pRect, xmlpp::Node const &pNode) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    AGWidget *c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGLayoutCreator::create(pParent,pRect,pNode);
    }
    obj0 = SWIG_NewPointerObj((void *) pParent, SWIGTYPE_p_AGWidget,0);
    obj1 = SWIG_NewPointerObj((void *) &pRect, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pNode, SWIGTYPE_p_Node,0);
    result = rb_funcall(swig_get_self(), rb_intern("create"), 3,obj0,obj1,obj2);
    if ((SWIG_ConvertPtr(result,(void **) &c_result, SWIGTYPE_p_AGWidget,SWIG_POINTER_EXCEPTION | 0 )) == -1) throw Swig::DirectorTypeMismatchException("Pointer conversion failed.");
    return (AGWidget *) c_result;
}


SwigDirector_AGVTiler::SwigDirector_AGVTiler(VALUE self, AGWidget *pParent, AGRect const &pRect, bool pAdaptMyHeight): AGVTiler(pParent, pRect, pAdaptMyHeight), Swig::Director(self) {
    
}



bool SwigDirector_AGVTiler::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGVTiler::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGVTiler::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGVTiler::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGVTiler::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


float SwigDirector_AGVTiler::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGVTiler::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGVTiler::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGVTiler::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGVTiler::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGVTiler::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGVTiler::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGVTiler::~SwigDirector_AGVTiler() {
}

bool SwigDirector_AGVTiler::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGVTiler::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGVTiler::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGVTiler::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGVTiler::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGVTiler::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGVTiler::addChild(AGWidget *pWidget) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) pWidget, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGVTiler::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGHTiler::SwigDirector_AGHTiler(VALUE self, AGWidget *pParent, AGRect const &pRect, bool pAdaptMyHeight): AGHTiler(pParent, pRect, pAdaptMyHeight), Swig::Director(self) {
    
}



bool SwigDirector_AGHTiler::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGHTiler::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGHTiler::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGHTiler::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGHTiler::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGHTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


float SwigDirector_AGHTiler::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGHTiler::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGHTiler::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGHTiler::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGHTiler::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGHTiler::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGHTiler::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGHTiler::~SwigDirector_AGHTiler() {
}

bool SwigDirector_AGHTiler::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGHTiler::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGHTiler::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGHTiler::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGHTiler::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGHTiler::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGHTiler::addChild(AGWidget *pWidget) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) pWidget, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGHTiler::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGListBox::SwigDirector_AGListBox(VALUE self, AGWidget *pParent, AGRect const &pRect): AGListBox(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGListBox::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGListBox::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGListBox::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGListBox::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGListBox::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGListBox::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGListBox::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGListBox::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGListBox::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGListBox::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGListBox::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGListBox::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGListBox::~SwigDirector_AGListBox() {
}

bool SwigDirector_AGListBox::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListBox::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListBox::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGListBox::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGListBox::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGListBox::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGListBox::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGListBox::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGListBox::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGListBox::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGListBox::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGMenu::SwigDirector_AGMenu(VALUE self, AGWidget *pParent, AGPoint pWishPos, std::string const &pName): AGMenu(pParent, pWishPos, pName), Swig::Director(self) {
    
}



bool SwigDirector_AGMenu::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGMenu::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGMenu::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGMenu::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGMenu::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


float SwigDirector_AGMenu::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGMenu::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGMenu::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGMenu::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGMenu::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGMenu::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGMenu::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGMenu::~SwigDirector_AGMenu() {
}

bool SwigDirector_AGMenu::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGMenu::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGMenu::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGMenu::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGMenu::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGMenu::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGMenu::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGMenu::addChild(AGWidget *pWidget) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) pWidget, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGMenu::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGMenuItem::SwigDirector_AGMenuItem(VALUE self, AGWidget *pParent, std::string const &pText): AGMenuItem(pParent, pText), Swig::Director(self) {
    
}



bool SwigDirector_AGMenuItem::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenuItem::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGMenuItem::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGMenuItem::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGMenuItem::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGMenuItem::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenuItem::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGHTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


float SwigDirector_AGMenuItem::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGMenuItem::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGMenuItem::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGMenuItem::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGMenuItem::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGMenuItem::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGMenuItem::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGMenuItem::~SwigDirector_AGMenuItem() {
}

bool SwigDirector_AGMenuItem::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenuItem::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_AGMenuItem::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenuItem::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGMenuItem::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGMenuItem::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGMenuItem::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGMenuItem::eventSelect() {
    VALUE result;
    
    if (swig_get_up()) {
        AGMenuItem::eventSelect();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSelect"), 0, NULL);
}


void SwigDirector_AGMenuItem::eventUnselect() {
    VALUE result;
    
    if (swig_get_up()) {
        AGMenuItem::eventUnselect();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventUnselect"), 0, NULL);
}


bool SwigDirector_AGMenuItem::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenuItem::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenuItem::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGMenuItem::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGMenuItem::addChild(AGWidget *pWidget) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) pWidget, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGMenuItem::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGSubMenu::SwigDirector_AGSubMenu(VALUE self, AGWidget *pParent, std::string const &ptext): AGSubMenu(pParent, ptext), Swig::Director(self) {
    
}



bool SwigDirector_AGSubMenu::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSubMenu::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGSubMenu::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGSubMenu::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGSubMenu::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGSubMenu::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSubMenu::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGHTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


float SwigDirector_AGSubMenu::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGSubMenu::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGSubMenu::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGSubMenu::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGSubMenu::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGSubMenu::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGSubMenu::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSubMenu::~SwigDirector_AGSubMenu() {
}

bool SwigDirector_AGSubMenu::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSubMenu::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSubMenu::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_AGSubMenu::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSubMenu::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGSubMenu::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGSubMenu::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGMenuItem::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGSubMenu::eventSelect() {
    VALUE result;
    
    if (swig_get_up()) {
        AGSubMenu::eventSelect();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSelect"), 0, NULL);
}


void SwigDirector_AGSubMenu::eventUnselect() {
    VALUE result;
    
    if (swig_get_up()) {
        AGSubMenu::eventUnselect();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventUnselect"), 0, NULL);
}


bool SwigDirector_AGSubMenu::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSubMenu::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSubMenu::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGSubMenu::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGSubMenu::addChild(AGWidget *pWidget) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) pWidget, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGSubMenu::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGSound::SwigDirector_AGSound(VALUE self): AGSound(), Swig::Director(self) {
    
}



bool SwigDirector_AGSound::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGSound::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGSound::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGSound::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGSound::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGSound::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGSound::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGSound::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGSound::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGSound::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGSound::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGSound::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSound::~SwigDirector_AGSound() {
}

bool SwigDirector_AGSound::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGSound::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGSound::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGSound::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGSound::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGSound::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGSound::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGSound::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGRadioGroup::SwigDirector_AGRadioGroup(VALUE self, AGWidget *pParent, AGRect const &pr): AGRadioGroup(pParent, pr), Swig::Director(self) {
    
}



bool SwigDirector_AGRadioGroup::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGRadioGroup::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGRadioGroup::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGRadioGroup::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGRadioGroup::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGRadioGroup::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGRadioGroup::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGRadioGroup::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGRadioGroup::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::eventChange(std::string const &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGRadioGroup::eventChange(p);
        return;
    }
    obj0=rb_str_new2(p.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("eventChange"), 1,obj0);
}


SwigDirector_AGRadioGroup::~SwigDirector_AGRadioGroup() {
}

bool SwigDirector_AGRadioGroup::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGRadioGroup::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGRadioGroup::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGRadioGroup::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGRadioGroup::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGRadioGroup::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGRadioGroup::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGRadioGroup::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGRadio::SwigDirector_AGRadio(VALUE self, AGWidget *pParent, AGRect pRect): AGRadio(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGRadio::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGRadio::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGRadio::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGRadio::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGRadio::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGRadio::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGRadio::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGRadio::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGRadio::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


AGRect SwigDirector_AGRadio::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGRadio::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGRadio::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGRadio::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


std::string SwigDirector_AGRadio::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGRadio::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGRadio::~SwigDirector_AGRadio() {
}

bool SwigDirector_AGRadio::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGRadio::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_AGRadio::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGRadio::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGRadio::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGRadio::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGRadio::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGRadio::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGRadio::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGRadio::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGRadio::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGScreen::SwigDirector_AGScreen(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_AGScreen::endPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::endPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("endPaint"), 0, NULL);
}


void SwigDirector_AGScreen::beginPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::beginPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("beginPaint"), 0, NULL);
}


void SwigDirector_AGScreen::drawLine(AGPoint const &p0, AGPoint const &p1, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p0, SWIGTYPE_p_AGVector2,0);
    obj1 = SWIG_NewPointerObj((void *) &p1, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


SwigDirector_AGScreen::~SwigDirector_AGScreen() {
}

AGColor SwigDirector_AGScreen::getPixel(int x, int y) const {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGPaintTarget::getPixel(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("getPixel"), 2,obj0,obj1);
    {
        AGColor *b;
        Data_Get_Struct(result,AGColor,b);
        c_result=*b;
    }
    return (AGColor) c_result;
}


AGRect SwigDirector_AGScreen::getRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGPaintTarget::getRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


size_t SwigDirector_AGScreen::getWidth() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGScreen::getWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getWidth"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


size_t SwigDirector_AGScreen::getHeight() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGScreen::getHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getHeight"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_AGScreen::begin() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::begin();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("begin"), 0, NULL);
}


void SwigDirector_AGScreen::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGScreen::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGScreen::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGScreen::flip() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::flip();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("flip"), 0, NULL);
}


void SwigDirector_AGScreen::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGScreen::fillRect(AGRect const &pr, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRect(pr,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRect"), 2,obj0,obj1);
}


void SwigDirector_AGScreen::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGTriangle2,0);
    obj2 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGTriangle2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


SwigDirector_AGTable::SwigDirector_AGTable(VALUE self, AGWidget *pWidget, AGRect const &pRect): AGTable(pWidget, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGTable::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGTable::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGTable::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGTable::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGTable::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGTable::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGTable::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGTable::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGTable::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGTable::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGTable::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGTable::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGTable::~SwigDirector_AGTable() {
}

bool SwigDirector_AGTable::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGTable::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGTable::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGTable::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGTable::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGTable::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGTable::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGTable::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGTable::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGTable::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGTheme::SwigDirector_AGTheme(VALUE self): AGTheme(), Swig::Director(self) {
    
}



SwigDirector_AGTheme::~SwigDirector_AGTheme() {
}

SwigDirector_AGWindow::SwigDirector_AGWindow(VALUE self, AGWidget *pWidget, AGRect const &pRect, std::string const &pTitle, std::string const &pTheme): AGWindow(pWidget, pRect, pTitle, pTheme), Swig::Director(self) {
    
}



bool SwigDirector_AGWindow::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGWindow::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGWindow::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGWindow::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGWindow::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGWindow::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGWindow::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGWindow::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGPoint SwigDirector_AGWindow::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGWindow::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGWindow::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGWindow::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


SwigDirector_AGWindow::~SwigDirector_AGWindow() {
}

bool SwigDirector_AGWindow::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGWindow::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGWindow::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGWindow::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGWindow::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGWindow::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGWindow::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGWindow::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGWindow::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWindow::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGWindow::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGFrame::SwigDirector_AGFrame(VALUE self, AGWidget *pParent, AGRect const &pRect, size_t width): AGFrame(pParent, pRect, width), Swig::Director(self) {
    
}



SwigDirector_AGFrame::SwigDirector_AGFrame(VALUE self, AGWidget *pParent, AGRect const &pRect, AGBorder const &pBorder): AGFrame(pParent, pRect, pBorder), Swig::Director(self) {
    
}



bool SwigDirector_AGFrame::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGFrame::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGFrame::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGFrame::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGFrame::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGFrame::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGFrame::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGFrame::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGFrame::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGPoint SwigDirector_AGFrame::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGFrame::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGFrame::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGFrame::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGFrame::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


SwigDirector_AGFrame::~SwigDirector_AGFrame() {
}

bool SwigDirector_AGFrame::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGFrame::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGFrame::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGFrame::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGFrame::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGFrame::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGFrame::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGFrame::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGFrame::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGFrame::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGFrame::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGFrame::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGScreenWidget::SwigDirector_AGScreenWidget(VALUE self): AGScreenWidget(), Swig::Director(self) {
    
}



bool SwigDirector_AGScreenWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGScreenWidget::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGScreenWidget::eventDragBy(AGEvent *event, AGPoint const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGScreenWidget::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGScreenWidget::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGScreenWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect SwigDirector_AGScreenWidget::getClientRect() const {
    AGRect c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect *b;
        Data_Get_Struct(result,AGRect,b);
        c_result=*b;
    }
    return (AGRect) c_result;
}


AGPoint SwigDirector_AGScreenWidget::getMousePosition() const {
    AGPoint c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGPoint *b;
        Data_Get_Struct(result,AGPoint,b);
        c_result=*b;
    }
    return (AGPoint) c_result;
}


Uint8 SwigDirector_AGScreenWidget::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGScreenWidget::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGScreenWidget::~SwigDirector_AGScreenWidget() {
}

bool SwigDirector_AGScreenWidget::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGScreenWidget::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGScreenWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGScreenWidget::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGScreenWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGScreenWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGScreenWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGScreenWidget::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGScreenWidget::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGScreenWidget::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGScreenWidget::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGShaderProgram::SwigDirector_AGShaderProgram(VALUE self, std::string const &pVertexFile, std::string const &pFragFile): AGShaderProgram(pVertexFile, pFragFile), Swig::Director(self) {
    
}



void SwigDirector_AGShaderProgram::doUpdate(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGShaderProgram::doUpdate(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("doUpdate"), 1,obj0);
}


SwigDirector_AGShaderProgram::~SwigDirector_AGShaderProgram() {
}

void SwigDirector_AGShaderProgram::enable() {
    VALUE result;
    
    if (swig_get_up()) {
        AGShaderProgram::enable();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("enable"), 0, NULL);
}


void SwigDirector_AGShaderProgram::disable() {
    VALUE result;
    
    if (swig_get_up()) {
        AGShaderProgram::disable();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("disable"), 0, NULL);
}


swig_class cStringVector;

static VALUE
_wrap_new_StringVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<std::string > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<std::string > *)new std::vector<std::string >(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_StringVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<std::string > *)new std::vector<std::string >();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_StringVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::string *arg2 = 0 ;
    std::vector<std::string > *result;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (std::vector<std::string > *)new std::vector<std::string >(arg1,(std::string const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_StringVector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_StringVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTstd__string_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_StringVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = 0 ;
    std::vector<std::string > *result;
    std::vector<std::string > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (std::vector<std::string > *)new std::vector<std::string >((std::vector<std::string > const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_StringVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_StringVector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if (SWIG_STRING_P(o))
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<std::string >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTstd__string_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_StringVector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_StringVector'");
    return Qnil;
}


static VALUE
_wrap_StringVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    unsigned int result;
    std::vector<std::string > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (unsigned int)((std::vector<std::string > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_StringVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    bool result;
    std::vector<std::string > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (bool)((std::vector<std::string > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_StringVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_StringVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->push_back(arg2);
    
    return Qnil;
}


static VALUE
_wrap_StringVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    try {
        result = std_vector_Sl_std_string_Sg__pop(arg1);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_StringVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    int arg2 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    arg2 = NUM2INT(argv[0]);
    try {
        result = std_vector_Sl_std_string_Sg____getitem__(arg1,arg2);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_StringVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    int arg2 ;
    std::string arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    arg2 = NUM2INT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg3 = std::string(StringValuePtr(argv[1]));
            arg3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    try {
        std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,arg3);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    return Qnil;
}


static VALUE
_wrap_StringVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    std_vector_Sl_std_string_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_std_string_Sg_(std::vector<std::string > *arg1) {
    delete arg1;
}

swig_class cNodeVector;

static VALUE
_wrap_new_NodeVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<Node * > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<Node * > *)new std::vector<Node * >(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_NodeVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<Node * > *)new std::vector<Node * >();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_NodeVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    Node **arg2 = 0 ;
    std::vector<Node * > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<Node * > *)new std::vector<Node * >(arg1,*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_NodeVector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_NodeVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTNode_p_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_NodeVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = 0 ;
    std::vector<Node * > *result;
    std::vector<Node * > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (std::vector<Node * > *)new std::vector<Node * >((std::vector<Node * > const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_NodeVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_NodeVector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_NodeVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            // native sequence?
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    // an empty sequence can be of any type
                    _v = 1;
                } else {
                    // check the first element only
                    Node* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_Node,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                // wrapped vector? 
                std::vector<Node* >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTNode_p_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_NodeVector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_p_Node, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_NodeVector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_NodeVector'");
    return Qnil;
}


static VALUE
_wrap_NodeVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    unsigned int result;
    std::vector<Node * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (unsigned int)((std::vector<Node * > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_NodeVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    bool result;
    std::vector<Node * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (bool)((std::vector<Node * > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_NodeVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_NodeVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    Node *arg2 = (Node *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0);
    (arg1)->push_back(arg2);
    
    return Qnil;
}


static VALUE
_wrap_NodeVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    try {
        result = (Node *)std_vector_Sl_Node_Sm__Sg__pop(arg1);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_NodeVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    int arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    arg2 = NUM2INT(argv[0]);
    try {
        result = (Node *)std_vector_Sl_Node_Sm__Sg____getitem__(arg1,arg2);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_NodeVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    int arg2 ;
    Node *arg3 = (Node *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Node, 0);
    try {
        std_vector_Sl_Node_Sm__Sg____setitem__(arg1,arg2,arg3);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    return Qnil;
}


static VALUE
_wrap_NodeVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    std_vector_Sl_Node_Sm__Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_Node_Sm__Sg_(std::vector<Node * > *arg1) {
    delete arg1;
}

swig_class cAGRubyObject;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRubyObject_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRubyObject_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRubyObject);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRubyObject(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGRubyObject *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargisgui::AGRubyObject";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGRubyObject *)new SwigDirector_AGRubyObject(arg1);
            
        } else {
            result = (AGRubyObject *)new AGRubyObject();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGRubyObject(AGRubyObject *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGRubyObject_clear(int argc, VALUE *argv, VALUE self) {
    AGRubyObject *arg1 = (AGRubyObject *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRubyObject, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_general_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, SWIG_POINTER_EXCEPTION|0);
    general_markfunc(arg1);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGRubyObject(int argc, VALUE *argv, VALUE self) {
    AGRubyObject *arg1 = (AGRubyObject *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRubyObject, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_saveDelete(int argc, VALUE *argv, VALUE self) {
    AGRubyObject *arg1 = (AGRubyObject *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRubyObject, 0);
    result = (bool)saveDelete(arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


swig_class cAGEvent;

static VALUE
_wrap_new_AGEvent__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    std::string *arg3 = 0 ;
    SDL_Event *arg4 = (SDL_Event *) 0 ;
    AGEvent *result;
    std::string temp3 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_SDL_Event, 0);
    char *classname = "Libantargisgui::AGEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEvent *)new SwigDirector_AGEvent(arg1,arg2,(std::string const &)*arg3,(SDL_Event const *)arg4);
        
    } else {
        result = (AGEvent *)new AGEvent(arg2,(std::string const &)*arg3,(SDL_Event const *)arg4);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEvent__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    std::string *arg3 = 0 ;
    AGEvent *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargisgui::AGEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEvent *)new SwigDirector_AGEvent(arg1,arg2,(std::string const &)*arg3);
        
    } else {
        result = (AGEvent *)new AGEvent(arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGEvent(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGEvent__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_SDL_Event, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGEvent__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGEvent'");
    return Qnil;
}


static void
free_AGEvent(AGEvent *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGEvent_getCaller(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    AGListener *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (AGListener *)((AGEvent const *)arg1)->getCaller();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<AGCaption*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                else if(dynamic_cast<AGWindow*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                else if(dynamic_cast<AGScreenWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
                else if(dynamic_cast<AGSound*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                else if(dynamic_cast<AGDialog*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                else if(dynamic_cast<AGApplication*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGApplication,0);
                else if(dynamic_cast<AGImage*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                else if(dynamic_cast<AGRadioGroup*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                else if(dynamic_cast<AGGLWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                else if(dynamic_cast<AGEdit*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                else if(dynamic_cast<AGListBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                else if(dynamic_cast<AGSubMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                else if(dynamic_cast<AGFrame*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFrame,0);
                else if(dynamic_cast<AGColorButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                else if(dynamic_cast<AGMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                else if(dynamic_cast<AGRadio*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                else if(dynamic_cast<AGText*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                else if(dynamic_cast<AGTable*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                else if(dynamic_cast<AGCheckBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                else if(dynamic_cast<AGMenuItem*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                else if(dynamic_cast<AGLayout*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                else if(dynamic_cast<AGButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                else if(dynamic_cast<AGHTiler*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGHTiler,0);
                else if(dynamic_cast<AGVTiler*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVTiler,0);
                else if(dynamic_cast<AGWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                else if(dynamic_cast<AGMessageObject*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMessageObject,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListener,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_AGEvent_setCaller(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    AGListener *arg2 = (AGListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0);
    (arg1)->setCaller(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEvent_getName(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = ((AGEvent const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGEvent_getMousePosition(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = ((AGEvent const *)arg1)->getMousePosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEvent_getKey(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    SDLKey result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (SDLKey)((AGEvent const *)arg1)->getKey();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEvent_getMod(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    SDLMod result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (SDLMod)((AGEvent const *)arg1)->getMod();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEvent_getButton(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (int)((AGEvent const *)arg1)->getButton();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEvent_get(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    SDL_Event *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (SDL_Event *)((AGEvent const *)arg1)->get();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Event,0);
    return vresult;
}


static VALUE
_wrap_AGEvent_isSDLEvent(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (bool)((AGEvent const *)arg1)->isSDLEvent();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEvent_setName(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGEvent(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGListener;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListener_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListener_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListener);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListener(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargisgui::AGListener";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGListener *)new SwigDirector_AGListener(arg1);
            
        } else {
            result = (AGListener *)new AGListener();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGListener(AGListener *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGListener_signal(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListener, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->signal(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGListener(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListener, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGCPPListener;

static void
free_AGCPPListener(AGCPPListener *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGCPPListener_signal(int argc, VALUE *argv, VALUE self) {
    AGCPPListener *arg1 = (AGCPPListener *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCPPListener, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGCPPListener const *)arg1)->signal(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCPPListener_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCPPListener_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCPPListener);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCPPListener(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGCPPListener *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGCPPListener";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGCPPListener *)new SwigDirector_AGCPPListener(arg1);
        
    } else {
        rb_raise(rb_eNameError,"accessing abstract class or protected constructor"); 
        return Qnil;
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_disown_AGCPPListener(int argc, VALUE *argv, VALUE self) {
    AGCPPListener *arg1 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCPPListener, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSignal;

static VALUE
_wrap_new_AGSignal__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSignal *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1);
        
    } else {
        result = (AGSignal *)new AGSignal();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGSignal__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *arg2 = (AGMessageObject *) 0 ;
    AGSignal *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMessageObject, 0);
    char *classname = "Libantargisgui::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1,arg2);
        
    } else {
        result = (AGSignal *)new AGSignal(arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSignal_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSignal_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSignal);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSignal__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *arg2 = (AGMessageObject *) 0 ;
    std::string *arg3 = 0 ;
    AGSignal *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMessageObject, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargisgui::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1,arg2,(std::string const &)*arg3);
        
    } else {
        result = (AGSignal *)new AGSignal(arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGSignal(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGSignal__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMessageObject, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGSignal__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMessageObject, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGSignal__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGSignal'");
    return Qnil;
}


static void
free_AGSignal(AGSignal *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGSignal_connect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGListener *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->connect(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSignal_disconnect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGListener *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->disconnect(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSignal_connect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGCPPListener *arg2 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGCPPListener, 0);
    (arg1)->connect(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSignal_connect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_connect__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGCPPListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_connect__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSignal_connect'");
    return Qnil;
}


static VALUE
_wrap_AGSignal_disconnect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGCPPListener *arg2 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGCPPListener, 0);
    (arg1)->disconnect(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSignal_disconnect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_disconnect__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGCPPListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_disconnect__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSignal_disconnect'");
    return Qnil;
}


static VALUE
_wrap_AGSignal_signal(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->signal(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSignal___call__(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->operator ()(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGSignal(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGMessageObject;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMessageObject_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMessageObject_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMessageObject);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMessageObject(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargisgui::AGMessageObject";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGMessageObject *)new SwigDirector_AGMessageObject(arg1);
            
        } else {
            result = (AGMessageObject *)new AGMessageObject();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGMessageObject(AGMessageObject *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGMessageObject_processEvent(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->processEvent(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_acceptEvent(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    SDL_Event *arg2 = (SDL_Event *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Event, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->acceptEvent((SDL_Event const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventActive(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventActive(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventKeyUp(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventQuit(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuit(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventQuitModal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuitModal(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventSysWM(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventSysWM(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventResize(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventResize(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_getButtonState(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    Uint8 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGMessageObject const *)arg1)->getButtonState();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMessageObject_getMousePosition(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGPoint result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGMessageObject const *)arg1)->getMousePosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigActive_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigActive = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigActive_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigActive);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigKeyDown_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigKeyDown = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigKeyDown_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigKeyDown);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigKeyUp_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigKeyUp = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigKeyUp_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigKeyUp);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseMotion_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseMotion = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseMotion_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigMouseMotion);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonDown_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseButtonDown = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonDown_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigMouseButtonDown);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonUp_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseButtonUp = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonUp_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigMouseButtonUp);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigQuit_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigQuit = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigQuit_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigQuit);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigSysWM_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigSysWM = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigSysWM_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigSysWM);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigVideoResize_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigVideoResize = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigVideoResize_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigVideoResize);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_pushSignal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    (arg1)->pushSignal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_popSignal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    (arg1)->popSignal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGMessageObject(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_newEvent(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    std::string *arg2 = 0 ;
    SDL_Event *arg3 = (SDL_Event *) 0 ;
    AGEvent *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListener, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_SDL_Event, 0);
    result = (AGEvent *)newEvent(arg1,(std::string const &)*arg2,(SDL_Event const *)arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEvent,0);
    return vresult;
}


swig_class cAGAngle;

static VALUE
_wrap_AGAngle_angle_set(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = (AGAngle *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGAngle, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->angle = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGAngle_angle_get(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = (AGAngle *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGAngle, 0);
    result = (float) ((arg1)->angle);
    
    vresult = rb_float_new(result);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGAngle_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGAngle_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGAngle);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGAngle(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    AGAngle *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    result = (AGAngle *)new AGAngle(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGAngle(AGAngle *arg1) {
    delete arg1;
}

swig_class cAGVector2;

static VALUE
_wrap_AGVector2_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 0);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector2_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGVector2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector2 *)new AGVector2(arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGVector2 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector2 *)new AGVector2((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector2__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector2 *)new AGVector2((AGVector2 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector2__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector2 *)new AGVector2();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGVector2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector2__SWIG_3(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector2__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector2__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector2__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector2'");
    return Qnil;
}


static VALUE
_wrap_AGVector2_setX(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_setY(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_x(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float)((AGVector2 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_y(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float)((AGVector2 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_getAngle(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    SwigValueWrapper<AGAngle > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = ((AGVector2 const *)arg1)->getAngle();
    
    {
        AGAngle * resultptr;
        resultptr = new AGAngle((AGAngle &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGAngle, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector2 const *)arg1)->operator -((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___add__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector2 const *)arg1)->operator +((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector2 const *)arg1)->operator *((AGVector2 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector2 const *)arg1)->operator *(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector2___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector2___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector2___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector2___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector2___div__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector2 const *)arg1)->operator /(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector2 const *)arg1)->operator ==((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector2_length(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float)((AGVector2 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_length2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float)((AGVector2 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = ((AGVector2 const *)arg1)->normalized();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_normal(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = ((AGVector2 const *)arg1)->normal();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___getitem__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    int arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = NUM2INT(argv[0]);
    result = (float)((AGVector2 const *)arg1)->operator [](arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (bool)((AGVector2 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector2_saveXML(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((AGVector2 const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_loadXML(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = ((AGVector2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGVector2(AGVector2 *arg1) {
    delete arg1;
}

swig_class cAGVector3;

static VALUE
_wrap_AGVector3_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 0);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector3_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    float arg2 ;
    AGVector3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector3 *)new AGVector3((AGVector2 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGVector2 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGVector3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGVector3 *)new AGVector3(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_3(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGVector3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector3 *)new AGVector3(arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector3__SWIG_6(int argc, VALUE *argv, VALUE self) {
    AGVector3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector3 *)new AGVector3();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGVector3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector3__SWIG_6(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_4(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_5(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector3__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector3__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVector3__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector3'");
    return Qnil;
}


static VALUE
_wrap_AGVector3_setX(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_setY(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_setZ(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setZ(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_x(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_y(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_z(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->getZ();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_getAngle(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    SwigValueWrapper<AGAngle > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->getAngle();
    
    {
        AGAngle * resultptr;
        resultptr = new AGAngle((AGAngle &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGAngle, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___neg__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->operator -();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator -((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___add__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator +((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_add(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector3 &_result_ref = (arg1)->operator +=((AGVector3 const &)*arg2);
        result = (AGVector3 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3_sub(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector3 &_result_ref = (arg1)->operator -=((AGVector3 const &)*arg2);
        result = (AGVector3 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector3 const *)arg1)->operator *((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector3 const *)arg1)->operator *(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector3___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector3___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector3___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector3___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector3___div__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector3 const *)arg1)->operator /(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___mod__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator %((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector3 const *)arg1)->operator ==((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3_length(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_length2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->normalized();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_normal(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->normal();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (bool)((AGVector3 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3_saveXML(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((AGVector3 const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_loadXML(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_dim2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->dim2();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGVector3(AGVector3 *arg1) {
    delete arg1;
}

swig_class cAGPoint3;

static VALUE
_wrap_new_AGPoint3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPoint3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGPoint3 *)new AGPoint3();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGPoint3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGPoint3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGPoint3 *)new AGPoint3(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGPoint3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGPoint3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGPoint3 *)new AGPoint3(arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPoint3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPoint3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPoint3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPoint3__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGPoint3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGPoint3 *)new AGPoint3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGPoint3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGPoint3__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGPoint3__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGPoint3__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGPoint3__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGPoint3'");
    return Qnil;
}


static void
free_AGPoint3(AGPoint3 *arg1) {
    delete arg1;
}

swig_class cAGMatrix3;

static VALUE
_wrap_new_AGMatrix3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMatrix3 *)new AGMatrix3();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGMatrix3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGMatrix3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix3 *)new AGMatrix3((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMatrix3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMatrix3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMatrix3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMatrix3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGMatrix3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix3 *)new AGMatrix3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGMatrix3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGMatrix3__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix3__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix3__SWIG_2(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGMatrix3'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3_set(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGMatrix3_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix3 const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix3_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->get(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix3_get(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix3_get__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix3_get__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix3_get'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix3 const *)arg1)->operator *((AGMatrix3 const &)*arg2);
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix3 const *)arg1)->operator *((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE _wrap_AGMatrix3___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix3___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix3___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix3___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3___neg__(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    result = ((AGMatrix3 const *)arg1)->operator -();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_inverted(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    result = ((AGMatrix3 const *)arg1)->inverted();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_transposed(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    result = ((AGMatrix3 const *)arg1)->transposed();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_to_s(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    result = ((AGMatrix3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGMatrix3(AGMatrix3 *arg1) {
    delete arg1;
}

swig_class cAGLine2;

static VALUE
_wrap_new_AGLine2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGLine2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLine2 *)new AGLine2();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLine2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLine2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLine2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLine2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *arg2 = 0 ;
    AGLine2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGLine2 *)new AGLine2((AGVector2 const &)*arg1,(AGVector2 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGLine2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGLine2__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGLine2__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGLine2'");
    return Qnil;
}


static VALUE
_wrap_AGLine2_getV0(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->getV0();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_getV1(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->getV1();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_has(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->has((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_collide(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->collide((AGLine2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_collisionPoint(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGLine2 const *)arg1)->collisionPoint((AGLine2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_collisionPointNI(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGLine2 const *)arg1)->collisionPointNI((AGLine2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_includes(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->includes((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_getBBox(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->getBBox();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_normal(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->normal();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_direction(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->direction();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_distance(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGLine2 const *)arg1)->distance((AGVector2 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGLine2_to_s(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGLine2(AGLine2 *arg1) {
    delete arg1;
}

swig_class cAGLine3;

static VALUE
_wrap_new_AGLine3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGLine3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLine3 *)new AGLine3();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLine3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLine3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLine3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLine3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGLine3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGLine3 *)new AGLine3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGLine3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGLine3__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGLine3__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGLine3'");
    return Qnil;
}


static VALUE
_wrap_AGLine3_getV0(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    result = ((AGLine3 const *)arg1)->getV0();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_getV1(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    result = ((AGLine3 const *)arg1)->getV1();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_has(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine3 const *)arg1)->has((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine3_direction(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    result = ((AGLine3 const *)arg1)->direction();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_distance(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGLine3 const *)arg1)->distance((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGLine3_to_s(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    result = ((AGLine3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGLine3(AGLine3 *arg1) {
    delete arg1;
}

swig_class cAGCollisionData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCollisionData_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCollisionData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCollisionData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCollisionData(int argc, VALUE *argv, VALUE self) {
    AGCollisionData *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGCollisionData *)new AGCollisionData();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGCollisionData(AGCollisionData *arg1) {
    delete arg1;
}

swig_class cAGTriangle2;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTriangle2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTriangle2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTriangle2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTriangle2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 *arg3 = 0 ;
    AGTriangle2 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTriangle2 *)new AGTriangle2((AGVector2 const &)*arg1,(AGVector2 const &)*arg2,(AGVector2 const &)*arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGTriangle2_get(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    int arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    arg2 = NUM2INT(argv[0]);
    result = ((AGTriangle2 const *)arg1)->get(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_collide(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGTriangle2 const *)arg1)->collide((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getNormals(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    SwigValueWrapper<std::vector<AGVector2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    result = ((AGTriangle2 const *)arg1)->getNormals();
    
    {
        std::vector<AGVector2 > * resultptr;
        resultptr = new std::vector<AGVector2 >((std::vector<AGVector2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_apply(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->apply((AGMatrix3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTriangle2_applied(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    SwigValueWrapper<AGTriangle2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->applied((AGMatrix3 const &)*arg2);
    
    {
        AGTriangle2 * resultptr;
        resultptr = new AGTriangle2((AGTriangle2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTriangle2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_touchPoint(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->touchPoint((AGTriangle2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_touchVector(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->touchVector((AGTriangle2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_collisionPoints(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    SwigValueWrapper<std::vector<AGVector2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->collisionPoints((AGLine2 const &)*arg2);
    
    {
        std::vector<AGVector2 > * resultptr;
        resultptr = new std::vector<AGVector2 >((std::vector<AGVector2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_contains(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGTriangle2 const *)arg1)->contains((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getBBox(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    result = ((AGTriangle2 const *)arg1)->getBBox();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_nearestLine(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGLine2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->nearestLine((AGVector2 const &)*arg2);
    
    {
        AGLine2 * resultptr;
        resultptr = new AGLine2((AGLine2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGLine2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getLines(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    SwigValueWrapper<std::vector<AGLine2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    result = ((AGTriangle2 const *)arg1)->getLines();
    
    {
        std::vector<AGLine2 > * resultptr;
        resultptr = new std::vector<AGLine2 >((std::vector<AGLine2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_to_s(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    result = ((AGTriangle2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGTriangle2(AGTriangle2 *arg1) {
    delete arg1;
}

swig_class cAGCircle2;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCircle2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCircle2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCircle2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCircle2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    float arg2 ;
    AGCircle2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGCircle2 *)new AGCircle2((AGVector3 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGCircle2_inCircle__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->inCircle((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGCircle2_outCircle__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->outCircle((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGCircle2_inCircle__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->inCircle((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGCircle2_inCircle(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTriangle2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_inCircle__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_inCircle__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGCircle2_inCircle'");
    return Qnil;
}


static VALUE
_wrap_AGCircle2_outCircle__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->outCircle((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGCircle2_outCircle(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTriangle2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_outCircle__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_outCircle__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGCircle2_outCircle'");
    return Qnil;
}


static VALUE
_wrap_AGCircle2_getPos(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    result = ((AGCircle2 const *)arg1)->getPos();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGCircle2_getRadius(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    result = (float)((AGCircle2 const *)arg1)->getRadius();
    
    vresult = rb_float_new(result);
    return vresult;
}


static void
free_AGCircle2(AGCircle2 *arg1) {
    delete arg1;
}

swig_class cAGTriangle3;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTriangle3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTriangle3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTriangle3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTriangle3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *arg3 = 0 ;
    AGTriangle3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_AGVector3, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTriangle3 *)new AGTriangle3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2,(AGVector3 const &)*arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGTriangle3_collide(int argc, VALUE *argv, VALUE self) {
    AGTriangle3 *arg1 = (AGTriangle3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle3 const *)arg1)->collide((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle3_toString(int argc, VALUE *argv, VALUE self) {
    AGTriangle3 *arg1 = (AGTriangle3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle3, 0);
    result = ((AGTriangle3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGTriangle3(AGTriangle3 *arg1) {
    delete arg1;
}

swig_class cAGRect2;

static VALUE
_wrap_new_AGRect2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGRect2 *)new AGRect2();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGRect2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *arg2 = 0 ;
    AGRect2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect2 *)new AGRect2((AGVector2 const &)*arg1,(AGVector2 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGRect2__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    AGRect2 *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    arg4 = (float) NUM2DBL(argv[3]);
    result = (AGRect2 *)new AGRect2(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect2__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGRect2 *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGRect2 *)new AGRect2((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGRect2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGRect2__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGRect2__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGRect2__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FLOAT) || (TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGRect2__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGRect2'");
    return Qnil;
}


static VALUE
_wrap_AGRect2_collide(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->collide((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2_include(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->include((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2___add__(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect2 const *)arg1)->operator +((AGVector2 const &)*arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_contains__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->contains((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2_contains__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->contains((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGRect2_contains(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect2_contains__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect2_contains__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGRect2_contains'");
    return Qnil;
}


static VALUE
_wrap_AGRect2_split(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    SwigValueWrapper<std::list<AGRect2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->split();
    
    {
        std::list<AGRect2 > * resultptr;
        resultptr = new std::list<AGRect2 >((std::list<AGRect2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTAGRect2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->getV0();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->getV1();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV01(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->getV01();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV10(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->getV10();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_shrink(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGRect2 const *)arg1)->shrink(arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_setX(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setY(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setLeft(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setLeft(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setTop(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setTop(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setRight(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setRight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setBottom(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setBottom(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setWidth(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = (float)(arg1)->setWidth(arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_setHeight(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = (float)(arg1)->setHeight(arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_x(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->x();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_y(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->y();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_w(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->w();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_h(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->h();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_width(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->width();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_height(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->height();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_x0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->x0();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_y0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->y0();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_x1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->x1();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_y1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->y1();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_origin(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->origin();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_intersect(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect2 const *)arg1)->intersect((AGRect2 const &)*arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_sdl(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    SDL_Rect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->sdl();
    
    {
        SDL_Rect * resultptr;
        resultptr = new SDL_Rect((SDL_Rect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_SDL_Rect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2___eq__(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->operator ==((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2_check(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    ((AGRect2 const *)arg1)->check();
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_to_s(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGRect2(AGRect2 *arg1) {
    delete arg1;
}

swig_class cAGVector4;

static VALUE
_wrap_AGVector4_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 0);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector4_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector4__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    AGVector4 *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    arg4 = (float) NUM2DBL(argv[3]);
    result = (AGVector4 *)new AGVector4(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGVector4 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGVector4 *)new AGVector4(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = 0 ;
    AGVector4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector4, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector4 *)new AGVector4((AGVector4 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    float arg2 ;
    AGVector4 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector4 *)new AGVector4((AGVector3 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector4_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector4__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGVector4 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector4 *)new AGVector4();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGVector4(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector4__SWIG_4(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector4__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector4__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVector4__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FLOAT) || (TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGVector4__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector4'");
    return Qnil;
}


static VALUE
_wrap_AGVector4_setX(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setY(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setZ(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setZ(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setW(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setW(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_x(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_y(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_z(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->getZ();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_w(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->getW();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator -((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___add__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator +((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_add(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector4 &_result_ref = (arg1)->operator +=((AGVector4 const &)*arg2);
        result = (AGVector4 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4_sub(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector4 &_result_ref = (arg1)->operator -=((AGVector4 const &)*arg2);
        result = (AGVector4 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector4 const *)arg1)->operator *((AGVector4 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector4 const *)arg1)->operator *(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector4___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector4___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector4___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector4___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector4___div__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector4 const *)arg1)->operator /(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___neg__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->operator -();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector4 const *)arg1)->operator ==((AGVector4 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4_length(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_length2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_length3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->length3();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->normalized();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_normalized3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->normalized3();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_normalize3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    (arg1)->normalize3();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (bool)((AGVector4 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4___mod__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator %((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_cross(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->cross((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_dim3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->dim3();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_dim2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->dim2();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGVector4(AGVector4 *arg1) {
    delete arg1;
}

swig_class cAGMatrix4;

static VALUE
_wrap_new_AGMatrix4__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMatrix4 *)new AGMatrix4();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGMatrix4__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float *arg1 ;
    AGMatrix4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_float, 0);
    result = (AGMatrix4 *)new AGMatrix4(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGMatrix4__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    AGVector3 *arg2 = 0 ;
    AGMatrix4 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix4 *)new AGMatrix4(arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMatrix4_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMatrix4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMatrix4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMatrix4__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = 0 ;
    AGMatrix4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector4, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix4 *)new AGMatrix4((AGVector4 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGMatrix4(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGMatrix4__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_float, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix4__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix4__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGMatrix4__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGMatrix4'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_set(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix4 const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix4_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->get(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix4_get(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4_get__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4_get__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4_get'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 *arg2 = 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix4 const *)arg1)->operator *((AGMatrix4 const &)*arg2);
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_get3x3(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = ((AGMatrix4 const *)arg1)->get3x3(arg2,arg3);
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix4 const *)arg1)->operator *((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE _wrap_AGMatrix4___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix4___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix4___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4___call____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix4 const *)arg1)->operator ()(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix4___call____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->operator ()(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix4___call__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4___call____SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4___call____SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4___call__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_inverted(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    result = ((AGMatrix4 const *)arg1)->inverted();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_transposed(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    result = ((AGMatrix4 const *)arg1)->transposed();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_to_s(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    result = ((AGMatrix4 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_getRow(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    result = ((AGMatrix4 const *)arg1)->getRow(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static void
free_AGMatrix4(AGMatrix4 *arg1) {
    delete arg1;
}

swig_class cAGRect3;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGRect3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect3 *)new AGRect3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGRect3_collides(int argc, VALUE *argv, VALUE self) {
    AGRect3 *arg1 = (AGRect3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect3 const *)arg1)->collides((AGLine3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect3_toString(int argc, VALUE *argv, VALUE self) {
    AGRect3 *arg1 = (AGRect3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect3, 0);
    result = ((AGRect3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGRect3(AGRect3 *arg1) {
    delete arg1;
}

swig_class cAGBox3;

static VALUE
_wrap_AGBox3_base_set(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0);
    if (arg1) (arg1)->base = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_base_get(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = (AGVector3 *)& ((arg1)->base);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGBox3_dir_set(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0);
    if (arg1) (arg1)->dir = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_dir_get(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = (AGVector3 *)& ((arg1)->dir);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_new_AGBox3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGBox3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGBox3 *)new AGBox3();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBox3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBox3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBox3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBox3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGBox3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGBox3 *)new AGBox3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGBox3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGBox3__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGBox3__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGBox3'");
    return Qnil;
}


static VALUE
_wrap_AGBox3_include(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->include((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_includes(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGBox3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBox3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)(arg1)->includes((AGBox3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGLine3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGBox3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBox3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGBox3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_getSides(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGRect3 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = ((AGBox3 const *)arg1)->getSides();
    
    {
        std::vector<AGRect3 > * resultptr;
        resultptr = new std::vector<AGRect3 >((std::vector<AGRect3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGRect3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_toString(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = ((AGBox3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_split(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGBox3 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = ((AGBox3 const *)arg1)->split();
    
    {
        std::vector<AGBox3 > * resultptr;
        resultptr = new std::vector<AGBox3 >((std::vector<AGBox3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGBox3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGMatrix4 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGMatrix4 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGBox3_collides(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGLine3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_3(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGBox3_collides'");
    return Qnil;
}


static VALUE
_wrap_AGBox3_getVertices(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGVector4 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = ((AGBox3 const *)arg1)->getVertices();
    
    {
        std::vector<AGVector4 > * resultptr;
        resultptr = new std::vector<AGVector4 >((std::vector<AGVector4 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3___add__(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGBox3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGBox3 const *)arg1)->operator +((AGVector3 const &)*arg2);
    
    {
        AGBox3 * resultptr;
        resultptr = new AGBox3((AGBox3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGBox3, 1);
    }
    return vresult;
}


static void
free_AGBox3(AGBox3 *arg1) {
    delete arg1;
}

swig_class cAGFont;

static VALUE
_wrap_new_AGFont__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGFont *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGFont *)new AGFont();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGFont__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    int arg2 ;
    AGFont *result;
    std::string temp1 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg2 = NUM2INT(argv[1]);
    result = (AGFont *)new AGFont((std::string const &)*arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFont_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFont_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFont);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFont__SWIG_2(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGFont *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGFont *)new AGFont((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGFont(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGFont__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGFont__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGFont__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGFont'");
    return Qnil;
}


static VALUE
_wrap_AGFont_setColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setBorderColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setBorderColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getBorderColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getBorderColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setBorder(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setBorder(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getBorder(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = (int)((AGFont const *)arg1)->getBorder();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_setAlpha(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setAlpha(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getAlpha(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getAlpha();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setSize(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSize(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getSize(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getSize();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setStyle(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGFont::Style *arg2 = 0 ;
    AGFont::Style temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    temp2 = (AGFont::Style) NUM2INT(argv[0]);
    arg2 = &temp2;
    (arg1)->setStyle((enum AGFont::Style const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getStyle(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGFont::Style result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = (AGFont::Style)((AGFont const *)arg1)->getStyle();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_setName(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getName(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setEmbossed(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setEmbossed(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getEmbossed(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = (bool)((AGFont const *)arg1)->getEmbossed();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGFont_setInset(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setInset(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getInset(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = (bool)((AGFont const *)arg1)->getInset();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGFont_getWidth(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)((AGFont const *)arg1)->getWidth((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_getHeight(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)((AGFont const *)arg1)->getHeight((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_toString(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGFont(AGFont *arg1) {
    delete arg1;
}

swig_class cAGColor;

static VALUE
_wrap_new_AGColor__SWIG_0(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    AGColor *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    arg4 = NUM2INT(argv[3]);
    result = (AGColor *)new AGColor(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_1(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    AGColor *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    result = (AGColor *)new AGColor(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = 0 ;
    AGColor *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColor, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGColor *)new AGColor((AGColor const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_3(int argc, VALUE *argv, VALUE self) {
    Uint32 arg1 ;
    AGSurface *arg2 = 0 ;
    AGColor *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        Uint32 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint32, 0);
        if (ptr) arg1 = *ptr;
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGColor *)new AGColor(arg1,(AGSurface const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_4(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGColor *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGColor *)new AGColor((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGColor_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGColor_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGColor);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGColor__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGColor *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGColor *)new AGColor();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGColor(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGColor__SWIG_5(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGColor__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGColor__SWIG_4(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Uint32, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGColor__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGColor__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGColor__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGColor'");
    return Qnil;
}


static VALUE
_wrap_AGColor___mul__(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    float arg2 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGColor const *)arg1)->operator *(arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor___add__(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    AGColor *arg2 = 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGColor const *)arg1)->operator +((AGColor const &)*arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_mapRGB(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    SDL_PixelFormat *arg2 = (SDL_PixelFormat *) 0 ;
    Uint32 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_PixelFormat, 0);
    result = ((AGColor const *)arg1)->mapRGB(arg2);
    
    {
        Uint32 * resultptr;
        resultptr = new Uint32((Uint32 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint32, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_toString(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    result = ((AGColor const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGColor_grey(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    result = ((AGColor const *)arg1)->grey();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_brightness(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    result = ((AGColor const *)arg1)->brightness();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_light(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->light(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColor_a_set(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg2 = *ptr;
    }
    if (arg1) (arg1)->a = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGColor_a_get(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    result =  ((arg1)->a);
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static void
free_AGColor(AGColor *arg1) {
    delete arg1;
}

static VALUE
_wrap_toInt__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Uint8 arg1 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg1 = *ptr;
    }
    result = (int)toInt(arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


swig_class cAGWidget;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGWidget *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWidget *)new SwigDirector_AGWidget(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGWidget *)new AGWidget(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGWidget(AGWidget *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGWidget_draw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_drawAfter(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAfter(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_drawAll(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAll(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = ((AGWidget const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGWidget const *)arg1)->getClientRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setRect((AGRect2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setParent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->setParent(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getParent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (AGWidget *)(arg1)->getParent();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGScreenWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGFrame*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFrame,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGHTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGHTiler,0);
                    else if(dynamic_cast<AGVTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVTiler,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_eventShow(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventShow();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventHide(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventHide();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventGotFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventGotFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventLostFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventLostFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_canFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGWidget const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_processEvent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->processEvent(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_sigMouseEnter_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseEnter = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigMouseEnter_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (AGSignal *)& ((arg1)->sigMouseEnter);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_sigMouseLeave_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseLeave = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigMouseLeave_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (AGSignal *)& ((arg1)->sigMouseLeave);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_sigClick_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigClick = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigClick_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (AGSignal *)& ((arg1)->sigClick);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_minWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (float)((AGWidget const *)arg1)->minWidth();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_minHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (float)((AGWidget const *)arg1)->minHeight();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_width(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->width();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_height(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->height();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_top(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->top();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_left(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->left();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_visible(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->visible();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_setWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setTop(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setTop(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setLeft(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setLeft(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_fixedWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->fixedWidth();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_fixedHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->fixedHeight();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_show(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->show();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_hide(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->hide();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_mark(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_addChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_addChildBack(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChildBack(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_removeChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->removeChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_redraw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGWidget const *)arg1)->redraw();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_prepareDraw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->prepareDraw();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setCaching(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setCaching(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_checkRedraw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->checkRedraw();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_clear(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getScreenRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = ((AGWidget const *)arg1)->getScreenRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_getScreenPosition(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = ((AGWidget const *)arg1)->getScreenPosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_fromScreen(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGWidget const *)arg1)->fromScreen((AGVector2 const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_gainFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->gainFocus(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->gainFocus();
    
    return Qnil;
}


static VALUE _wrap_AGWidget_gainFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_gainFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_gainFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_gainFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainCompleteFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->gainCompleteFocus(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainCompleteFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->gainCompleteFocus();
    
    return Qnil;
}


static VALUE _wrap_AGWidget_gainCompleteFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_gainCompleteFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_gainCompleteFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_gainCompleteFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_eventDragBy(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    AGPoint *arg3 = 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventDragBy(arg2,(AGVector2 const &)*arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_getFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->getFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_hasFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    result = (bool)(arg1)->hasFocus((AGWidget const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_hasFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)(arg1)->hasFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGWidget_hasFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_hasFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_hasFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_hasFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_getName(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = ((AGWidget const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setName(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string *arg2 = 0 ;
    AGWidget *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGWidget *)(arg1)->getChild((std::string const &)*arg2);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGScreenWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGFrame*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFrame,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGHTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGHTiler,0);
                    else if(dynamic_cast<AGVTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVTiler,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setModal(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setModal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_erase(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->erase(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_eventChildrenDeleted(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->eventChildrenDeleted(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGWidget(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGWidget(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGWidget *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGWidget *)toAGWidget(arg1);
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<AGCaption*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                else if(dynamic_cast<AGWindow*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                else if(dynamic_cast<AGScreenWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
                else if(dynamic_cast<AGSound*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                else if(dynamic_cast<AGDialog*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                else if(dynamic_cast<AGImage*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                else if(dynamic_cast<AGRadioGroup*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                else if(dynamic_cast<AGGLWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                else if(dynamic_cast<AGEdit*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                else if(dynamic_cast<AGListBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                else if(dynamic_cast<AGSubMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                else if(dynamic_cast<AGFrame*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFrame,0);
                else if(dynamic_cast<AGColorButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                else if(dynamic_cast<AGMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                else if(dynamic_cast<AGRadio*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                else if(dynamic_cast<AGText*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                else if(dynamic_cast<AGTable*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                else if(dynamic_cast<AGCheckBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                else if(dynamic_cast<AGMenuItem*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                else if(dynamic_cast<AGLayout*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                else if(dynamic_cast<AGButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                else if(dynamic_cast<AGHTiler*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGHTiler,0);
                else if(dynamic_cast<AGVTiler*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVTiler,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
agNoParent_get(VALUE self) {
    VALUE _val;
    
    _val = SWIG_NewPointerObj((void *) agNoParent, SWIGTYPE_p_AGWidget,0);    return _val;
}


static VALUE
agNoParent_set(VALUE self, VALUE _val) {
    SWIG_ConvertPtr(_val, (void **) &agNoParent, SWIGTYPE_p_AGWidget, 1);
    return _val;
}


swig_class cAGColorButton;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGColorButton_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGColorButton_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGColorButton);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGColorButton(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    int arg4 ;
    int arg5 ;
    AGColorButton *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = NUM2INT(argv[2]);
    arg5 = NUM2INT(argv[3]);
    {
        char *classname = "Libantargisgui::AGColorButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGColorButton *)new SwigDirector_AGColorButton(arg1,arg2,(AGRect2 const &)*arg3,arg4,arg5);
            
        } else {
            result = (AGColorButton *)new AGColorButton(arg2,(AGRect2 const &)*arg3,arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGColorButton_draw(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColorButton_getColor(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    result = ((AGColorButton const *)arg1)->getColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColorButton_setColor__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColorButton_setColor__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGColorButton_setColor(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColorButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGColorButton_setColor__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColorButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGColorButton_setColor__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGColorButton_setColor'");
    return Qnil;
}


static VALUE
_wrap_AGColorButton_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGColorButton(AGColorButton *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGColorButton(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGColorButton(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGColorButton *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGColorButton &_result_ref = toAGColorButton(*arg1);
        result = (AGColorButton *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
    return vresult;
}


swig_class cAGGLWidget;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGGLWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGGLWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGGLWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGGLWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGGLWidget *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGGLWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGGLWidget *)new SwigDirector_AGGLWidget(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGGLWidget *)new AGGLWidget(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGGLWidget_drawGL(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGL();
    
    return Qnil;
}


static VALUE
_wrap_AGGLWidget_drawAll(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAll(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGGLWidget_getRatio(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    result = (float)((AGGLWidget const *)arg1)->getRatio();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGGLWidget_setPerspective(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->setPerspective(arg2,arg3,arg4);
    
    return Qnil;
}


static void
free_AGGLWidget(AGGLWidget *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGGLWidget(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cNode;

static VALUE
_wrap_new_Node__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Node *)new Node();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_Node__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Node *)new Node(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_Node__SWIG_2(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = 0 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Node, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (Node *)new Node((Node const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Node_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Node_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Node);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Node__SWIG_3(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (Node *)new Node((Node const *)arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_Node(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Node__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Node'");
    return Qnil;
}


static void
free_Node(Node *arg1) {
    delete arg1;
}

static VALUE
_wrap_Node_setName(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_getChildren__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::NodeVector result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->getChildren();
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            Node* x = result[i]; // modified, so that is given by reference and not by value
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_Node, 0));
        }
    }
    return vresult;
}


static VALUE
_wrap_Node_getChildren__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    Node::NodeVector result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->getChildren(arg2);
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            Node* x = result[i]; // modified, so that is given by reference and not by value
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_Node, 0));
        }
    }
    return vresult;
}


static VALUE _wrap_Node_getChildren(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_getChildren__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_getChildren__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getChildren'");
    return Qnil;
}


static VALUE
_wrap_Node_getName(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_setAttributes(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::Attributes *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setAttributes((std::map<std::string,std::string > const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_addChild(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    Node *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        Node &_result_ref = (arg1)->addChild((std::string const &)*arg2);
        result = (Node *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Node_removeChild(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->removeChild(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_begin__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (arg1)->begin();
    
    {
        Node::iterator * resultptr;
        resultptr = new Node::iterator((Node::iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__iterator, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_begin__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::const_iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->begin();
    
    {
        Node::const_iterator * resultptr;
        resultptr = new Node::const_iterator((Node::const_iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__const_iterator, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_begin(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_begin__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_begin__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_begin'");
    return Qnil;
}


static VALUE
_wrap_Node_end__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (arg1)->end();
    
    {
        Node::iterator * resultptr;
        resultptr = new Node::iterator((Node::iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__iterator, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_end__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::const_iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->end();
    
    {
        Node::const_iterator * resultptr;
        resultptr = new Node::const_iterator((Node::const_iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__const_iterator, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_end(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_end__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_end__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_end'");
    return Qnil;
}


static VALUE
_wrap_Node_setContent(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setContent((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_getContent__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->getContent();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_set(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->set((std::string const &)*arg2,(std::string const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_get(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->get((std::string const &)*arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_clear(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_Node_escape(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = Node::escape((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_unescape(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = Node::unescape((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_getStart__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    bool arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = RTEST(argv[1]);
    ((Node const *)arg1)->getStart(*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_getStart__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((Node const *)arg1)->getStart(*arg2);
    
    return Qnil;
}


static VALUE _wrap_Node_getStart(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_getStart__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Node_getStart__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getStart'");
    return Qnil;
}


static VALUE
_wrap_Node_getEnd(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((Node const *)arg1)->getEnd(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_indent(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    ((Node const *)arg1)->indent(*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_getContent__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    ((Node const *)arg1)->getContent(*arg2,arg3);
    
    return Qnil;
}


static VALUE _wrap_Node_getContent(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_getContent__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Node_getContent__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getContent'");
    return Qnil;
}


static VALUE
_wrap_Node_toString__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool arg2 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    arg2 = RTEST(argv[0]);
    result = ((Node const *)arg1)->toString(arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_toString__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE _wrap_Node_toString(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_toString__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_toString__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_toString'");
    return Qnil;
}


static VALUE
_wrap_Node_isTextNode(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (bool)((Node const *)arg1)->isTextNode();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Node_getText(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_hasTextNode(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (bool)((Node const *)arg1)->hasTextNode();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Node_size(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


swig_class cDocument;

static VALUE
_wrap_new_Document__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Document *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Document *)new Document();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Document_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Document_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Document);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Document__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    Document *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Document *)new Document(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_Document(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Document__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Document__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Document'");
    return Qnil;
}


static void
free_Document(Document *arg1) {
    delete arg1;
}

static VALUE
_wrap_Document_parseFile(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)(arg1)->parseFile(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Document_root(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 0);
    {
        Node &_result_ref = (arg1)->root();
        result = (Node *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Document_toString(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 0);
    result = ((Document const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Document_parseMemory(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parseMemory((std::string const &)*arg2);
    
    return Qnil;
}


swig_class cParser;

static void
free_Parser(Parser *arg1) {
    delete arg1;
}

static VALUE
_wrap_Parser_parse(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parse((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_getLine(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    result = ((Parser const *)arg1)->getLine();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Parser_simpleTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->simpleTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Parser_startTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->startTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Parser_endTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endTag((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_text(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->text((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_comment(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->comment((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_header(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->header((std::string const &)*arg2);
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Parser_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Parser_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Parser);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Parser(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Parser *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::Parser";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (Parser *)new SwigDirector_Parser(arg1);
        
    } else {
        result = (Parser *)new Parser();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_disown_Parser(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cDomParser;

static VALUE
_wrap_DomParser_simpleTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->simpleTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_startTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->startTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_endTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endTag((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_text(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->text((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_comment(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->comment((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_header(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->header((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_parse__SWIG_0(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Document *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Document *)(arg1)->parse((std::string const &)*arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


static VALUE
_wrap_DomParser_parse__SWIG_1(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Document *arg3 = (Document *) 0 ;
    Document *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Document, 0);
    result = (Document *)(arg1)->parse((std::string const &)*arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


static VALUE _wrap_DomParser_parse(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_DomParser, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_DomParser_parse__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_DomParser, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_Document, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_DomParser_parse__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'DomParser_parse'");
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_DomParser_allocate(VALUE self) {
#else
    static VALUE
    _wrap_DomParser_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_DomParser);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_DomParser(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    DomParser *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::DomParser";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (DomParser *)new SwigDirector_DomParser(arg1);
        
    } else {
        result = (DomParser *)new DomParser();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_DomParser(DomParser *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_DomParser(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGLayout;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLayout_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLayout_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLayout);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLayout(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGLayout *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGLayout";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGLayout *)new SwigDirector_AGLayout(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGLayout *)new AGLayout(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGLayout_addTabIndex(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    int arg2 ;
    AGWidget *arg3 = (AGWidget *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayout, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGWidget, 0);
    (arg1)->addTabIndex(arg2,arg3);
    
    return Qnil;
}


static void
free_AGLayout(AGLayout *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGLayout(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGLayout, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_parseNode(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AGWidget *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGWidget *)parseNode(arg1,(Node const &)*arg2);
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<AGCaption*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                else if(dynamic_cast<AGWindow*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                else if(dynamic_cast<AGScreenWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
                else if(dynamic_cast<AGSound*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                else if(dynamic_cast<AGDialog*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                else if(dynamic_cast<AGImage*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                else if(dynamic_cast<AGRadioGroup*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                else if(dynamic_cast<AGGLWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                else if(dynamic_cast<AGEdit*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                else if(dynamic_cast<AGListBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                else if(dynamic_cast<AGSubMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                else if(dynamic_cast<AGFrame*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFrame,0);
                else if(dynamic_cast<AGColorButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                else if(dynamic_cast<AGMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                else if(dynamic_cast<AGRadio*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                else if(dynamic_cast<AGText*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                else if(dynamic_cast<AGTable*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                else if(dynamic_cast<AGCheckBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                else if(dynamic_cast<AGMenuItem*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                else if(dynamic_cast<AGLayout*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                else if(dynamic_cast<AGButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                else if(dynamic_cast<AGHTiler*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGHTiler,0);
                else if(dynamic_cast<AGVTiler*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVTiler,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_parseChildren(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    parseChildren(arg1,(Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_getLayoutGeometry(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = getLayoutGeometry(arg1,(Node const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


swig_class cAGDialog;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGDialog_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGDialog_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGDialog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGDialog(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGDialog *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGDialog";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGDialog *)new SwigDirector_AGDialog(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGDialog *)new AGDialog(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGDialog_eventOk(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventOk(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGDialog_eventCancel(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventCancel(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGDialog_eventClose(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventClose(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGDialog(AGDialog *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGDialog(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGDialog, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGMutex;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMutex_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMutex_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMutex);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMutex(int argc, VALUE *argv, VALUE self) {
    AGMutex *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMutex *)new AGMutex();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGMutex(AGMutex *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGMutex_enter(int argc, VALUE *argv, VALUE self) {
    AGMutex *arg1 = (AGMutex *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMutex, 0);
    (arg1)->enter();
    
    return Qnil;
}


static VALUE
_wrap_AGMutex_leave(int argc, VALUE *argv, VALUE self) {
    AGMutex *arg1 = (AGMutex *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMutex, 0);
    (arg1)->leave();
    
    return Qnil;
}


swig_class cAGApplication;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGApplication_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGApplication_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGApplication);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGApplication(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGApplication *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargisgui::AGApplication";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGApplication *)new SwigDirector_AGApplication(arg1);
            
        } else {
            result = (AGApplication *)new AGApplication();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGApplication_run(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    result = (bool)(arg1)->run();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventIdle(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventIdle();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventFrame(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrame(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventFrameEnd(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrameEnd(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventQuit(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuit(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventChangedRes(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventChangedRes();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_setMainWidget(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->setMainWidget(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_draw(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_prepareDraw(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->prepareDraw();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_tryQuit(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tryQuit();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_getTicks(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    long result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    result = (long)((AGApplication const *)arg1)->getTicks();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGApplication_delay(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->delay(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_mark(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static void
free_AGApplication(AGApplication *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGApplication(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_disableKeyrepeat(int argc, VALUE *argv, VALUE self) {
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    disableKeyrepeat();
    
    return Qnil;
}


swig_class cAGBackground;

static VALUE
_wrap_new_AGBackground__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    AGBackground *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGBackground *)new AGBackground(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGBackground__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBackground *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGBackground *)new AGBackground();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBackground_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBackground_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBackground);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBackground__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = 0 ;
    AGBackground *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColor, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGBackground *)new AGBackground((AGColor const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGBackground(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGBackground__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBackground__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBackground__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGBackground'");
    return Qnil;
}


static VALUE
_wrap_AGBackground_draw(int argc, VALUE *argv, VALUE self) {
    AGBackground *arg1 = (AGBackground *) 0 ;
    AGPainter *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBackground, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static void
free_AGBackground(AGBackground *arg1) {
    delete arg1;
}

swig_class cAGBorder;

static VALUE
_wrap_new_AGBorder__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGBorder *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGBorder *)new AGBorder((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBorder_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBorder_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBorder);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBorder__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBorder *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGBorder *)new AGBorder();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGBorder(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGBorder__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBorder__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGBorder'");
    return Qnil;
}


static VALUE
_wrap_AGBorder_draw(int argc, VALUE *argv, VALUE self) {
    AGBorder *arg1 = (AGBorder *) 0 ;
    AGPainter *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBorder, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGBorder_getWidth(int argc, VALUE *argv, VALUE self) {
    AGBorder *arg1 = (AGBorder *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBorder, 0);
    result = ((AGBorder const *)arg1)->getWidth();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static void
free_AGBorder(AGBorder *arg1) {
    delete arg1;
}

swig_class cAGButton;

static VALUE
_wrap_new_AGButton__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    int arg5 ;
    AGButton *result;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg5 = NUM2INT(argv[3]);
    {
        char *classname = "Libantargisgui::AGButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGButton *)new SwigDirector_AGButton(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,arg5);
            
        } else {
            result = (AGButton *)new AGButton(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGButton_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGButton_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGButton);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGButton__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGButton *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGButton *)new SwigDirector_AGButton(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGButton *)new AGButton(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGButton(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGButton__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = ((TYPE(argv[4]) == T_FIXNUM) || (TYPE(argv[4]) == T_BIGNUM)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGButton__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGButton'");
    return Qnil;
}


static VALUE
_wrap_AGButton_setSurface__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGSurface arg2 ;
    bool arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 0);
        if (ptr) arg2 = *ptr;
    }
    arg3 = RTEST(argv[1]);
    (arg1)->setSurface(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setSurface__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGSurface arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSurface(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGButton_setSurface(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGButton_setSurface__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGButton_setSurface__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGButton_setSurface'");
    return Qnil;
}


static VALUE
_wrap_AGButton_draw(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_setWidth(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setHeight(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_getCaption(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGButton const *)arg1)->getCaption();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGButton_setEnabled(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setEnabled(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setTheme(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setTheme((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setCaption(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setCaption((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setState(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGButton::State *arg2 = 0 ;
    AGButton::State temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    temp2 = (AGButton::State) NUM2INT(argv[0]);
    arg2 = &temp2;
    (arg1)->setState((enum AGButton::State const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setChecked(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    arg2 = RTEST(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setChecked(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_isChecked(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    result = (bool)((AGButton const *)arg1)->isChecked();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_canFocus(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGButton const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGButton(AGButton *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGButton(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGButton(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGButton *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGButton &_result_ref = toAGButton(*arg1);
        result = (AGButton *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
    return vresult;
}


swig_class cAGText;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGText_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGText_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGText);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGText(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGFont *arg5 = 0 ;
    AGText *result;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGFont, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGText";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGText *)new SwigDirector_AGText(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5);
            
        } else {
            result = (AGText *)new AGText(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGText_setDeriveRect(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    (arg1)->setDeriveRect();
    
    return Qnil;
}


static VALUE
_wrap_AGText_draw(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGText_setText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGText_getText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    result = ((AGText const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGText_setFont(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static void
free_AGText(AGText *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGText, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGText(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGText *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGText &_result_ref = toAGText(*arg1);
        result = (AGText *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
    return vresult;
}


swig_class cAGCaption;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCaption_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCaption_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCaption);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCaption(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGFont *arg5 = 0 ;
    AGBackground *arg6 = 0 ;
    AGCaption *result;
    std::string temp4 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGFont, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGBackground, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGCaption";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGCaption *)new SwigDirector_AGCaption(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5,(AGBackground const &)*arg6);
            
        } else {
            result = (AGCaption *)new AGCaption(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5,(AGBackground const &)*arg6);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGCaption_draw(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCaption, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGCaption_setBackground(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    AGBackground arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCaption, 0);
    {
        AGBackground * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGBackground, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setBackground(arg2);
    
    return Qnil;
}


static void
free_AGCaption(AGCaption *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGCaption(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCaption, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGCheckBox;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCheckBox_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCheckBox_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCheckBox);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCheckBox(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect arg3 ;
    AGCheckBox *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        AGRect * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect2, 0);
        if (ptr) arg3 = *ptr;
    }
    {
        char *classname = "Libantargisgui::AGCheckBox";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGCheckBox *)new SwigDirector_AGCheckBox(arg1,arg2,arg3);
            
        } else {
            result = (AGCheckBox *)new AGCheckBox(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGCheckBox_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGCheckBox *arg1 = (AGCheckBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCheckBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGCheckBox(AGCheckBox *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGCheckBox(int argc, VALUE *argv, VALUE self) {
    AGCheckBox *arg1 = (AGCheckBox *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCheckBox, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGEditLine;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEditLine_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEditLine_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEditLine);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEditLine(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    AGFont arg3 ;
    bool arg4 ;
    AGEditLine *result;
    std::string temp2 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGFont * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGFont, 0);
        if (ptr) arg3 = *ptr;
    }
    arg4 = RTEST(argv[2]);
    char *classname = "Libantargisgui::AGEditLine";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEditLine *)new SwigDirector_AGEditLine(arg1,(std::string const &)*arg2,arg3,arg4);
        
    } else {
        result = (AGEditLine *)new AGEditLine((std::string const &)*arg2,arg3,arg4);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGEditLine(AGEditLine *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGEditLine_setAlign(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = (AGAlign) NUM2INT(argv[0]);
    (arg1)->setAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_setVAlign(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGVAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = (AGVAlign) NUM2INT(argv[0]);
    (arg1)->setVAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_draw(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGPainter *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2,(AGVector2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_drawCursor(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGPainter *arg2 = 0 ;
    int arg3 ;
    AGPoint *arg4 = 0 ;
    AGRect *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGVector2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGRect2, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawCursor(*arg2,arg3,(AGVector2 const &)*arg4,(AGRect2 const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_height(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = (int)((AGEditLine const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_width(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = (int)((AGEditLine const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_insert(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    char arg2 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2CHR(argv[0]);
    arg3 = NUM2INT(argv[1]);
    (arg1)->insert(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_doDelete(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->doDelete(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_split(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    SwigValueWrapper<AGEditLine > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2INT(argv[0]);
    result = (arg1)->split(arg2);
    
    {
        AGEditLine * resultptr;
        resultptr = new AGEditLine((AGEditLine &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGEditLine, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_length(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = (int)((AGEditLine const *)arg1)->length();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_append(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->append(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_prepend(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->prepend(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_getText(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = ((AGEditLine const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_getFont(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGFont result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = ((AGEditLine const *)arg1)->getFont();
    
    {
        AGFont * resultptr;
        resultptr = new AGFont((AGFont &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGFont, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_setText(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_hardEnd(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = (bool)((AGEditLine const *)arg1)->hardEnd();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEditLine_setHardEnd(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setHardEnd(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_checkUnwrap(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    std::string arg3 ;
    std::pair<std::string,bool > result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2INT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg3 = std::string(StringValuePtr(argv[1]));
            arg3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->checkUnwrap(arg2,arg3);
    
    {
        std::pair<std::string,bool > * resultptr;
        resultptr = new std::pair<std::string,bool >((std::pair<std::string,bool > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTstd__string_bool_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_checkWrap(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    std::pair<std::string,bool > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2INT(argv[0]);
    result = (arg1)->checkWrap(arg2);
    
    {
        std::pair<std::string,bool > * resultptr;
        resultptr = new std::pair<std::string,bool >((std::pair<std::string,bool > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTstd__string_bool_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_setFont(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGEditLine(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGEdit;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEdit_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEdit_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEdit);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEdit(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGEdit *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGEdit";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGEdit *)new SwigDirector_AGEdit(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGEdit *)new AGEdit(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGEdit_draw(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_drawBackground(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawBackground(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_eventKeyUp(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_setMulti(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setMulti(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_insert(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    char arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = NUM2CHR(argv[0]);
    result = (bool)(arg1)->insert(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_doDelete(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->doDelete(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setText(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setFont(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_clear(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setMutable(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setMutable(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setAlign(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = (AGAlign) NUM2INT(argv[0]);
    (arg1)->setAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setVAlign(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGVAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = (AGVAlign) NUM2INT(argv[0]);
    (arg1)->setVAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setBackground__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setBackground(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setBackground__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGBackground *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBackground, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setBackground((AGBackground const &)*arg2);
    
    return Qnil;
}


static VALUE _wrap_AGEdit_setBackground(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGEdit, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGBackground, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGEdit_setBackground__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGEdit, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGEdit_setBackground__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGEdit_setBackground'");
    return Qnil;
}


static VALUE
_wrap_AGEdit_setTheme(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setTheme((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_canFocus(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGEdit const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_getText(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    result = ((AGEdit const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGEdit_setMaxLength(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setMaxLength(arg2);
    
    return Qnil;
}


static void
free_AGEdit(AGEdit *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGEdit(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGEdit(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGEdit *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGEdit &_result_ref = toAGEdit(*arg1);
        result = (AGEdit *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
    return vresult;
}


swig_class cAGFontEngine;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFontEngine_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFontEngine_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFontEngine);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFontEngine(int argc, VALUE *argv, VALUE self) {
    AGFontEngine *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGFontEngine *)new AGFontEngine();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGFontEngine(AGFontEngine *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGFontEngine_renderText(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    std::string *arg3 = 0 ;
    AGFont *arg4 = 0 ;
    AGTexture *result;
    std::string temp3 ;
    VALUE vresult = Qnil;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[2]));
            temp3 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg4, SWIGTYPE_p_AGFont, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTexture *)AGFontEngine::renderText(arg1,arg2,(std::string const &)*arg3,(AGFont const &)*arg4);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
    return vresult;
}


static VALUE
_wrap_AGFontEngine_getWidth(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGFont, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)AGFontEngine::getWidth((AGFont const &)*arg1,(std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFontEngine_getHeight(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGFont, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)AGFontEngine::getHeight((AGFont const &)*arg1,(std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_initFS(int argc, VALUE *argv, VALUE self) {
    char *arg1 = (char *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = StringValuePtr(argv[0]);
    initFS((char const *)arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = loadFile((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_saveFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    saveFile((std::string const &)*arg1,(std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_fileExists(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    bool result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)fileExists((std::string const &)*arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_getDirectory(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::vector<std::string > result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = getDirectory((std::string const &)*arg1);
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++)
        rb_ary_store(vresult,i,SWIG_STR2RB(((std::vector<std::string > &)result)[i]));
    }
    return vresult;
}


static VALUE
_wrap_addPath(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    addPath((std::string const &)*arg1);
    
    return Qnil;
}


swig_class cAGPaintTarget;

static void
free_AGPaintTarget(AGPaintTarget *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGPaintTarget_blitTri(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGTexture *arg2 = 0 ;
    AGTriangle2 *arg3 = 0 ;
    AGTriangle2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGTriangle2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGTriangle2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blitTri((AGTexture const &)*arg2,(AGTriangle2 const &)*arg3,(AGTriangle2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_blit__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPaintTarget_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPaintTarget_blit__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPaintTarget_blit__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGPaintTarget_blit__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPaintTarget_blit'");
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_drawLine(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawLine((AGVector2 const &)*arg2,(AGVector2 const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_fillRect(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->fillRect((AGRect2 const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_getRect(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGPaintTarget const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPaintTarget_putPixel(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_getPixel(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGPaintTarget const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPaintTarget_beginPaint(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->beginPaint();
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_endPaint(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endPaint();
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPaintTarget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPaintTarget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPaintTarget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPaintTarget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGPaintTarget *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGPaintTarget";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGPaintTarget *)new SwigDirector_AGPaintTarget(arg1);
        
    } else {
        result = (AGPaintTarget *)new AGPaintTarget();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_disown_AGPaintTarget(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGTexture;

static VALUE
_wrap_new_AGTexture__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGTexture *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1);
        
    } else {
        result = (AGTexture *)new AGTexture();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGTexture__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *arg2 = 0 ;
    bool arg3 ;
    AGTexture *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = RTEST(argv[1]);
    char *classname = "Libantargisgui::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1,(AGSurface const &)*arg2,arg3);
        
    } else {
        result = (AGTexture *)new AGTexture((AGSurface const &)*arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGTexture__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *arg2 = 0 ;
    AGTexture *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargisgui::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1,(AGSurface const &)*arg2);
        
    } else {
        result = (AGTexture *)new AGTexture((AGSurface const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGTexture__SWIG_3(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGTexture *arg2 = 0 ;
    AGTexture *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargisgui::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1,(AGTexture const &)*arg2);
        
    } else {
        result = (AGTexture *)new AGTexture((AGTexture const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTexture_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTexture_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTexture);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTexture__SWIG_4(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    AGTexture *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    char *classname = "Libantargisgui::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1,arg2,arg3);
        
    } else {
        result = (AGTexture *)new AGTexture(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGTexture(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGTexture__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGTexture__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGTexture__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGTexture__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGTexture__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGTexture'");
    return Qnil;
}


static void
free_AGTexture(AGTexture *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGTexture_copy(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGTexture result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = ((AGTexture const *)arg1)->copy();
    
    {
        AGTexture * resultptr;
        resultptr = new AGTexture((AGTexture &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTexture, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_width(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (int)((AGTexture const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_height(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (int)((AGTexture const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getRect(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGTexture const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_getPixel(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGTexture const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_getSurfaceWidth(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getSurfaceWidth();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getSurfaceHeight(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getSurfaceHeight();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTextureWidth(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getTextureWidth();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTextureHeight(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getTextureHeight();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTW(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getTW();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTH(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getTH();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_hasTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (bool)((AGTexture const *)arg1)->hasTexture();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTexture_textureUsed(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (bool)((AGTexture const *)arg1)->textureUsed();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTexture_clearTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    (arg1)->clearTexture();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_clearTextureUsed(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    (arg1)->clearTextureUsed();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_beginPaint(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->beginPaint();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_endPaint(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endPaint();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_putPixel(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_fillRect(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->fillRect((AGRect2 const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE _wrap_AGTexture_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGTexture_blit__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGTexture_blit__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGTexture_blit'");
    return Qnil;
}


static VALUE
_wrap_AGTexture_setWrapping(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setWrapping(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_setFilter(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    GLuint arg2 ;
    GLuint arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg2 = *ptr;
    }
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setFilter(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_setClamp(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    GLuint arg2 ;
    GLuint arg3 ;
    GLuint arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg2 = *ptr;
    }
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg3 = *ptr;
    }
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg4 = *ptr;
    }
    (arg1)->setClamp(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_glTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGGLTexture *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (AGGLTexture *)(arg1)->glTexture();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLTexture,0);
    return vresult;
}


static VALUE
_wrap_AGTexture_sdlTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGInternalSurface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (AGInternalSurface *)(arg1)->sdlTexture();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGInternalSurface,0);
    return vresult;
}


static VALUE
_wrap_AGTexture_is3d(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (bool)((AGTexture const *)arg1)->is3d();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_beginRender(int argc, VALUE *argv, VALUE self) {
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    beginRender();
    
    return Qnil;
}


static VALUE
_wrap_endRender(int argc, VALUE *argv, VALUE self) {
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    endRender();
    
    return Qnil;
}


static VALUE
_wrap_isRendering(int argc, VALUE *argv, VALUE self) {
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (bool)isRendering();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


swig_class cAGInternalSurface;

static VALUE
_wrap_AGInternalSurface_sdlTexture_set(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    AGInternalSurface *arg2 = (AGInternalSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGInternalSurface, SWIG_POINTER_DISOWN);
    if (arg1) (arg1)->sdlTexture = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGInternalSurface_sdlTexture_get(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    AGInternalSurface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    result = (AGInternalSurface *) ((arg1)->sdlTexture);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGInternalSurface,0);
    return vresult;
}


static VALUE
_wrap_AGInternalSurface_glTexture_set(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    AGGLTexture *arg2 = (AGGLTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGGLTexture, SWIG_POINTER_DISOWN);
    if (arg1) (arg1)->glTexture = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGInternalSurface_glTexture_get(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    AGGLTexture *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    result = (AGGLTexture *) ((arg1)->glTexture);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLTexture,0);
    return vresult;
}


static VALUE
_wrap_AGInternalSurface_surface_set(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    SDL_Surface *arg2 = (SDL_Surface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Surface, SWIG_POINTER_DISOWN);
    if (arg1) (arg1)->surface = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGInternalSurface_surface_get(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    SDL_Surface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    result = (SDL_Surface *) ((arg1)->surface);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGInternalSurface_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGInternalSurface_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGInternalSurface);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGInternalSurface(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGInternalSurface *)new AGInternalSurface();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGInternalSurface(AGInternalSurface *arg1) {
    delete arg1;
}

swig_class cAGSurface;

static VALUE
_wrap_new_AGSurface__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1);
        
    } else {
        result = (AGSurface *)new AGSurface();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGSurface__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    AGSurface *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    char *classname = "Libantargisgui::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1,arg2,arg3);
        
    } else {
        result = (AGSurface *)new AGSurface(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSurface_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSurface_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSurface);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSurface__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *arg2 = 0 ;
    AGSurface *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargisgui::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1,(AGSurface const &)*arg2);
        
    } else {
        result = (AGSurface *)new AGSurface((AGSurface const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGSurface(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGSurface__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGSurface__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGSurface__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGSurface'");
    return Qnil;
}


static void
free_AGSurface(AGSurface *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGSurface_copy(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = ((AGSurface const *)arg1)->copy();
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_width(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = (int)((AGSurface const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSurface_height(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = (int)((AGSurface const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSurface_getRect(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSurface const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_getSubSurface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    AGSurface result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGSurface const *)arg1)->getSubSurface((AGRect2 const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_valid(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = (bool)((AGSurface const *)arg1)->valid();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSurface_blit(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradient((AGRect2 const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawGradientAlpha(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradientAlpha((AGRect2 const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawBorder((AGRect2 const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_putPixel(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_getPixel(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSurface const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_save(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    ((AGSurface const *)arg1)->save((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_load(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGSurface result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = AGSurface::load((std::string const &)*arg1);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_surface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGInternalSurface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = (AGInternalSurface *)((AGSurface const *)arg1)->surface();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGInternalSurface,0);
    return vresult;
}


static VALUE
_wrap_disown_AGSurface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_AGFreeSurface(int argc, VALUE *argv, VALUE self) {
    SDL_Surface *arg1 = (SDL_Surface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SDL_Surface, 0);
    AGFreeSurface(arg1);
    
    return Qnil;
}


swig_class cAGGLTexture;

static VALUE
_wrap_new_AGGLTexture__SWIG_0(int argc, VALUE *argv, VALUE self) {
    size_t arg1 ;
    size_t arg2 ;
    GLint arg3 ;
    AGGLTexture *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = NUM2ULONG(argv[0]);
    arg2 = NUM2ULONG(argv[1]);
    {
        GLint * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_GLint, 0);
        if (ptr) arg3 = *ptr;
    }
    result = (AGGLTexture *)new AGGLTexture(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGGLTexture__SWIG_1(int argc, VALUE *argv, VALUE self) {
    size_t arg1 ;
    size_t arg2 ;
    AGGLTexture *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2ULONG(argv[0]);
    arg2 = NUM2ULONG(argv[1]);
    result = (AGGLTexture *)new AGGLTexture(arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGGLTexture__SWIG_2(int argc, VALUE *argv, VALUE self) {
    size_t arg1 ;
    size_t arg2 ;
    size_t arg3 ;
    GLint arg4 ;
    AGGLTexture *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = NUM2ULONG(argv[0]);
    arg2 = NUM2ULONG(argv[1]);
    arg3 = NUM2ULONG(argv[2]);
    {
        GLint * ptr;
        SWIG_ConvertPtr(argv[3], (void **) &ptr, SWIGTYPE_p_GLint, 0);
        if (ptr) arg4 = *ptr;
    }
    result = (AGGLTexture *)new AGGLTexture(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGGLTexture_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGGLTexture_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGGLTexture);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGGLTexture__SWIG_3(int argc, VALUE *argv, VALUE self) {
    size_t arg1 ;
    size_t arg2 ;
    size_t arg3 ;
    AGGLTexture *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = NUM2ULONG(argv[0]);
    arg2 = NUM2ULONG(argv[1]);
    arg3 = NUM2ULONG(argv[2]);
    result = (AGGLTexture *)new AGGLTexture(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGGLTexture(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGGLTexture__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_GLint, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGGLTexture__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGGLTexture__SWIG_3(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_GLint, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGGLTexture__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGGLTexture'");
    return Qnil;
}


static void
free_AGGLTexture(AGGLTexture *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGGLTexture_setSurface__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGGLTexture *arg1 = (AGGLTexture *) 0 ;
    AGInternalSurface *arg2 = (AGInternalSurface *) 0 ;
    AGVector2 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGInternalSurface, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setSurface(arg2,(AGVector2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGGLTexture_setSurface__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGGLTexture *arg1 = (AGGLTexture *) 0 ;
    AGInternalSurface *arg2 = (AGInternalSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGInternalSurface, 0);
    (arg1)->setSurface(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGGLTexture_setSurface(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGGLTexture, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGInternalSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGGLTexture_setSurface__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGGLTexture, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGInternalSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGGLTexture_setSurface__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGGLTexture_setSurface'");
    return Qnil;
}


static VALUE
_wrap_AGGLTexture_id(int argc, VALUE *argv, VALUE self) {
    AGGLTexture *arg1 = (AGGLTexture *) 0 ;
    GLuint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLTexture, 0);
    result = (arg1)->id();
    
    {
        GLuint * resultptr;
        resultptr = new GLuint((GLuint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_GLuint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGGLTexture_is3d(int argc, VALUE *argv, VALUE self) {
    AGGLTexture *arg1 = (AGGLTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLTexture, 0);
    result = (bool)((AGGLTexture const *)arg1)->is3d();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGGLTexture_width(int argc, VALUE *argv, VALUE self) {
    AGGLTexture *arg1 = (AGGLTexture *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLTexture, 0);
    result = ((AGGLTexture const *)arg1)->width();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGGLTexture_height(int argc, VALUE *argv, VALUE self) {
    AGGLTexture *arg1 = (AGGLTexture *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLTexture, 0);
    result = ((AGGLTexture const *)arg1)->height();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGGLTexture_depth(int argc, VALUE *argv, VALUE self) {
    AGGLTexture *arg1 = (AGGLTexture *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLTexture, 0);
    result = ((AGGLTexture const *)arg1)->depth();
    
    vresult = UINT2NUM(result);
    return vresult;
}


swig_class cAGImage;

static VALUE
_wrap_new_AGImage__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGSurface arg4 ;
    bool arg5 ;
    AGRect *arg6 = 0 ;
    AGImage *result;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGSurface, 0);
        if (ptr) arg4 = *ptr;
    }
    arg5 = RTEST(argv[3]);
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGRect2, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGImage";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGImage *)new SwigDirector_AGImage(arg1,arg2,(AGRect2 const &)*arg3,arg4,arg5,(AGRect2 const &)*arg6);
            
        } else {
            result = (AGImage *)new AGImage(arg2,(AGRect2 const &)*arg3,arg4,arg5,(AGRect2 const &)*arg6);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGImage_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGImage_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGImage);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGImage__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGSurface arg4 ;
    bool arg5 ;
    AGImage *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGSurface, 0);
        if (ptr) arg4 = *ptr;
    }
    arg5 = RTEST(argv[3]);
    {
        char *classname = "Libantargisgui::AGImage";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGImage *)new SwigDirector_AGImage(arg1,arg2,(AGRect2 const &)*arg3,arg4,arg5);
            
        } else {
            result = (AGImage *)new AGImage(arg2,(AGRect2 const &)*arg3,arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGImage(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[7];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 6); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGImage__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    if (argc == 6) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            {
                                void *ptr;
                                _v = (NIL_P(argv[5]) || (TYPE(argv[5]) == T_DATA && SWIG_ConvertPtr(argv[5], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                            }
                            if (_v) {
                                return _wrap_new_AGImage__SWIG_0(nargs, args, self);
                            }
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGImage'");
    return Qnil;
}


static void
free_AGImage(AGImage *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGImage_draw(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGImage_setSurface(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGSurface *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setSurface((AGSurface const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGImage_setTexture(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGTexture *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setTexture((AGTexture const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGImage(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGLayoutCreator;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLayoutCreator_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLayoutCreator_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLayoutCreator);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLayoutCreator(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    AGLayoutCreator *result;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargisgui::AGLayoutCreator";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGLayoutCreator *)new SwigDirector_AGLayoutCreator(arg1,(std::string const &)*arg2);
        
    } else {
        result = (AGLayoutCreator *)new AGLayoutCreator((std::string const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGLayoutCreator(AGLayoutCreator *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGLayoutCreator_create(int argc, VALUE *argv, VALUE self) {
    AGLayoutCreator *arg1 = (AGLayoutCreator *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    xmlpp::Node *arg4 = 0 ;
    AGWidget *result;
    Swig::Director *director = 0;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutCreator, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_Node, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (AGWidget *)(arg1)->create(arg2,(AGRect2 const &)*arg3,(Node const &)*arg4);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGScreenWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGFrame*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFrame,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGHTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGHTiler,0);
                    else if(dynamic_cast<AGVTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVTiler,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_disown_AGLayoutCreator(int argc, VALUE *argv, VALUE self) {
    AGLayoutCreator *arg1 = (AGLayoutCreator *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGLayoutCreator, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGLayoutFactory;

static void
free_AGLayoutFactory(AGLayoutFactory *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGLayoutFactory_addCreator(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *arg1 = (AGLayoutFactory *) 0 ;
    std::string *arg2 = 0 ;
    AGLayoutCreator *arg3 = (AGLayoutCreator *) 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutFactory, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGLayoutCreator, 0);
    (arg1)->addCreator((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGLayoutFactory_create(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *arg1 = (AGLayoutFactory *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    xmlpp::Node *arg4 = 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutFactory, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_Node, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGWidget *)(arg1)->create(arg2,(AGRect2 const &)*arg3,(Node const &)*arg4);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGScreenWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGFrame*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFrame,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGHTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGHTiler,0);
                    else if(dynamic_cast<AGVTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVTiler,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_getLayoutFactory(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLayoutFactory *)getLayoutFactory();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayoutFactory,0);
    return vresult;
}


swig_class cAGVTiler;

static VALUE
_wrap_new_AGVTiler__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    bool arg4 ;
    AGVTiler *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = RTEST(argv[2]);
    {
        char *classname = "Libantargisgui::AGVTiler";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGVTiler *)new SwigDirector_AGVTiler(arg1,arg2,(AGRect2 const &)*arg3,arg4);
            
        } else {
            result = (AGVTiler *)new AGVTiler(arg2,(AGRect2 const &)*arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVTiler_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVTiler_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVTiler);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVTiler__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGVTiler *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGVTiler";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGVTiler *)new SwigDirector_AGVTiler(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGVTiler *)new AGVTiler(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGVTiler(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVTiler__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (argv[3] == Qtrue || argv[3] == Qfalse) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGVTiler__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVTiler'");
    return Qnil;
}


static VALUE
_wrap_AGVTiler_addChild(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVTiler_rePosition(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->rePosition();
    
    return Qnil;
}


static VALUE
_wrap_AGVTiler_adaptHeightFromChildren(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 0);
    (arg1)->adaptHeightFromChildren();
    
    return Qnil;
}


static VALUE
_wrap_AGVTiler_adaptWidthFromChildren(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 0);
    (arg1)->adaptWidthFromChildren();
    
    return Qnil;
}


static void
free_AGVTiler(AGVTiler *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGVTiler(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVTiler, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGHTiler;

static VALUE
_wrap_new_AGHTiler__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    bool arg4 ;
    AGHTiler *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = RTEST(argv[2]);
    {
        char *classname = "Libantargisgui::AGHTiler";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGHTiler *)new SwigDirector_AGHTiler(arg1,arg2,(AGRect2 const &)*arg3,arg4);
            
        } else {
            result = (AGHTiler *)new AGHTiler(arg2,(AGRect2 const &)*arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGHTiler_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGHTiler_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGHTiler);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGHTiler__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGHTiler *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGHTiler";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGHTiler *)new SwigDirector_AGHTiler(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGHTiler *)new AGHTiler(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGHTiler(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGHTiler__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (argv[3] == Qtrue || argv[3] == Qfalse) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGHTiler__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGHTiler'");
    return Qnil;
}


static VALUE
_wrap_AGHTiler_rePosition(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->rePosition();
    
    return Qnil;
}


static VALUE
_wrap_AGHTiler_adaptHeightFromChildren(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 0);
    (arg1)->adaptHeightFromChildren();
    
    return Qnil;
}


static VALUE
_wrap_AGHTiler_adaptWidthFromChildren(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 0);
    (arg1)->adaptWidthFromChildren();
    
    return Qnil;
}


static VALUE
_wrap_AGHTiler_adaptWidthFromParent(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 0);
    (arg1)->adaptWidthFromParent();
    
    return Qnil;
}


static void
free_AGHTiler(AGHTiler *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGHTiler(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGHTiler, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGListBoxItem;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListBoxItem_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListBoxItem_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListBoxItem);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListBoxItem(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    std::string arg2 ;
    AGListBoxItem *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[1]));
            arg2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGListBoxItem *)new AGListBoxItem(arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGListBoxItem_id_set(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 0);
    if (arg1) (arg1)->id = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBoxItem_id_get(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 0);
    result = (std::string *)& ((arg1)->id);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_AGListBoxItem_value_set(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 0);
    if (arg1) (arg1)->value = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBoxItem_value_get(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 0);
    result = (std::string *)& ((arg1)->value);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static void
free_AGListBoxItem(AGListBoxItem *arg1) {
    delete arg1;
}

swig_class cAGListBox;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListBox_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListBox_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListBox);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListBox(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGListBox *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGListBox";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGListBox *)new SwigDirector_AGListBox(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGListBox *)new AGListBox(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGListBox_insertItem(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string arg2 ;
    std::string arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg3 = std::string(StringValuePtr(argv[1]));
            arg3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->insertItem(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_selectItem(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->selectItem(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_getSelectedID(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    result = ((AGListBox const *)arg1)->getSelectedID();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGListBox_getSelectedValue(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    result = ((AGListBox const *)arg1)->getSelectedValue();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGListBox_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGListBox_sigSelect_set(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigSelect = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_sigSelect_get(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    result = (AGSignal *)& ((arg1)->sigSelect);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGListBox_sigDoubleClick_set(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigDoubleClick = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_sigDoubleClick_get(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    result = (AGSignal *)& ((arg1)->sigDoubleClick);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGListBox_draw(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGListBox_clearList(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    (arg1)->clearList();
    
    return Qnil;
}


static void
free_AGListBox(AGListBox *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGListBox(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGListBox(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGListBox *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGListBox &_result_ref = toAGListBox(*arg1);
        result = (AGListBox *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
    return vresult;
}


swig_class cAGMain;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMain_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMain_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMain);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMain(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    bool arg4 ;
    bool arg5 ;
    AGMain *result;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    arg4 = RTEST(argv[3]);
    arg5 = RTEST(argv[4]);
    result = (AGMain *)new AGMain(arg1,arg2,arg3,arg4,arg5);
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGMain(AGMain *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGMain_flip(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGMain_changeRes(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    bool arg5 ;
    bool arg6 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    arg5 = RTEST(argv[3]);
    arg6 = RTEST(argv[4]);
    (arg1)->changeRes(arg2,arg3,arg4,arg5,arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGMain_toggleFull(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    (arg1)->toggleFull();
    
    return Qnil;
}


static VALUE
_wrap_AGMain_width(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    result = (int)((AGMain const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGMain_height(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    result = (int)((AGMain const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGMain_setIcon(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setIcon((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMain_setCaption(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setCaption((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_getMain(int argc, VALUE *argv, VALUE self) {
    AGMain *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMain *)getMain();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMain,0);
    return vresult;
}


static VALUE
_wrap_hasQuit(int argc, VALUE *argv, VALUE self) {
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (bool)hasQuit();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


swig_class cAGMenu;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMenu_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMenu_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMenu);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMenu(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGPoint arg3 ;
    std::string *arg4 = 0 ;
    AGMenu *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        AGPoint * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGVector2, 0);
        if (ptr) arg3 = *ptr;
    }
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGMenu";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGMenu *)new SwigDirector_AGMenu(arg1,arg2,arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGMenu *)new AGMenu(arg2,arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGMenu_show(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGPoint arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        AGPoint * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGVector2, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->show(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_addItem(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->addItem((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_addMenu(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    AGMenu *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGMenu &_result_ref = (arg1)->addMenu((std::string const &)*arg2);
        result = (AGMenu *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
    }
    return vresult;
}


static VALUE
_wrap_AGMenu_draw(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_eventItemSelected(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->eventItemSelected((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_eventItemClicked(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->eventItemClicked((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_sigSelected_set(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigSelected = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_sigSelected_get(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    result = (AGSignal *)& ((arg1)->sigSelected);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static void
free_AGMenu(AGMenu *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGMenu(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGMenuItem;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMenuItem_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMenuItem_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMenuItem);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMenuItem(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGMenuItem *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGMenuItem";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGMenuItem *)new SwigDirector_AGMenuItem(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGMenuItem *)new AGMenuItem(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGMenuItem(AGMenuItem *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGMenuItem_draw(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenuItem_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMenuItem_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMenuItem_getSelected(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    result = (bool)((AGMenuItem const *)arg1)->getSelected();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMenuItem_unSelect(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    (arg1)->unSelect();
    
    return Qnil;
}


static VALUE
_wrap_AGMenuItem_getName(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    result = ((AGMenuItem const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGMenuItem_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMenuItem_eventSelect(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventSelect();
    
    return Qnil;
}


static VALUE
_wrap_AGMenuItem_eventUnselect(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventUnselect();
    
    return Qnil;
}


static VALUE
_wrap_disown_AGMenuItem(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSubMenu;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSubMenu_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSubMenu_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSubMenu);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSubMenu(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGSubMenu *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGSubMenu";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGSubMenu *)new SwigDirector_AGSubMenu(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGSubMenu *)new AGSubMenu(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGSubMenu(AGSubMenu *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGSubMenu_getMenu(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    AGMenu *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    result = (AGMenu *)(arg1)->getMenu();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AGSubMenu_eventSelect(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventSelect();
    
    return Qnil;
}


static VALUE
_wrap_AGSubMenu_eventUnselect(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventUnselect();
    
    return Qnil;
}


static VALUE
_wrap_AGSubMenu_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGSubMenu(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSound;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSound_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSound_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSound);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSound(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSound *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargisgui::AGSound";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGSound *)new SwigDirector_AGSound(arg1);
            
        } else {
            result = (AGSound *)new AGSound();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGSound(AGSound *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGSound_playMp3(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)(arg1)->playMp3((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSound_stopMp3(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    (arg1)->stopMp3();
    
    return Qnil;
}


static VALUE
_wrap_AGSound_checkFinished(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    (arg1)->checkFinished();
    
    return Qnil;
}


static VALUE
_wrap_AGSound_fadeOutMusic(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->fadeOutMusic(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_playWave__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->playWave((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_playWave__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->playWave((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSound_playWave(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSound_playWave__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSound_playWave__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSound_playWave'");
    return Qnil;
}


static VALUE
_wrap_AGSound_loopPlay__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    result = (int)(arg1)->loopPlay((std::string const &)*arg2,arg3);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSound_loopPlay__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)(arg1)->loopPlay((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE _wrap_AGSound_loopPlay(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSound_loopPlay__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSound_loopPlay__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSound_loopPlay'");
    return Qnil;
}


static VALUE
_wrap_AGSound_stopChannel__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    int arg2 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    (arg1)->stopChannel(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_stopChannel__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->stopChannel(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSound_stopChannel(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSound_stopChannel__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSound_stopChannel__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSound_stopChannel'");
    return Qnil;
}


static VALUE
_wrap_AGSound_volumeSound(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->volumeSound(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_volumeMusic(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->volumeMusic(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_loadWave(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->loadWave((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_sigMp3Finished_set(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMp3Finished = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGSound_sigMp3Finished_get(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    result = (AGSignal *)& ((arg1)->sigMp3Finished);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_getSoundManager(int argc, VALUE *argv, VALUE self) {
    AGSound *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGSound *)getSoundManager();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_disown_AGSound(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGProjection;

static VALUE
_wrap_AGProjection_a_set(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGMatrix3 *arg2 = (AGMatrix3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 0);
    if (arg1) (arg1)->a = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGProjection_a_get(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGMatrix3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    result = (AGMatrix3 *)& ((arg1)->a);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMatrix3,0);
    return vresult;
}


static VALUE
_wrap_AGProjection_clip_set(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 *arg2 = (AGRect2 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0);
    if (arg1) (arg1)->clip = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGProjection_clip_get(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    result = (AGRect2 *)& ((arg1)->clip);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRect2,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGProjection_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGProjection_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGProjection);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGProjection(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = 0 ;
    AGProjection *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRect2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGProjection *)new AGProjection((AGRect2 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGProjection_project__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGProjection const *)arg1)->project((AGVector2 const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGProjection_pointOk(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGPoint *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGProjection const *)arg1)->pointOk((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGProjection_project__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGProjection const *)arg1)->project((AGRect2 const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE _wrap_AGProjection_project(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGProjection, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGProjection_project__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGProjection, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGProjection_project__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGProjection_project'");
    return Qnil;
}


static VALUE
_wrap_AGProjection_clipRect(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect arg2 ;
    AGRect arg3 ;
    SwigValueWrapper<std::pair<AGRect2,AGRect2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    {
        AGRect * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGRect2, 0);
        if (ptr) arg2 = *ptr;
    }
    {
        AGRect * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect2, 0);
        if (ptr) arg3 = *ptr;
    }
    result = ((AGProjection const *)arg1)->clipRect(arg2,arg3);
    
    {
        std::pair<AGRect,AGRect > * resultptr;
        resultptr = new std::pair<AGRect,AGRect >((std::pair<AGRect,AGRect > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTAGRect2_AGRect2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGProjection_clipLine(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGLine2 arg2 ;
    AGLine2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    {
        AGLine2 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGLine2, 0);
        if (ptr) arg2 = *ptr;
    }
    result = ((AGProjection const *)arg1)->clipLine(arg2);
    
    {
        AGLine2 * resultptr;
        resultptr = new AGLine2((AGLine2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGLine2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGProjection_translate(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGVector2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->translate((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGProjection_setClip(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setClip((AGRect2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGProjection_getRect(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    result = ((AGProjection const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static void
free_AGProjection(AGProjection *arg1) {
    delete arg1;
}

swig_class cAGPainter;

static VALUE
_wrap_new_AGPainter__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGPainter *)new AGPainter();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGPainter__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = 0 ;
    AGPainter *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGPainter, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGPainter *)new AGPainter((AGPainter const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPainter_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPainter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPainter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPainter__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = 0 ;
    AGPainter *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGPainter *)new AGPainter(*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGPainter(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGPainter__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGPainter__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGPainter__SWIG_2(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGPainter'");
    return Qnil;
}


static void
free_AGPainter(AGPainter *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGPainter_putPixel(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->putPixel((AGVector2 const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_getPixel(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = (arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_drawCircle(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    float arg3 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = (float) NUM2DBL(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawCircle((AGVector2 const &)*arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blitTri(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGTriangle2 *arg3 = 0 ;
    AGTriangle2 *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGTriangle2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGTriangle2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blitTri((AGTexture const &)*arg2,(AGTriangle2 const &)*arg3,(AGTriangle2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGTexture const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGTexture const &)*arg2,(AGRect2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGSurface const &)*arg2,(AGRect2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGSurface const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPainter_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_blit__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_blit__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_5(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGPainter_blit__SWIG_3(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPainter_blit'");
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGSurface const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGSurface const &)*arg2,(AGRect2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGSurface const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPainter_tile(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGPainter_tile__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGPainter_tile__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_tile__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_tile__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_tile__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_tile__SWIG_5(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPainter_tile'");
    return Qnil;
}


static VALUE
_wrap_AGPainter_renderText(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    std::string *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGFont *arg4 = 0 ;
    std::string temp2 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGFont, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->renderText((std::string const &)*arg2,(AGVector2 const &)*arg3,(AGFont const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_getRect(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    result = ((AGPainter const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradient((AGRect2 const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawBorder((AGRect2 const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_fillRect(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->fillRect((AGRect2 const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawLine(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawLine((AGVector2 const &)*arg2,(AGVector2 const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_pushMatrix(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    (arg1)->pushMatrix();
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_popMatrix(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    (arg1)->popMatrix();
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_translate(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->translate((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_scale(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->scale((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_clip(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->clip((AGRect2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_transform(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->transform((AGRect2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_project(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGPainter const *)arg1)->project((AGVector2 const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_pointOk(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGPainter const *)arg1)->pointOk((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_toPNG(int argc, VALUE *argv, VALUE self) {
    SDL_Surface *arg1 = (SDL_Surface *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SDL_Surface, 0);
    result = toPNG((SDL_Surface const *)arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_fromPNG(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    SDL_Surface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (SDL_Surface *)fromPNG(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


swig_class cAGRadioGroup;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRadioGroup_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRadioGroup_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRadioGroup);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRadioGroup(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGRadioGroup *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGRadioGroup";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGRadioGroup *)new SwigDirector_AGRadioGroup(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGRadioGroup *)new AGRadioGroup(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGRadioGroup(AGRadioGroup *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGRadioGroup_eventChange(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventChange((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_add(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGRadio *arg2 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadio, 0);
    (arg1)->add(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_erase(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGRadio *arg2 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadio, 0);
    (arg1)->erase(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_sigChanged_set(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigChanged = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_sigChanged_get(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    result = (AGSignal *)& ((arg1)->sigChanged);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_disown_AGRadioGroup(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGRadio;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRadio_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRadio_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRadio);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRadio(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect arg3 ;
    AGRadio *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        AGRect * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect2, 0);
        if (ptr) arg3 = *ptr;
    }
    {
        char *classname = "Libantargisgui::AGRadio";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGRadio *)new SwigDirector_AGRadio(arg1,arg2,arg3);
            
        } else {
            result = (AGRadio *)new AGRadio(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGRadio(AGRadio *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGRadio_setGroup(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    AGRadioGroup *arg2 = (AGRadioGroup *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadioGroup, 0);
    (arg1)->setGroup(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadio_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRadio_deselect(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    (arg1)->deselect();
    
    return Qnil;
}


static VALUE
_wrap_AGRadio_setChecked(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    bool arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    arg2 = RTEST(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setChecked(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGRadio(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGScreen;

static VALUE
_wrap_AGScreen_begin(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->begin();
    
    return Qnil;
}


static VALUE
_wrap_AGScreen_flip(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGScreen_getWidth(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGScreen const *)arg1)->getWidth();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGScreen_getHeight(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGScreen const *)arg1)->getHeight();
    
    vresult = UINT2NUM(result);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGScreen_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGScreen_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGScreen);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGScreen(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGScreen *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGScreen";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGScreen *)new SwigDirector_AGScreen(arg1);
        
    } else {
        result = (AGScreen *)new AGScreen();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGScreen(AGScreen *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        AGScreen &_result_ref = getScreen();
        result = (AGScreen *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreen,0);
    return vresult;
}


static VALUE
_wrap_setScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    setScreen(arg1);
    
    return Qnil;
}


swig_class cAGTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTable_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTable(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGTable *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGTable";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGTable *)new SwigDirector_AGTable(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGTable *)new AGTable(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGTable(AGTable *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGTable_addFixedColumn(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addFixedColumn(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addFixedRow(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addFixedRow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addColumn(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addColumn(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addRow(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addRow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addChild(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    int arg3 ;
    AGWidget *arg4 = (AGWidget *) 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGWidget, 0);
    (arg1)->addChild(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    int arg3 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = ((AGTable const *)arg1)->getClientRect(arg2,arg3);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTable_arrange(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    (arg1)->arrange();
    
    return Qnil;
}


static VALUE
_wrap_AGTable_setWidth(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_setHeight(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGTable(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGTextureCache;

static VALUE
_wrap_AGTextureCache_get(int argc, VALUE *argv, VALUE self) {
    AGTextureCache *arg1 = (AGTextureCache *) 0 ;
    std::string *arg2 = 0 ;
    AGTexture *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureCache, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGTexture const &_result_ref = (arg1)->get((std::string const &)*arg2);
        result = (AGTexture *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
    }
    return vresult;
}


static VALUE
_wrap_AGTextureCache_get3D(int argc, VALUE *argv, VALUE self) {
    AGTextureCache *arg1 = (AGTextureCache *) 0 ;
    std::string *arg2 = 0 ;
    AGTexture *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureCache, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGTexture const &_result_ref = (arg1)->get3D((std::string const &)*arg2);
        result = (AGTexture *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
    }
    return vresult;
}


static VALUE
_wrap_getTextureCache(int argc, VALUE *argv, VALUE self) {
    AGTextureCache *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTextureCache *)getTextureCache();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTextureCache,0);
    return vresult;
}


static void
free_AGTextureCache(AGTextureCache *arg1) {
    delete arg1;
}

swig_class cAGTheme;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTheme_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTheme_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTheme);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTheme(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGTheme *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGTheme";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTheme *)new SwigDirector_AGTheme(arg1);
        
    } else {
        result = (AGTheme *)new AGTheme();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGTheme(AGTheme *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGTheme_getFont(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGFont result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getFont((std::string const &)*arg2);
    
    {
        AGFont * resultptr;
        resultptr = new AGFont((AGFont &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGFont, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_getColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGColor result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getColor((std::string const &)*arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setFont(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGFont arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGFont * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGFont, 0);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setFont((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_setColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGColor arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGColor * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGColor, 0);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setColor((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getInt(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)(arg1)->getInt((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTheme_setInt(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = NUM2INT(argv[1]);
    (arg1)->setInt((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getSurface((std::string const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGSurface, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setSurface((std::string const &)*arg2,(AGSurface const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getSurfaceName(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getSurfaceName((std::string const &)*arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setSurfaceName(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setSurfaceName((std::string const &)*arg2,(std::string const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_hasSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)((AGTheme const *)arg1)->hasSurface((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTheme_hasColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)((AGTheme const *)arg1)->hasColor((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTheme *)getTheme();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTheme,0);
    return vresult;
}


static VALUE
_wrap_setTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTheme, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    setTheme((AGTheme const &)*arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadTheme(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    loadTheme((std::string const &)*arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadThemeFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    bool result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)loadThemeFile((std::string const &)*arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_addPoint(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = addPoint((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_toInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    int result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)toInt((std::string const &)*arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE _wrap_toInt(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Uint8, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_toInt__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_toInt__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'toInt'");
    return Qnil;
}


static VALUE
_wrap_toFloat(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    float result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (float)toFloat((std::string const &)*arg1);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_fromHex(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    int result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)fromHex((std::string const &)*arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_toHex(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2INT(argv[0]);
    result = toHex(arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


swig_class cAGWindow;

static VALUE
_wrap_new_AGWindow__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    AGWindow *result;
    std::string temp4 ;
    std::string temp5 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[3]) == T_STRING) {
            //            temp5 = std::string(StringValuePtr(argv[3]));
            temp5 = std::string(RSTRING(argv[3])->ptr,RSTRING(argv[3])->len);
            arg5 = &temp5;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_new_AGWindow__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGWindow *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGWindow_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGWindow_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGWindow);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGWindow__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGWindow *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGWindow(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGWindow__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGWindow__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (TYPE(argv[4]) == T_STRING) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGWindow__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGWindow'");
    return Qnil;
}


static VALUE
_wrap_AGWindow_addChild(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_getClient(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    result = (AGWidget *)(arg1)->getClient();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGScreenWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGFrame*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFrame,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGHTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGHTiler,0);
                    else if(dynamic_cast<AGVTiler*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVTiler,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AGWindow_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_eventDragBy(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    AGPoint *arg3 = 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventDragBy(arg2,(AGVector2 const &)*arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_close(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    (arg1)->close();
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_tryClose(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->tryClose(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGWindow const *)arg1)->getClientRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWindow_sigClose_set(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigClose = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_sigClose_get(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    result = (AGSignal *)& ((arg1)->sigClose);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static void
free_AGWindow(AGWindow *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGWindow(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGWindow(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGWindow *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGWindow &_result_ref = toAGWindow(*arg1);
        result = (AGWindow *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
    return vresult;
}


swig_class cAGFrame;

static VALUE
_wrap_new_AGFrame__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    size_t arg4 ;
    AGFrame *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = NUM2ULONG(argv[2]);
    {
        char *classname = "Libantargisgui::AGFrame";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGFrame *)new SwigDirector_AGFrame(arg1,arg2,(AGRect2 const &)*arg3,arg4);
            
        } else {
            result = (AGFrame *)new AGFrame(arg2,(AGRect2 const &)*arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFrame_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFrame_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFrame);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFrame__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGBorder *arg4 = 0 ;
    AGFrame *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGBorder, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGFrame";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGFrame *)new SwigDirector_AGFrame(arg1,arg2,(AGRect2 const &)*arg3,(AGBorder const &)*arg4);
            
        } else {
            result = (AGFrame *)new AGFrame(arg2,(AGRect2 const &)*arg3,(AGBorder const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGFrame(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGBorder, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGFrame__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGFrame__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGFrame'");
    return Qnil;
}


static void
free_AGFrame(AGFrame *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGFrame_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGFrame *arg1 = (AGFrame *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFrame, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGFrame const *)arg1)->getClientRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFrame_draw(int argc, VALUE *argv, VALUE self) {
    AGFrame *arg1 = (AGFrame *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFrame, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGFrame(int argc, VALUE *argv, VALUE self) {
    AGFrame *arg1 = (AGFrame *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGFrame, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGScreenWidget;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGScreenWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGScreenWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGScreenWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGScreenWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGScreenWidget *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargisgui::AGScreenWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGScreenWidget *)new SwigDirector_AGScreenWidget(arg1);
            
        } else {
            result = (AGScreenWidget *)new AGScreenWidget();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGScreenWidget(AGScreenWidget *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGScreenWidget_draw(int argc, VALUE *argv, VALUE self) {
    AGScreenWidget *arg1 = (AGScreenWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreenWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGScreenWidget(int argc, VALUE *argv, VALUE self) {
    AGScreenWidget *arg1 = (AGScreenWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreenWidget, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGVertexProgram;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVertexProgram_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVertexProgram_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVertexProgram);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVertexProgram(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGVertexProgram *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGVertexProgram *)new AGVertexProgram((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGVertexProgram(AGVertexProgram *arg1) {
    delete arg1;
}

swig_class cAGFragProgram;

static VALUE
_wrap_new_AGFragProgram__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGFragProgram *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGFragProgram *)new AGFragProgram((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFragProgram_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFragProgram_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFragProgram);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFragProgram__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGFragProgram *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGFragProgram *)new AGFragProgram();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGFragProgram(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGFragProgram__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGFragProgram__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGFragProgram'");
    return Qnil;
}


static void
free_AGFragProgram(AGFragProgram *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGFragProgram_valid(int argc, VALUE *argv, VALUE self) {
    AGFragProgram *arg1 = (AGFragProgram *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFragProgram, 0);
    result = (bool)((AGFragProgram const *)arg1)->valid();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


swig_class cAGShaderParameter;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGShaderParameter_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGShaderParameter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGShaderParameter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGShaderParameter(int argc, VALUE *argv, VALUE self) {
    AGShaderParameter *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGShaderParameter *)new AGShaderParameter();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGShaderParameter(AGShaderParameter *arg1) {
    delete arg1;
}

swig_class cAGShaderProgram;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGShaderProgram_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGShaderProgram_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGShaderProgram);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGShaderProgram(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    AGShaderProgram *result;
    std::string temp2 ;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargisgui::AGShaderProgram";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGShaderProgram *)new SwigDirector_AGShaderProgram(arg1,(std::string const &)*arg2,(std::string const &)*arg3);
        
    } else {
        result = (AGShaderProgram *)new AGShaderProgram((std::string const &)*arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGShaderProgram(AGShaderProgram *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGShaderProgram_enable(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->enable();
    
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_disable(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->disable();
    
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_update(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->update(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_doUpdate(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->doUpdate(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_getLoc(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    GLint result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getLoc((std::string const &)*arg2);
    
    {
        GLint * resultptr;
        resultptr = new GLint((GLint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_GLint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGShaderProgram_getAttr(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    GLint result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getAttr((std::string const &)*arg2);
    
    {
        GLint * resultptr;
        resultptr = new GLint((GLint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_GLint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGShaderProgram_sendUniform__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = NUM2INT(argv[1]);
    (arg1)->sendUniform((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_sendUniform__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->sendUniform((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_sendUniform__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    AGVector3 *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector3, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendUniform((std::string const &)*arg2,(AGVector3 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_sendUniform__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    AGVector4 *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector4, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendUniform((std::string const &)*arg2,(AGVector4 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_sendUniform__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    AGMatrix4 *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGMatrix4, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendUniform((std::string const &)*arg2,(AGMatrix4 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_sendUniform__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    std::vector<AGMatrix4 > *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTAGMatrix4_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendUniform((std::string const &)*arg2,(std::vector<AGMatrix4 > const &)*arg3);
    
    return Qnil;
}


static VALUE _wrap_AGShaderProgram_sendUniform(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGShaderProgram_sendUniform__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGShaderProgram_sendUniform__SWIG_3(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGShaderProgram_sendUniform__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_std__vectorTAGMatrix4_t, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGShaderProgram_sendUniform__SWIG_5(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGShaderProgram_sendUniform__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGShaderProgram_sendUniform__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGShaderProgram_sendUniform'");
    return Qnil;
}


static VALUE
_wrap_AGShaderProgram_sendAttribute(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    std::vector<float > *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTfloat_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendAttribute((std::string const &)*arg2,(std::vector<float > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGShaderProgram(int argc, VALUE *argv, VALUE self) {
    AGShaderProgram *arg1 = (AGShaderProgram *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGShaderProgram, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_glslOk(int argc, VALUE *argv, VALUE self) {
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (bool)glslOk();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_AGSubMenuTo_p_AGHTiler(void *x) {
    return (void *)((AGHTiler *) (AGMenuItem *) ((AGSubMenu *) x));
}
static void *_p_AGMenuItemTo_p_AGHTiler(void *x) {
    return (void *)((AGHTiler *)  ((AGMenuItem *) x));
}
static void *_p_AGDialogTo_p_AGLayout(void *x) {
    return (void *)((AGLayout *)  ((AGDialog *) x));
}
static void *_p_AGHTilerTo_p_AGVTiler(void *x) {
    return (void *)((AGVTiler *)  ((AGHTiler *) x));
}
static void *_p_AGMenuTo_p_AGVTiler(void *x) {
    return (void *)((AGVTiler *)  ((AGMenu *) x));
}
static void *_p_AGSubMenuTo_p_AGVTiler(void *x) {
    return (void *)((AGVTiler *) (AGHTiler *)(AGMenuItem *) ((AGSubMenu *) x));
}
static void *_p_AGMenuItemTo_p_AGVTiler(void *x) {
    return (void *)((AGVTiler *) (AGHTiler *) ((AGMenuItem *) x));
}
static void *_p_AGRadioTo_p_AGCheckBox(void *x) {
    return (void *)((AGCheckBox *)  ((AGRadio *) x));
}
static void *_p_AGWindowTo_p_AGTable(void *x) {
    return (void *)((AGTable *)  ((AGWindow *) x));
}
static void *_p_AGRadioTo_p_AGButton(void *x) {
    return (void *)((AGButton *) (AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGCheckBoxTo_p_AGButton(void *x) {
    return (void *)((AGButton *)  ((AGCheckBox *) x));
}
static void *_p_AGListBoxTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGListBox *) x));
}
static void *_p_AGWindowTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGTable *) ((AGWindow *) x));
}
static void *_p_AGCaptionTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGText *) ((AGCaption *) x));
}
static void *_p_AGSubMenuTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGVTiler *)(AGHTiler *)(AGMenuItem *) ((AGSubMenu *) x));
}
static void *_p_AGButtonTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGVTiler *) x));
}
static void *_p_AGMenuItemTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGVTiler *)(AGHTiler *) ((AGMenuItem *) x));
}
static void *_p_AGTableTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGTable *) x));
}
static void *_p_AGMenuTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGColorButton *) x));
}
static void *_p_AGHTilerTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGGLWidgetTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGGLWidget *) x));
}
static void *_p_AGImageTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGImage *) x));
}
static void *_p_AGScreenWidgetTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGScreenWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGLayout *) x));
}
static void *_p_AGFrameTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGFrame *) x));
}
static void *_p_AGDialogTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGLayout *) ((AGDialog *) x));
}
static void *_p_AGRadioTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGTextTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGSound *) x));
}
static void *_p_AGListBoxTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGListBox *) x));
}
static void *_p_AGWindowTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_AGCaptionTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGApplicationTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *)  ((AGApplication *) x));
}
static void *_p_AGSubMenuTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGVTiler *)(AGHTiler *)(AGMenuItem *) ((AGSubMenu *) x));
}
static void *_p_AGButtonTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGVTiler *) x));
}
static void *_p_AGMenuItemTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGVTiler *)(AGHTiler *) ((AGMenuItem *) x));
}
static void *_p_AGTableTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGTable *) x));
}
static void *_p_AGWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *)  ((AGWidget *) x));
}
static void *_p_AGMenuTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGColorButton *) x));
}
static void *_p_AGHTilerTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGGLWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGGLWidget *) x));
}
static void *_p_AGImageTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGImage *) x));
}
static void *_p_AGScreenWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGScreenWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGLayout *) x));
}
static void *_p_AGFrameTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGFrame *) x));
}
static void *_p_AGDialogTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGRadioTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGTextTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGSound *) x));
}
static void *_p_AGListBoxTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGListBox *) x));
}
static void *_p_AGWindowTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_AGCaptionTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGApplicationTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *) ((AGApplication *) x));
}
static void *_p_AGSubMenuTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGVTiler *)(AGHTiler *)(AGMenuItem *) ((AGSubMenu *) x));
}
static void *_p_AGButtonTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGVTiler *) x));
}
static void *_p_AGMenuItemTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGVTiler *)(AGHTiler *) ((AGMenuItem *) x));
}
static void *_p_AGTableTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGTable *) x));
}
static void *_p_AGWidgetTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *) ((AGWidget *) x));
}
static void *_p_AGMenuTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGColorButton *) x));
}
static void *_p_AGListenerTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *)  ((AGListener *) x));
}
static void *_p_AGHTilerTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGGLWidgetTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGGLWidget *) x));
}
static void *_p_AGImageTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGImage *) x));
}
static void *_p_AGScreenWidgetTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGScreenWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGLayout *) x));
}
static void *_p_AGFrameTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGFrame *) x));
}
static void *_p_AGMessageObjectTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *) ((AGMessageObject *) x));
}
static void *_p_AGDialogTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGRadioTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGTextTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGSound *) x));
}
static void *_p_AGSubMenuTo_p_AGMenuItem(void *x) {
    return (void *)((AGMenuItem *)  ((AGSubMenu *) x));
}
static void *_p_AGPoint3To_p_AGVector3(void *x) {
    return (void *)((AGVector3 *)  ((AGPoint3 *) x));
}
static void *_p_DomParserTo_p_Parser(void *x) {
    return (void *)((Parser *)  ((DomParser *) x));
}
static void *_p_AGSurfaceTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGSurface *) x));
}
static void *_p_AGTextureTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGTexture *) x));
}
static void *_p_AGScreenTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGScreen *) x));
}
static void *_p_AGCaptionTo_p_AGText(void *x) {
    return (void *)((AGText *)  ((AGCaption *) x));
}
static void *_p_AGListBoxTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGListBox *) x));
}
static void *_p_AGWindowTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_AGCaptionTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGApplicationTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *) ((AGApplication *) x));
}
static void *_p_AGSubMenuTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGVTiler *)(AGHTiler *)(AGMenuItem *) ((AGSubMenu *) x));
}
static void *_p_AGButtonTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGVTiler *) x));
}
static void *_p_AGMenuItemTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGVTiler *)(AGHTiler *) ((AGMenuItem *) x));
}
static void *_p_AGTableTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGTable *) x));
}
static void *_p_AGWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *) ((AGWidget *) x));
}
static void *_p_AGMenuTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGColorButton *) x));
}
static void *_p_AGHTilerTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGGLWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGGLWidget *) x));
}
static void *_p_AGImageTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGImage *) x));
}
static void *_p_AGScreenWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGScreenWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGLayout *) x));
}
static void *_p_AGFrameTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGFrame *) x));
}
static void *_p_AGMessageObjectTo_p_AGListener(void *x) {
    return (void *)((AGListener *)  ((AGMessageObject *) x));
}
static void *_p_AGDialogTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGRadioTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGTextTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGSound *) x));
}
static swig_type_info _swigt__p_AGAngle = {"_p_AGAngle", "AGAngle *", 0, 0, 0};
static swig_type_info _swigt__p_AGApplication = {"_p_AGApplication", "AGApplication *", 0, 0, 0};
static swig_type_info _swigt__p_AGBackground = {"_p_AGBackground", "AGBackground *", 0, 0, 0};
static swig_type_info _swigt__p_AGBorder = {"_p_AGBorder", "AGBorder *", 0, 0, 0};
static swig_type_info _swigt__p_AGBox3 = {"_p_AGBox3", "AGBox3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGButton = {"_p_AGButton", "AGButton *", 0, 0, 0};
static swig_type_info _swigt__p_AGCPPListener = {"_p_AGCPPListener", "AGCPPListener *", 0, 0, 0};
static swig_type_info _swigt__p_AGCaption = {"_p_AGCaption", "AGCaption *", 0, 0, 0};
static swig_type_info _swigt__p_AGCheckBox = {"_p_AGCheckBox", "AGCheckBox *", 0, 0, 0};
static swig_type_info _swigt__p_AGCircle2 = {"_p_AGCircle2", "AGCircle2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGCollisionData = {"_p_AGCollisionData", "AGCollisionData *", 0, 0, 0};
static swig_type_info _swigt__p_AGColor = {"_p_AGColor", "AGColor *", 0, 0, 0};
static swig_type_info _swigt__p_AGColorButton = {"_p_AGColorButton", "AGColorButton *", 0, 0, 0};
static swig_type_info _swigt__p_AGDialog = {"_p_AGDialog", "AGDialog *", 0, 0, 0};
static swig_type_info _swigt__p_AGEdit = {"_p_AGEdit", "AGEdit *", 0, 0, 0};
static swig_type_info _swigt__p_AGEditLine = {"_p_AGEditLine", "AGEditLine *", 0, 0, 0};
static swig_type_info _swigt__p_AGEvent = {"_p_AGEvent", "AGEvent *", 0, 0, 0};
static swig_type_info _swigt__p_AGFont = {"_p_AGFont", "AGFont *", 0, 0, 0};
static swig_type_info _swigt__p_AGFontEngine = {"_p_AGFontEngine", "AGFontEngine *", 0, 0, 0};
static swig_type_info _swigt__p_AGFragProgram = {"_p_AGFragProgram", "AGFragProgram *", 0, 0, 0};
static swig_type_info _swigt__p_AGFrame = {"_p_AGFrame", "AGFrame *", 0, 0, 0};
static swig_type_info _swigt__p_AGGLTexture = {"_p_AGGLTexture", "AGGLTexture *", 0, 0, 0};
static swig_type_info _swigt__p_AGGLWidget = {"_p_AGGLWidget", "AGGLWidget *", 0, 0, 0};
static swig_type_info _swigt__p_AGHTiler = {"_p_AGHTiler", "AGHTiler *", 0, 0, 0};
static swig_type_info _swigt__p_AGImage = {"_p_AGImage", "AGImage *", 0, 0, 0};
static swig_type_info _swigt__p_AGInternalSurface = {"_p_AGInternalSurface", "AGInternalSurface *", 0, 0, 0};
static swig_type_info _swigt__p_AGLayout = {"_p_AGLayout", "AGLayout *", 0, 0, 0};
static swig_type_info _swigt__p_AGLayoutCreator = {"_p_AGLayoutCreator", "AGLayoutCreator *", 0, 0, 0};
static swig_type_info _swigt__p_AGLayoutFactory = {"_p_AGLayoutFactory", "AGLayoutFactory *", 0, 0, 0};
static swig_type_info _swigt__p_AGLine2 = {"_p_AGLine2", "AGLine2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGLine3 = {"_p_AGLine3", "AGLine3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGListBox = {"_p_AGListBox", "AGListBox *", 0, 0, 0};
static swig_type_info _swigt__p_AGListBoxItem = {"_p_AGListBoxItem", "AGListBoxItem *", 0, 0, 0};
static swig_type_info _swigt__p_AGListener = {"_p_AGListener", "AGListener *", 0, 0, 0};
static swig_type_info _swigt__p_AGMain = {"_p_AGMain", "AGMain *", 0, 0, 0};
static swig_type_info _swigt__p_AGMatrix3 = {"_p_AGMatrix3", "AGMatrix3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGMatrix4 = {"_p_AGMatrix4", "AGMatrix4 *", 0, 0, 0};
static swig_type_info _swigt__p_AGMenu = {"_p_AGMenu", "AGMenu *", 0, 0, 0};
static swig_type_info _swigt__p_AGMenuItem = {"_p_AGMenuItem", "AGMenuItem *", 0, 0, 0};
static swig_type_info _swigt__p_AGMessageObject = {"_p_AGMessageObject", "AGMessageObject *", 0, 0, 0};
static swig_type_info _swigt__p_AGMutex = {"_p_AGMutex", "AGMutex *", 0, 0, 0};
static swig_type_info _swigt__p_AGPaintTarget = {"_p_AGPaintTarget", "AGPaintTarget *", 0, 0, 0};
static swig_type_info _swigt__p_AGPainter = {"_p_AGPainter", "AGPainter *", 0, 0, 0};
static swig_type_info _swigt__p_AGPoint3 = {"_p_AGPoint3", "AGPoint3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGProjection = {"_p_AGProjection", "AGProjection *", 0, 0, 0};
static swig_type_info _swigt__p_AGRadio = {"_p_AGRadio", "AGRadio *", 0, 0, 0};
static swig_type_info _swigt__p_AGRadioGroup = {"_p_AGRadioGroup", "AGRadioGroup *", 0, 0, 0};
static swig_type_info _swigt__p_AGRect2 = {"_p_AGRect2", "AGRect2 *|AGRect *", 0, 0, 0};
static swig_type_info _swigt__p_AGRect3 = {"_p_AGRect3", "AGRect3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGRubyObject = {"_p_AGRubyObject", "AGRubyObject *", 0, 0, 0};
static swig_type_info _swigt__p_AGScreen = {"_p_AGScreen", "AGScreen *", 0, 0, 0};
static swig_type_info _swigt__p_AGScreenWidget = {"_p_AGScreenWidget", "AGScreenWidget *", 0, 0, 0};
static swig_type_info _swigt__p_AGShaderParameter = {"_p_AGShaderParameter", "AGShaderParameter *", 0, 0, 0};
static swig_type_info _swigt__p_AGShaderProgram = {"_p_AGShaderProgram", "AGShaderProgram *", 0, 0, 0};
static swig_type_info _swigt__p_AGSignal = {"_p_AGSignal", "AGSignal *", 0, 0, 0};
static swig_type_info _swigt__p_AGSound = {"_p_AGSound", "AGSound *", 0, 0, 0};
static swig_type_info _swigt__p_AGSubMenu = {"_p_AGSubMenu", "AGSubMenu *", 0, 0, 0};
static swig_type_info _swigt__p_AGSurface = {"_p_AGSurface", "AGSurface *", 0, 0, 0};
static swig_type_info _swigt__p_AGTable = {"_p_AGTable", "AGTable *", 0, 0, 0};
static swig_type_info _swigt__p_AGText = {"_p_AGText", "AGText *", 0, 0, 0};
static swig_type_info _swigt__p_AGTexture = {"_p_AGTexture", "AGTexture *", 0, 0, 0};
static swig_type_info _swigt__p_AGTextureCache = {"_p_AGTextureCache", "AGTextureCache *", 0, 0, 0};
static swig_type_info _swigt__p_AGTheme = {"_p_AGTheme", "AGTheme *", 0, 0, 0};
static swig_type_info _swigt__p_AGTriangle2 = {"_p_AGTriangle2", "AGTriangle2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGTriangle3 = {"_p_AGTriangle3", "AGTriangle3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGVTiler = {"_p_AGVTiler", "AGVTiler *", 0, 0, 0};
static swig_type_info _swigt__p_AGVector2 = {"_p_AGVector2", "AGVector2 *|AGPoint *", 0, 0, 0};
static swig_type_info _swigt__p_AGVector3 = {"_p_AGVector3", "AGVector3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGVector4 = {"_p_AGVector4", "AGVector4 *", 0, 0, 0};
static swig_type_info _swigt__p_AGVertexProgram = {"_p_AGVertexProgram", "AGVertexProgram *", 0, 0, 0};
static swig_type_info _swigt__p_AGWidget = {"_p_AGWidget", "AGWidget *", 0, 0, 0};
static swig_type_info _swigt__p_AGWindow = {"_p_AGWindow", "AGWindow *", 0, 0, 0};
static swig_type_info _swigt__p_Attributes = {"_p_Attributes", "Attributes *", 0, 0, 0};
static swig_type_info _swigt__p_Document = {"_p_Document", "Document *|xmlpp::Document *", 0, 0, 0};
static swig_type_info _swigt__p_DomParser = {"_p_DomParser", "DomParser *", 0, 0, 0};
static swig_type_info _swigt__p_GLint = {"_p_GLint", "GLint *", 0, 0, 0};
static swig_type_info _swigt__p_GLuint = {"_p_GLuint", "GLuint *", 0, 0, 0};
static swig_type_info _swigt__p_Node = {"_p_Node", "Node *|xmlpp::Node *", 0, 0, 0};
static swig_type_info _swigt__p_NodeVector = {"_p_NodeVector", "NodeVector *", 0, 0, 0};
static swig_type_info _swigt__p_Node__NodeVector__const_iterator = {"_p_Node__NodeVector__const_iterator", "Node::NodeVector::const_iterator *|Node::const_iterator *", 0, 0, 0};
static swig_type_info _swigt__p_Node__NodeVector__iterator = {"_p_Node__NodeVector__iterator", "Node::NodeVector::iterator *|Node::iterator *", 0, 0, 0};
static swig_type_info _swigt__p_Parser = {"_p_Parser", "Parser *", 0, 0, 0};
static swig_type_info _swigt__p_SDLKey = {"_p_SDLKey", "enum SDLKey *|SDLKey *", 0, 0, 0};
static swig_type_info _swigt__p_SDLMod = {"_p_SDLMod", "enum SDLMod *|SDLMod *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_Event = {"_p_SDL_Event", "SDL_Event *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_PixelFormat = {"_p_SDL_PixelFormat", "SDL_PixelFormat *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_Rect = {"_p_SDL_Rect", "SDL_Rect *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_Surface = {"_p_SDL_Surface", "SDL_Surface *", 0, 0, 0};
static swig_type_info _swigt__p_Uint32 = {"_p_Uint32", "Uint32 *", 0, 0, 0};
static swig_type_info _swigt__p_Uint8 = {"_p_Uint8", "Uint8 *", 0, 0, 0};
static swig_type_info _swigt__p_const_iterator = {"_p_const_iterator", "const_iterator *", 0, 0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *", 0, 0, 0};
static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, 0};
static swig_type_info _swigt__p_p_Node = {"_p_p_Node", "Node **", 0, 0, 0};
static swig_type_info _swigt__p_std__listTAGRect2_t = {"_p_std__listTAGRect2_t", "std::list<AGRect2 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__mapTstd__string_std__string_t = {"_p_std__mapTstd__string_std__string_t", "std::map<std::string,std::string > *|Node::Attributes *", 0, 0, 0};
static swig_type_info _swigt__p_std__ostringstream = {"_p_std__ostringstream", "std::ostringstream *", 0, 0, 0};
static swig_type_info _swigt__p_std__pairTAGRect2_AGRect2_t = {"_p_std__pairTAGRect2_AGRect2_t", "std::pair<AGRect2,AGRect2 > *|std::pair<AGRect,AGRect > *", 0, 0, 0};
static swig_type_info _swigt__p_std__pairTstd__string_bool_t = {"_p_std__pairTstd__string_bool_t", "std::pair<std::string,bool > *", 0, 0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGBox3_t = {"_p_std__vectorTAGBox3_t", "std::vector<AGBox3 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGLine2_t = {"_p_std__vectorTAGLine2_t", "std::vector<AGLine2 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGMatrix4_t = {"_p_std__vectorTAGMatrix4_t", "std::vector<AGMatrix4 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGRect3_t = {"_p_std__vectorTAGRect3_t", "std::vector<AGRect3 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGVector2_t = {"_p_std__vectorTAGVector2_t", "std::vector<AGVector2 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGVector4_t = {"_p_std__vectorTAGVector4_t", "std::vector<AGVector4 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTNode_p_t = {"_p_std__vectorTNode_p_t", "std::vector<Node * > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTfloat_t = {"_p_std__vectorTfloat_t", "std::vector<float > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTstd__string_t = {"_p_std__vectorTstd__string_t", "std::vector<std::string > *", 0, 0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "unsigned long *|VALUE *", 0, 0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_AGAngle,
  &_swigt__p_AGApplication,
  &_swigt__p_AGBackground,
  &_swigt__p_AGBorder,
  &_swigt__p_AGBox3,
  &_swigt__p_AGButton,
  &_swigt__p_AGCPPListener,
  &_swigt__p_AGCaption,
  &_swigt__p_AGCheckBox,
  &_swigt__p_AGCircle2,
  &_swigt__p_AGCollisionData,
  &_swigt__p_AGColor,
  &_swigt__p_AGColorButton,
  &_swigt__p_AGDialog,
  &_swigt__p_AGEdit,
  &_swigt__p_AGEditLine,
  &_swigt__p_AGEvent,
  &_swigt__p_AGFont,
  &_swigt__p_AGFontEngine,
  &_swigt__p_AGFragProgram,
  &_swigt__p_AGFrame,
  &_swigt__p_AGGLTexture,
  &_swigt__p_AGGLWidget,
  &_swigt__p_AGHTiler,
  &_swigt__p_AGImage,
  &_swigt__p_AGInternalSurface,
  &_swigt__p_AGLayout,
  &_swigt__p_AGLayoutCreator,
  &_swigt__p_AGLayoutFactory,
  &_swigt__p_AGLine2,
  &_swigt__p_AGLine3,
  &_swigt__p_AGListBox,
  &_swigt__p_AGListBoxItem,
  &_swigt__p_AGListener,
  &_swigt__p_AGMain,
  &_swigt__p_AGMatrix3,
  &_swigt__p_AGMatrix4,
  &_swigt__p_AGMenu,
  &_swigt__p_AGMenuItem,
  &_swigt__p_AGMessageObject,
  &_swigt__p_AGMutex,
  &_swigt__p_AGPaintTarget,
  &_swigt__p_AGPainter,
  &_swigt__p_AGPoint3,
  &_swigt__p_AGProjection,
  &_swigt__p_AGRadio,
  &_swigt__p_AGRadioGroup,
  &_swigt__p_AGRect2,
  &_swigt__p_AGRect3,
  &_swigt__p_AGRubyObject,
  &_swigt__p_AGScreen,
  &_swigt__p_AGScreenWidget,
  &_swigt__p_AGShaderParameter,
  &_swigt__p_AGShaderProgram,
  &_swigt__p_AGSignal,
  &_swigt__p_AGSound,
  &_swigt__p_AGSubMenu,
  &_swigt__p_AGSurface,
  &_swigt__p_AGTable,
  &_swigt__p_AGText,
  &_swigt__p_AGTexture,
  &_swigt__p_AGTextureCache,
  &_swigt__p_AGTheme,
  &_swigt__p_AGTriangle2,
  &_swigt__p_AGTriangle3,
  &_swigt__p_AGVTiler,
  &_swigt__p_AGVector2,
  &_swigt__p_AGVector3,
  &_swigt__p_AGVector4,
  &_swigt__p_AGVertexProgram,
  &_swigt__p_AGWidget,
  &_swigt__p_AGWindow,
  &_swigt__p_Attributes,
  &_swigt__p_Document,
  &_swigt__p_DomParser,
  &_swigt__p_GLint,
  &_swigt__p_GLuint,
  &_swigt__p_Node,
  &_swigt__p_NodeVector,
  &_swigt__p_Node__NodeVector__const_iterator,
  &_swigt__p_Node__NodeVector__iterator,
  &_swigt__p_Parser,
  &_swigt__p_SDLKey,
  &_swigt__p_SDLMod,
  &_swigt__p_SDL_Event,
  &_swigt__p_SDL_PixelFormat,
  &_swigt__p_SDL_Rect,
  &_swigt__p_SDL_Surface,
  &_swigt__p_Uint32,
  &_swigt__p_Uint8,
  &_swigt__p_const_iterator,
  &_swigt__p_float,
  &_swigt__p_iterator,
  &_swigt__p_p_Node,
  &_swigt__p_std__listTAGRect2_t,
  &_swigt__p_std__mapTstd__string_std__string_t,
  &_swigt__p_std__ostringstream,
  &_swigt__p_std__pairTAGRect2_AGRect2_t,
  &_swigt__p_std__pairTstd__string_bool_t,
  &_swigt__p_std__string,
  &_swigt__p_std__vectorTAGBox3_t,
  &_swigt__p_std__vectorTAGLine2_t,
  &_swigt__p_std__vectorTAGMatrix4_t,
  &_swigt__p_std__vectorTAGRect3_t,
  &_swigt__p_std__vectorTAGVector2_t,
  &_swigt__p_std__vectorTAGVector4_t,
  &_swigt__p_std__vectorTNode_p_t,
  &_swigt__p_std__vectorTfloat_t,
  &_swigt__p_std__vectorTstd__string_t,
  &_swigt__p_unsigned_long,
};

static swig_cast_info _swigc__p_AGAngle[] = {  {&_swigt__p_AGAngle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGApplication[] = {  {&_swigt__p_AGApplication, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGBackground[] = {  {&_swigt__p_AGBackground, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGBorder[] = {  {&_swigt__p_AGBorder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGBox3[] = {  {&_swigt__p_AGBox3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGButton[] = {  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGButton, 0, 0},  {&_swigt__p_AGButton, 0, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGButton, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCPPListener[] = {  {&_swigt__p_AGCPPListener, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCaption[] = {  {&_swigt__p_AGCaption, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCheckBox[] = {  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGCheckBox, 0, 0},  {&_swigt__p_AGCheckBox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCircle2[] = {  {&_swigt__p_AGCircle2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCollisionData[] = {  {&_swigt__p_AGCollisionData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGColor[] = {  {&_swigt__p_AGColor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGColorButton[] = {  {&_swigt__p_AGColorButton, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGDialog[] = {  {&_swigt__p_AGDialog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGEdit[] = {  {&_swigt__p_AGEdit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGEditLine[] = {  {&_swigt__p_AGEditLine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGEvent[] = {  {&_swigt__p_AGEvent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGFont[] = {  {&_swigt__p_AGFont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGFontEngine[] = {  {&_swigt__p_AGFontEngine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGFragProgram[] = {  {&_swigt__p_AGFragProgram, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGFrame[] = {  {&_swigt__p_AGFrame, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGGLTexture[] = {  {&_swigt__p_AGGLTexture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGGLWidget[] = {  {&_swigt__p_AGGLWidget, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGHTiler[] = {  {&_swigt__p_AGHTiler, 0, 0, 0},  {&_swigt__p_AGSubMenu, _p_AGSubMenuTo_p_AGHTiler, 0, 0},  {&_swigt__p_AGMenuItem, _p_AGMenuItemTo_p_AGHTiler, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGImage[] = {  {&_swigt__p_AGImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGInternalSurface[] = {  {&_swigt__p_AGInternalSurface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLayout[] = {  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGLayout, 0, 0},  {&_swigt__p_AGLayout, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLayoutCreator[] = {  {&_swigt__p_AGLayoutCreator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLayoutFactory[] = {  {&_swigt__p_AGLayoutFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLine2[] = {  {&_swigt__p_AGLine2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLine3[] = {  {&_swigt__p_AGLine3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGListBox[] = {  {&_swigt__p_AGListBox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGListBoxItem[] = {  {&_swigt__p_AGListBoxItem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGListener[] = {  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGListener, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGListener, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGListener, 0, 0},  {&_swigt__p_AGSubMenu, _p_AGSubMenuTo_p_AGListener, 0, 0},  {&_swigt__p_AGMenu, _p_AGMenuTo_p_AGListener, 0, 0},  {&_swigt__p_AGApplication, _p_AGApplicationTo_p_AGListener, 0, 0},  {&_swigt__p_AGMenuItem, _p_AGMenuItemTo_p_AGListener, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGListener, 0, 0},  {&_swigt__p_AGVTiler, _p_AGVTilerTo_p_AGListener, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGListener, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGListener, 0, 0},  {&_swigt__p_AGWidget, _p_AGWidgetTo_p_AGListener, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGListener, 0, 0},  {&_swigt__p_AGListener, 0, 0, 0},  {&_swigt__p_AGHTiler, _p_AGHTilerTo_p_AGListener, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGListener, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGListener, 0, 0},  {&_swigt__p_AGScreenWidget, _p_AGScreenWidgetTo_p_AGListener, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGListener, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGListener, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGListener, 0, 0},  {&_swigt__p_AGFrame, _p_AGFrameTo_p_AGListener, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGListener, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGListener, 0, 0},  {&_swigt__p_AGMessageObject, _p_AGMessageObjectTo_p_AGListener, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGListener, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGListener, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMain[] = {  {&_swigt__p_AGMain, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMatrix3[] = {  {&_swigt__p_AGMatrix3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMatrix4[] = {  {&_swigt__p_AGMatrix4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMenu[] = {  {&_swigt__p_AGMenu, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMenuItem[] = {  {&_swigt__p_AGSubMenu, _p_AGSubMenuTo_p_AGMenuItem, 0, 0},  {&_swigt__p_AGMenuItem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMessageObject[] = {  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGSubMenu, _p_AGSubMenuTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGMenu, _p_AGMenuTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGApplication, _p_AGApplicationTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGMenuItem, _p_AGMenuItemTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGVTiler, _p_AGVTilerTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGWidget, _p_AGWidgetTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGHTiler, _p_AGHTilerTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGScreenWidget, _p_AGScreenWidgetTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGFrame, _p_AGFrameTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGMessageObject, 0, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGMessageObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMutex[] = {  {&_swigt__p_AGMutex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGPaintTarget[] = {  {&_swigt__p_AGPaintTarget, 0, 0, 0},  {&_swigt__p_AGSurface, _p_AGSurfaceTo_p_AGPaintTarget, 0, 0},  {&_swigt__p_AGTexture, _p_AGTextureTo_p_AGPaintTarget, 0, 0},  {&_swigt__p_AGScreen, _p_AGScreenTo_p_AGPaintTarget, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGPainter[] = {  {&_swigt__p_AGPainter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGPoint3[] = {  {&_swigt__p_AGPoint3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGProjection[] = {  {&_swigt__p_AGProjection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRadio[] = {  {&_swigt__p_AGRadio, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRadioGroup[] = {  {&_swigt__p_AGRadioGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRect2[] = {  {&_swigt__p_AGRect2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRect3[] = {  {&_swigt__p_AGRect3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRubyObject[] = {  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGSubMenu, _p_AGSubMenuTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGMenu, _p_AGMenuTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGApplication, _p_AGApplicationTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGMenuItem, _p_AGMenuItemTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGVTiler, _p_AGVTilerTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGWidget, _p_AGWidgetTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGHTiler, _p_AGHTilerTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGListener, _p_AGListenerTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGScreenWidget, _p_AGScreenWidgetTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGFrame, _p_AGFrameTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGRubyObject, 0, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGMessageObject, _p_AGMessageObjectTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGRubyObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGScreen[] = {  {&_swigt__p_AGScreen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGScreenWidget[] = {  {&_swigt__p_AGScreenWidget, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGShaderParameter[] = {  {&_swigt__p_AGShaderParameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGShaderProgram[] = {  {&_swigt__p_AGShaderProgram, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSignal[] = {  {&_swigt__p_AGSignal, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSound[] = {  {&_swigt__p_AGSound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSubMenu[] = {  {&_swigt__p_AGSubMenu, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSurface[] = {  {&_swigt__p_AGSurface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTable[] = {  {&_swigt__p_AGTable, 0, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGTable, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGText[] = {  {&_swigt__p_AGText, 0, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGText, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTexture[] = {  {&_swigt__p_AGTexture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTextureCache[] = {  {&_swigt__p_AGTextureCache, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTheme[] = {  {&_swigt__p_AGTheme, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTriangle2[] = {  {&_swigt__p_AGTriangle2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTriangle3[] = {  {&_swigt__p_AGTriangle3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVTiler[] = {  {&_swigt__p_AGVTiler, 0, 0, 0},  {&_swigt__p_AGHTiler, _p_AGHTilerTo_p_AGVTiler, 0, 0},  {&_swigt__p_AGSubMenu, _p_AGSubMenuTo_p_AGVTiler, 0, 0},  {&_swigt__p_AGMenu, _p_AGMenuTo_p_AGVTiler, 0, 0},  {&_swigt__p_AGMenuItem, _p_AGMenuItemTo_p_AGVTiler, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVector2[] = {  {&_swigt__p_AGVector2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVector3[] = {  {&_swigt__p_AGPoint3, _p_AGPoint3To_p_AGVector3, 0, 0},  {&_swigt__p_AGVector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVector4[] = {  {&_swigt__p_AGVector4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVertexProgram[] = {  {&_swigt__p_AGVertexProgram, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGWidget[] = {  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGWidget, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGWidget, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGWidget, 0, 0},  {&_swigt__p_AGSubMenu, _p_AGSubMenuTo_p_AGWidget, 0, 0},  {&_swigt__p_AGMenu, _p_AGMenuTo_p_AGWidget, 0, 0},  {&_swigt__p_AGMenuItem, _p_AGMenuItemTo_p_AGWidget, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGWidget, 0, 0},  {&_swigt__p_AGVTiler, _p_AGVTilerTo_p_AGWidget, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGWidget, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGWidget, 0, 0},  {&_swigt__p_AGWidget, 0, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGWidget, 0, 0},  {&_swigt__p_AGHTiler, _p_AGHTilerTo_p_AGWidget, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGWidget, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGWidget, 0, 0},  {&_swigt__p_AGScreenWidget, _p_AGScreenWidgetTo_p_AGWidget, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGWidget, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGWidget, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGWidget, 0, 0},  {&_swigt__p_AGFrame, _p_AGFrameTo_p_AGWidget, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGWidget, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGWidget, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGWidget, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGWidget, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGWindow[] = {  {&_swigt__p_AGWindow, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Attributes[] = {  {&_swigt__p_Attributes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Document[] = {  {&_swigt__p_Document, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DomParser[] = {  {&_swigt__p_DomParser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLint[] = {  {&_swigt__p_GLint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLuint[] = {  {&_swigt__p_GLuint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Node[] = {  {&_swigt__p_Node, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NodeVector[] = {  {&_swigt__p_NodeVector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Node__NodeVector__const_iterator[] = {  {&_swigt__p_Node__NodeVector__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Node__NodeVector__iterator[] = {  {&_swigt__p_Node__NodeVector__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Parser[] = {  {&_swigt__p_Parser, 0, 0, 0},  {&_swigt__p_DomParser, _p_DomParserTo_p_Parser, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDLKey[] = {  {&_swigt__p_SDLKey, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDLMod[] = {  {&_swigt__p_SDLMod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_Event[] = {  {&_swigt__p_SDL_Event, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_PixelFormat[] = {  {&_swigt__p_SDL_PixelFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_Rect[] = {  {&_swigt__p_SDL_Rect, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_Surface[] = {  {&_swigt__p_SDL_Surface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Uint32[] = {  {&_swigt__p_Uint32, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Uint8[] = {  {&_swigt__p_Uint8, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_iterator[] = {  {&_swigt__p_const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_Node[] = {  {&_swigt__p_p_Node, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listTAGRect2_t[] = {  {&_swigt__p_std__listTAGRect2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTstd__string_std__string_t[] = {  {&_swigt__p_std__mapTstd__string_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostringstream[] = {  {&_swigt__p_std__ostringstream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairTAGRect2_AGRect2_t[] = {  {&_swigt__p_std__pairTAGRect2_AGRect2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairTstd__string_bool_t[] = {  {&_swigt__p_std__pairTstd__string_bool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGBox3_t[] = {  {&_swigt__p_std__vectorTAGBox3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGLine2_t[] = {  {&_swigt__p_std__vectorTAGLine2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGMatrix4_t[] = {  {&_swigt__p_std__vectorTAGMatrix4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGRect3_t[] = {  {&_swigt__p_std__vectorTAGRect3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGVector2_t[] = {  {&_swigt__p_std__vectorTAGVector2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGVector4_t[] = {  {&_swigt__p_std__vectorTAGVector4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTNode_p_t[] = {  {&_swigt__p_std__vectorTNode_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTfloat_t[] = {  {&_swigt__p_std__vectorTfloat_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__string_t[] = {  {&_swigt__p_std__vectorTstd__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_AGAngle,
  _swigc__p_AGApplication,
  _swigc__p_AGBackground,
  _swigc__p_AGBorder,
  _swigc__p_AGBox3,
  _swigc__p_AGButton,
  _swigc__p_AGCPPListener,
  _swigc__p_AGCaption,
  _swigc__p_AGCheckBox,
  _swigc__p_AGCircle2,
  _swigc__p_AGCollisionData,
  _swigc__p_AGColor,
  _swigc__p_AGColorButton,
  _swigc__p_AGDialog,
  _swigc__p_AGEdit,
  _swigc__p_AGEditLine,
  _swigc__p_AGEvent,
  _swigc__p_AGFont,
  _swigc__p_AGFontEngine,
  _swigc__p_AGFragProgram,
  _swigc__p_AGFrame,
  _swigc__p_AGGLTexture,
  _swigc__p_AGGLWidget,
  _swigc__p_AGHTiler,
  _swigc__p_AGImage,
  _swigc__p_AGInternalSurface,
  _swigc__p_AGLayout,
  _swigc__p_AGLayoutCreator,
  _swigc__p_AGLayoutFactory,
  _swigc__p_AGLine2,
  _swigc__p_AGLine3,
  _swigc__p_AGListBox,
  _swigc__p_AGListBoxItem,
  _swigc__p_AGListener,
  _swigc__p_AGMain,
  _swigc__p_AGMatrix3,
  _swigc__p_AGMatrix4,
  _swigc__p_AGMenu,
  _swigc__p_AGMenuItem,
  _swigc__p_AGMessageObject,
  _swigc__p_AGMutex,
  _swigc__p_AGPaintTarget,
  _swigc__p_AGPainter,
  _swigc__p_AGPoint3,
  _swigc__p_AGProjection,
  _swigc__p_AGRadio,
  _swigc__p_AGRadioGroup,
  _swigc__p_AGRect2,
  _swigc__p_AGRect3,
  _swigc__p_AGRubyObject,
  _swigc__p_AGScreen,
  _swigc__p_AGScreenWidget,
  _swigc__p_AGShaderParameter,
  _swigc__p_AGShaderProgram,
  _swigc__p_AGSignal,
  _swigc__p_AGSound,
  _swigc__p_AGSubMenu,
  _swigc__p_AGSurface,
  _swigc__p_AGTable,
  _swigc__p_AGText,
  _swigc__p_AGTexture,
  _swigc__p_AGTextureCache,
  _swigc__p_AGTheme,
  _swigc__p_AGTriangle2,
  _swigc__p_AGTriangle3,
  _swigc__p_AGVTiler,
  _swigc__p_AGVector2,
  _swigc__p_AGVector3,
  _swigc__p_AGVector4,
  _swigc__p_AGVertexProgram,
  _swigc__p_AGWidget,
  _swigc__p_AGWindow,
  _swigc__p_Attributes,
  _swigc__p_Document,
  _swigc__p_DomParser,
  _swigc__p_GLint,
  _swigc__p_GLuint,
  _swigc__p_Node,
  _swigc__p_NodeVector,
  _swigc__p_Node__NodeVector__const_iterator,
  _swigc__p_Node__NodeVector__iterator,
  _swigc__p_Parser,
  _swigc__p_SDLKey,
  _swigc__p_SDLMod,
  _swigc__p_SDL_Event,
  _swigc__p_SDL_PixelFormat,
  _swigc__p_SDL_Rect,
  _swigc__p_SDL_Surface,
  _swigc__p_Uint32,
  _swigc__p_Uint8,
  _swigc__p_const_iterator,
  _swigc__p_float,
  _swigc__p_iterator,
  _swigc__p_p_Node,
  _swigc__p_std__listTAGRect2_t,
  _swigc__p_std__mapTstd__string_std__string_t,
  _swigc__p_std__ostringstream,
  _swigc__p_std__pairTAGRect2_AGRect2_t,
  _swigc__p_std__pairTstd__string_bool_t,
  _swigc__p_std__string,
  _swigc__p_std__vectorTAGBox3_t,
  _swigc__p_std__vectorTAGLine2_t,
  _swigc__p_std__vectorTAGMatrix4_t,
  _swigc__p_std__vectorTAGRect3_t,
  _swigc__p_std__vectorTAGVector2_t,
  _swigc__p_std__vectorTAGVector4_t,
  _swigc__p_std__vectorTNode_p_t,
  _swigc__p_std__vectorTfloat_t,
  _swigc__p_std__vectorTstd__string_t,
  _swigc__p_unsigned_long,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/*************************************************************************
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.

 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop though that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.

 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
**/

#ifdef __cplusplus
extern "C" {
#endif

SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  swig_type_info *type, *ret;
  swig_cast_info *cast;
  size_t i;
  swig_module_info *module_head;
  static int init_run = 0;

  clientdata = clientdata;

  if (init_run) return;
  init_run = 1;

  /* Initialize the swig_module */
  swig_module.type_initial = swig_type_initial;
  swig_module.cast_initial = swig_cast_initial;

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (module_head) {
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  } else {
    /* This is the first module loaded */
    swig_module.next = &swig_module;
    SWIG_SetModule(clientdata, &swig_module);
  }
		 
  /* Now work on filling in swig_module.types */
  for (i = 0; i < swig_module.size; ++i) {
    type = 0;

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
      if (swig_module.type_initial[i]->clientdata) type->clientdata = swig_module.type_initial[i]->clientdata;
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
      }
      if (ret && type == swig_module.type_initial[i]) {
        cast->type = ret;
        ret = 0;
      }
      
      if (!ret) {
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }

      cast++;
    }

    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_libantargisgui(void) {
    size_t i;
    
    SWIG_InitRuntime();
    mLibantargisgui = rb_define_module("Libantargisgui");
    
    SWIG_InitializeModule(0);
    for (i = 0; i < swig_module.size; i++) {
        SWIG_define_class(swig_module.types[i]);
    }
    
    SWIG_RubyInitializeTrackings();
    
    cStringVector.klass = rb_define_class_under(mLibantargisgui, "StringVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__string_t, (void *) &cStringVector);
    rb_include_module(cStringVector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cStringVector.klass, _wrap_StringVector_allocate);
    rb_define_method(cStringVector.klass, "initialize", VALUEFUNC(_wrap_new_StringVector), -1);
    rb_define_method(cStringVector.klass, "length", VALUEFUNC(_wrap_StringVector___len__), -1);
    rb_define_method(cStringVector.klass, "empty?", VALUEFUNC(_wrap_StringVector_emptyq___), -1);
    rb_define_method(cStringVector.klass, "clear", VALUEFUNC(_wrap_StringVector_clear), -1);
    rb_define_method(cStringVector.klass, "push", VALUEFUNC(_wrap_StringVector_push), -1);
    rb_define_method(cStringVector.klass, "pop", VALUEFUNC(_wrap_StringVector_pop), -1);
    rb_define_method(cStringVector.klass, "[]", VALUEFUNC(_wrap_StringVector___getitem__), -1);
    rb_define_method(cStringVector.klass, "[]=", VALUEFUNC(_wrap_StringVector___setitem__), -1);
    rb_define_method(cStringVector.klass, "each", VALUEFUNC(_wrap_StringVector_each), -1);
    cStringVector.mark = 0;
    cStringVector.destroy = (void (*)(void *)) free_std_vector_Sl_std_string_Sg_;
    
    cNodeVector.klass = rb_define_class_under(mLibantargisgui, "NodeVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTNode_p_t, (void *) &cNodeVector);
    rb_include_module(cNodeVector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cNodeVector.klass, _wrap_NodeVector_allocate);
    rb_define_method(cNodeVector.klass, "initialize", VALUEFUNC(_wrap_new_NodeVector), -1);
    rb_define_method(cNodeVector.klass, "length", VALUEFUNC(_wrap_NodeVector___len__), -1);
    rb_define_method(cNodeVector.klass, "empty?", VALUEFUNC(_wrap_NodeVector_emptyq___), -1);
    rb_define_method(cNodeVector.klass, "clear", VALUEFUNC(_wrap_NodeVector_clear), -1);
    rb_define_method(cNodeVector.klass, "push", VALUEFUNC(_wrap_NodeVector_push), -1);
    rb_define_method(cNodeVector.klass, "pop", VALUEFUNC(_wrap_NodeVector_pop), -1);
    rb_define_method(cNodeVector.klass, "[]", VALUEFUNC(_wrap_NodeVector___getitem__), -1);
    rb_define_method(cNodeVector.klass, "[]=", VALUEFUNC(_wrap_NodeVector___setitem__), -1);
    rb_define_method(cNodeVector.klass, "each", VALUEFUNC(_wrap_NodeVector_each), -1);
    cNodeVector.mark = 0;
    cNodeVector.destroy = (void (*)(void *)) free_std_vector_Sl_Node_Sm__Sg_;
    rb_define_module_function(mLibantargisgui, "general_markfunc", VALUEFUNC(_wrap_general_markfunc), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGRubyObject", VALUEFUNC(_wrap_disown_AGRubyObject), -1);
    
    cAGRubyObject.klass = rb_define_class_under(mLibantargisgui, "AGRubyObject", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRubyObject, (void *) &cAGRubyObject);
    rb_define_alloc_func(cAGRubyObject.klass, _wrap_AGRubyObject_allocate);
    rb_define_method(cAGRubyObject.klass, "initialize", VALUEFUNC(_wrap_new_AGRubyObject), -1);
    rb_define_method(cAGRubyObject.klass, "clear", VALUEFUNC(_wrap_AGRubyObject_clear), -1);
    cAGRubyObject.mark = (void (*)(void *)) general_markfunc;
    cAGRubyObject.destroy = (void (*)(void *)) free_AGRubyObject;
    rb_define_module_function(mLibantargisgui, "saveDelete", VALUEFUNC(_wrap_saveDelete), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGEvent", VALUEFUNC(_wrap_disown_AGEvent), -1);
    
    cAGEvent.klass = rb_define_class_under(mLibantargisgui, "AGEvent", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGEvent, (void *) &cAGEvent);
    rb_define_alloc_func(cAGEvent.klass, _wrap_AGEvent_allocate);
    rb_define_method(cAGEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGEvent), -1);
    rb_define_method(cAGEvent.klass, "getCaller", VALUEFUNC(_wrap_AGEvent_getCaller), -1);
    rb_define_method(cAGEvent.klass, "setCaller", VALUEFUNC(_wrap_AGEvent_setCaller), -1);
    rb_define_method(cAGEvent.klass, "getName", VALUEFUNC(_wrap_AGEvent_getName), -1);
    rb_define_method(cAGEvent.klass, "getMousePosition", VALUEFUNC(_wrap_AGEvent_getMousePosition), -1);
    rb_define_method(cAGEvent.klass, "getKey", VALUEFUNC(_wrap_AGEvent_getKey), -1);
    rb_define_method(cAGEvent.klass, "getMod", VALUEFUNC(_wrap_AGEvent_getMod), -1);
    rb_define_method(cAGEvent.klass, "getButton", VALUEFUNC(_wrap_AGEvent_getButton), -1);
    rb_define_method(cAGEvent.klass, "get", VALUEFUNC(_wrap_AGEvent_get), -1);
    rb_define_method(cAGEvent.klass, "isSDLEvent", VALUEFUNC(_wrap_AGEvent_isSDLEvent), -1);
    rb_define_method(cAGEvent.klass, "setName", VALUEFUNC(_wrap_AGEvent_setName), -1);
    cAGEvent.mark = 0;
    cAGEvent.destroy = (void (*)(void *)) free_AGEvent;
    rb_define_module_function(mLibantargisgui, "disown_AGListener", VALUEFUNC(_wrap_disown_AGListener), -1);
    
    cAGListener.klass = rb_define_class_under(mLibantargisgui, "AGListener", ((swig_class *) SWIGTYPE_p_AGRubyObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGListener, (void *) &cAGListener);
    rb_define_alloc_func(cAGListener.klass, _wrap_AGListener_allocate);
    rb_define_method(cAGListener.klass, "initialize", VALUEFUNC(_wrap_new_AGListener), -1);
    rb_define_method(cAGListener.klass, "signal", VALUEFUNC(_wrap_AGListener_signal), -1);
    cAGListener.mark = (void (*)(void *)) general_markfunc;
    cAGListener.destroy = (void (*)(void *)) free_AGListener;
    rb_define_module_function(mLibantargisgui, "disown_AGCPPListener", VALUEFUNC(_wrap_disown_AGCPPListener), -1);
    
    cAGCPPListener.klass = rb_define_class_under(mLibantargisgui, "AGCPPListener", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCPPListener, (void *) &cAGCPPListener);
    rb_define_alloc_func(cAGCPPListener.klass, _wrap_AGCPPListener_allocate);
    rb_define_method(cAGCPPListener.klass, "initialize", VALUEFUNC(_wrap_new_AGCPPListener), -1);
    rb_define_method(cAGCPPListener.klass, "signal", VALUEFUNC(_wrap_AGCPPListener_signal), -1);
    cAGCPPListener.mark = 0;
    cAGCPPListener.destroy = (void (*)(void *)) free_AGCPPListener;
    rb_define_module_function(mLibantargisgui, "disown_AGSignal", VALUEFUNC(_wrap_disown_AGSignal), -1);
    
    cAGSignal.klass = rb_define_class_under(mLibantargisgui, "AGSignal", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGSignal, (void *) &cAGSignal);
    rb_define_alloc_func(cAGSignal.klass, _wrap_AGSignal_allocate);
    rb_define_method(cAGSignal.klass, "initialize", VALUEFUNC(_wrap_new_AGSignal), -1);
    rb_define_method(cAGSignal.klass, "connect", VALUEFUNC(_wrap_AGSignal_connect), -1);
    rb_define_method(cAGSignal.klass, "disconnect", VALUEFUNC(_wrap_AGSignal_disconnect), -1);
    rb_define_method(cAGSignal.klass, "signal", VALUEFUNC(_wrap_AGSignal_signal), -1);
    rb_define_method(cAGSignal.klass, "call", VALUEFUNC(_wrap_AGSignal___call__), -1);
    cAGSignal.mark = 0;
    cAGSignal.destroy = (void (*)(void *)) free_AGSignal;
    rb_define_module_function(mLibantargisgui, "disown_AGMessageObject", VALUEFUNC(_wrap_disown_AGMessageObject), -1);
    
    cAGMessageObject.klass = rb_define_class_under(mLibantargisgui, "AGMessageObject", ((swig_class *) SWIGTYPE_p_AGListener->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMessageObject, (void *) &cAGMessageObject);
    rb_define_alloc_func(cAGMessageObject.klass, _wrap_AGMessageObject_allocate);
    rb_define_method(cAGMessageObject.klass, "initialize", VALUEFUNC(_wrap_new_AGMessageObject), -1);
    rb_define_method(cAGMessageObject.klass, "processEvent", VALUEFUNC(_wrap_AGMessageObject_processEvent), -1);
    rb_define_method(cAGMessageObject.klass, "acceptEvent", VALUEFUNC(_wrap_AGMessageObject_acceptEvent), -1);
    rb_define_method(cAGMessageObject.klass, "eventActive", VALUEFUNC(_wrap_AGMessageObject_eventActive), -1);
    rb_define_method(cAGMessageObject.klass, "eventKeyDown", VALUEFUNC(_wrap_AGMessageObject_eventKeyDown), -1);
    rb_define_method(cAGMessageObject.klass, "eventKeyUp", VALUEFUNC(_wrap_AGMessageObject_eventKeyUp), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseMotion", VALUEFUNC(_wrap_AGMessageObject_eventMouseMotion), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGMessageObject_eventMouseButtonDown), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGMessageObject_eventMouseButtonUp), -1);
    rb_define_method(cAGMessageObject.klass, "eventQuit", VALUEFUNC(_wrap_AGMessageObject_eventQuit), -1);
    rb_define_method(cAGMessageObject.klass, "eventQuitModal", VALUEFUNC(_wrap_AGMessageObject_eventQuitModal), -1);
    rb_define_method(cAGMessageObject.klass, "eventSysWM", VALUEFUNC(_wrap_AGMessageObject_eventSysWM), -1);
    rb_define_method(cAGMessageObject.klass, "eventResize", VALUEFUNC(_wrap_AGMessageObject_eventResize), -1);
    rb_define_method(cAGMessageObject.klass, "getButtonState", VALUEFUNC(_wrap_AGMessageObject_getButtonState), -1);
    rb_define_method(cAGMessageObject.klass, "getMousePosition", VALUEFUNC(_wrap_AGMessageObject_getMousePosition), -1);
    rb_define_method(cAGMessageObject.klass, "sigActive=", VALUEFUNC(_wrap_AGMessageObject_sigActive_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigActive", VALUEFUNC(_wrap_AGMessageObject_sigActive_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyDown=", VALUEFUNC(_wrap_AGMessageObject_sigKeyDown_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyDown", VALUEFUNC(_wrap_AGMessageObject_sigKeyDown_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyUp=", VALUEFUNC(_wrap_AGMessageObject_sigKeyUp_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyUp", VALUEFUNC(_wrap_AGMessageObject_sigKeyUp_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseMotion=", VALUEFUNC(_wrap_AGMessageObject_sigMouseMotion_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseMotion", VALUEFUNC(_wrap_AGMessageObject_sigMouseMotion_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonDown=", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonDown_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonDown", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonDown_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonUp=", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonUp_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonUp", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonUp_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigQuit=", VALUEFUNC(_wrap_AGMessageObject_sigQuit_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigQuit", VALUEFUNC(_wrap_AGMessageObject_sigQuit_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigSysWM=", VALUEFUNC(_wrap_AGMessageObject_sigSysWM_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigSysWM", VALUEFUNC(_wrap_AGMessageObject_sigSysWM_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigVideoResize=", VALUEFUNC(_wrap_AGMessageObject_sigVideoResize_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigVideoResize", VALUEFUNC(_wrap_AGMessageObject_sigVideoResize_get), -1);
    rb_define_method(cAGMessageObject.klass, "pushSignal", VALUEFUNC(_wrap_AGMessageObject_pushSignal), -1);
    rb_define_method(cAGMessageObject.klass, "popSignal", VALUEFUNC(_wrap_AGMessageObject_popSignal), -1);
    cAGMessageObject.mark = (void (*)(void *)) general_markfunc;
    cAGMessageObject.destroy = (void (*)(void *)) free_AGMessageObject;
    rb_define_module_function(mLibantargisgui, "newEvent", VALUEFUNC(_wrap_newEvent), -1);
    
    cAGAngle.klass = rb_define_class_under(mLibantargisgui, "AGAngle", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGAngle, (void *) &cAGAngle);
    rb_define_alloc_func(cAGAngle.klass, _wrap_AGAngle_allocate);
    rb_define_method(cAGAngle.klass, "initialize", VALUEFUNC(_wrap_new_AGAngle), -1);
    rb_define_method(cAGAngle.klass, "angle=", VALUEFUNC(_wrap_AGAngle_angle_set), -1);
    rb_define_method(cAGAngle.klass, "angle", VALUEFUNC(_wrap_AGAngle_angle_get), -1);
    cAGAngle.mark = 0;
    cAGAngle.destroy = (void (*)(void *)) free_AGAngle;
    
    cAGVector2.klass = rb_define_class_under(mLibantargisgui, "AGVector2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector2, (void *) &cAGVector2);
    rb_define_alloc_func(cAGVector2.klass, _wrap_AGVector2_allocate);
    rb_define_method(cAGVector2.klass, "initialize", VALUEFUNC(_wrap_new_AGVector2), -1);
    rb_define_method(cAGVector2.klass, "v=", VALUEFUNC(_wrap_AGVector2_v_set), -1);
    rb_define_method(cAGVector2.klass, "v", VALUEFUNC(_wrap_AGVector2_v_get), -1);
    rb_define_method(cAGVector2.klass, "setX", VALUEFUNC(_wrap_AGVector2_setX), -1);
    rb_define_method(cAGVector2.klass, "setY", VALUEFUNC(_wrap_AGVector2_setY), -1);
    rb_define_method(cAGVector2.klass, "x", VALUEFUNC(_wrap_AGVector2_x), -1);
    rb_define_method(cAGVector2.klass, "y", VALUEFUNC(_wrap_AGVector2_y), -1);
    rb_define_method(cAGVector2.klass, "getAngle", VALUEFUNC(_wrap_AGVector2_getAngle), -1);
    rb_define_method(cAGVector2.klass, "-", VALUEFUNC(_wrap_AGVector2___sub__), -1);
    rb_define_method(cAGVector2.klass, "+", VALUEFUNC(_wrap_AGVector2___add__), -1);
    rb_define_method(cAGVector2.klass, "*", VALUEFUNC(_wrap_AGVector2___mul__), -1);
    rb_define_method(cAGVector2.klass, "/", VALUEFUNC(_wrap_AGVector2___div__), -1);
    rb_define_method(cAGVector2.klass, "==", VALUEFUNC(_wrap_AGVector2___eq__), -1);
    rb_define_method(cAGVector2.klass, "length", VALUEFUNC(_wrap_AGVector2_length), -1);
    rb_define_method(cAGVector2.klass, "length2", VALUEFUNC(_wrap_AGVector2_length2), -1);
    rb_define_method(cAGVector2.klass, "normalized", VALUEFUNC(_wrap_AGVector2_normalized), -1);
    rb_define_method(cAGVector2.klass, "normalize", VALUEFUNC(_wrap_AGVector2_normalize), -1);
    rb_define_method(cAGVector2.klass, "normal", VALUEFUNC(_wrap_AGVector2_normal), -1);
    rb_define_method(cAGVector2.klass, "[]", VALUEFUNC(_wrap_AGVector2___getitem__), -1);
    rb_define_method(cAGVector2.klass, "nonZero", VALUEFUNC(_wrap_AGVector2_nonZero), -1);
    rb_define_method(cAGVector2.klass, "saveXML", VALUEFUNC(_wrap_AGVector2_saveXML), -1);
    rb_define_method(cAGVector2.klass, "loadXML", VALUEFUNC(_wrap_AGVector2_loadXML), -1);
    rb_define_method(cAGVector2.klass, "to_s", VALUEFUNC(_wrap_AGVector2_to_s), -1);
    cAGVector2.mark = 0;
    cAGVector2.destroy = (void (*)(void *)) free_AGVector2;
    
    cAGVector3.klass = rb_define_class_under(mLibantargisgui, "AGVector3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector3, (void *) &cAGVector3);
    rb_define_alloc_func(cAGVector3.klass, _wrap_AGVector3_allocate);
    rb_define_method(cAGVector3.klass, "initialize", VALUEFUNC(_wrap_new_AGVector3), -1);
    rb_define_method(cAGVector3.klass, "v=", VALUEFUNC(_wrap_AGVector3_v_set), -1);
    rb_define_method(cAGVector3.klass, "v", VALUEFUNC(_wrap_AGVector3_v_get), -1);
    rb_define_method(cAGVector3.klass, "setX", VALUEFUNC(_wrap_AGVector3_setX), -1);
    rb_define_method(cAGVector3.klass, "setY", VALUEFUNC(_wrap_AGVector3_setY), -1);
    rb_define_method(cAGVector3.klass, "setZ", VALUEFUNC(_wrap_AGVector3_setZ), -1);
    rb_define_method(cAGVector3.klass, "x", VALUEFUNC(_wrap_AGVector3_x), -1);
    rb_define_method(cAGVector3.klass, "y", VALUEFUNC(_wrap_AGVector3_y), -1);
    rb_define_method(cAGVector3.klass, "z", VALUEFUNC(_wrap_AGVector3_z), -1);
    rb_define_method(cAGVector3.klass, "getAngle", VALUEFUNC(_wrap_AGVector3_getAngle), -1);
    rb_define_method(cAGVector3.klass, "-@", VALUEFUNC(_wrap_AGVector3___neg__), -1);
    rb_define_method(cAGVector3.klass, "-", VALUEFUNC(_wrap_AGVector3___sub__), -1);
    rb_define_method(cAGVector3.klass, "+", VALUEFUNC(_wrap_AGVector3___add__), -1);
    rb_define_method(cAGVector3.klass, "add", VALUEFUNC(_wrap_AGVector3_add), -1);
    rb_define_method(cAGVector3.klass, "sub", VALUEFUNC(_wrap_AGVector3_sub), -1);
    rb_define_method(cAGVector3.klass, "*", VALUEFUNC(_wrap_AGVector3___mul__), -1);
    rb_define_method(cAGVector3.klass, "/", VALUEFUNC(_wrap_AGVector3___div__), -1);
    rb_define_method(cAGVector3.klass, "%", VALUEFUNC(_wrap_AGVector3___mod__), -1);
    rb_define_method(cAGVector3.klass, "==", VALUEFUNC(_wrap_AGVector3___eq__), -1);
    rb_define_method(cAGVector3.klass, "length", VALUEFUNC(_wrap_AGVector3_length), -1);
    rb_define_method(cAGVector3.klass, "length2", VALUEFUNC(_wrap_AGVector3_length2), -1);
    rb_define_method(cAGVector3.klass, "normalized", VALUEFUNC(_wrap_AGVector3_normalized), -1);
    rb_define_method(cAGVector3.klass, "normalize", VALUEFUNC(_wrap_AGVector3_normalize), -1);
    rb_define_method(cAGVector3.klass, "normal", VALUEFUNC(_wrap_AGVector3_normal), -1);
    rb_define_method(cAGVector3.klass, "nonZero", VALUEFUNC(_wrap_AGVector3_nonZero), -1);
    rb_define_method(cAGVector3.klass, "saveXML", VALUEFUNC(_wrap_AGVector3_saveXML), -1);
    rb_define_method(cAGVector3.klass, "loadXML", VALUEFUNC(_wrap_AGVector3_loadXML), -1);
    rb_define_method(cAGVector3.klass, "dim2", VALUEFUNC(_wrap_AGVector3_dim2), -1);
    rb_define_method(cAGVector3.klass, "to_s", VALUEFUNC(_wrap_AGVector3_to_s), -1);
    cAGVector3.mark = 0;
    cAGVector3.destroy = (void (*)(void *)) free_AGVector3;
    
    cAGPoint3.klass = rb_define_class_under(mLibantargisgui, "AGPoint3", ((swig_class *) SWIGTYPE_p_AGVector3->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGPoint3, (void *) &cAGPoint3);
    rb_define_alloc_func(cAGPoint3.klass, _wrap_AGPoint3_allocate);
    rb_define_method(cAGPoint3.klass, "initialize", VALUEFUNC(_wrap_new_AGPoint3), -1);
    cAGPoint3.mark = 0;
    cAGPoint3.destroy = (void (*)(void *)) free_AGPoint3;
    
    cAGMatrix3.klass = rb_define_class_under(mLibantargisgui, "AGMatrix3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMatrix3, (void *) &cAGMatrix3);
    rb_define_alloc_func(cAGMatrix3.klass, _wrap_AGMatrix3_allocate);
    rb_define_method(cAGMatrix3.klass, "initialize", VALUEFUNC(_wrap_new_AGMatrix3), -1);
    rb_define_method(cAGMatrix3.klass, "set", VALUEFUNC(_wrap_AGMatrix3_set), -1);
    rb_define_method(cAGMatrix3.klass, "get", VALUEFUNC(_wrap_AGMatrix3_get), -1);
    rb_define_method(cAGMatrix3.klass, "*", VALUEFUNC(_wrap_AGMatrix3___mul__), -1);
    rb_define_method(cAGMatrix3.klass, "-@", VALUEFUNC(_wrap_AGMatrix3___neg__), -1);
    rb_define_method(cAGMatrix3.klass, "inverted", VALUEFUNC(_wrap_AGMatrix3_inverted), -1);
    rb_define_method(cAGMatrix3.klass, "transposed", VALUEFUNC(_wrap_AGMatrix3_transposed), -1);
    rb_define_method(cAGMatrix3.klass, "to_s", VALUEFUNC(_wrap_AGMatrix3_to_s), -1);
    cAGMatrix3.mark = 0;
    cAGMatrix3.destroy = (void (*)(void *)) free_AGMatrix3;
    
    cAGLine2.klass = rb_define_class_under(mLibantargisgui, "AGLine2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLine2, (void *) &cAGLine2);
    rb_define_alloc_func(cAGLine2.klass, _wrap_AGLine2_allocate);
    rb_define_method(cAGLine2.klass, "initialize", VALUEFUNC(_wrap_new_AGLine2), -1);
    rb_define_method(cAGLine2.klass, "getV0", VALUEFUNC(_wrap_AGLine2_getV0), -1);
    rb_define_method(cAGLine2.klass, "getV1", VALUEFUNC(_wrap_AGLine2_getV1), -1);
    rb_define_method(cAGLine2.klass, "has", VALUEFUNC(_wrap_AGLine2_has), -1);
    rb_define_method(cAGLine2.klass, "collide", VALUEFUNC(_wrap_AGLine2_collide), -1);
    rb_define_method(cAGLine2.klass, "collisionPoint", VALUEFUNC(_wrap_AGLine2_collisionPoint), -1);
    rb_define_method(cAGLine2.klass, "collisionPointNI", VALUEFUNC(_wrap_AGLine2_collisionPointNI), -1);
    rb_define_method(cAGLine2.klass, "includes", VALUEFUNC(_wrap_AGLine2_includes), -1);
    rb_define_method(cAGLine2.klass, "getBBox", VALUEFUNC(_wrap_AGLine2_getBBox), -1);
    rb_define_method(cAGLine2.klass, "normal", VALUEFUNC(_wrap_AGLine2_normal), -1);
    rb_define_method(cAGLine2.klass, "direction", VALUEFUNC(_wrap_AGLine2_direction), -1);
    rb_define_method(cAGLine2.klass, "distance", VALUEFUNC(_wrap_AGLine2_distance), -1);
    rb_define_method(cAGLine2.klass, "to_s", VALUEFUNC(_wrap_AGLine2_to_s), -1);
    cAGLine2.mark = 0;
    cAGLine2.destroy = (void (*)(void *)) free_AGLine2;
    
    cAGLine3.klass = rb_define_class_under(mLibantargisgui, "AGLine3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLine3, (void *) &cAGLine3);
    rb_define_alloc_func(cAGLine3.klass, _wrap_AGLine3_allocate);
    rb_define_method(cAGLine3.klass, "initialize", VALUEFUNC(_wrap_new_AGLine3), -1);
    rb_define_method(cAGLine3.klass, "getV0", VALUEFUNC(_wrap_AGLine3_getV0), -1);
    rb_define_method(cAGLine3.klass, "getV1", VALUEFUNC(_wrap_AGLine3_getV1), -1);
    rb_define_method(cAGLine3.klass, "has", VALUEFUNC(_wrap_AGLine3_has), -1);
    rb_define_method(cAGLine3.klass, "direction", VALUEFUNC(_wrap_AGLine3_direction), -1);
    rb_define_method(cAGLine3.klass, "distance", VALUEFUNC(_wrap_AGLine3_distance), -1);
    rb_define_method(cAGLine3.klass, "to_s", VALUEFUNC(_wrap_AGLine3_to_s), -1);
    cAGLine3.mark = 0;
    cAGLine3.destroy = (void (*)(void *)) free_AGLine3;
    
    cAGCollisionData.klass = rb_define_class_under(mLibantargisgui, "AGCollisionData", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCollisionData, (void *) &cAGCollisionData);
    rb_define_alloc_func(cAGCollisionData.klass, _wrap_AGCollisionData_allocate);
    rb_define_method(cAGCollisionData.klass, "initialize", VALUEFUNC(_wrap_new_AGCollisionData), -1);
    cAGCollisionData.mark = 0;
    cAGCollisionData.destroy = (void (*)(void *)) free_AGCollisionData;
    
    cAGTriangle2.klass = rb_define_class_under(mLibantargisgui, "AGTriangle2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTriangle2, (void *) &cAGTriangle2);
    rb_define_alloc_func(cAGTriangle2.klass, _wrap_AGTriangle2_allocate);
    rb_define_method(cAGTriangle2.klass, "initialize", VALUEFUNC(_wrap_new_AGTriangle2), -1);
    rb_define_method(cAGTriangle2.klass, "get", VALUEFUNC(_wrap_AGTriangle2_get), -1);
    rb_define_method(cAGTriangle2.klass, "collide", VALUEFUNC(_wrap_AGTriangle2_collide), -1);
    rb_define_method(cAGTriangle2.klass, "getNormals", VALUEFUNC(_wrap_AGTriangle2_getNormals), -1);
    rb_define_method(cAGTriangle2.klass, "apply", VALUEFUNC(_wrap_AGTriangle2_apply), -1);
    rb_define_method(cAGTriangle2.klass, "applied", VALUEFUNC(_wrap_AGTriangle2_applied), -1);
    rb_define_method(cAGTriangle2.klass, "touchPoint", VALUEFUNC(_wrap_AGTriangle2_touchPoint), -1);
    rb_define_method(cAGTriangle2.klass, "touchVector", VALUEFUNC(_wrap_AGTriangle2_touchVector), -1);
    rb_define_method(cAGTriangle2.klass, "collisionPoints", VALUEFUNC(_wrap_AGTriangle2_collisionPoints), -1);
    rb_define_method(cAGTriangle2.klass, "contains", VALUEFUNC(_wrap_AGTriangle2_contains), -1);
    rb_define_method(cAGTriangle2.klass, "getBBox", VALUEFUNC(_wrap_AGTriangle2_getBBox), -1);
    rb_define_method(cAGTriangle2.klass, "nearestLine", VALUEFUNC(_wrap_AGTriangle2_nearestLine), -1);
    rb_define_method(cAGTriangle2.klass, "getLines", VALUEFUNC(_wrap_AGTriangle2_getLines), -1);
    rb_define_method(cAGTriangle2.klass, "to_s", VALUEFUNC(_wrap_AGTriangle2_to_s), -1);
    cAGTriangle2.mark = 0;
    cAGTriangle2.destroy = (void (*)(void *)) free_AGTriangle2;
    
    cAGCircle2.klass = rb_define_class_under(mLibantargisgui, "AGCircle2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCircle2, (void *) &cAGCircle2);
    rb_define_alloc_func(cAGCircle2.klass, _wrap_AGCircle2_allocate);
    rb_define_method(cAGCircle2.klass, "initialize", VALUEFUNC(_wrap_new_AGCircle2), -1);
    rb_define_method(cAGCircle2.klass, "inCircle", VALUEFUNC(_wrap_AGCircle2_inCircle), -1);
    rb_define_method(cAGCircle2.klass, "outCircle", VALUEFUNC(_wrap_AGCircle2_outCircle), -1);
    rb_define_method(cAGCircle2.klass, "getPos", VALUEFUNC(_wrap_AGCircle2_getPos), -1);
    rb_define_method(cAGCircle2.klass, "getRadius", VALUEFUNC(_wrap_AGCircle2_getRadius), -1);
    cAGCircle2.mark = 0;
    cAGCircle2.destroy = (void (*)(void *)) free_AGCircle2;
    
    cAGTriangle3.klass = rb_define_class_under(mLibantargisgui, "AGTriangle3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTriangle3, (void *) &cAGTriangle3);
    rb_define_alloc_func(cAGTriangle3.klass, _wrap_AGTriangle3_allocate);
    rb_define_method(cAGTriangle3.klass, "initialize", VALUEFUNC(_wrap_new_AGTriangle3), -1);
    rb_define_method(cAGTriangle3.klass, "collide", VALUEFUNC(_wrap_AGTriangle3_collide), -1);
    rb_define_method(cAGTriangle3.klass, "toString", VALUEFUNC(_wrap_AGTriangle3_toString), -1);
    cAGTriangle3.mark = 0;
    cAGTriangle3.destroy = (void (*)(void *)) free_AGTriangle3;
    
    cAGRect2.klass = rb_define_class_under(mLibantargisgui, "AGRect2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect2, (void *) &cAGRect2);
    rb_define_alloc_func(cAGRect2.klass, _wrap_AGRect2_allocate);
    rb_define_method(cAGRect2.klass, "initialize", VALUEFUNC(_wrap_new_AGRect2), -1);
    rb_define_method(cAGRect2.klass, "collide", VALUEFUNC(_wrap_AGRect2_collide), -1);
    rb_define_method(cAGRect2.klass, "include", VALUEFUNC(_wrap_AGRect2_include), -1);
    rb_define_method(cAGRect2.klass, "+", VALUEFUNC(_wrap_AGRect2___add__), -1);
    rb_define_method(cAGRect2.klass, "contains", VALUEFUNC(_wrap_AGRect2_contains), -1);
    rb_define_method(cAGRect2.klass, "split", VALUEFUNC(_wrap_AGRect2_split), -1);
    rb_define_method(cAGRect2.klass, "getV0", VALUEFUNC(_wrap_AGRect2_getV0), -1);
    rb_define_method(cAGRect2.klass, "getV1", VALUEFUNC(_wrap_AGRect2_getV1), -1);
    rb_define_method(cAGRect2.klass, "getV01", VALUEFUNC(_wrap_AGRect2_getV01), -1);
    rb_define_method(cAGRect2.klass, "getV10", VALUEFUNC(_wrap_AGRect2_getV10), -1);
    rb_define_method(cAGRect2.klass, "shrink", VALUEFUNC(_wrap_AGRect2_shrink), -1);
    rb_define_method(cAGRect2.klass, "setX", VALUEFUNC(_wrap_AGRect2_setX), -1);
    rb_define_method(cAGRect2.klass, "setY", VALUEFUNC(_wrap_AGRect2_setY), -1);
    rb_define_method(cAGRect2.klass, "setLeft", VALUEFUNC(_wrap_AGRect2_setLeft), -1);
    rb_define_method(cAGRect2.klass, "setTop", VALUEFUNC(_wrap_AGRect2_setTop), -1);
    rb_define_method(cAGRect2.klass, "setRight", VALUEFUNC(_wrap_AGRect2_setRight), -1);
    rb_define_method(cAGRect2.klass, "setBottom", VALUEFUNC(_wrap_AGRect2_setBottom), -1);
    rb_define_method(cAGRect2.klass, "setWidth", VALUEFUNC(_wrap_AGRect2_setWidth), -1);
    rb_define_method(cAGRect2.klass, "setHeight", VALUEFUNC(_wrap_AGRect2_setHeight), -1);
    rb_define_method(cAGRect2.klass, "x", VALUEFUNC(_wrap_AGRect2_x), -1);
    rb_define_method(cAGRect2.klass, "y", VALUEFUNC(_wrap_AGRect2_y), -1);
    rb_define_method(cAGRect2.klass, "w", VALUEFUNC(_wrap_AGRect2_w), -1);
    rb_define_method(cAGRect2.klass, "h", VALUEFUNC(_wrap_AGRect2_h), -1);
    rb_define_method(cAGRect2.klass, "width", VALUEFUNC(_wrap_AGRect2_width), -1);
    rb_define_method(cAGRect2.klass, "height", VALUEFUNC(_wrap_AGRect2_height), -1);
    rb_define_method(cAGRect2.klass, "x0", VALUEFUNC(_wrap_AGRect2_x0), -1);
    rb_define_method(cAGRect2.klass, "y0", VALUEFUNC(_wrap_AGRect2_y0), -1);
    rb_define_method(cAGRect2.klass, "x1", VALUEFUNC(_wrap_AGRect2_x1), -1);
    rb_define_method(cAGRect2.klass, "y1", VALUEFUNC(_wrap_AGRect2_y1), -1);
    rb_define_method(cAGRect2.klass, "origin", VALUEFUNC(_wrap_AGRect2_origin), -1);
    rb_define_method(cAGRect2.klass, "intersect", VALUEFUNC(_wrap_AGRect2_intersect), -1);
    rb_define_method(cAGRect2.klass, "sdl", VALUEFUNC(_wrap_AGRect2_sdl), -1);
    rb_define_method(cAGRect2.klass, "==", VALUEFUNC(_wrap_AGRect2___eq__), -1);
    rb_define_method(cAGRect2.klass, "check", VALUEFUNC(_wrap_AGRect2_check), -1);
    rb_define_method(cAGRect2.klass, "to_s", VALUEFUNC(_wrap_AGRect2_to_s), -1);
    cAGRect2.mark = 0;
    cAGRect2.destroy = (void (*)(void *)) free_AGRect2;
    
    cAGVector4.klass = rb_define_class_under(mLibantargisgui, "AGVector4", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector4, (void *) &cAGVector4);
    rb_define_alloc_func(cAGVector4.klass, _wrap_AGVector4_allocate);
    rb_define_method(cAGVector4.klass, "initialize", VALUEFUNC(_wrap_new_AGVector4), -1);
    rb_define_method(cAGVector4.klass, "v=", VALUEFUNC(_wrap_AGVector4_v_set), -1);
    rb_define_method(cAGVector4.klass, "v", VALUEFUNC(_wrap_AGVector4_v_get), -1);
    rb_define_method(cAGVector4.klass, "setX", VALUEFUNC(_wrap_AGVector4_setX), -1);
    rb_define_method(cAGVector4.klass, "setY", VALUEFUNC(_wrap_AGVector4_setY), -1);
    rb_define_method(cAGVector4.klass, "setZ", VALUEFUNC(_wrap_AGVector4_setZ), -1);
    rb_define_method(cAGVector4.klass, "setW", VALUEFUNC(_wrap_AGVector4_setW), -1);
    rb_define_method(cAGVector4.klass, "x", VALUEFUNC(_wrap_AGVector4_x), -1);
    rb_define_method(cAGVector4.klass, "y", VALUEFUNC(_wrap_AGVector4_y), -1);
    rb_define_method(cAGVector4.klass, "z", VALUEFUNC(_wrap_AGVector4_z), -1);
    rb_define_method(cAGVector4.klass, "w", VALUEFUNC(_wrap_AGVector4_w), -1);
    rb_define_method(cAGVector4.klass, "-", VALUEFUNC(_wrap_AGVector4___sub__), -1);
    rb_define_method(cAGVector4.klass, "+", VALUEFUNC(_wrap_AGVector4___add__), -1);
    rb_define_method(cAGVector4.klass, "add", VALUEFUNC(_wrap_AGVector4_add), -1);
    rb_define_method(cAGVector4.klass, "sub", VALUEFUNC(_wrap_AGVector4_sub), -1);
    rb_define_method(cAGVector4.klass, "*", VALUEFUNC(_wrap_AGVector4___mul__), -1);
    rb_define_method(cAGVector4.klass, "/", VALUEFUNC(_wrap_AGVector4___div__), -1);
    rb_define_method(cAGVector4.klass, "-@", VALUEFUNC(_wrap_AGVector4___neg__), -1);
    rb_define_method(cAGVector4.klass, "==", VALUEFUNC(_wrap_AGVector4___eq__), -1);
    rb_define_method(cAGVector4.klass, "length", VALUEFUNC(_wrap_AGVector4_length), -1);
    rb_define_method(cAGVector4.klass, "length2", VALUEFUNC(_wrap_AGVector4_length2), -1);
    rb_define_method(cAGVector4.klass, "length3", VALUEFUNC(_wrap_AGVector4_length3), -1);
    rb_define_method(cAGVector4.klass, "normalized", VALUEFUNC(_wrap_AGVector4_normalized), -1);
    rb_define_method(cAGVector4.klass, "normalize", VALUEFUNC(_wrap_AGVector4_normalize), -1);
    rb_define_method(cAGVector4.klass, "normalized3", VALUEFUNC(_wrap_AGVector4_normalized3), -1);
    rb_define_method(cAGVector4.klass, "normalize3", VALUEFUNC(_wrap_AGVector4_normalize3), -1);
    rb_define_method(cAGVector4.klass, "nonZero", VALUEFUNC(_wrap_AGVector4_nonZero), -1);
    rb_define_method(cAGVector4.klass, "%", VALUEFUNC(_wrap_AGVector4___mod__), -1);
    rb_define_method(cAGVector4.klass, "cross", VALUEFUNC(_wrap_AGVector4_cross), -1);
    rb_define_method(cAGVector4.klass, "dim3", VALUEFUNC(_wrap_AGVector4_dim3), -1);
    rb_define_method(cAGVector4.klass, "dim2", VALUEFUNC(_wrap_AGVector4_dim2), -1);
    rb_define_method(cAGVector4.klass, "to_s", VALUEFUNC(_wrap_AGVector4_to_s), -1);
    cAGVector4.mark = 0;
    cAGVector4.destroy = (void (*)(void *)) free_AGVector4;
    
    cAGMatrix4.klass = rb_define_class_under(mLibantargisgui, "AGMatrix4", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMatrix4, (void *) &cAGMatrix4);
    rb_define_alloc_func(cAGMatrix4.klass, _wrap_AGMatrix4_allocate);
    rb_define_method(cAGMatrix4.klass, "initialize", VALUEFUNC(_wrap_new_AGMatrix4), -1);
    rb_define_method(cAGMatrix4.klass, "set", VALUEFUNC(_wrap_AGMatrix4_set), -1);
    rb_define_method(cAGMatrix4.klass, "get", VALUEFUNC(_wrap_AGMatrix4_get), -1);
    rb_define_method(cAGMatrix4.klass, "get3x3", VALUEFUNC(_wrap_AGMatrix4_get3x3), -1);
    rb_define_method(cAGMatrix4.klass, "*", VALUEFUNC(_wrap_AGMatrix4___mul__), -1);
    rb_define_method(cAGMatrix4.klass, "call", VALUEFUNC(_wrap_AGMatrix4___call__), -1);
    rb_define_method(cAGMatrix4.klass, "inverted", VALUEFUNC(_wrap_AGMatrix4_inverted), -1);
    rb_define_method(cAGMatrix4.klass, "transposed", VALUEFUNC(_wrap_AGMatrix4_transposed), -1);
    rb_define_method(cAGMatrix4.klass, "to_s", VALUEFUNC(_wrap_AGMatrix4_to_s), -1);
    rb_define_method(cAGMatrix4.klass, "getRow", VALUEFUNC(_wrap_AGMatrix4_getRow), -1);
    cAGMatrix4.mark = 0;
    cAGMatrix4.destroy = (void (*)(void *)) free_AGMatrix4;
    
    cAGRect3.klass = rb_define_class_under(mLibantargisgui, "AGRect3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect3, (void *) &cAGRect3);
    rb_define_alloc_func(cAGRect3.klass, _wrap_AGRect3_allocate);
    rb_define_method(cAGRect3.klass, "initialize", VALUEFUNC(_wrap_new_AGRect3), -1);
    rb_define_method(cAGRect3.klass, "collides", VALUEFUNC(_wrap_AGRect3_collides), -1);
    rb_define_method(cAGRect3.klass, "toString", VALUEFUNC(_wrap_AGRect3_toString), -1);
    cAGRect3.mark = 0;
    cAGRect3.destroy = (void (*)(void *)) free_AGRect3;
    
    cAGBox3.klass = rb_define_class_under(mLibantargisgui, "AGBox3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBox3, (void *) &cAGBox3);
    rb_define_alloc_func(cAGBox3.klass, _wrap_AGBox3_allocate);
    rb_define_method(cAGBox3.klass, "initialize", VALUEFUNC(_wrap_new_AGBox3), -1);
    rb_define_method(cAGBox3.klass, "base=", VALUEFUNC(_wrap_AGBox3_base_set), -1);
    rb_define_method(cAGBox3.klass, "base", VALUEFUNC(_wrap_AGBox3_base_get), -1);
    rb_define_method(cAGBox3.klass, "dir=", VALUEFUNC(_wrap_AGBox3_dir_set), -1);
    rb_define_method(cAGBox3.klass, "dir", VALUEFUNC(_wrap_AGBox3_dir_get), -1);
    rb_define_method(cAGBox3.klass, "include", VALUEFUNC(_wrap_AGBox3_include), -1);
    rb_define_method(cAGBox3.klass, "includes", VALUEFUNC(_wrap_AGBox3_includes), -1);
    rb_define_method(cAGBox3.klass, "getSides", VALUEFUNC(_wrap_AGBox3_getSides), -1);
    rb_define_method(cAGBox3.klass, "toString", VALUEFUNC(_wrap_AGBox3_toString), -1);
    rb_define_method(cAGBox3.klass, "split", VALUEFUNC(_wrap_AGBox3_split), -1);
    rb_define_method(cAGBox3.klass, "collides", VALUEFUNC(_wrap_AGBox3_collides), -1);
    rb_define_method(cAGBox3.klass, "getVertices", VALUEFUNC(_wrap_AGBox3_getVertices), -1);
    rb_define_method(cAGBox3.klass, "+", VALUEFUNC(_wrap_AGBox3___add__), -1);
    cAGBox3.mark = 0;
    cAGBox3.destroy = (void (*)(void *)) free_AGBox3;
    
    cAGFont.klass = rb_define_class_under(mLibantargisgui, "AGFont", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGFont, (void *) &cAGFont);
    rb_define_alloc_func(cAGFont.klass, _wrap_AGFont_allocate);
    rb_define_method(cAGFont.klass, "initialize", VALUEFUNC(_wrap_new_AGFont), -1);
    rb_define_const(cAGFont.klass,"NORMAL", INT2NUM(AGFont::NORMAL));
    rb_define_const(cAGFont.klass,"BOLD", INT2NUM(AGFont::BOLD));
    rb_define_const(cAGFont.klass,"UNDERLINE", INT2NUM(AGFont::UNDERLINE));
    rb_define_const(cAGFont.klass,"ITALIC", INT2NUM(AGFont::ITALIC));
    rb_define_method(cAGFont.klass, "setColor", VALUEFUNC(_wrap_AGFont_setColor), -1);
    rb_define_method(cAGFont.klass, "getColor", VALUEFUNC(_wrap_AGFont_getColor), -1);
    rb_define_method(cAGFont.klass, "setBorderColor", VALUEFUNC(_wrap_AGFont_setBorderColor), -1);
    rb_define_method(cAGFont.klass, "getBorderColor", VALUEFUNC(_wrap_AGFont_getBorderColor), -1);
    rb_define_method(cAGFont.klass, "setBorder", VALUEFUNC(_wrap_AGFont_setBorder), -1);
    rb_define_method(cAGFont.klass, "getBorder", VALUEFUNC(_wrap_AGFont_getBorder), -1);
    rb_define_method(cAGFont.klass, "setAlpha", VALUEFUNC(_wrap_AGFont_setAlpha), -1);
    rb_define_method(cAGFont.klass, "getAlpha", VALUEFUNC(_wrap_AGFont_getAlpha), -1);
    rb_define_method(cAGFont.klass, "setSize", VALUEFUNC(_wrap_AGFont_setSize), -1);
    rb_define_method(cAGFont.klass, "getSize", VALUEFUNC(_wrap_AGFont_getSize), -1);
    rb_define_method(cAGFont.klass, "setStyle", VALUEFUNC(_wrap_AGFont_setStyle), -1);
    rb_define_method(cAGFont.klass, "getStyle", VALUEFUNC(_wrap_AGFont_getStyle), -1);
    rb_define_method(cAGFont.klass, "setName", VALUEFUNC(_wrap_AGFont_setName), -1);
    rb_define_method(cAGFont.klass, "getName", VALUEFUNC(_wrap_AGFont_getName), -1);
    rb_define_method(cAGFont.klass, "setEmbossed", VALUEFUNC(_wrap_AGFont_setEmbossed), -1);
    rb_define_method(cAGFont.klass, "getEmbossed", VALUEFUNC(_wrap_AGFont_getEmbossed), -1);
    rb_define_method(cAGFont.klass, "setInset", VALUEFUNC(_wrap_AGFont_setInset), -1);
    rb_define_method(cAGFont.klass, "getInset", VALUEFUNC(_wrap_AGFont_getInset), -1);
    rb_define_method(cAGFont.klass, "getWidth", VALUEFUNC(_wrap_AGFont_getWidth), -1);
    rb_define_method(cAGFont.klass, "getHeight", VALUEFUNC(_wrap_AGFont_getHeight), -1);
    rb_define_method(cAGFont.klass, "toString", VALUEFUNC(_wrap_AGFont_toString), -1);
    cAGFont.mark = 0;
    cAGFont.destroy = (void (*)(void *)) free_AGFont;
    
    cAGColor.klass = rb_define_class_under(mLibantargisgui, "AGColor", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGColor, (void *) &cAGColor);
    rb_define_alloc_func(cAGColor.klass, _wrap_AGColor_allocate);
    rb_define_method(cAGColor.klass, "initialize", VALUEFUNC(_wrap_new_AGColor), -1);
    rb_define_method(cAGColor.klass, "*", VALUEFUNC(_wrap_AGColor___mul__), -1);
    rb_define_method(cAGColor.klass, "+", VALUEFUNC(_wrap_AGColor___add__), -1);
    rb_define_method(cAGColor.klass, "mapRGB", VALUEFUNC(_wrap_AGColor_mapRGB), -1);
    rb_define_method(cAGColor.klass, "toString", VALUEFUNC(_wrap_AGColor_toString), -1);
    rb_define_method(cAGColor.klass, "grey", VALUEFUNC(_wrap_AGColor_grey), -1);
    rb_define_method(cAGColor.klass, "brightness", VALUEFUNC(_wrap_AGColor_brightness), -1);
    rb_define_method(cAGColor.klass, "light", VALUEFUNC(_wrap_AGColor_light), -1);
    rb_define_method(cAGColor.klass, "a=", VALUEFUNC(_wrap_AGColor_a_set), -1);
    rb_define_method(cAGColor.klass, "a", VALUEFUNC(_wrap_AGColor_a_get), -1);
    cAGColor.mark = 0;
    cAGColor.destroy = (void (*)(void *)) free_AGColor;
    rb_define_module_function(mLibantargisgui, "disown_AGWidget", VALUEFUNC(_wrap_disown_AGWidget), -1);
    
    cAGWidget.klass = rb_define_class_under(mLibantargisgui, "AGWidget", ((swig_class *) SWIGTYPE_p_AGMessageObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGWidget, (void *) &cAGWidget);
    rb_define_alloc_func(cAGWidget.klass, _wrap_AGWidget_allocate);
    rb_define_method(cAGWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGWidget), -1);
    rb_define_method(cAGWidget.klass, "draw", VALUEFUNC(_wrap_AGWidget_draw), -1);
    rb_define_method(cAGWidget.klass, "drawAfter", VALUEFUNC(_wrap_AGWidget_drawAfter), -1);
    rb_define_method(cAGWidget.klass, "drawAll", VALUEFUNC(_wrap_AGWidget_drawAll), -1);
    rb_define_method(cAGWidget.klass, "getRect", VALUEFUNC(_wrap_AGWidget_getRect), -1);
    rb_define_method(cAGWidget.klass, "getClientRect", VALUEFUNC(_wrap_AGWidget_getClientRect), -1);
    rb_define_method(cAGWidget.klass, "setRect", VALUEFUNC(_wrap_AGWidget_setRect), -1);
    rb_define_method(cAGWidget.klass, "setParent", VALUEFUNC(_wrap_AGWidget_setParent), -1);
    rb_define_method(cAGWidget.klass, "getParent", VALUEFUNC(_wrap_AGWidget_getParent), -1);
    rb_define_method(cAGWidget.klass, "eventShow", VALUEFUNC(_wrap_AGWidget_eventShow), -1);
    rb_define_method(cAGWidget.klass, "eventHide", VALUEFUNC(_wrap_AGWidget_eventHide), -1);
    rb_define_method(cAGWidget.klass, "eventMouseMotion", VALUEFUNC(_wrap_AGWidget_eventMouseMotion), -1);
    rb_define_method(cAGWidget.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGWidget_eventMouseEnter), -1);
    rb_define_method(cAGWidget.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGWidget_eventMouseLeave), -1);
    rb_define_method(cAGWidget.klass, "eventMouseClick", VALUEFUNC(_wrap_AGWidget_eventMouseClick), -1);
    rb_define_method(cAGWidget.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGWidget_eventMouseButtonDown), -1);
    rb_define_method(cAGWidget.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGWidget_eventMouseButtonUp), -1);
    rb_define_method(cAGWidget.klass, "eventGotFocus", VALUEFUNC(_wrap_AGWidget_eventGotFocus), -1);
    rb_define_method(cAGWidget.klass, "eventLostFocus", VALUEFUNC(_wrap_AGWidget_eventLostFocus), -1);
    rb_define_method(cAGWidget.klass, "canFocus", VALUEFUNC(_wrap_AGWidget_canFocus), -1);
    rb_define_method(cAGWidget.klass, "processEvent", VALUEFUNC(_wrap_AGWidget_processEvent), -1);
    rb_define_method(cAGWidget.klass, "sigMouseEnter=", VALUEFUNC(_wrap_AGWidget_sigMouseEnter_set), -1);
    rb_define_method(cAGWidget.klass, "sigMouseEnter", VALUEFUNC(_wrap_AGWidget_sigMouseEnter_get), -1);
    rb_define_method(cAGWidget.klass, "sigMouseLeave=", VALUEFUNC(_wrap_AGWidget_sigMouseLeave_set), -1);
    rb_define_method(cAGWidget.klass, "sigMouseLeave", VALUEFUNC(_wrap_AGWidget_sigMouseLeave_get), -1);
    rb_define_method(cAGWidget.klass, "sigClick=", VALUEFUNC(_wrap_AGWidget_sigClick_set), -1);
    rb_define_method(cAGWidget.klass, "sigClick", VALUEFUNC(_wrap_AGWidget_sigClick_get), -1);
    rb_define_method(cAGWidget.klass, "minWidth", VALUEFUNC(_wrap_AGWidget_minWidth), -1);
    rb_define_method(cAGWidget.klass, "minHeight", VALUEFUNC(_wrap_AGWidget_minHeight), -1);
    rb_define_method(cAGWidget.klass, "width", VALUEFUNC(_wrap_AGWidget_width), -1);
    rb_define_method(cAGWidget.klass, "height", VALUEFUNC(_wrap_AGWidget_height), -1);
    rb_define_method(cAGWidget.klass, "top", VALUEFUNC(_wrap_AGWidget_top), -1);
    rb_define_method(cAGWidget.klass, "left", VALUEFUNC(_wrap_AGWidget_left), -1);
    rb_define_method(cAGWidget.klass, "visible", VALUEFUNC(_wrap_AGWidget_visible), -1);
    rb_define_method(cAGWidget.klass, "setWidth", VALUEFUNC(_wrap_AGWidget_setWidth), -1);
    rb_define_method(cAGWidget.klass, "setHeight", VALUEFUNC(_wrap_AGWidget_setHeight), -1);
    rb_define_method(cAGWidget.klass, "setTop", VALUEFUNC(_wrap_AGWidget_setTop), -1);
    rb_define_method(cAGWidget.klass, "setLeft", VALUEFUNC(_wrap_AGWidget_setLeft), -1);
    rb_define_method(cAGWidget.klass, "fixedWidth", VALUEFUNC(_wrap_AGWidget_fixedWidth), -1);
    rb_define_method(cAGWidget.klass, "fixedHeight", VALUEFUNC(_wrap_AGWidget_fixedHeight), -1);
    rb_define_method(cAGWidget.klass, "show", VALUEFUNC(_wrap_AGWidget_show), -1);
    rb_define_method(cAGWidget.klass, "hide", VALUEFUNC(_wrap_AGWidget_hide), -1);
    rb_define_method(cAGWidget.klass, "mark", VALUEFUNC(_wrap_AGWidget_mark), -1);
    rb_define_method(cAGWidget.klass, "addChild", VALUEFUNC(_wrap_AGWidget_addChild), -1);
    rb_define_method(cAGWidget.klass, "addChildBack", VALUEFUNC(_wrap_AGWidget_addChildBack), -1);
    rb_define_method(cAGWidget.klass, "removeChild", VALUEFUNC(_wrap_AGWidget_removeChild), -1);
    rb_define_method(cAGWidget.klass, "redraw", VALUEFUNC(_wrap_AGWidget_redraw), -1);
    rb_define_method(cAGWidget.klass, "prepareDraw", VALUEFUNC(_wrap_AGWidget_prepareDraw), -1);
    rb_define_method(cAGWidget.klass, "setCaching", VALUEFUNC(_wrap_AGWidget_setCaching), -1);
    rb_define_method(cAGWidget.klass, "checkRedraw", VALUEFUNC(_wrap_AGWidget_checkRedraw), -1);
    rb_define_method(cAGWidget.klass, "clear", VALUEFUNC(_wrap_AGWidget_clear), -1);
    rb_define_method(cAGWidget.klass, "getScreenRect", VALUEFUNC(_wrap_AGWidget_getScreenRect), -1);
    rb_define_method(cAGWidget.klass, "getScreenPosition", VALUEFUNC(_wrap_AGWidget_getScreenPosition), -1);
    rb_define_method(cAGWidget.klass, "fromScreen", VALUEFUNC(_wrap_AGWidget_fromScreen), -1);
    rb_define_method(cAGWidget.klass, "gainFocus", VALUEFUNC(_wrap_AGWidget_gainFocus), -1);
    rb_define_method(cAGWidget.klass, "gainCompleteFocus", VALUEFUNC(_wrap_AGWidget_gainCompleteFocus), -1);
    rb_define_method(cAGWidget.klass, "eventDragBy", VALUEFUNC(_wrap_AGWidget_eventDragBy), -1);
    rb_define_method(cAGWidget.klass, "getFocus", VALUEFUNC(_wrap_AGWidget_getFocus), -1);
    rb_define_method(cAGWidget.klass, "hasFocus", VALUEFUNC(_wrap_AGWidget_hasFocus), -1);
    rb_define_method(cAGWidget.klass, "getName", VALUEFUNC(_wrap_AGWidget_getName), -1);
    rb_define_method(cAGWidget.klass, "setName", VALUEFUNC(_wrap_AGWidget_setName), -1);
    rb_define_method(cAGWidget.klass, "getChild", VALUEFUNC(_wrap_AGWidget_getChild), -1);
    rb_define_method(cAGWidget.klass, "setModal", VALUEFUNC(_wrap_AGWidget_setModal), -1);
    rb_define_method(cAGWidget.klass, "erase", VALUEFUNC(_wrap_AGWidget_erase), -1);
    rb_define_method(cAGWidget.klass, "eventChildrenDeleted", VALUEFUNC(_wrap_AGWidget_eventChildrenDeleted), -1);
    cAGWidget.mark = (void (*)(void *)) general_markfunc;
    cAGWidget.destroy = (void (*)(void *)) free_AGWidget;
    rb_define_module_function(mLibantargisgui, "toAGWidget", VALUEFUNC(_wrap_toAGWidget), -1);
    rb_define_singleton_method(mLibantargisgui, "agNoParent", VALUEFUNC(agNoParent_get), 0);
    rb_define_singleton_method(mLibantargisgui, "agNoParent=", VALUEFUNC(agNoParent_set), 1);
    rb_define_module_function(mLibantargisgui, "disown_AGColorButton", VALUEFUNC(_wrap_disown_AGColorButton), -1);
    
    cAGColorButton.klass = rb_define_class_under(mLibantargisgui, "AGColorButton", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGColorButton, (void *) &cAGColorButton);
    rb_define_alloc_func(cAGColorButton.klass, _wrap_AGColorButton_allocate);
    rb_define_method(cAGColorButton.klass, "initialize", VALUEFUNC(_wrap_new_AGColorButton), -1);
    rb_define_method(cAGColorButton.klass, "draw", VALUEFUNC(_wrap_AGColorButton_draw), -1);
    rb_define_method(cAGColorButton.klass, "getColor", VALUEFUNC(_wrap_AGColorButton_getColor), -1);
    rb_define_method(cAGColorButton.klass, "setColor", VALUEFUNC(_wrap_AGColorButton_setColor), -1);
    rb_define_method(cAGColorButton.klass, "eventMouseClick", VALUEFUNC(_wrap_AGColorButton_eventMouseClick), -1);
    cAGColorButton.mark = (void (*)(void *)) general_markfunc;
    cAGColorButton.destroy = (void (*)(void *)) free_AGColorButton;
    rb_define_module_function(mLibantargisgui, "toAGColorButton", VALUEFUNC(_wrap_toAGColorButton), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGGLWidget", VALUEFUNC(_wrap_disown_AGGLWidget), -1);
    
    cAGGLWidget.klass = rb_define_class_under(mLibantargisgui, "AGGLWidget", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGGLWidget, (void *) &cAGGLWidget);
    rb_define_alloc_func(cAGGLWidget.klass, _wrap_AGGLWidget_allocate);
    rb_define_method(cAGGLWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGGLWidget), -1);
    rb_define_method(cAGGLWidget.klass, "drawGL", VALUEFUNC(_wrap_AGGLWidget_drawGL), -1);
    rb_define_method(cAGGLWidget.klass, "drawAll", VALUEFUNC(_wrap_AGGLWidget_drawAll), -1);
    rb_define_method(cAGGLWidget.klass, "getRatio", VALUEFUNC(_wrap_AGGLWidget_getRatio), -1);
    rb_define_method(cAGGLWidget.klass, "setPerspective", VALUEFUNC(_wrap_AGGLWidget_setPerspective), -1);
    cAGGLWidget.mark = (void (*)(void *)) general_markfunc;
    cAGGLWidget.destroy = (void (*)(void *)) free_AGGLWidget;
    
    cNode.klass = rb_define_class_under(mLibantargisgui, "Node", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Node, (void *) &cNode);
    rb_define_alloc_func(cNode.klass, _wrap_Node_allocate);
    rb_define_method(cNode.klass, "initialize", VALUEFUNC(_wrap_new_Node), -1);
    rb_define_method(cNode.klass, "setName", VALUEFUNC(_wrap_Node_setName), -1);
    rb_define_method(cNode.klass, "getChildren", VALUEFUNC(_wrap_Node_getChildren), -1);
    rb_define_method(cNode.klass, "getName", VALUEFUNC(_wrap_Node_getName), -1);
    rb_define_method(cNode.klass, "setAttributes", VALUEFUNC(_wrap_Node_setAttributes), -1);
    rb_define_method(cNode.klass, "addChild", VALUEFUNC(_wrap_Node_addChild), -1);
    rb_define_method(cNode.klass, "removeChild", VALUEFUNC(_wrap_Node_removeChild), -1);
    rb_define_method(cNode.klass, "begin", VALUEFUNC(_wrap_Node_begin), -1);
    rb_define_method(cNode.klass, "end", VALUEFUNC(_wrap_Node_end), -1);
    rb_define_method(cNode.klass, "setContent", VALUEFUNC(_wrap_Node_setContent), -1);
    rb_define_method(cNode.klass, "set", VALUEFUNC(_wrap_Node_set), -1);
    rb_define_method(cNode.klass, "get", VALUEFUNC(_wrap_Node_get), -1);
    rb_define_method(cNode.klass, "clear", VALUEFUNC(_wrap_Node_clear), -1);
    rb_define_singleton_method(cNode.klass, "escape", VALUEFUNC(_wrap_Node_escape), -1);
    rb_define_singleton_method(cNode.klass, "unescape", VALUEFUNC(_wrap_Node_unescape), -1);
    rb_define_method(cNode.klass, "getStart", VALUEFUNC(_wrap_Node_getStart), -1);
    rb_define_method(cNode.klass, "getEnd", VALUEFUNC(_wrap_Node_getEnd), -1);
    rb_define_method(cNode.klass, "indent", VALUEFUNC(_wrap_Node_indent), -1);
    rb_define_method(cNode.klass, "getContent", VALUEFUNC(_wrap_Node_getContent), -1);
    rb_define_method(cNode.klass, "toString", VALUEFUNC(_wrap_Node_toString), -1);
    rb_define_method(cNode.klass, "isTextNode", VALUEFUNC(_wrap_Node_isTextNode), -1);
    rb_define_method(cNode.klass, "getText", VALUEFUNC(_wrap_Node_getText), -1);
    rb_define_method(cNode.klass, "hasTextNode", VALUEFUNC(_wrap_Node_hasTextNode), -1);
    rb_define_method(cNode.klass, "size", VALUEFUNC(_wrap_Node_size), -1);
    cNode.mark = 0;
    cNode.destroy = (void (*)(void *)) free_Node;
    
    cDocument.klass = rb_define_class_under(mLibantargisgui, "Document", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Document, (void *) &cDocument);
    rb_define_alloc_func(cDocument.klass, _wrap_Document_allocate);
    rb_define_method(cDocument.klass, "initialize", VALUEFUNC(_wrap_new_Document), -1);
    rb_define_method(cDocument.klass, "parseFile", VALUEFUNC(_wrap_Document_parseFile), -1);
    rb_define_method(cDocument.klass, "root", VALUEFUNC(_wrap_Document_root), -1);
    rb_define_method(cDocument.klass, "toString", VALUEFUNC(_wrap_Document_toString), -1);
    rb_define_method(cDocument.klass, "parseMemory", VALUEFUNC(_wrap_Document_parseMemory), -1);
    cDocument.mark = 0;
    cDocument.destroy = (void (*)(void *)) free_Document;
    rb_define_module_function(mLibantargisgui, "disown_Parser", VALUEFUNC(_wrap_disown_Parser), -1);
    
    cParser.klass = rb_define_class_under(mLibantargisgui, "Parser", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Parser, (void *) &cParser);
    rb_define_alloc_func(cParser.klass, _wrap_Parser_allocate);
    rb_define_method(cParser.klass, "initialize", VALUEFUNC(_wrap_new_Parser), -1);
    rb_define_method(cParser.klass, "parse", VALUEFUNC(_wrap_Parser_parse), -1);
    rb_define_method(cParser.klass, "getLine", VALUEFUNC(_wrap_Parser_getLine), -1);
    rb_define_method(cParser.klass, "simpleTag", VALUEFUNC(_wrap_Parser_simpleTag), -1);
    rb_define_method(cParser.klass, "startTag", VALUEFUNC(_wrap_Parser_startTag), -1);
    rb_define_method(cParser.klass, "endTag", VALUEFUNC(_wrap_Parser_endTag), -1);
    rb_define_method(cParser.klass, "text", VALUEFUNC(_wrap_Parser_text), -1);
    rb_define_method(cParser.klass, "comment", VALUEFUNC(_wrap_Parser_comment), -1);
    rb_define_method(cParser.klass, "header", VALUEFUNC(_wrap_Parser_header), -1);
    cParser.mark = 0;
    cParser.destroy = (void (*)(void *)) free_Parser;
    rb_define_module_function(mLibantargisgui, "disown_DomParser", VALUEFUNC(_wrap_disown_DomParser), -1);
    
    cDomParser.klass = rb_define_class_under(mLibantargisgui, "DomParser", ((swig_class *) SWIGTYPE_p_Parser->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_DomParser, (void *) &cDomParser);
    rb_define_alloc_func(cDomParser.klass, _wrap_DomParser_allocate);
    rb_define_method(cDomParser.klass, "initialize", VALUEFUNC(_wrap_new_DomParser), -1);
    rb_define_method(cDomParser.klass, "simpleTag", VALUEFUNC(_wrap_DomParser_simpleTag), -1);
    rb_define_method(cDomParser.klass, "startTag", VALUEFUNC(_wrap_DomParser_startTag), -1);
    rb_define_method(cDomParser.klass, "endTag", VALUEFUNC(_wrap_DomParser_endTag), -1);
    rb_define_method(cDomParser.klass, "text", VALUEFUNC(_wrap_DomParser_text), -1);
    rb_define_method(cDomParser.klass, "comment", VALUEFUNC(_wrap_DomParser_comment), -1);
    rb_define_method(cDomParser.klass, "header", VALUEFUNC(_wrap_DomParser_header), -1);
    rb_define_method(cDomParser.klass, "parse", VALUEFUNC(_wrap_DomParser_parse), -1);
    cDomParser.mark = 0;
    cDomParser.destroy = (void (*)(void *)) free_DomParser;
    rb_define_module_function(mLibantargisgui, "disown_AGLayout", VALUEFUNC(_wrap_disown_AGLayout), -1);
    
    cAGLayout.klass = rb_define_class_under(mLibantargisgui, "AGLayout", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayout, (void *) &cAGLayout);
    rb_define_alloc_func(cAGLayout.klass, _wrap_AGLayout_allocate);
    rb_define_method(cAGLayout.klass, "initialize", VALUEFUNC(_wrap_new_AGLayout), -1);
    rb_define_method(cAGLayout.klass, "addTabIndex", VALUEFUNC(_wrap_AGLayout_addTabIndex), -1);
    cAGLayout.mark = (void (*)(void *)) general_markfunc;
    cAGLayout.destroy = (void (*)(void *)) free_AGLayout;
    rb_define_module_function(mLibantargisgui, "parseNode", VALUEFUNC(_wrap_parseNode), -1);
    rb_define_module_function(mLibantargisgui, "parseChildren", VALUEFUNC(_wrap_parseChildren), -1);
    rb_define_module_function(mLibantargisgui, "getLayoutGeometry", VALUEFUNC(_wrap_getLayoutGeometry), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGDialog", VALUEFUNC(_wrap_disown_AGDialog), -1);
    
    cAGDialog.klass = rb_define_class_under(mLibantargisgui, "AGDialog", ((swig_class *) SWIGTYPE_p_AGLayout->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGDialog, (void *) &cAGDialog);
    rb_define_alloc_func(cAGDialog.klass, _wrap_AGDialog_allocate);
    rb_define_method(cAGDialog.klass, "initialize", VALUEFUNC(_wrap_new_AGDialog), -1);
    rb_define_method(cAGDialog.klass, "eventOk", VALUEFUNC(_wrap_AGDialog_eventOk), -1);
    rb_define_method(cAGDialog.klass, "eventCancel", VALUEFUNC(_wrap_AGDialog_eventCancel), -1);
    rb_define_method(cAGDialog.klass, "eventClose", VALUEFUNC(_wrap_AGDialog_eventClose), -1);
    cAGDialog.mark = (void (*)(void *)) general_markfunc;
    cAGDialog.destroy = (void (*)(void *)) free_AGDialog;
    
    cAGMutex.klass = rb_define_class_under(mLibantargisgui, "AGMutex", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMutex, (void *) &cAGMutex);
    rb_define_alloc_func(cAGMutex.klass, _wrap_AGMutex_allocate);
    rb_define_method(cAGMutex.klass, "initialize", VALUEFUNC(_wrap_new_AGMutex), -1);
    rb_define_method(cAGMutex.klass, "enter", VALUEFUNC(_wrap_AGMutex_enter), -1);
    rb_define_method(cAGMutex.klass, "leave", VALUEFUNC(_wrap_AGMutex_leave), -1);
    cAGMutex.mark = 0;
    cAGMutex.destroy = (void (*)(void *)) free_AGMutex;
    rb_define_module_function(mLibantargisgui, "disown_AGApplication", VALUEFUNC(_wrap_disown_AGApplication), -1);
    
    cAGApplication.klass = rb_define_class_under(mLibantargisgui, "AGApplication", ((swig_class *) SWIGTYPE_p_AGMessageObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGApplication, (void *) &cAGApplication);
    rb_define_alloc_func(cAGApplication.klass, _wrap_AGApplication_allocate);
    rb_define_method(cAGApplication.klass, "initialize", VALUEFUNC(_wrap_new_AGApplication), -1);
    rb_define_method(cAGApplication.klass, "run", VALUEFUNC(_wrap_AGApplication_run), -1);
    rb_define_method(cAGApplication.klass, "eventIdle", VALUEFUNC(_wrap_AGApplication_eventIdle), -1);
    rb_define_method(cAGApplication.klass, "eventFrame", VALUEFUNC(_wrap_AGApplication_eventFrame), -1);
    rb_define_method(cAGApplication.klass, "eventFrameEnd", VALUEFUNC(_wrap_AGApplication_eventFrameEnd), -1);
    rb_define_method(cAGApplication.klass, "eventQuit", VALUEFUNC(_wrap_AGApplication_eventQuit), -1);
    rb_define_method(cAGApplication.klass, "eventKeyDown", VALUEFUNC(_wrap_AGApplication_eventKeyDown), -1);
    rb_define_method(cAGApplication.klass, "eventChangedRes", VALUEFUNC(_wrap_AGApplication_eventChangedRes), -1);
    rb_define_method(cAGApplication.klass, "setMainWidget", VALUEFUNC(_wrap_AGApplication_setMainWidget), -1);
    rb_define_method(cAGApplication.klass, "draw", VALUEFUNC(_wrap_AGApplication_draw), -1);
    rb_define_method(cAGApplication.klass, "prepareDraw", VALUEFUNC(_wrap_AGApplication_prepareDraw), -1);
    rb_define_method(cAGApplication.klass, "tryQuit", VALUEFUNC(_wrap_AGApplication_tryQuit), -1);
    rb_define_method(cAGApplication.klass, "getTicks", VALUEFUNC(_wrap_AGApplication_getTicks), -1);
    rb_define_method(cAGApplication.klass, "delay", VALUEFUNC(_wrap_AGApplication_delay), -1);
    rb_define_method(cAGApplication.klass, "mark", VALUEFUNC(_wrap_AGApplication_mark), -1);
    cAGApplication.mark = (void (*)(void *)) general_markfunc;
    cAGApplication.destroy = (void (*)(void *)) free_AGApplication;
    rb_define_module_function(mLibantargisgui, "disableKeyrepeat", VALUEFUNC(_wrap_disableKeyrepeat), -1);
    
    cAGBackground.klass = rb_define_class_under(mLibantargisgui, "AGBackground", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBackground, (void *) &cAGBackground);
    rb_define_alloc_func(cAGBackground.klass, _wrap_AGBackground_allocate);
    rb_define_method(cAGBackground.klass, "initialize", VALUEFUNC(_wrap_new_AGBackground), -1);
    rb_define_method(cAGBackground.klass, "draw", VALUEFUNC(_wrap_AGBackground_draw), -1);
    cAGBackground.mark = 0;
    cAGBackground.destroy = (void (*)(void *)) free_AGBackground;
    
    cAGBorder.klass = rb_define_class_under(mLibantargisgui, "AGBorder", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBorder, (void *) &cAGBorder);
    rb_define_alloc_func(cAGBorder.klass, _wrap_AGBorder_allocate);
    rb_define_method(cAGBorder.klass, "initialize", VALUEFUNC(_wrap_new_AGBorder), -1);
    rb_define_method(cAGBorder.klass, "draw", VALUEFUNC(_wrap_AGBorder_draw), -1);
    rb_define_method(cAGBorder.klass, "getWidth", VALUEFUNC(_wrap_AGBorder_getWidth), -1);
    cAGBorder.mark = 0;
    cAGBorder.destroy = (void (*)(void *)) free_AGBorder;
    rb_define_module_function(mLibantargisgui, "disown_AGButton", VALUEFUNC(_wrap_disown_AGButton), -1);
    
    cAGButton.klass = rb_define_class_under(mLibantargisgui, "AGButton", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGButton, (void *) &cAGButton);
    rb_define_alloc_func(cAGButton.klass, _wrap_AGButton_allocate);
    rb_define_method(cAGButton.klass, "initialize", VALUEFUNC(_wrap_new_AGButton), -1);
    rb_define_const(cAGButton.klass,"NORMAL", INT2NUM(AGButton::NORMAL));
    rb_define_const(cAGButton.klass,"LIGHTED", INT2NUM(AGButton::LIGHTED));
    rb_define_const(cAGButton.klass,"PRESSED", INT2NUM(AGButton::PRESSED));
    rb_define_const(cAGButton.klass,"CHECKED", INT2NUM(AGButton::CHECKED));
    rb_define_const(cAGButton.klass,"CHECKEDLIGHTED", INT2NUM(AGButton::CHECKEDLIGHTED));
    rb_define_const(cAGButton.klass,"CHECKEDPRESSED", INT2NUM(AGButton::CHECKEDPRESSED));
    rb_define_method(cAGButton.klass, "setSurface", VALUEFUNC(_wrap_AGButton_setSurface), -1);
    rb_define_method(cAGButton.klass, "draw", VALUEFUNC(_wrap_AGButton_draw), -1);
    rb_define_method(cAGButton.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGButton_eventMouseEnter), -1);
    rb_define_method(cAGButton.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGButton_eventMouseLeave), -1);
    rb_define_method(cAGButton.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGButton_eventMouseButtonDown), -1);
    rb_define_method(cAGButton.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGButton_eventMouseButtonUp), -1);
    rb_define_method(cAGButton.klass, "setWidth", VALUEFUNC(_wrap_AGButton_setWidth), -1);
    rb_define_method(cAGButton.klass, "setHeight", VALUEFUNC(_wrap_AGButton_setHeight), -1);
    rb_define_method(cAGButton.klass, "getCaption", VALUEFUNC(_wrap_AGButton_getCaption), -1);
    rb_define_method(cAGButton.klass, "setEnabled", VALUEFUNC(_wrap_AGButton_setEnabled), -1);
    rb_define_method(cAGButton.klass, "setTheme", VALUEFUNC(_wrap_AGButton_setTheme), -1);
    rb_define_method(cAGButton.klass, "setCaption", VALUEFUNC(_wrap_AGButton_setCaption), -1);
    rb_define_method(cAGButton.klass, "setState", VALUEFUNC(_wrap_AGButton_setState), -1);
    rb_define_method(cAGButton.klass, "setChecked", VALUEFUNC(_wrap_AGButton_setChecked), -1);
    rb_define_method(cAGButton.klass, "isChecked", VALUEFUNC(_wrap_AGButton_isChecked), -1);
    rb_define_method(cAGButton.klass, "canFocus", VALUEFUNC(_wrap_AGButton_canFocus), -1);
    cAGButton.mark = (void (*)(void *)) general_markfunc;
    cAGButton.destroy = (void (*)(void *)) free_AGButton;
    rb_define_module_function(mLibantargisgui, "toAGButton", VALUEFUNC(_wrap_toAGButton), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGText", VALUEFUNC(_wrap_disown_AGText), -1);
    
    cAGText.klass = rb_define_class_under(mLibantargisgui, "AGText", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGText, (void *) &cAGText);
    rb_define_alloc_func(cAGText.klass, _wrap_AGText_allocate);
    rb_define_method(cAGText.klass, "initialize", VALUEFUNC(_wrap_new_AGText), -1);
    rb_define_method(cAGText.klass, "setDeriveRect", VALUEFUNC(_wrap_AGText_setDeriveRect), -1);
    rb_define_method(cAGText.klass, "draw", VALUEFUNC(_wrap_AGText_draw), -1);
    rb_define_method(cAGText.klass, "setText", VALUEFUNC(_wrap_AGText_setText), -1);
    rb_define_method(cAGText.klass, "getText", VALUEFUNC(_wrap_AGText_getText), -1);
    rb_define_method(cAGText.klass, "setFont", VALUEFUNC(_wrap_AGText_setFont), -1);
    cAGText.mark = (void (*)(void *)) general_markfunc;
    cAGText.destroy = (void (*)(void *)) free_AGText;
    rb_define_module_function(mLibantargisgui, "toAGText", VALUEFUNC(_wrap_toAGText), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGCaption", VALUEFUNC(_wrap_disown_AGCaption), -1);
    
    cAGCaption.klass = rb_define_class_under(mLibantargisgui, "AGCaption", ((swig_class *) SWIGTYPE_p_AGText->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGCaption, (void *) &cAGCaption);
    rb_define_alloc_func(cAGCaption.klass, _wrap_AGCaption_allocate);
    rb_define_method(cAGCaption.klass, "initialize", VALUEFUNC(_wrap_new_AGCaption), -1);
    rb_define_method(cAGCaption.klass, "draw", VALUEFUNC(_wrap_AGCaption_draw), -1);
    rb_define_method(cAGCaption.klass, "setBackground", VALUEFUNC(_wrap_AGCaption_setBackground), -1);
    cAGCaption.mark = (void (*)(void *)) general_markfunc;
    cAGCaption.destroy = (void (*)(void *)) free_AGCaption;
    rb_define_module_function(mLibantargisgui, "disown_AGCheckBox", VALUEFUNC(_wrap_disown_AGCheckBox), -1);
    
    cAGCheckBox.klass = rb_define_class_under(mLibantargisgui, "AGCheckBox", ((swig_class *) SWIGTYPE_p_AGButton->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGCheckBox, (void *) &cAGCheckBox);
    rb_define_alloc_func(cAGCheckBox.klass, _wrap_AGCheckBox_allocate);
    rb_define_method(cAGCheckBox.klass, "initialize", VALUEFUNC(_wrap_new_AGCheckBox), -1);
    rb_define_method(cAGCheckBox.klass, "eventMouseClick", VALUEFUNC(_wrap_AGCheckBox_eventMouseClick), -1);
    cAGCheckBox.mark = (void (*)(void *)) general_markfunc;
    cAGCheckBox.destroy = (void (*)(void *)) free_AGCheckBox;
    rb_define_const(mLibantargisgui,"EDIT_LEFT", INT2NUM(EDIT_LEFT));
    rb_define_const(mLibantargisgui,"EDIT_RIGHT", INT2NUM(EDIT_RIGHT));
    rb_define_const(mLibantargisgui,"EDIT_JUSTIFY", INT2NUM(EDIT_JUSTIFY));
    rb_define_const(mLibantargisgui,"EDIT_CENTER", INT2NUM(EDIT_CENTER));
    rb_define_const(mLibantargisgui,"EDIT_TOP", INT2NUM(EDIT_TOP));
    rb_define_const(mLibantargisgui,"EDIT_BOTTOM", INT2NUM(EDIT_BOTTOM));
    rb_define_const(mLibantargisgui,"EDIT_VCENTER", INT2NUM(EDIT_VCENTER));
    rb_define_module_function(mLibantargisgui, "disown_AGEditLine", VALUEFUNC(_wrap_disown_AGEditLine), -1);
    
    cAGEditLine.klass = rb_define_class_under(mLibantargisgui, "AGEditLine", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGEditLine, (void *) &cAGEditLine);
    rb_define_alloc_func(cAGEditLine.klass, _wrap_AGEditLine_allocate);
    rb_define_method(cAGEditLine.klass, "initialize", VALUEFUNC(_wrap_new_AGEditLine), -1);
    rb_define_method(cAGEditLine.klass, "setAlign", VALUEFUNC(_wrap_AGEditLine_setAlign), -1);
    rb_define_method(cAGEditLine.klass, "setVAlign", VALUEFUNC(_wrap_AGEditLine_setVAlign), -1);
    rb_define_method(cAGEditLine.klass, "draw", VALUEFUNC(_wrap_AGEditLine_draw), -1);
    rb_define_method(cAGEditLine.klass, "drawCursor", VALUEFUNC(_wrap_AGEditLine_drawCursor), -1);
    rb_define_method(cAGEditLine.klass, "height", VALUEFUNC(_wrap_AGEditLine_height), -1);
    rb_define_method(cAGEditLine.klass, "width", VALUEFUNC(_wrap_AGEditLine_width), -1);
    rb_define_method(cAGEditLine.klass, "insert", VALUEFUNC(_wrap_AGEditLine_insert), -1);
    rb_define_method(cAGEditLine.klass, "doDelete", VALUEFUNC(_wrap_AGEditLine_doDelete), -1);
    rb_define_method(cAGEditLine.klass, "split", VALUEFUNC(_wrap_AGEditLine_split), -1);
    rb_define_method(cAGEditLine.klass, "length", VALUEFUNC(_wrap_AGEditLine_length), -1);
    rb_define_method(cAGEditLine.klass, "append", VALUEFUNC(_wrap_AGEditLine_append), -1);
    rb_define_method(cAGEditLine.klass, "prepend", VALUEFUNC(_wrap_AGEditLine_prepend), -1);
    rb_define_method(cAGEditLine.klass, "getText", VALUEFUNC(_wrap_AGEditLine_getText), -1);
    rb_define_method(cAGEditLine.klass, "getFont", VALUEFUNC(_wrap_AGEditLine_getFont), -1);
    rb_define_method(cAGEditLine.klass, "setText", VALUEFUNC(_wrap_AGEditLine_setText), -1);
    rb_define_method(cAGEditLine.klass, "hardEnd", VALUEFUNC(_wrap_AGEditLine_hardEnd), -1);
    rb_define_method(cAGEditLine.klass, "setHardEnd", VALUEFUNC(_wrap_AGEditLine_setHardEnd), -1);
    rb_define_method(cAGEditLine.klass, "checkUnwrap", VALUEFUNC(_wrap_AGEditLine_checkUnwrap), -1);
    rb_define_method(cAGEditLine.klass, "checkWrap", VALUEFUNC(_wrap_AGEditLine_checkWrap), -1);
    rb_define_method(cAGEditLine.klass, "setFont", VALUEFUNC(_wrap_AGEditLine_setFont), -1);
    cAGEditLine.mark = 0;
    cAGEditLine.destroy = (void (*)(void *)) free_AGEditLine;
    rb_define_module_function(mLibantargisgui, "disown_AGEdit", VALUEFUNC(_wrap_disown_AGEdit), -1);
    
    cAGEdit.klass = rb_define_class_under(mLibantargisgui, "AGEdit", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGEdit, (void *) &cAGEdit);
    rb_define_alloc_func(cAGEdit.klass, _wrap_AGEdit_allocate);
    rb_define_method(cAGEdit.klass, "initialize", VALUEFUNC(_wrap_new_AGEdit), -1);
    rb_define_method(cAGEdit.klass, "draw", VALUEFUNC(_wrap_AGEdit_draw), -1);
    rb_define_method(cAGEdit.klass, "drawBackground", VALUEFUNC(_wrap_AGEdit_drawBackground), -1);
    rb_define_method(cAGEdit.klass, "eventKeyDown", VALUEFUNC(_wrap_AGEdit_eventKeyDown), -1);
    rb_define_method(cAGEdit.klass, "eventKeyUp", VALUEFUNC(_wrap_AGEdit_eventKeyUp), -1);
    rb_define_method(cAGEdit.klass, "setMulti", VALUEFUNC(_wrap_AGEdit_setMulti), -1);
    rb_define_method(cAGEdit.klass, "insert", VALUEFUNC(_wrap_AGEdit_insert), -1);
    rb_define_method(cAGEdit.klass, "doDelete", VALUEFUNC(_wrap_AGEdit_doDelete), -1);
    rb_define_method(cAGEdit.klass, "setText", VALUEFUNC(_wrap_AGEdit_setText), -1);
    rb_define_method(cAGEdit.klass, "setFont", VALUEFUNC(_wrap_AGEdit_setFont), -1);
    rb_define_method(cAGEdit.klass, "clear", VALUEFUNC(_wrap_AGEdit_clear), -1);
    rb_define_method(cAGEdit.klass, "setMutable", VALUEFUNC(_wrap_AGEdit_setMutable), -1);
    rb_define_method(cAGEdit.klass, "setAlign", VALUEFUNC(_wrap_AGEdit_setAlign), -1);
    rb_define_method(cAGEdit.klass, "setVAlign", VALUEFUNC(_wrap_AGEdit_setVAlign), -1);
    rb_define_method(cAGEdit.klass, "setBackground", VALUEFUNC(_wrap_AGEdit_setBackground), -1);
    rb_define_method(cAGEdit.klass, "setTheme", VALUEFUNC(_wrap_AGEdit_setTheme), -1);
    rb_define_method(cAGEdit.klass, "canFocus", VALUEFUNC(_wrap_AGEdit_canFocus), -1);
    rb_define_method(cAGEdit.klass, "getText", VALUEFUNC(_wrap_AGEdit_getText), -1);
    rb_define_method(cAGEdit.klass, "setMaxLength", VALUEFUNC(_wrap_AGEdit_setMaxLength), -1);
    cAGEdit.mark = (void (*)(void *)) general_markfunc;
    cAGEdit.destroy = (void (*)(void *)) free_AGEdit;
    rb_define_module_function(mLibantargisgui, "toAGEdit", VALUEFUNC(_wrap_toAGEdit), -1);
    
    cAGFontEngine.klass = rb_define_class_under(mLibantargisgui, "AGFontEngine", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGFontEngine, (void *) &cAGFontEngine);
    rb_define_alloc_func(cAGFontEngine.klass, _wrap_AGFontEngine_allocate);
    rb_define_method(cAGFontEngine.klass, "initialize", VALUEFUNC(_wrap_new_AGFontEngine), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "renderText", VALUEFUNC(_wrap_AGFontEngine_renderText), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "getWidth", VALUEFUNC(_wrap_AGFontEngine_getWidth), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "getHeight", VALUEFUNC(_wrap_AGFontEngine_getHeight), -1);
    cAGFontEngine.mark = 0;
    cAGFontEngine.destroy = (void (*)(void *)) free_AGFontEngine;
    rb_define_module_function(mLibantargisgui, "initFS", VALUEFUNC(_wrap_initFS), -1);
    rb_define_module_function(mLibantargisgui, "loadFile", VALUEFUNC(_wrap_loadFile), -1);
    rb_define_module_function(mLibantargisgui, "saveFile", VALUEFUNC(_wrap_saveFile), -1);
    rb_define_module_function(mLibantargisgui, "fileExists", VALUEFUNC(_wrap_fileExists), -1);
    rb_define_module_function(mLibantargisgui, "getDirectory", VALUEFUNC(_wrap_getDirectory), -1);
    rb_define_module_function(mLibantargisgui, "addPath", VALUEFUNC(_wrap_addPath), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGPaintTarget", VALUEFUNC(_wrap_disown_AGPaintTarget), -1);
    
    cAGPaintTarget.klass = rb_define_class_under(mLibantargisgui, "AGPaintTarget", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGPaintTarget, (void *) &cAGPaintTarget);
    rb_define_alloc_func(cAGPaintTarget.klass, _wrap_AGPaintTarget_allocate);
    rb_define_method(cAGPaintTarget.klass, "initialize", VALUEFUNC(_wrap_new_AGPaintTarget), -1);
    rb_define_method(cAGPaintTarget.klass, "blitTri", VALUEFUNC(_wrap_AGPaintTarget_blitTri), -1);
    rb_define_method(cAGPaintTarget.klass, "blit", VALUEFUNC(_wrap_AGPaintTarget_blit), -1);
    rb_define_method(cAGPaintTarget.klass, "drawLine", VALUEFUNC(_wrap_AGPaintTarget_drawLine), -1);
    rb_define_method(cAGPaintTarget.klass, "fillRect", VALUEFUNC(_wrap_AGPaintTarget_fillRect), -1);
    rb_define_method(cAGPaintTarget.klass, "getRect", VALUEFUNC(_wrap_AGPaintTarget_getRect), -1);
    rb_define_method(cAGPaintTarget.klass, "putPixel", VALUEFUNC(_wrap_AGPaintTarget_putPixel), -1);
    rb_define_method(cAGPaintTarget.klass, "getPixel", VALUEFUNC(_wrap_AGPaintTarget_getPixel), -1);
    rb_define_method(cAGPaintTarget.klass, "beginPaint", VALUEFUNC(_wrap_AGPaintTarget_beginPaint), -1);
    rb_define_method(cAGPaintTarget.klass, "endPaint", VALUEFUNC(_wrap_AGPaintTarget_endPaint), -1);
    cAGPaintTarget.mark = 0;
    cAGPaintTarget.destroy = (void (*)(void *)) free_AGPaintTarget;
    rb_define_module_function(mLibantargisgui, "disown_AGTexture", VALUEFUNC(_wrap_disown_AGTexture), -1);
    
    cAGTexture.klass = rb_define_class_under(mLibantargisgui, "AGTexture", ((swig_class *) SWIGTYPE_p_AGPaintTarget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGTexture, (void *) &cAGTexture);
    rb_define_alloc_func(cAGTexture.klass, _wrap_AGTexture_allocate);
    rb_define_method(cAGTexture.klass, "initialize", VALUEFUNC(_wrap_new_AGTexture), -1);
    rb_define_method(cAGTexture.klass, "copy", VALUEFUNC(_wrap_AGTexture_copy), -1);
    rb_define_method(cAGTexture.klass, "width", VALUEFUNC(_wrap_AGTexture_width), -1);
    rb_define_method(cAGTexture.klass, "height", VALUEFUNC(_wrap_AGTexture_height), -1);
    rb_define_method(cAGTexture.klass, "getRect", VALUEFUNC(_wrap_AGTexture_getRect), -1);
    rb_define_method(cAGTexture.klass, "getPixel", VALUEFUNC(_wrap_AGTexture_getPixel), -1);
    rb_define_method(cAGTexture.klass, "getSurfaceWidth", VALUEFUNC(_wrap_AGTexture_getSurfaceWidth), -1);
    rb_define_method(cAGTexture.klass, "getSurfaceHeight", VALUEFUNC(_wrap_AGTexture_getSurfaceHeight), -1);
    rb_define_method(cAGTexture.klass, "getTextureWidth", VALUEFUNC(_wrap_AGTexture_getTextureWidth), -1);
    rb_define_method(cAGTexture.klass, "getTextureHeight", VALUEFUNC(_wrap_AGTexture_getTextureHeight), -1);
    rb_define_method(cAGTexture.klass, "getTW", VALUEFUNC(_wrap_AGTexture_getTW), -1);
    rb_define_method(cAGTexture.klass, "getTH", VALUEFUNC(_wrap_AGTexture_getTH), -1);
    rb_define_method(cAGTexture.klass, "hasTexture", VALUEFUNC(_wrap_AGTexture_hasTexture), -1);
    rb_define_method(cAGTexture.klass, "textureUsed", VALUEFUNC(_wrap_AGTexture_textureUsed), -1);
    rb_define_method(cAGTexture.klass, "clearTexture", VALUEFUNC(_wrap_AGTexture_clearTexture), -1);
    rb_define_method(cAGTexture.klass, "clearTextureUsed", VALUEFUNC(_wrap_AGTexture_clearTextureUsed), -1);
    rb_define_method(cAGTexture.klass, "beginPaint", VALUEFUNC(_wrap_AGTexture_beginPaint), -1);
    rb_define_method(cAGTexture.klass, "endPaint", VALUEFUNC(_wrap_AGTexture_endPaint), -1);
    rb_define_method(cAGTexture.klass, "putPixel", VALUEFUNC(_wrap_AGTexture_putPixel), -1);
    rb_define_method(cAGTexture.klass, "fillRect", VALUEFUNC(_wrap_AGTexture_fillRect), -1);
    rb_define_method(cAGTexture.klass, "blit", VALUEFUNC(_wrap_AGTexture_blit), -1);
    rb_define_method(cAGTexture.klass, "setWrapping", VALUEFUNC(_wrap_AGTexture_setWrapping), -1);
    rb_define_method(cAGTexture.klass, "setFilter", VALUEFUNC(_wrap_AGTexture_setFilter), -1);
    rb_define_method(cAGTexture.klass, "setClamp", VALUEFUNC(_wrap_AGTexture_setClamp), -1);
    rb_define_method(cAGTexture.klass, "glTexture", VALUEFUNC(_wrap_AGTexture_glTexture), -1);
    rb_define_method(cAGTexture.klass, "sdlTexture", VALUEFUNC(_wrap_AGTexture_sdlTexture), -1);
    rb_define_method(cAGTexture.klass, "is3d", VALUEFUNC(_wrap_AGTexture_is3d), -1);
    cAGTexture.mark = 0;
    cAGTexture.destroy = (void (*)(void *)) free_AGTexture;
    rb_define_module_function(mLibantargisgui, "beginRender", VALUEFUNC(_wrap_beginRender), -1);
    rb_define_module_function(mLibantargisgui, "endRender", VALUEFUNC(_wrap_endRender), -1);
    rb_define_module_function(mLibantargisgui, "isRendering", VALUEFUNC(_wrap_isRendering), -1);
    
    cAGInternalSurface.klass = rb_define_class_under(mLibantargisgui, "AGInternalSurface", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGInternalSurface, (void *) &cAGInternalSurface);
    rb_define_alloc_func(cAGInternalSurface.klass, _wrap_AGInternalSurface_allocate);
    rb_define_method(cAGInternalSurface.klass, "initialize", VALUEFUNC(_wrap_new_AGInternalSurface), -1);
    rb_define_method(cAGInternalSurface.klass, "sdlTexture=", VALUEFUNC(_wrap_AGInternalSurface_sdlTexture_set), -1);
    rb_define_method(cAGInternalSurface.klass, "sdlTexture", VALUEFUNC(_wrap_AGInternalSurface_sdlTexture_get), -1);
    rb_define_method(cAGInternalSurface.klass, "glTexture=", VALUEFUNC(_wrap_AGInternalSurface_glTexture_set), -1);
    rb_define_method(cAGInternalSurface.klass, "glTexture", VALUEFUNC(_wrap_AGInternalSurface_glTexture_get), -1);
    rb_define_method(cAGInternalSurface.klass, "surface=", VALUEFUNC(_wrap_AGInternalSurface_surface_set), -1);
    rb_define_method(cAGInternalSurface.klass, "surface", VALUEFUNC(_wrap_AGInternalSurface_surface_get), -1);
    cAGInternalSurface.mark = 0;
    cAGInternalSurface.destroy = (void (*)(void *)) free_AGInternalSurface;
    rb_define_module_function(mLibantargisgui, "disown_AGSurface", VALUEFUNC(_wrap_disown_AGSurface), -1);
    
    cAGSurface.klass = rb_define_class_under(mLibantargisgui, "AGSurface", ((swig_class *) SWIGTYPE_p_AGPaintTarget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSurface, (void *) &cAGSurface);
    rb_define_alloc_func(cAGSurface.klass, _wrap_AGSurface_allocate);
    rb_define_method(cAGSurface.klass, "initialize", VALUEFUNC(_wrap_new_AGSurface), -1);
    rb_define_method(cAGSurface.klass, "copy", VALUEFUNC(_wrap_AGSurface_copy), -1);
    rb_define_method(cAGSurface.klass, "width", VALUEFUNC(_wrap_AGSurface_width), -1);
    rb_define_method(cAGSurface.klass, "height", VALUEFUNC(_wrap_AGSurface_height), -1);
    rb_define_method(cAGSurface.klass, "getRect", VALUEFUNC(_wrap_AGSurface_getRect), -1);
    rb_define_method(cAGSurface.klass, "getSubSurface", VALUEFUNC(_wrap_AGSurface_getSubSurface), -1);
    rb_define_method(cAGSurface.klass, "valid", VALUEFUNC(_wrap_AGSurface_valid), -1);
    rb_define_method(cAGSurface.klass, "blit", VALUEFUNC(_wrap_AGSurface_blit), -1);
    rb_define_method(cAGSurface.klass, "drawGradient", VALUEFUNC(_wrap_AGSurface_drawGradient), -1);
    rb_define_method(cAGSurface.klass, "drawGradientAlpha", VALUEFUNC(_wrap_AGSurface_drawGradientAlpha), -1);
    rb_define_method(cAGSurface.klass, "drawBorder", VALUEFUNC(_wrap_AGSurface_drawBorder), -1);
    rb_define_method(cAGSurface.klass, "putPixel", VALUEFUNC(_wrap_AGSurface_putPixel), -1);
    rb_define_method(cAGSurface.klass, "getPixel", VALUEFUNC(_wrap_AGSurface_getPixel), -1);
    rb_define_method(cAGSurface.klass, "save", VALUEFUNC(_wrap_AGSurface_save), -1);
    rb_define_singleton_method(cAGSurface.klass, "load", VALUEFUNC(_wrap_AGSurface_load), -1);
    rb_define_method(cAGSurface.klass, "surface", VALUEFUNC(_wrap_AGSurface_surface), -1);
    cAGSurface.mark = 0;
    cAGSurface.destroy = (void (*)(void *)) free_AGSurface;
    rb_define_module_function(mLibantargisgui, "AGFreeSurface", VALUEFUNC(_wrap_AGFreeSurface), -1);
    
    cAGGLTexture.klass = rb_define_class_under(mLibantargisgui, "AGGLTexture", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGGLTexture, (void *) &cAGGLTexture);
    rb_define_alloc_func(cAGGLTexture.klass, _wrap_AGGLTexture_allocate);
    rb_define_method(cAGGLTexture.klass, "initialize", VALUEFUNC(_wrap_new_AGGLTexture), -1);
    rb_define_method(cAGGLTexture.klass, "setSurface", VALUEFUNC(_wrap_AGGLTexture_setSurface), -1);
    rb_define_method(cAGGLTexture.klass, "id", VALUEFUNC(_wrap_AGGLTexture_id), -1);
    rb_define_method(cAGGLTexture.klass, "is3d", VALUEFUNC(_wrap_AGGLTexture_is3d), -1);
    rb_define_method(cAGGLTexture.klass, "width", VALUEFUNC(_wrap_AGGLTexture_width), -1);
    rb_define_method(cAGGLTexture.klass, "height", VALUEFUNC(_wrap_AGGLTexture_height), -1);
    rb_define_method(cAGGLTexture.klass, "depth", VALUEFUNC(_wrap_AGGLTexture_depth), -1);
    cAGGLTexture.mark = 0;
    cAGGLTexture.destroy = (void (*)(void *)) free_AGGLTexture;
    rb_define_module_function(mLibantargisgui, "disown_AGImage", VALUEFUNC(_wrap_disown_AGImage), -1);
    
    cAGImage.klass = rb_define_class_under(mLibantargisgui, "AGImage", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGImage, (void *) &cAGImage);
    rb_define_alloc_func(cAGImage.klass, _wrap_AGImage_allocate);
    rb_define_method(cAGImage.klass, "initialize", VALUEFUNC(_wrap_new_AGImage), -1);
    rb_define_method(cAGImage.klass, "draw", VALUEFUNC(_wrap_AGImage_draw), -1);
    rb_define_method(cAGImage.klass, "setSurface", VALUEFUNC(_wrap_AGImage_setSurface), -1);
    rb_define_method(cAGImage.klass, "setTexture", VALUEFUNC(_wrap_AGImage_setTexture), -1);
    cAGImage.mark = (void (*)(void *)) general_markfunc;
    cAGImage.destroy = (void (*)(void *)) free_AGImage;
    rb_define_module_function(mLibantargisgui, "disown_AGLayoutCreator", VALUEFUNC(_wrap_disown_AGLayoutCreator), -1);
    
    cAGLayoutCreator.klass = rb_define_class_under(mLibantargisgui, "AGLayoutCreator", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayoutCreator, (void *) &cAGLayoutCreator);
    rb_define_alloc_func(cAGLayoutCreator.klass, _wrap_AGLayoutCreator_allocate);
    rb_define_method(cAGLayoutCreator.klass, "initialize", VALUEFUNC(_wrap_new_AGLayoutCreator), -1);
    rb_define_method(cAGLayoutCreator.klass, "create", VALUEFUNC(_wrap_AGLayoutCreator_create), -1);
    cAGLayoutCreator.mark = 0;
    cAGLayoutCreator.destroy = (void (*)(void *)) free_AGLayoutCreator;
    rb_define_module_function(mLibantargisgui, "getLayoutFactory", VALUEFUNC(_wrap_getLayoutFactory), -1);
    
    cAGLayoutFactory.klass = rb_define_class_under(mLibantargisgui, "AGLayoutFactory", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayoutFactory, (void *) &cAGLayoutFactory);
    rb_undef_alloc_func(cAGLayoutFactory.klass);
    rb_define_method(cAGLayoutFactory.klass, "addCreator", VALUEFUNC(_wrap_AGLayoutFactory_addCreator), -1);
    rb_define_method(cAGLayoutFactory.klass, "create", VALUEFUNC(_wrap_AGLayoutFactory_create), -1);
    cAGLayoutFactory.mark = 0;
    cAGLayoutFactory.destroy = (void (*)(void *)) free_AGLayoutFactory;
    rb_define_module_function(mLibantargisgui, "disown_AGVTiler", VALUEFUNC(_wrap_disown_AGVTiler), -1);
    
    cAGVTiler.klass = rb_define_class_under(mLibantargisgui, "AGVTiler", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGVTiler, (void *) &cAGVTiler);
    rb_define_alloc_func(cAGVTiler.klass, _wrap_AGVTiler_allocate);
    rb_define_method(cAGVTiler.klass, "initialize", VALUEFUNC(_wrap_new_AGVTiler), -1);
    rb_define_method(cAGVTiler.klass, "addChild", VALUEFUNC(_wrap_AGVTiler_addChild), -1);
    rb_define_method(cAGVTiler.klass, "rePosition", VALUEFUNC(_wrap_AGVTiler_rePosition), -1);
    rb_define_method(cAGVTiler.klass, "adaptHeightFromChildren", VALUEFUNC(_wrap_AGVTiler_adaptHeightFromChildren), -1);
    rb_define_method(cAGVTiler.klass, "adaptWidthFromChildren", VALUEFUNC(_wrap_AGVTiler_adaptWidthFromChildren), -1);
    cAGVTiler.mark = (void (*)(void *)) general_markfunc;
    cAGVTiler.destroy = (void (*)(void *)) free_AGVTiler;
    rb_define_module_function(mLibantargisgui, "disown_AGHTiler", VALUEFUNC(_wrap_disown_AGHTiler), -1);
    
    cAGHTiler.klass = rb_define_class_under(mLibantargisgui, "AGHTiler", ((swig_class *) SWIGTYPE_p_AGVTiler->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGHTiler, (void *) &cAGHTiler);
    rb_define_alloc_func(cAGHTiler.klass, _wrap_AGHTiler_allocate);
    rb_define_method(cAGHTiler.klass, "initialize", VALUEFUNC(_wrap_new_AGHTiler), -1);
    rb_define_method(cAGHTiler.klass, "rePosition", VALUEFUNC(_wrap_AGHTiler_rePosition), -1);
    rb_define_method(cAGHTiler.klass, "adaptHeightFromChildren", VALUEFUNC(_wrap_AGHTiler_adaptHeightFromChildren), -1);
    rb_define_method(cAGHTiler.klass, "adaptWidthFromChildren", VALUEFUNC(_wrap_AGHTiler_adaptWidthFromChildren), -1);
    rb_define_method(cAGHTiler.klass, "adaptWidthFromParent", VALUEFUNC(_wrap_AGHTiler_adaptWidthFromParent), -1);
    cAGHTiler.mark = (void (*)(void *)) general_markfunc;
    cAGHTiler.destroy = (void (*)(void *)) free_AGHTiler;
    
    cAGListBoxItem.klass = rb_define_class_under(mLibantargisgui, "AGListBoxItem", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGListBoxItem, (void *) &cAGListBoxItem);
    rb_define_alloc_func(cAGListBoxItem.klass, _wrap_AGListBoxItem_allocate);
    rb_define_method(cAGListBoxItem.klass, "initialize", VALUEFUNC(_wrap_new_AGListBoxItem), -1);
    rb_define_method(cAGListBoxItem.klass, "id=", VALUEFUNC(_wrap_AGListBoxItem_id_set), -1);
    rb_define_method(cAGListBoxItem.klass, "id", VALUEFUNC(_wrap_AGListBoxItem_id_get), -1);
    rb_define_method(cAGListBoxItem.klass, "value=", VALUEFUNC(_wrap_AGListBoxItem_value_set), -1);
    rb_define_method(cAGListBoxItem.klass, "value", VALUEFUNC(_wrap_AGListBoxItem_value_get), -1);
    cAGListBoxItem.mark = 0;
    cAGListBoxItem.destroy = (void (*)(void *)) free_AGListBoxItem;
    rb_define_module_function(mLibantargisgui, "disown_AGListBox", VALUEFUNC(_wrap_disown_AGListBox), -1);
    
    cAGListBox.klass = rb_define_class_under(mLibantargisgui, "AGListBox", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGListBox, (void *) &cAGListBox);
    rb_define_alloc_func(cAGListBox.klass, _wrap_AGListBox_allocate);
    rb_define_method(cAGListBox.klass, "initialize", VALUEFUNC(_wrap_new_AGListBox), -1);
    rb_define_method(cAGListBox.klass, "insertItem", VALUEFUNC(_wrap_AGListBox_insertItem), -1);
    rb_define_method(cAGListBox.klass, "selectItem", VALUEFUNC(_wrap_AGListBox_selectItem), -1);
    rb_define_method(cAGListBox.klass, "getSelectedID", VALUEFUNC(_wrap_AGListBox_getSelectedID), -1);
    rb_define_method(cAGListBox.klass, "getSelectedValue", VALUEFUNC(_wrap_AGListBox_getSelectedValue), -1);
    rb_define_method(cAGListBox.klass, "eventKeyDown", VALUEFUNC(_wrap_AGListBox_eventKeyDown), -1);
    rb_define_method(cAGListBox.klass, "sigSelect=", VALUEFUNC(_wrap_AGListBox_sigSelect_set), -1);
    rb_define_method(cAGListBox.klass, "sigSelect", VALUEFUNC(_wrap_AGListBox_sigSelect_get), -1);
    rb_define_method(cAGListBox.klass, "sigDoubleClick=", VALUEFUNC(_wrap_AGListBox_sigDoubleClick_set), -1);
    rb_define_method(cAGListBox.klass, "sigDoubleClick", VALUEFUNC(_wrap_AGListBox_sigDoubleClick_get), -1);
    rb_define_method(cAGListBox.klass, "draw", VALUEFUNC(_wrap_AGListBox_draw), -1);
    rb_define_method(cAGListBox.klass, "eventMouseClick", VALUEFUNC(_wrap_AGListBox_eventMouseClick), -1);
    rb_define_method(cAGListBox.klass, "clearList", VALUEFUNC(_wrap_AGListBox_clearList), -1);
    cAGListBox.mark = (void (*)(void *)) general_markfunc;
    cAGListBox.destroy = (void (*)(void *)) free_AGListBox;
    rb_define_module_function(mLibantargisgui, "toAGListBox", VALUEFUNC(_wrap_toAGListBox), -1);
    
    cAGMain.klass = rb_define_class_under(mLibantargisgui, "AGMain", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMain, (void *) &cAGMain);
    rb_define_alloc_func(cAGMain.klass, _wrap_AGMain_allocate);
    rb_define_method(cAGMain.klass, "initialize", VALUEFUNC(_wrap_new_AGMain), -1);
    rb_define_method(cAGMain.klass, "flip", VALUEFUNC(_wrap_AGMain_flip), -1);
    rb_define_method(cAGMain.klass, "changeRes", VALUEFUNC(_wrap_AGMain_changeRes), -1);
    rb_define_method(cAGMain.klass, "toggleFull", VALUEFUNC(_wrap_AGMain_toggleFull), -1);
    rb_define_method(cAGMain.klass, "width", VALUEFUNC(_wrap_AGMain_width), -1);
    rb_define_method(cAGMain.klass, "height", VALUEFUNC(_wrap_AGMain_height), -1);
    rb_define_method(cAGMain.klass, "setIcon", VALUEFUNC(_wrap_AGMain_setIcon), -1);
    rb_define_method(cAGMain.klass, "setCaption", VALUEFUNC(_wrap_AGMain_setCaption), -1);
    cAGMain.mark = 0;
    cAGMain.destroy = (void (*)(void *)) free_AGMain;
    rb_define_module_function(mLibantargisgui, "getMain", VALUEFUNC(_wrap_getMain), -1);
    rb_define_module_function(mLibantargisgui, "hasQuit", VALUEFUNC(_wrap_hasQuit), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGMenu", VALUEFUNC(_wrap_disown_AGMenu), -1);
    
    cAGMenu.klass = rb_define_class_under(mLibantargisgui, "AGMenu", ((swig_class *) SWIGTYPE_p_AGVTiler->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMenu, (void *) &cAGMenu);
    rb_define_alloc_func(cAGMenu.klass, _wrap_AGMenu_allocate);
    rb_define_method(cAGMenu.klass, "initialize", VALUEFUNC(_wrap_new_AGMenu), -1);
    rb_define_method(cAGMenu.klass, "show", VALUEFUNC(_wrap_AGMenu_show), -1);
    rb_define_method(cAGMenu.klass, "addItem", VALUEFUNC(_wrap_AGMenu_addItem), -1);
    rb_define_method(cAGMenu.klass, "addMenu", VALUEFUNC(_wrap_AGMenu_addMenu), -1);
    rb_define_method(cAGMenu.klass, "draw", VALUEFUNC(_wrap_AGMenu_draw), -1);
    rb_define_method(cAGMenu.klass, "eventItemSelected", VALUEFUNC(_wrap_AGMenu_eventItemSelected), -1);
    rb_define_method(cAGMenu.klass, "eventItemClicked", VALUEFUNC(_wrap_AGMenu_eventItemClicked), -1);
    rb_define_method(cAGMenu.klass, "sigSelected=", VALUEFUNC(_wrap_AGMenu_sigSelected_set), -1);
    rb_define_method(cAGMenu.klass, "sigSelected", VALUEFUNC(_wrap_AGMenu_sigSelected_get), -1);
    cAGMenu.mark = (void (*)(void *)) general_markfunc;
    cAGMenu.destroy = (void (*)(void *)) free_AGMenu;
    rb_define_module_function(mLibantargisgui, "disown_AGMenuItem", VALUEFUNC(_wrap_disown_AGMenuItem), -1);
    
    cAGMenuItem.klass = rb_define_class_under(mLibantargisgui, "AGMenuItem", ((swig_class *) SWIGTYPE_p_AGHTiler->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMenuItem, (void *) &cAGMenuItem);
    rb_define_alloc_func(cAGMenuItem.klass, _wrap_AGMenuItem_allocate);
    rb_define_method(cAGMenuItem.klass, "initialize", VALUEFUNC(_wrap_new_AGMenuItem), -1);
    rb_define_method(cAGMenuItem.klass, "draw", VALUEFUNC(_wrap_AGMenuItem_draw), -1);
    rb_define_method(cAGMenuItem.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGMenuItem_eventMouseEnter), -1);
    rb_define_method(cAGMenuItem.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGMenuItem_eventMouseLeave), -1);
    rb_define_method(cAGMenuItem.klass, "getSelected", VALUEFUNC(_wrap_AGMenuItem_getSelected), -1);
    rb_define_method(cAGMenuItem.klass, "unSelect", VALUEFUNC(_wrap_AGMenuItem_unSelect), -1);
    rb_define_method(cAGMenuItem.klass, "getName", VALUEFUNC(_wrap_AGMenuItem_getName), -1);
    rb_define_method(cAGMenuItem.klass, "eventMouseClick", VALUEFUNC(_wrap_AGMenuItem_eventMouseClick), -1);
    rb_define_method(cAGMenuItem.klass, "eventSelect", VALUEFUNC(_wrap_AGMenuItem_eventSelect), -1);
    rb_define_method(cAGMenuItem.klass, "eventUnselect", VALUEFUNC(_wrap_AGMenuItem_eventUnselect), -1);
    cAGMenuItem.mark = (void (*)(void *)) general_markfunc;
    cAGMenuItem.destroy = (void (*)(void *)) free_AGMenuItem;
    rb_define_module_function(mLibantargisgui, "disown_AGSubMenu", VALUEFUNC(_wrap_disown_AGSubMenu), -1);
    
    cAGSubMenu.klass = rb_define_class_under(mLibantargisgui, "AGSubMenu", ((swig_class *) SWIGTYPE_p_AGMenuItem->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSubMenu, (void *) &cAGSubMenu);
    rb_define_alloc_func(cAGSubMenu.klass, _wrap_AGSubMenu_allocate);
    rb_define_method(cAGSubMenu.klass, "initialize", VALUEFUNC(_wrap_new_AGSubMenu), -1);
    rb_define_method(cAGSubMenu.klass, "getMenu", VALUEFUNC(_wrap_AGSubMenu_getMenu), -1);
    rb_define_method(cAGSubMenu.klass, "eventSelect", VALUEFUNC(_wrap_AGSubMenu_eventSelect), -1);
    rb_define_method(cAGSubMenu.klass, "eventUnselect", VALUEFUNC(_wrap_AGSubMenu_eventUnselect), -1);
    rb_define_method(cAGSubMenu.klass, "eventMouseClick", VALUEFUNC(_wrap_AGSubMenu_eventMouseClick), -1);
    cAGSubMenu.mark = (void (*)(void *)) general_markfunc;
    cAGSubMenu.destroy = (void (*)(void *)) free_AGSubMenu;
    rb_define_module_function(mLibantargisgui, "getSoundManager", VALUEFUNC(_wrap_getSoundManager), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGSound", VALUEFUNC(_wrap_disown_AGSound), -1);
    
    cAGSound.klass = rb_define_class_under(mLibantargisgui, "AGSound", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSound, (void *) &cAGSound);
    rb_define_alloc_func(cAGSound.klass, _wrap_AGSound_allocate);
    rb_define_method(cAGSound.klass, "initialize", VALUEFUNC(_wrap_new_AGSound), -1);
    rb_define_method(cAGSound.klass, "playMp3", VALUEFUNC(_wrap_AGSound_playMp3), -1);
    rb_define_method(cAGSound.klass, "stopMp3", VALUEFUNC(_wrap_AGSound_stopMp3), -1);
    rb_define_method(cAGSound.klass, "checkFinished", VALUEFUNC(_wrap_AGSound_checkFinished), -1);
    rb_define_method(cAGSound.klass, "fadeOutMusic", VALUEFUNC(_wrap_AGSound_fadeOutMusic), -1);
    rb_define_method(cAGSound.klass, "playWave", VALUEFUNC(_wrap_AGSound_playWave), -1);
    rb_define_method(cAGSound.klass, "loopPlay", VALUEFUNC(_wrap_AGSound_loopPlay), -1);
    rb_define_method(cAGSound.klass, "stopChannel", VALUEFUNC(_wrap_AGSound_stopChannel), -1);
    rb_define_method(cAGSound.klass, "volumeSound", VALUEFUNC(_wrap_AGSound_volumeSound), -1);
    rb_define_method(cAGSound.klass, "volumeMusic", VALUEFUNC(_wrap_AGSound_volumeMusic), -1);
    rb_define_method(cAGSound.klass, "loadWave", VALUEFUNC(_wrap_AGSound_loadWave), -1);
    rb_define_method(cAGSound.klass, "sigMp3Finished=", VALUEFUNC(_wrap_AGSound_sigMp3Finished_set), -1);
    rb_define_method(cAGSound.klass, "sigMp3Finished", VALUEFUNC(_wrap_AGSound_sigMp3Finished_get), -1);
    cAGSound.mark = (void (*)(void *)) general_markfunc;
    cAGSound.destroy = (void (*)(void *)) free_AGSound;
    
    cAGProjection.klass = rb_define_class_under(mLibantargisgui, "AGProjection", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGProjection, (void *) &cAGProjection);
    rb_define_alloc_func(cAGProjection.klass, _wrap_AGProjection_allocate);
    rb_define_method(cAGProjection.klass, "initialize", VALUEFUNC(_wrap_new_AGProjection), -1);
    rb_define_method(cAGProjection.klass, "a=", VALUEFUNC(_wrap_AGProjection_a_set), -1);
    rb_define_method(cAGProjection.klass, "a", VALUEFUNC(_wrap_AGProjection_a_get), -1);
    rb_define_method(cAGProjection.klass, "clip=", VALUEFUNC(_wrap_AGProjection_clip_set), -1);
    rb_define_method(cAGProjection.klass, "clip", VALUEFUNC(_wrap_AGProjection_clip_get), -1);
    rb_define_method(cAGProjection.klass, "pointOk", VALUEFUNC(_wrap_AGProjection_pointOk), -1);
    rb_define_method(cAGProjection.klass, "project", VALUEFUNC(_wrap_AGProjection_project), -1);
    rb_define_method(cAGProjection.klass, "clipRect", VALUEFUNC(_wrap_AGProjection_clipRect), -1);
    rb_define_method(cAGProjection.klass, "clipLine", VALUEFUNC(_wrap_AGProjection_clipLine), -1);
    rb_define_method(cAGProjection.klass, "translate", VALUEFUNC(_wrap_AGProjection_translate), -1);
    rb_define_method(cAGProjection.klass, "setClip", VALUEFUNC(_wrap_AGProjection_setClip), -1);
    rb_define_method(cAGProjection.klass, "getRect", VALUEFUNC(_wrap_AGProjection_getRect), -1);
    cAGProjection.mark = 0;
    cAGProjection.destroy = (void (*)(void *)) free_AGProjection;
    
    cAGPainter.klass = rb_define_class_under(mLibantargisgui, "AGPainter", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGPainter, (void *) &cAGPainter);
    rb_define_alloc_func(cAGPainter.klass, _wrap_AGPainter_allocate);
    rb_define_method(cAGPainter.klass, "initialize", VALUEFUNC(_wrap_new_AGPainter), -1);
    rb_define_method(cAGPainter.klass, "putPixel", VALUEFUNC(_wrap_AGPainter_putPixel), -1);
    rb_define_method(cAGPainter.klass, "getPixel", VALUEFUNC(_wrap_AGPainter_getPixel), -1);
    rb_define_method(cAGPainter.klass, "drawCircle", VALUEFUNC(_wrap_AGPainter_drawCircle), -1);
    rb_define_method(cAGPainter.klass, "blitTri", VALUEFUNC(_wrap_AGPainter_blitTri), -1);
    rb_define_method(cAGPainter.klass, "blit", VALUEFUNC(_wrap_AGPainter_blit), -1);
    rb_define_method(cAGPainter.klass, "tile", VALUEFUNC(_wrap_AGPainter_tile), -1);
    rb_define_method(cAGPainter.klass, "renderText", VALUEFUNC(_wrap_AGPainter_renderText), -1);
    rb_define_method(cAGPainter.klass, "getRect", VALUEFUNC(_wrap_AGPainter_getRect), -1);
    rb_define_method(cAGPainter.klass, "drawGradient", VALUEFUNC(_wrap_AGPainter_drawGradient), -1);
    rb_define_method(cAGPainter.klass, "drawBorder", VALUEFUNC(_wrap_AGPainter_drawBorder), -1);
    rb_define_method(cAGPainter.klass, "fillRect", VALUEFUNC(_wrap_AGPainter_fillRect), -1);
    rb_define_method(cAGPainter.klass, "drawLine", VALUEFUNC(_wrap_AGPainter_drawLine), -1);
    rb_define_method(cAGPainter.klass, "pushMatrix", VALUEFUNC(_wrap_AGPainter_pushMatrix), -1);
    rb_define_method(cAGPainter.klass, "popMatrix", VALUEFUNC(_wrap_AGPainter_popMatrix), -1);
    rb_define_method(cAGPainter.klass, "translate", VALUEFUNC(_wrap_AGPainter_translate), -1);
    rb_define_method(cAGPainter.klass, "scale", VALUEFUNC(_wrap_AGPainter_scale), -1);
    rb_define_method(cAGPainter.klass, "clip", VALUEFUNC(_wrap_AGPainter_clip), -1);
    rb_define_method(cAGPainter.klass, "transform", VALUEFUNC(_wrap_AGPainter_transform), -1);
    rb_define_method(cAGPainter.klass, "project", VALUEFUNC(_wrap_AGPainter_project), -1);
    rb_define_method(cAGPainter.klass, "pointOk", VALUEFUNC(_wrap_AGPainter_pointOk), -1);
    cAGPainter.mark = 0;
    cAGPainter.destroy = (void (*)(void *)) free_AGPainter;
    rb_define_module_function(mLibantargisgui, "toPNG", VALUEFUNC(_wrap_toPNG), -1);
    rb_define_module_function(mLibantargisgui, "fromPNG", VALUEFUNC(_wrap_fromPNG), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGRadioGroup", VALUEFUNC(_wrap_disown_AGRadioGroup), -1);
    
    cAGRadioGroup.klass = rb_define_class_under(mLibantargisgui, "AGRadioGroup", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGRadioGroup, (void *) &cAGRadioGroup);
    rb_define_alloc_func(cAGRadioGroup.klass, _wrap_AGRadioGroup_allocate);
    rb_define_method(cAGRadioGroup.klass, "initialize", VALUEFUNC(_wrap_new_AGRadioGroup), -1);
    rb_define_method(cAGRadioGroup.klass, "eventChange", VALUEFUNC(_wrap_AGRadioGroup_eventChange), -1);
    rb_define_method(cAGRadioGroup.klass, "add", VALUEFUNC(_wrap_AGRadioGroup_add), -1);
    rb_define_method(cAGRadioGroup.klass, "erase", VALUEFUNC(_wrap_AGRadioGroup_erase), -1);
    rb_define_method(cAGRadioGroup.klass, "sigChanged=", VALUEFUNC(_wrap_AGRadioGroup_sigChanged_set), -1);
    rb_define_method(cAGRadioGroup.klass, "sigChanged", VALUEFUNC(_wrap_AGRadioGroup_sigChanged_get), -1);
    cAGRadioGroup.mark = (void (*)(void *)) general_markfunc;
    cAGRadioGroup.destroy = (void (*)(void *)) free_AGRadioGroup;
    rb_define_module_function(mLibantargisgui, "disown_AGRadio", VALUEFUNC(_wrap_disown_AGRadio), -1);
    
    cAGRadio.klass = rb_define_class_under(mLibantargisgui, "AGRadio", ((swig_class *) SWIGTYPE_p_AGCheckBox->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGRadio, (void *) &cAGRadio);
    rb_define_alloc_func(cAGRadio.klass, _wrap_AGRadio_allocate);
    rb_define_method(cAGRadio.klass, "initialize", VALUEFUNC(_wrap_new_AGRadio), -1);
    rb_define_method(cAGRadio.klass, "setGroup", VALUEFUNC(_wrap_AGRadio_setGroup), -1);
    rb_define_method(cAGRadio.klass, "eventMouseClick", VALUEFUNC(_wrap_AGRadio_eventMouseClick), -1);
    rb_define_method(cAGRadio.klass, "deselect", VALUEFUNC(_wrap_AGRadio_deselect), -1);
    rb_define_method(cAGRadio.klass, "setChecked", VALUEFUNC(_wrap_AGRadio_setChecked), -1);
    cAGRadio.mark = (void (*)(void *)) general_markfunc;
    cAGRadio.destroy = (void (*)(void *)) free_AGRadio;
    rb_define_module_function(mLibantargisgui, "disown_AGScreen", VALUEFUNC(_wrap_disown_AGScreen), -1);
    
    cAGScreen.klass = rb_define_class_under(mLibantargisgui, "AGScreen", ((swig_class *) SWIGTYPE_p_AGPaintTarget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGScreen, (void *) &cAGScreen);
    rb_define_alloc_func(cAGScreen.klass, _wrap_AGScreen_allocate);
    rb_define_method(cAGScreen.klass, "initialize", VALUEFUNC(_wrap_new_AGScreen), -1);
    rb_define_method(cAGScreen.klass, "begin", VALUEFUNC(_wrap_AGScreen_begin), -1);
    rb_define_method(cAGScreen.klass, "flip", VALUEFUNC(_wrap_AGScreen_flip), -1);
    rb_define_method(cAGScreen.klass, "getWidth", VALUEFUNC(_wrap_AGScreen_getWidth), -1);
    rb_define_method(cAGScreen.klass, "getHeight", VALUEFUNC(_wrap_AGScreen_getHeight), -1);
    cAGScreen.mark = 0;
    cAGScreen.destroy = (void (*)(void *)) free_AGScreen;
    rb_define_module_function(mLibantargisgui, "getScreen", VALUEFUNC(_wrap_getScreen), -1);
    rb_define_module_function(mLibantargisgui, "setScreen", VALUEFUNC(_wrap_setScreen), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGTable", VALUEFUNC(_wrap_disown_AGTable), -1);
    
    cAGTable.klass = rb_define_class_under(mLibantargisgui, "AGTable", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGTable, (void *) &cAGTable);
    rb_define_alloc_func(cAGTable.klass, _wrap_AGTable_allocate);
    rb_define_method(cAGTable.klass, "initialize", VALUEFUNC(_wrap_new_AGTable), -1);
    rb_define_method(cAGTable.klass, "addFixedColumn", VALUEFUNC(_wrap_AGTable_addFixedColumn), -1);
    rb_define_method(cAGTable.klass, "addFixedRow", VALUEFUNC(_wrap_AGTable_addFixedRow), -1);
    rb_define_method(cAGTable.klass, "addColumn", VALUEFUNC(_wrap_AGTable_addColumn), -1);
    rb_define_method(cAGTable.klass, "addRow", VALUEFUNC(_wrap_AGTable_addRow), -1);
    rb_define_method(cAGTable.klass, "addChild", VALUEFUNC(_wrap_AGTable_addChild), -1);
    rb_define_method(cAGTable.klass, "getClientRect", VALUEFUNC(_wrap_AGTable_getClientRect), -1);
    rb_define_method(cAGTable.klass, "arrange", VALUEFUNC(_wrap_AGTable_arrange), -1);
    rb_define_method(cAGTable.klass, "setWidth", VALUEFUNC(_wrap_AGTable_setWidth), -1);
    rb_define_method(cAGTable.klass, "setHeight", VALUEFUNC(_wrap_AGTable_setHeight), -1);
    cAGTable.mark = (void (*)(void *)) general_markfunc;
    cAGTable.destroy = (void (*)(void *)) free_AGTable;
    rb_define_module_function(mLibantargisgui, "getTextureCache", VALUEFUNC(_wrap_getTextureCache), -1);
    
    cAGTextureCache.klass = rb_define_class_under(mLibantargisgui, "AGTextureCache", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTextureCache, (void *) &cAGTextureCache);
    rb_undef_alloc_func(cAGTextureCache.klass);
    rb_define_method(cAGTextureCache.klass, "get", VALUEFUNC(_wrap_AGTextureCache_get), -1);
    rb_define_method(cAGTextureCache.klass, "get3D", VALUEFUNC(_wrap_AGTextureCache_get3D), -1);
    cAGTextureCache.mark = 0;
    cAGTextureCache.destroy = (void (*)(void *)) free_AGTextureCache;
    rb_define_module_function(mLibantargisgui, "disown_AGTheme", VALUEFUNC(_wrap_disown_AGTheme), -1);
    
    cAGTheme.klass = rb_define_class_under(mLibantargisgui, "AGTheme", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTheme, (void *) &cAGTheme);
    rb_define_alloc_func(cAGTheme.klass, _wrap_AGTheme_allocate);
    rb_define_method(cAGTheme.klass, "initialize", VALUEFUNC(_wrap_new_AGTheme), -1);
    rb_define_method(cAGTheme.klass, "getFont", VALUEFUNC(_wrap_AGTheme_getFont), -1);
    rb_define_method(cAGTheme.klass, "getColor", VALUEFUNC(_wrap_AGTheme_getColor), -1);
    rb_define_method(cAGTheme.klass, "setFont", VALUEFUNC(_wrap_AGTheme_setFont), -1);
    rb_define_method(cAGTheme.klass, "setColor", VALUEFUNC(_wrap_AGTheme_setColor), -1);
    rb_define_method(cAGTheme.klass, "getInt", VALUEFUNC(_wrap_AGTheme_getInt), -1);
    rb_define_method(cAGTheme.klass, "setInt", VALUEFUNC(_wrap_AGTheme_setInt), -1);
    rb_define_method(cAGTheme.klass, "getSurface", VALUEFUNC(_wrap_AGTheme_getSurface), -1);
    rb_define_method(cAGTheme.klass, "setSurface", VALUEFUNC(_wrap_AGTheme_setSurface), -1);
    rb_define_method(cAGTheme.klass, "getSurfaceName", VALUEFUNC(_wrap_AGTheme_getSurfaceName), -1);
    rb_define_method(cAGTheme.klass, "setSurfaceName", VALUEFUNC(_wrap_AGTheme_setSurfaceName), -1);
    rb_define_method(cAGTheme.klass, "hasSurface", VALUEFUNC(_wrap_AGTheme_hasSurface), -1);
    rb_define_method(cAGTheme.klass, "hasColor", VALUEFUNC(_wrap_AGTheme_hasColor), -1);
    cAGTheme.mark = 0;
    cAGTheme.destroy = (void (*)(void *)) free_AGTheme;
    rb_define_module_function(mLibantargisgui, "getTheme", VALUEFUNC(_wrap_getTheme), -1);
    rb_define_module_function(mLibantargisgui, "setTheme", VALUEFUNC(_wrap_setTheme), -1);
    rb_define_module_function(mLibantargisgui, "loadTheme", VALUEFUNC(_wrap_loadTheme), -1);
    rb_define_module_function(mLibantargisgui, "loadThemeFile", VALUEFUNC(_wrap_loadThemeFile), -1);
    rb_define_module_function(mLibantargisgui, "addPoint", VALUEFUNC(_wrap_addPoint), -1);
    rb_define_module_function(mLibantargisgui, "toInt", VALUEFUNC(_wrap_toInt), -1);
    rb_define_module_function(mLibantargisgui, "toFloat", VALUEFUNC(_wrap_toFloat), -1);
    rb_define_module_function(mLibantargisgui, "fromHex", VALUEFUNC(_wrap_fromHex), -1);
    rb_define_module_function(mLibantargisgui, "toHex", VALUEFUNC(_wrap_toHex), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGWindow", VALUEFUNC(_wrap_disown_AGWindow), -1);
    
    cAGWindow.klass = rb_define_class_under(mLibantargisgui, "AGWindow", ((swig_class *) SWIGTYPE_p_AGTable->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGWindow, (void *) &cAGWindow);
    rb_define_alloc_func(cAGWindow.klass, _wrap_AGWindow_allocate);
    rb_define_method(cAGWindow.klass, "initialize", VALUEFUNC(_wrap_new_AGWindow), -1);
    rb_define_method(cAGWindow.klass, "addChild", VALUEFUNC(_wrap_AGWindow_addChild), -1);
    rb_define_method(cAGWindow.klass, "getClient", VALUEFUNC(_wrap_AGWindow_getClient), -1);
    rb_define_method(cAGWindow.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGWindow_eventMouseButtonDown), -1);
    rb_define_method(cAGWindow.klass, "eventDragBy", VALUEFUNC(_wrap_AGWindow_eventDragBy), -1);
    rb_define_method(cAGWindow.klass, "close", VALUEFUNC(_wrap_AGWindow_close), -1);
    rb_define_method(cAGWindow.klass, "tryClose", VALUEFUNC(_wrap_AGWindow_tryClose), -1);
    rb_define_method(cAGWindow.klass, "getClientRect", VALUEFUNC(_wrap_AGWindow_getClientRect), -1);
    rb_define_method(cAGWindow.klass, "sigClose=", VALUEFUNC(_wrap_AGWindow_sigClose_set), -1);
    rb_define_method(cAGWindow.klass, "sigClose", VALUEFUNC(_wrap_AGWindow_sigClose_get), -1);
    cAGWindow.mark = (void (*)(void *)) general_markfunc;
    cAGWindow.destroy = (void (*)(void *)) free_AGWindow;
    rb_define_module_function(mLibantargisgui, "toAGWindow", VALUEFUNC(_wrap_toAGWindow), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGFrame", VALUEFUNC(_wrap_disown_AGFrame), -1);
    
    cAGFrame.klass = rb_define_class_under(mLibantargisgui, "AGFrame", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGFrame, (void *) &cAGFrame);
    rb_define_alloc_func(cAGFrame.klass, _wrap_AGFrame_allocate);
    rb_define_method(cAGFrame.klass, "initialize", VALUEFUNC(_wrap_new_AGFrame), -1);
    rb_define_method(cAGFrame.klass, "getClientRect", VALUEFUNC(_wrap_AGFrame_getClientRect), -1);
    rb_define_method(cAGFrame.klass, "draw", VALUEFUNC(_wrap_AGFrame_draw), -1);
    cAGFrame.mark = (void (*)(void *)) general_markfunc;
    cAGFrame.destroy = (void (*)(void *)) free_AGFrame;
    rb_define_module_function(mLibantargisgui, "disown_AGScreenWidget", VALUEFUNC(_wrap_disown_AGScreenWidget), -1);
    
    cAGScreenWidget.klass = rb_define_class_under(mLibantargisgui, "AGScreenWidget", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGScreenWidget, (void *) &cAGScreenWidget);
    rb_define_alloc_func(cAGScreenWidget.klass, _wrap_AGScreenWidget_allocate);
    rb_define_method(cAGScreenWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGScreenWidget), -1);
    rb_define_method(cAGScreenWidget.klass, "draw", VALUEFUNC(_wrap_AGScreenWidget_draw), -1);
    cAGScreenWidget.mark = (void (*)(void *)) general_markfunc;
    cAGScreenWidget.destroy = (void (*)(void *)) free_AGScreenWidget;
    
    cAGVertexProgram.klass = rb_define_class_under(mLibantargisgui, "AGVertexProgram", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVertexProgram, (void *) &cAGVertexProgram);
    rb_define_alloc_func(cAGVertexProgram.klass, _wrap_AGVertexProgram_allocate);
    rb_define_method(cAGVertexProgram.klass, "initialize", VALUEFUNC(_wrap_new_AGVertexProgram), -1);
    cAGVertexProgram.mark = 0;
    cAGVertexProgram.destroy = (void (*)(void *)) free_AGVertexProgram;
    
    cAGFragProgram.klass = rb_define_class_under(mLibantargisgui, "AGFragProgram", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGFragProgram, (void *) &cAGFragProgram);
    rb_define_alloc_func(cAGFragProgram.klass, _wrap_AGFragProgram_allocate);
    rb_define_method(cAGFragProgram.klass, "initialize", VALUEFUNC(_wrap_new_AGFragProgram), -1);
    rb_define_method(cAGFragProgram.klass, "valid", VALUEFUNC(_wrap_AGFragProgram_valid), -1);
    cAGFragProgram.mark = 0;
    cAGFragProgram.destroy = (void (*)(void *)) free_AGFragProgram;
    
    cAGShaderParameter.klass = rb_define_class_under(mLibantargisgui, "AGShaderParameter", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGShaderParameter, (void *) &cAGShaderParameter);
    rb_define_alloc_func(cAGShaderParameter.klass, _wrap_AGShaderParameter_allocate);
    rb_define_method(cAGShaderParameter.klass, "initialize", VALUEFUNC(_wrap_new_AGShaderParameter), -1);
    cAGShaderParameter.mark = 0;
    cAGShaderParameter.destroy = (void (*)(void *)) free_AGShaderParameter;
    rb_define_module_function(mLibantargisgui, "disown_AGShaderProgram", VALUEFUNC(_wrap_disown_AGShaderProgram), -1);
    
    cAGShaderProgram.klass = rb_define_class_under(mLibantargisgui, "AGShaderProgram", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGShaderProgram, (void *) &cAGShaderProgram);
    rb_define_alloc_func(cAGShaderProgram.klass, _wrap_AGShaderProgram_allocate);
    rb_define_method(cAGShaderProgram.klass, "initialize", VALUEFUNC(_wrap_new_AGShaderProgram), -1);
    rb_define_method(cAGShaderProgram.klass, "enable", VALUEFUNC(_wrap_AGShaderProgram_enable), -1);
    rb_define_method(cAGShaderProgram.klass, "disable", VALUEFUNC(_wrap_AGShaderProgram_disable), -1);
    rb_define_method(cAGShaderProgram.klass, "update", VALUEFUNC(_wrap_AGShaderProgram_update), -1);
    rb_define_method(cAGShaderProgram.klass, "doUpdate", VALUEFUNC(_wrap_AGShaderProgram_doUpdate), -1);
    rb_define_method(cAGShaderProgram.klass, "getLoc", VALUEFUNC(_wrap_AGShaderProgram_getLoc), -1);
    rb_define_method(cAGShaderProgram.klass, "getAttr", VALUEFUNC(_wrap_AGShaderProgram_getAttr), -1);
    rb_define_method(cAGShaderProgram.klass, "sendUniform", VALUEFUNC(_wrap_AGShaderProgram_sendUniform), -1);
    rb_define_method(cAGShaderProgram.klass, "sendAttribute", VALUEFUNC(_wrap_AGShaderProgram_sendAttribute), -1);
    cAGShaderProgram.mark = 0;
    cAGShaderProgram.destroy = (void (*)(void *)) free_AGShaderProgram;
    rb_define_module_function(mLibantargisgui, "glslOk", VALUEFUNC(_wrap_glslOk), -1);
    rb_define_const(mLibantargisgui,"SDLK_UNKNOWN", INT2NUM(SDLK_UNKNOWN));
    rb_define_const(mLibantargisgui,"SDLK_FIRST", INT2NUM(SDLK_FIRST));
    rb_define_const(mLibantargisgui,"SDLK_BACKSPACE", INT2NUM(SDLK_BACKSPACE));
    rb_define_const(mLibantargisgui,"SDLK_TAB", INT2NUM(SDLK_TAB));
    rb_define_const(mLibantargisgui,"SDLK_CLEAR", INT2NUM(SDLK_CLEAR));
    rb_define_const(mLibantargisgui,"SDLK_RETURN", INT2NUM(SDLK_RETURN));
    rb_define_const(mLibantargisgui,"SDLK_PAUSE", INT2NUM(SDLK_PAUSE));
    rb_define_const(mLibantargisgui,"SDLK_ESCAPE", INT2NUM(SDLK_ESCAPE));
    rb_define_const(mLibantargisgui,"SDLK_SPACE", INT2NUM(SDLK_SPACE));
    rb_define_const(mLibantargisgui,"SDLK_EXCLAIM", INT2NUM(SDLK_EXCLAIM));
    rb_define_const(mLibantargisgui,"SDLK_QUOTEDBL", INT2NUM(SDLK_QUOTEDBL));
    rb_define_const(mLibantargisgui,"SDLK_HASH", INT2NUM(SDLK_HASH));
    rb_define_const(mLibantargisgui,"SDLK_DOLLAR", INT2NUM(SDLK_DOLLAR));
    rb_define_const(mLibantargisgui,"SDLK_AMPERSAND", INT2NUM(SDLK_AMPERSAND));
    rb_define_const(mLibantargisgui,"SDLK_QUOTE", INT2NUM(SDLK_QUOTE));
    rb_define_const(mLibantargisgui,"SDLK_LEFTPAREN", INT2NUM(SDLK_LEFTPAREN));
    rb_define_const(mLibantargisgui,"SDLK_RIGHTPAREN", INT2NUM(SDLK_RIGHTPAREN));
    rb_define_const(mLibantargisgui,"SDLK_ASTERISK", INT2NUM(SDLK_ASTERISK));
    rb_define_const(mLibantargisgui,"SDLK_PLUS", INT2NUM(SDLK_PLUS));
    rb_define_const(mLibantargisgui,"SDLK_COMMA", INT2NUM(SDLK_COMMA));
    rb_define_const(mLibantargisgui,"SDLK_MINUS", INT2NUM(SDLK_MINUS));
    rb_define_const(mLibantargisgui,"SDLK_PERIOD", INT2NUM(SDLK_PERIOD));
    rb_define_const(mLibantargisgui,"SDLK_SLASH", INT2NUM(SDLK_SLASH));
    rb_define_const(mLibantargisgui,"SDLK_0", INT2NUM(SDLK_0));
    rb_define_const(mLibantargisgui,"SDLK_1", INT2NUM(SDLK_1));
    rb_define_const(mLibantargisgui,"SDLK_2", INT2NUM(SDLK_2));
    rb_define_const(mLibantargisgui,"SDLK_3", INT2NUM(SDLK_3));
    rb_define_const(mLibantargisgui,"SDLK_4", INT2NUM(SDLK_4));
    rb_define_const(mLibantargisgui,"SDLK_5", INT2NUM(SDLK_5));
    rb_define_const(mLibantargisgui,"SDLK_6", INT2NUM(SDLK_6));
    rb_define_const(mLibantargisgui,"SDLK_7", INT2NUM(SDLK_7));
    rb_define_const(mLibantargisgui,"SDLK_8", INT2NUM(SDLK_8));
    rb_define_const(mLibantargisgui,"SDLK_9", INT2NUM(SDLK_9));
    rb_define_const(mLibantargisgui,"SDLK_COLON", INT2NUM(SDLK_COLON));
    rb_define_const(mLibantargisgui,"SDLK_SEMICOLON", INT2NUM(SDLK_SEMICOLON));
    rb_define_const(mLibantargisgui,"SDLK_LESS", INT2NUM(SDLK_LESS));
    rb_define_const(mLibantargisgui,"SDLK_EQUALS", INT2NUM(SDLK_EQUALS));
    rb_define_const(mLibantargisgui,"SDLK_GREATER", INT2NUM(SDLK_GREATER));
    rb_define_const(mLibantargisgui,"SDLK_QUESTION", INT2NUM(SDLK_QUESTION));
    rb_define_const(mLibantargisgui,"SDLK_AT", INT2NUM(SDLK_AT));
    rb_define_const(mLibantargisgui,"SDLK_LEFTBRACKET", INT2NUM(SDLK_LEFTBRACKET));
    rb_define_const(mLibantargisgui,"SDLK_BACKSLASH", INT2NUM(SDLK_BACKSLASH));
    rb_define_const(mLibantargisgui,"SDLK_RIGHTBRACKET", INT2NUM(SDLK_RIGHTBRACKET));
    rb_define_const(mLibantargisgui,"SDLK_CARET", INT2NUM(SDLK_CARET));
    rb_define_const(mLibantargisgui,"SDLK_UNDERSCORE", INT2NUM(SDLK_UNDERSCORE));
    rb_define_const(mLibantargisgui,"SDLK_BACKQUOTE", INT2NUM(SDLK_BACKQUOTE));
    rb_define_const(mLibantargisgui,"SDLK_a", INT2NUM(SDLK_a));
    rb_define_const(mLibantargisgui,"SDLK_b", INT2NUM(SDLK_b));
    rb_define_const(mLibantargisgui,"SDLK_c", INT2NUM(SDLK_c));
    rb_define_const(mLibantargisgui,"SDLK_d", INT2NUM(SDLK_d));
    rb_define_const(mLibantargisgui,"SDLK_e", INT2NUM(SDLK_e));
    rb_define_const(mLibantargisgui,"SDLK_f", INT2NUM(SDLK_f));
    rb_define_const(mLibantargisgui,"SDLK_g", INT2NUM(SDLK_g));
    rb_define_const(mLibantargisgui,"SDLK_h", INT2NUM(SDLK_h));
    rb_define_const(mLibantargisgui,"SDLK_i", INT2NUM(SDLK_i));
    rb_define_const(mLibantargisgui,"SDLK_j", INT2NUM(SDLK_j));
    rb_define_const(mLibantargisgui,"SDLK_k", INT2NUM(SDLK_k));
    rb_define_const(mLibantargisgui,"SDLK_l", INT2NUM(SDLK_l));
    rb_define_const(mLibantargisgui,"SDLK_m", INT2NUM(SDLK_m));
    rb_define_const(mLibantargisgui,"SDLK_n", INT2NUM(SDLK_n));
    rb_define_const(mLibantargisgui,"SDLK_o", INT2NUM(SDLK_o));
    rb_define_const(mLibantargisgui,"SDLK_p", INT2NUM(SDLK_p));
    rb_define_const(mLibantargisgui,"SDLK_q", INT2NUM(SDLK_q));
    rb_define_const(mLibantargisgui,"SDLK_r", INT2NUM(SDLK_r));
    rb_define_const(mLibantargisgui,"SDLK_s", INT2NUM(SDLK_s));
    rb_define_const(mLibantargisgui,"SDLK_t", INT2NUM(SDLK_t));
    rb_define_const(mLibantargisgui,"SDLK_u", INT2NUM(SDLK_u));
    rb_define_const(mLibantargisgui,"SDLK_v", INT2NUM(SDLK_v));
    rb_define_const(mLibantargisgui,"SDLK_w", INT2NUM(SDLK_w));
    rb_define_const(mLibantargisgui,"SDLK_x", INT2NUM(SDLK_x));
    rb_define_const(mLibantargisgui,"SDLK_y", INT2NUM(SDLK_y));
    rb_define_const(mLibantargisgui,"SDLK_z", INT2NUM(SDLK_z));
    rb_define_const(mLibantargisgui,"SDLK_DELETE", INT2NUM(SDLK_DELETE));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_0", INT2NUM(SDLK_WORLD_0));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_1", INT2NUM(SDLK_WORLD_1));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_2", INT2NUM(SDLK_WORLD_2));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_3", INT2NUM(SDLK_WORLD_3));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_4", INT2NUM(SDLK_WORLD_4));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_5", INT2NUM(SDLK_WORLD_5));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_6", INT2NUM(SDLK_WORLD_6));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_7", INT2NUM(SDLK_WORLD_7));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_8", INT2NUM(SDLK_WORLD_8));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_9", INT2NUM(SDLK_WORLD_9));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_10", INT2NUM(SDLK_WORLD_10));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_11", INT2NUM(SDLK_WORLD_11));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_12", INT2NUM(SDLK_WORLD_12));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_13", INT2NUM(SDLK_WORLD_13));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_14", INT2NUM(SDLK_WORLD_14));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_15", INT2NUM(SDLK_WORLD_15));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_16", INT2NUM(SDLK_WORLD_16));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_17", INT2NUM(SDLK_WORLD_17));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_18", INT2NUM(SDLK_WORLD_18));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_19", INT2NUM(SDLK_WORLD_19));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_20", INT2NUM(SDLK_WORLD_20));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_21", INT2NUM(SDLK_WORLD_21));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_22", INT2NUM(SDLK_WORLD_22));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_23", INT2NUM(SDLK_WORLD_23));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_24", INT2NUM(SDLK_WORLD_24));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_25", INT2NUM(SDLK_WORLD_25));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_26", INT2NUM(SDLK_WORLD_26));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_27", INT2NUM(SDLK_WORLD_27));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_28", INT2NUM(SDLK_WORLD_28));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_29", INT2NUM(SDLK_WORLD_29));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_30", INT2NUM(SDLK_WORLD_30));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_31", INT2NUM(SDLK_WORLD_31));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_32", INT2NUM(SDLK_WORLD_32));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_33", INT2NUM(SDLK_WORLD_33));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_34", INT2NUM(SDLK_WORLD_34));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_35", INT2NUM(SDLK_WORLD_35));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_36", INT2NUM(SDLK_WORLD_36));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_37", INT2NUM(SDLK_WORLD_37));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_38", INT2NUM(SDLK_WORLD_38));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_39", INT2NUM(SDLK_WORLD_39));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_40", INT2NUM(SDLK_WORLD_40));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_41", INT2NUM(SDLK_WORLD_41));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_42", INT2NUM(SDLK_WORLD_42));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_43", INT2NUM(SDLK_WORLD_43));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_44", INT2NUM(SDLK_WORLD_44));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_45", INT2NUM(SDLK_WORLD_45));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_46", INT2NUM(SDLK_WORLD_46));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_47", INT2NUM(SDLK_WORLD_47));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_48", INT2NUM(SDLK_WORLD_48));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_49", INT2NUM(SDLK_WORLD_49));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_50", INT2NUM(SDLK_WORLD_50));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_51", INT2NUM(SDLK_WORLD_51));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_52", INT2NUM(SDLK_WORLD_52));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_53", INT2NUM(SDLK_WORLD_53));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_54", INT2NUM(SDLK_WORLD_54));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_55", INT2NUM(SDLK_WORLD_55));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_56", INT2NUM(SDLK_WORLD_56));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_57", INT2NUM(SDLK_WORLD_57));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_58", INT2NUM(SDLK_WORLD_58));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_59", INT2NUM(SDLK_WORLD_59));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_60", INT2NUM(SDLK_WORLD_60));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_61", INT2NUM(SDLK_WORLD_61));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_62", INT2NUM(SDLK_WORLD_62));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_63", INT2NUM(SDLK_WORLD_63));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_64", INT2NUM(SDLK_WORLD_64));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_65", INT2NUM(SDLK_WORLD_65));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_66", INT2NUM(SDLK_WORLD_66));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_67", INT2NUM(SDLK_WORLD_67));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_68", INT2NUM(SDLK_WORLD_68));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_69", INT2NUM(SDLK_WORLD_69));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_70", INT2NUM(SDLK_WORLD_70));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_71", INT2NUM(SDLK_WORLD_71));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_72", INT2NUM(SDLK_WORLD_72));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_73", INT2NUM(SDLK_WORLD_73));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_74", INT2NUM(SDLK_WORLD_74));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_75", INT2NUM(SDLK_WORLD_75));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_76", INT2NUM(SDLK_WORLD_76));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_77", INT2NUM(SDLK_WORLD_77));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_78", INT2NUM(SDLK_WORLD_78));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_79", INT2NUM(SDLK_WORLD_79));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_80", INT2NUM(SDLK_WORLD_80));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_81", INT2NUM(SDLK_WORLD_81));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_82", INT2NUM(SDLK_WORLD_82));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_83", INT2NUM(SDLK_WORLD_83));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_84", INT2NUM(SDLK_WORLD_84));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_85", INT2NUM(SDLK_WORLD_85));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_86", INT2NUM(SDLK_WORLD_86));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_87", INT2NUM(SDLK_WORLD_87));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_88", INT2NUM(SDLK_WORLD_88));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_89", INT2NUM(SDLK_WORLD_89));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_90", INT2NUM(SDLK_WORLD_90));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_91", INT2NUM(SDLK_WORLD_91));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_92", INT2NUM(SDLK_WORLD_92));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_93", INT2NUM(SDLK_WORLD_93));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_94", INT2NUM(SDLK_WORLD_94));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_95", INT2NUM(SDLK_WORLD_95));
    rb_define_const(mLibantargisgui,"SDLK_KP0", INT2NUM(SDLK_KP0));
    rb_define_const(mLibantargisgui,"SDLK_KP1", INT2NUM(SDLK_KP1));
    rb_define_const(mLibantargisgui,"SDLK_KP2", INT2NUM(SDLK_KP2));
    rb_define_const(mLibantargisgui,"SDLK_KP3", INT2NUM(SDLK_KP3));
    rb_define_const(mLibantargisgui,"SDLK_KP4", INT2NUM(SDLK_KP4));
    rb_define_const(mLibantargisgui,"SDLK_KP5", INT2NUM(SDLK_KP5));
    rb_define_const(mLibantargisgui,"SDLK_KP6", INT2NUM(SDLK_KP6));
    rb_define_const(mLibantargisgui,"SDLK_KP7", INT2NUM(SDLK_KP7));
    rb_define_const(mLibantargisgui,"SDLK_KP8", INT2NUM(SDLK_KP8));
    rb_define_const(mLibantargisgui,"SDLK_KP9", INT2NUM(SDLK_KP9));
    rb_define_const(mLibantargisgui,"SDLK_KP_PERIOD", INT2NUM(SDLK_KP_PERIOD));
    rb_define_const(mLibantargisgui,"SDLK_KP_DIVIDE", INT2NUM(SDLK_KP_DIVIDE));
    rb_define_const(mLibantargisgui,"SDLK_KP_MULTIPLY", INT2NUM(SDLK_KP_MULTIPLY));
    rb_define_const(mLibantargisgui,"SDLK_KP_MINUS", INT2NUM(SDLK_KP_MINUS));
    rb_define_const(mLibantargisgui,"SDLK_KP_PLUS", INT2NUM(SDLK_KP_PLUS));
    rb_define_const(mLibantargisgui,"SDLK_KP_ENTER", INT2NUM(SDLK_KP_ENTER));
    rb_define_const(mLibantargisgui,"SDLK_KP_EQUALS", INT2NUM(SDLK_KP_EQUALS));
    rb_define_const(mLibantargisgui,"SDLK_UP", INT2NUM(SDLK_UP));
    rb_define_const(mLibantargisgui,"SDLK_DOWN", INT2NUM(SDLK_DOWN));
    rb_define_const(mLibantargisgui,"SDLK_RIGHT", INT2NUM(SDLK_RIGHT));
    rb_define_const(mLibantargisgui,"SDLK_LEFT", INT2NUM(SDLK_LEFT));
    rb_define_const(mLibantargisgui,"SDLK_INSERT", INT2NUM(SDLK_INSERT));
    rb_define_const(mLibantargisgui,"SDLK_HOME", INT2NUM(SDLK_HOME));
    rb_define_const(mLibantargisgui,"SDLK_END", INT2NUM(SDLK_END));
    rb_define_const(mLibantargisgui,"SDLK_PAGEUP", INT2NUM(SDLK_PAGEUP));
    rb_define_const(mLibantargisgui,"SDLK_PAGEDOWN", INT2NUM(SDLK_PAGEDOWN));
    rb_define_const(mLibantargisgui,"SDLK_F1", INT2NUM(SDLK_F1));
    rb_define_const(mLibantargisgui,"SDLK_F2", INT2NUM(SDLK_F2));
    rb_define_const(mLibantargisgui,"SDLK_F3", INT2NUM(SDLK_F3));
    rb_define_const(mLibantargisgui,"SDLK_F4", INT2NUM(SDLK_F4));
    rb_define_const(mLibantargisgui,"SDLK_F5", INT2NUM(SDLK_F5));
    rb_define_const(mLibantargisgui,"SDLK_F6", INT2NUM(SDLK_F6));
    rb_define_const(mLibantargisgui,"SDLK_F7", INT2NUM(SDLK_F7));
    rb_define_const(mLibantargisgui,"SDLK_F8", INT2NUM(SDLK_F8));
    rb_define_const(mLibantargisgui,"SDLK_F9", INT2NUM(SDLK_F9));
    rb_define_const(mLibantargisgui,"SDLK_F10", INT2NUM(SDLK_F10));
    rb_define_const(mLibantargisgui,"SDLK_F11", INT2NUM(SDLK_F11));
    rb_define_const(mLibantargisgui,"SDLK_F12", INT2NUM(SDLK_F12));
    rb_define_const(mLibantargisgui,"SDLK_F13", INT2NUM(SDLK_F13));
    rb_define_const(mLibantargisgui,"SDLK_F14", INT2NUM(SDLK_F14));
    rb_define_const(mLibantargisgui,"SDLK_F15", INT2NUM(SDLK_F15));
    rb_define_const(mLibantargisgui,"SDLK_NUMLOCK", INT2NUM(SDLK_NUMLOCK));
    rb_define_const(mLibantargisgui,"SDLK_CAPSLOCK", INT2NUM(SDLK_CAPSLOCK));
    rb_define_const(mLibantargisgui,"SDLK_SCROLLOCK", INT2NUM(SDLK_SCROLLOCK));
    rb_define_const(mLibantargisgui,"SDLK_RSHIFT", INT2NUM(SDLK_RSHIFT));
    rb_define_const(mLibantargisgui,"SDLK_LSHIFT", INT2NUM(SDLK_LSHIFT));
    rb_define_const(mLibantargisgui,"SDLK_RCTRL", INT2NUM(SDLK_RCTRL));
    rb_define_const(mLibantargisgui,"SDLK_LCTRL", INT2NUM(SDLK_LCTRL));
    rb_define_const(mLibantargisgui,"SDLK_RALT", INT2NUM(SDLK_RALT));
    rb_define_const(mLibantargisgui,"SDLK_LALT", INT2NUM(SDLK_LALT));
    rb_define_const(mLibantargisgui,"SDLK_RMETA", INT2NUM(SDLK_RMETA));
    rb_define_const(mLibantargisgui,"SDLK_LMETA", INT2NUM(SDLK_LMETA));
    rb_define_const(mLibantargisgui,"SDLK_LSUPER", INT2NUM(SDLK_LSUPER));
    rb_define_const(mLibantargisgui,"SDLK_RSUPER", INT2NUM(SDLK_RSUPER));
    rb_define_const(mLibantargisgui,"SDLK_MODE", INT2NUM(SDLK_MODE));
    rb_define_const(mLibantargisgui,"SDLK_COMPOSE", INT2NUM(SDLK_COMPOSE));
    rb_define_const(mLibantargisgui,"SDLK_HELP", INT2NUM(SDLK_HELP));
    rb_define_const(mLibantargisgui,"SDLK_PRINT", INT2NUM(SDLK_PRINT));
    rb_define_const(mLibantargisgui,"SDLK_SYSREQ", INT2NUM(SDLK_SYSREQ));
    rb_define_const(mLibantargisgui,"SDLK_BREAK", INT2NUM(SDLK_BREAK));
    rb_define_const(mLibantargisgui,"SDLK_MENU", INT2NUM(SDLK_MENU));
    rb_define_const(mLibantargisgui,"SDLK_POWER", INT2NUM(SDLK_POWER));
    rb_define_const(mLibantargisgui,"SDLK_EURO", INT2NUM(SDLK_EURO));
    rb_define_const(mLibantargisgui,"SDLK_UNDO", INT2NUM(SDLK_UNDO));
    rb_define_const(mLibantargisgui,"SDLK_LAST", INT2NUM(SDLK_LAST));
    rb_define_const(mLibantargisgui,"KMOD_NONE", INT2NUM(KMOD_NONE));
    rb_define_const(mLibantargisgui,"KMOD_LSHIFT", INT2NUM(KMOD_LSHIFT));
    rb_define_const(mLibantargisgui,"KMOD_RSHIFT", INT2NUM(KMOD_RSHIFT));
    rb_define_const(mLibantargisgui,"KMOD_LCTRL", INT2NUM(KMOD_LCTRL));
    rb_define_const(mLibantargisgui,"KMOD_RCTRL", INT2NUM(KMOD_RCTRL));
    rb_define_const(mLibantargisgui,"KMOD_LALT", INT2NUM(KMOD_LALT));
    rb_define_const(mLibantargisgui,"KMOD_RALT", INT2NUM(KMOD_RALT));
    rb_define_const(mLibantargisgui,"KMOD_LMETA", INT2NUM(KMOD_LMETA));
    rb_define_const(mLibantargisgui,"KMOD_RMETA", INT2NUM(KMOD_RMETA));
    rb_define_const(mLibantargisgui,"KMOD_NUM", INT2NUM(KMOD_NUM));
    rb_define_const(mLibantargisgui,"KMOD_CAPS", INT2NUM(KMOD_CAPS));
    rb_define_const(mLibantargisgui,"KMOD_MODE", INT2NUM(KMOD_MODE));
    rb_define_const(mLibantargisgui,"KMOD_RESERVED", INT2NUM(KMOD_RESERVED));
}


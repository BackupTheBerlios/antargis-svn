.TH "VertexArray" 3 "27 Oct 2006" "Version 0.1.9" "Antargis" \" -*- nroff -*-
.ad l
.nh
.SH NAME
VertexArray \- 
.SH SYNOPSIS
.br
.PP
\fC#include <vertex_array.h>\fP
.PP
Inherited by \fBVertexArrayShader\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVertexArray\fP (bool pDynamic=false)"
.br
.ti -1c
.RI "virtual \fB~VertexArray\fP ()"
.br
.ti -1c
.RI "void \fBaddVertex\fP (\fBAGVector4\fP pVertex, \fBAGVector4\fP pColor, \fBAGVector3\fP pNormal, \fBAGVector2\fP pTex)"
.br
.ti -1c
.RI "void \fBaddVertex\fP (\fBAGVector4\fP pVertex, \fBAGVector4\fP pColor, \fBAGVector3\fP pNormal, \fBAGVector3\fP pTex)"
.br
.ti -1c
.RI "void \fBaddTriangle\fP (size_t p0, size_t p1, size_t p2)"
.br
.ti -1c
.RI "void \fBsetColors\fP (bool color)"
.br
.ti -1c
.RI "void \fBsetBuffers\fP (bool pBuffers)"
.br
.ti -1c
.RI "virtual void \fBdraw\fP ()"
.br
.ti -1c
.RI "virtual void \fBdrawDepth\fP ()"
.br
.ti -1c
.RI "void \fBdrawPick\fP ()"
.br
.ti -1c
.RI "void \fBinit\fP ()"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBupdate\fP ()"
.br
.ti -1c
.RI "size_t \fBgetTriangles\fP () const "
.br
.ti -1c
.RI "size_t \fBgetIndex\fP (size_t i)"
.br
.ti -1c
.RI "\fBAGVector4\fP \fBgetVertex\fP (size_t i)"
.br
.ti -1c
.RI "\fBAGVector4\fP \fBgetColor\fP (size_t i)"
.br
.ti -1c
.RI "\fBAGVector3\fP \fBgetNormal\fP (size_t i)"
.br
.ti -1c
.RI "\fBAGVector2\fP \fBgetTexCoord\fP (size_t i)"
.br
.ti -1c
.RI "void \fBsetTexCoord\fP (size_t i, const \fBAGVector2\fP &t)"
.br
.ti -1c
.RI "\fBAGVector4\fP \fBlineHit\fP (const \fBAGLine3\fP &pLine) const "
.br
.ti -1c
.RI "bool \fBuseVertexArrays\fP () const "
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "\fBVertexArray\fP * \fBmakeInstances\fP (const \fBVertexArray\fP &va, const std::vector< \fBAGMatrix4\fP > &ts)"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBVertexArray\fP is for fast drawing meshes (3d-models). It supports indexed vertex-arrays. If you do not have them in this format look at \fBmesh_optimizer.h\fP. The possible drawing modes are detected automatically. The best one is always used. These include: vertex-arrays vertex-buffers direct drawing mode (glVertex4f...)
.PP
if you have to do special drawing like picking, use the corresp. functions (drawDepth,drawPick) 
.PP
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VertexArray::VertexArray (bool pDynamic = \fCfalse\fP)"
.PP
.SS "VertexArray::~VertexArray ()\fC [virtual]\fP"
.PP
.SH "Member Function Documentation"
.PP 
.SS "void VertexArray::addTriangle (size_t p0, size_t p1, size_t p2)"
.PP
.SS "void VertexArray::addVertex (\fBAGVector4\fP pVertex, \fBAGVector4\fP pColor, \fBAGVector3\fP pNormal, \fBAGVector3\fP pTex)"
.PP
.SS "void VertexArray::addVertex (\fBAGVector4\fP pVertex, \fBAGVector4\fP pColor, \fBAGVector3\fP pNormal, \fBAGVector2\fP pTex)"
.PP
.SS "void VertexArray::clear ()"
.PP
.SS "void VertexArray::draw ()\fC [virtual]\fP"
.PP
Reimplemented in \fBVertexArrayShader\fP.
.SS "void VertexArray::drawDepth ()\fC [virtual]\fP"
.PP
.SS "void VertexArray::drawPick ()"
.PP
.SS "\fBAGVector4\fP VertexArray::getColor (size_t i)"
.PP
.SS "size_t VertexArray::getIndex (size_t i)"
.PP
.SS "\fBAGVector3\fP VertexArray::getNormal (size_t i)"
.PP
.SS "\fBAGVector2\fP VertexArray::getTexCoord (size_t i)"
.PP
.SS "size_t VertexArray::getTriangles () const\fC [inline]\fP"
.PP
.SS "\fBAGVector4\fP VertexArray::getVertex (size_t i)"
.PP
.SS "void VertexArray::init ()"
.PP
.SS "\fBAGVector4\fP VertexArray::lineHit (const \fBAGLine3\fP & pLine) const"
.PP
.SS "void VertexArray::setBuffers (bool pBuffers)"
.PP
.SS "void VertexArray::setColors (bool color)"
.PP
.SS "void VertexArray::setTexCoord (size_t i, const \fBAGVector2\fP & t)"
.PP
.SS "void VertexArray::update ()"
.PP
.SS "bool VertexArray::useVertexArrays () const"
.PP
.SH "Friends And Related Function Documentation"
.PP 
.SS "\fBVertexArray\fP* makeInstances (const \fBVertexArray\fP & va, const std::vector< \fBAGMatrix4\fP > & ts)\fC [friend]\fP"
.PP
makeInstances can be used for some kind of 'batching'. It creates several instances of a mesh stored in va. The positions of the instances are given through transformation matrices in ts 

.SH "Author"
.PP 
Generated automatically by Doxygen for Antargis from the source code.

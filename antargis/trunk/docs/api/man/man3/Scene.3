.TH "Scene" 3 "27 Oct 2006" "Version 0.1.9" "Antargis" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Scene \- quad-tree based scene-manager
.PP
\fBScene\fP is scene-manager. it holds all the 3d-objects (meshes and particles). These objects are stored in a \fBQuadTree\fP (could easily be exchanged for an octree, if needed). It takes further for drawing modes like picking, shadow-rendering and depth-drawing (for shadow-depth-computation). It contains a camera-object! So in the current state it's not possible to render the same scene from to places at the same time.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <scene.h>\fP
.PP
Inherits \fBAGRubyObject\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef std::vector< \fBPickNode\fP > \fBPickResult\fP"
.br
.ti -1c
.RI "typedef std::list< \fBSceneNode\fP * > \fBNodeList\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBScene\fP (int w, int h)"
.br
.ti -1c
.RI "virtual \fB~Scene\fP ()"
.br
.ti -1c
.RI "void \fBdraw\fP ()"
.br
.ti -1c
.RI "void \fBsetShadow\fP (int v)"
.br
.ti -1c
.RI "int \fBgetShadow\fP () const "
.br
.ti -1c
.RI "void \fBaddNode\fP (\fBSceneNode\fP *node)"
.br
.ti -1c
.RI "void \fBremoveNode\fP (\fBSceneNode\fP *node)"
.br
.ti -1c
.RI "void \fBprepareUpdate\fP (\fBSceneNode\fP *node)"
.br
.ti -1c
.RI "void \fBupdatePos\fP (\fBSceneNode\fP *node)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBsetCamera\fP (\fBAGVector4\fP v)"
.br
.ti -1c
.RI "\fBAGVector4\fP \fBgetCamera\fP () const "
.br
.ti -1c
.RI "void \fBadvance\fP (float time)"
.br
.ti -1c
.RI "\fBPickResult\fP \fBpick\fP (float x, float y, float w, float h)"
.br
.ti -1c
.RI "\fBAntCamera\fP & \fBgetCameraObject\fP ()"
.br
.ti -1c
.RI "size_t \fBgetDrawnMeshes\fP () const "
.br
.ti -1c
.RI "size_t \fBgetTriangles\fP () const "
.br
.ti -1c
.RI "size_t \fBgetPickTriangles\fP () const "
.br
.ti -1c
.RI "\fBAGVector3\fP \fBgetCameraDirTo\fP (const \fBAGVector3\fP &p) const "
.br
.RI "\fIget camera-viewing-direction to some 3d-point - used for particles \fP"
.ti -1c
.RI "float \fBwidth\fP () const "
.br
.RI "\fIwidth and height of screen \fP"
.ti -1c
.RI "float \fBheight\fP () const "
.br
.ti -1c
.RI "void \fBmark\fP ()"
.br
.RI "\fIoverride this function to mark your children \fP"
.ti -1c
.RI "\fBAGMatrix4\fP \fBgetLightComplete\fP () const "
.br
.ti -1c
.RI "\fBAGMatrix4\fP \fBgetLightView\fP () const "
.br
.ti -1c
.RI "\fBAGMatrix4\fP \fBgetLightProj\fP () const "
.br
.ti -1c
.RI "\fBAGVector2\fP \fBgetPosition\fP (const \fBAGVector4\fP &v) const "
.br
.ti -1c
.RI "\fBNodeList\fP \fBgetCurrentNodes\fP ()"
.br
.ti -1c
.RI "void \fBsetEnabled\fP (bool p)"
.br
.in -1c
.SH "Detailed Description"
.PP 
quad-tree based scene-manager
.PP
\fBScene\fP is scene-manager. it holds all the 3d-objects (meshes and particles). These objects are stored in a \fBQuadTree\fP (could easily be exchanged for an octree, if needed). It takes further for drawing modes like picking, shadow-rendering and depth-drawing (for shadow-depth-computation). It contains a camera-object! So in the current state it's not possible to render the same scene from to places at the same time. 
.PP
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::list<\fBSceneNode\fP*> \fBScene::NodeList\fP"
.PP
.SS "typedef std::vector<\fBPickNode\fP> \fBScene::PickResult\fP"
.PP
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Scene::Scene (int w, int h)"
.PP
.SS "Scene::~Scene ()\fC [virtual]\fP"
.PP
.SH "Member Function Documentation"
.PP 
.SS "void Scene::addNode (\fBSceneNode\fP * node)"
.PP
.SS "void Scene::advance (float time)"
.PP
.SS "void Scene::clear ()\fC [virtual]\fP"
.PP
Reimplemented from \fBAGRubyObject\fP.
.SS "void Scene::draw ()"
.PP
.SS "\fBAGVector4\fP Scene::getCamera () const"
.PP
.SS "\fBAGVector3\fP Scene::getCameraDirTo (const \fBAGVector3\fP & p) const"
.PP
get camera-viewing-direction to some 3d-point - used for particles 
.PP
.SS "\fBAntCamera\fP & Scene::getCameraObject ()"
.PP
.SS "\fBScene::NodeList\fP Scene::getCurrentNodes ()"
.PP
.SS "size_t Scene::getDrawnMeshes () const"
.PP
.SS "\fBAGMatrix4\fP Scene::getLightComplete () const"
.PP
.SS "\fBAGMatrix4\fP Scene::getLightProj () const"
.PP
.SS "\fBAGMatrix4\fP Scene::getLightView () const"
.PP
.SS "size_t Scene::getPickTriangles () const"
.PP
.SS "\fBAGVector2\fP Scene::getPosition (const \fBAGVector4\fP & v) const"
.PP
.SS "int Scene::getShadow () const"
.PP
.SS "size_t Scene::getTriangles () const"
.PP
.SS "float Scene::height () const"
.PP
.SS "void Scene::mark ()\fC [virtual]\fP"
.PP
override this function to mark your children 
.PP
Reimplemented from \fBAGRubyObject\fP.
.SS "\fBScene::PickResult\fP Scene::pick (float x, float y, float w, float h)"
.PP
picking is currently done with opengl. this uses software (at least on my box), which is pretty slow. Some new implementation using BSPs would be cool! \fBVertexArray\fP or \fBMeshData\fP should contain it's data in such a tree. rays can be transformed using inverse transformation-matrices. This way data can stay as is. 
.SS "void Scene::prepareUpdate (\fBSceneNode\fP * node)"
.PP
.SS "void Scene::removeNode (\fBSceneNode\fP * node)"
.PP
.SS "void Scene::setCamera (\fBAGVector4\fP v)"
.PP
.SS "void Scene::setEnabled (bool p)"
.PP
.SS "void Scene::setShadow (int v)"
.PP
.SS "void Scene::updatePos (\fBSceneNode\fP * node)"
.PP
.SS "float Scene::width () const"
.PP
width and height of screen 
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Antargis from the source code.

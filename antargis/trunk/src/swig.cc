/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.27
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIG_DIRECTORS

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif

/***********************************************************************
 *
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 *
 ************************************************************************/

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
#  if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#    define SWIGTEMPLATEDISAMBIGUATOR template
#  else
#    define SWIGTEMPLATEDISAMBIGUATOR 
#  endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__) || defined(__ICC)
#   define SWIGUNUSED __attribute__ ((unused)) 
# else
#   define SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods for Windows DLLs */
#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   define SWIGEXPORT
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif


/* ruby.swg */
/* Implementation : RUBY */
#define SWIGRUBY 1

#include "ruby.h"

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_OWN           0x1
#define SWIG_POINTER_DISOWN        0x2
#define SWIG_TRACK_OBJECTS	        0x4

#define NUM2USHRT(n) (\
    (0 <= NUM2UINT(n) && NUM2UINT(n) <= USHRT_MAX)\
    ? (unsigned short) NUM2UINT(n) \
    : (rb_raise(rb_eArgError, "integer %d out of range of `unsigned short'",\
               NUM2UINT(n)), (short)0)\
)

#define NUM2SHRT(n) (\
    (SHRT_MIN <= NUM2INT(n) && NUM2INT(n) <= SHRT_MAX)\
    ? (short)NUM2INT(n)\
    : (rb_raise(rb_eArgError, "integer %d out of range of `short'",\
               NUM2INT(n)), (short)0)\
)

/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
} swig_class;

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING(RB_STRING_VALUE(s))->ptr
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING(RB_STRING_VALUE(s))->len
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

/* Contract support */

#define SWIG_contract_assert(expr, msg) if (!(expr)) { rb_raise(rb_eRuntimeError, (char *) msg ); } else


/***********************************************************************
 * swigrun.swg
 *
 *     This file contains generic CAPI SWIG runtime support for pointer
 *     type checking.
 *
 ************************************************************************/

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "2"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store inforomation on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;


/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (int)(*f1 - *f2);
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/* think of this as a c++ template<> or a scheme macro */
#define SWIG_TypeCheck_Template(comparison, ty)         \
  if (ty) {                                             \
    swig_cast_info *iter = ty->cast;                    \
    while (iter) {                                      \
      if (comparison) {                                 \
        if (iter == ty->cast) return iter;              \
        /* Move iter to the top of the linked list */   \
        iter->prev->next = iter->next;                  \
        if (iter->next)                                 \
          iter->next->prev = iter->prev;                \
        iter->next = ty->cast;                          \
        iter->prev = 0;                                 \
        if (ty->cast) ty->cast->prev = iter;            \
        ty->cast = iter;                                \
        return iter;                                    \
      }                                                 \
      iter = iter->next;                                \
    }                                                   \
  }                                                     \
  return 0

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
}

/* Same as previous function, except strcmp is replaced with a pointer comparison */
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
  SWIG_TypeCheck_Template(iter->type == from, into);
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}


/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu = 0;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from 
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 ************************************************************************/

/* Global Ruby hash table to store Trackings from C/C++
   structs to Ruby Objects. */
static VALUE swig_ruby_trackings;

/* Setup a Ruby hash table to store Trackings */
static void SWIG_RubyInitializeTrackings() {
	/* Create a ruby hash table to store Trackings from C++ 
	objects to Ruby objects.  Also make sure to tell
	the garabage collector about the hash table. */
	swig_ruby_trackings = rb_hash_new();
	rb_gc_register_address(&swig_ruby_trackings);
}

/* Get a Ruby number to reference a pointer */
static VALUE SWIG_RubyPtrToReference(void* ptr) {
	/* We cast the pointer to an unsigned long
	 and then store a reference to it using
	 a Ruby number object. */

	/* Convert the pointer to a Ruby number */
	unsigned long value = (unsigned long) ptr;
	return LONG2NUM(value);
}

/* Get a Ruby number to reference an object */
static VALUE SWIG_RubyObjectToReference(VALUE object) {
	/* We cast the object to an unsigned long
	 and then store a reference to it using
	 a Ruby number object. */

	/* Convert the Object to a Ruby number */
	unsigned long value = (unsigned long) object;
	return LONG2NUM(value);
}

/* Get a Ruby object from a previously stored reference */
static VALUE SWIG_RubyReferenceToObject(VALUE reference) {
	/* The provided Ruby number object is a reference
	to the Ruby object we want.*/

	/* First convert the Ruby number to a C number */
	unsigned long value = NUM2LONG(reference);
	return (VALUE) value;
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
static void SWIG_RubyAddTracking(void* ptr, VALUE object) {
	/* In a Ruby hash table we store the pointer and
	the associated Ruby object.  The trick here is
	that we cannot store the Ruby object directly - if
	we do then it cannot be garbage collected.  So
	instead we typecast it as a unsigned long and
	convert it to a Ruby number object.*/

	/* Get a reference to the pointer as a Ruby number */
	VALUE key = SWIG_RubyPtrToReference(ptr);

	/* Get a reference to the Ruby object as a Ruby number */
	VALUE value = SWIG_RubyObjectToReference(object);

  /* Store the mapping to the global hash table. */
	rb_hash_aset(swig_ruby_trackings, key, value);
}

/* Get the Ruby object that owns the specified C/C++ struct */
static VALUE SWIG_RubyInstanceFor(void* ptr) {
	/* Get a reference to the pointer as a Ruby number */
	VALUE key = SWIG_RubyPtrToReference(ptr);

	/* Now lookup the value stored in the global hash table */
	VALUE value = rb_hash_aref(swig_ruby_trackings, key);
	
	if (value == Qnil) {
	  /* No object exists - return nil. */
		return Qnil;
	}
	else {
		/* Convert this value to Ruby object */
		return SWIG_RubyReferenceToObject(value);
	}
}

/* Remove a Tracking from a C/C++ struct to a Ruby object */
static void SWIG_RubyRemoveTracking(void* ptr) {
	/* Get a reference to the pointer as a Ruby number */
	VALUE key = SWIG_RubyPtrToReference(ptr);

	/* Define delete method - in C++ this could be marked as
	   static but unfortunately not in C. */
	VALUE delete_function = rb_intern("delete");

	/* Delete the object from the hash table by calling Ruby's
	   do this we need to call the Hash.delete method.*/
	rb_funcall(swig_ruby_trackings, delete_function, 1, key);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object */
static void SWIG_RubyUnlinkObjects(void* ptr) {
	VALUE object = SWIG_RubyInstanceFor(ptr);

	if (object != Qnil) {
		DATA_PTR(object) = 0;
	}
}

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags) \
  SWIG_Ruby_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags) \
  SWIG_Ruby_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags) \
  SWIG_Ruby_MustGetPtr(p, type, argnum, flags)
#define SWIG_GetModule(clientdata) \
  SWIG_Ruby_GetModule()
#define SWIG_SetModule(clientdata, pointer) \
  SWIG_Ruby_SetModule(pointer)

/* Ruby-specific SWIG API */

#define SWIG_InitRuntime() \
  SWIG_Ruby_InitRuntime()
#define SWIG_define_class(ty) \
  SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty) \
  SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value) \
  SWIG_Ruby_MangleStr(value)
#define SWIG_CheckConvert(value, ty) \
  SWIG_Ruby_CheckConvert(value, ty)
#define SWIG_NewPackedObj(ptr, sz, ty) \
  SWIG_Ruby_NewPackedObj(ptr, sz, ty)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)

/* rubydef.swg */
#ifdef __cplusplus
extern "C" {
#endif

static VALUE _mSWIG = Qnil;
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Initialize Ruby runtime support */
static void
SWIG_Ruby_InitRuntime(void)
{
    if (_mSWIG == Qnil) {
        _mSWIG = rb_define_module("SWIG");
    }
}

/* Define Ruby class for C type */
static void
SWIG_Ruby_define_class(swig_type_info *type)
{
    VALUE klass;
    char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    if (NIL_P(_cSWIG_Pointer)) {
	_cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
	rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
    }
    klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
    free((void *) klass_name);
}

/* Create a new pointer object */
static VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
	 int own = flags & SWIG_POINTER_OWN;
	 int track = flags & SWIG_TRACK_OBJECTS;
	 
    char *klass_name;
    swig_class *sklass;
    VALUE klass;
    VALUE obj;
    
    if (!ptr)
      return Qnil;
    
    /* Have we already wrapped this pointer? */
    if (track) {
	    obj = SWIG_RubyInstanceFor(ptr);
   	 if (obj != Qnil) {
      	return obj;
    	}
    }
		
    if (type->clientdata) {
      sklass = (swig_class *) type->clientdata;
      obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);
    } else {
      klass_name = (char *) malloc(4 + strlen(type->name) + 1);
      sprintf(klass_name, "TYPE%s", type->name);
      klass = rb_const_get(_mSWIG, rb_intern(klass_name));
      free((void *) klass_name);
      obj = Data_Wrap_Struct(klass, 0, 0, ptr);
    }
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    
    /* Keep track of this object if necessary */
    if (track) {
	   SWIG_RubyAddTracking(ptr, obj);
    }
   
    return obj;
}

/* Create a new class instance (always owned) */
static VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
    VALUE obj;
    swig_class *sklass = (swig_class *) type->clientdata;
    obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Get type mangle from class name */
static SWIGINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "__swigtype__");
  return StringValuePtr(stype);
}

/* Convert a pointer value */
static int
SWIG_Ruby_ConvertPtr(VALUE obj, void **ptr, swig_type_info *ty, int flags)
{
  char *c;
  swig_cast_info *tc;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return 0;
  } else {
    Data_Get_Struct(obj, void, *ptr);
  }
  
  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
	 if (flags & SWIG_TRACK_OBJECTS) {
      /* We are tracking objects.  Thus we change the destructor
		 * to SWIG_RubyRemoveTracking.  This allows us to
		 * remove the mapping from the C++ to Ruby object
		 * when the Ruby object is garbage collected.  If we don't
		 * do this, then it is possible we will return a reference 
		 * to a Ruby object that no longer exists thereby crashing Ruby. */
		RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
  	 } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
        if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
          if (*ptr == 0)
            rb_raise(rb_eRuntimeError, "This %s already released", ty->str);
          return 0;
        }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      if (flags & SWIG_POINTER_EXCEPTION)
        rb_raise(rb_eTypeError, "Expected %s", ty->str);
      else
        return -1;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      if (flags & SWIG_POINTER_EXCEPTION)
        rb_raise(rb_eTypeError, "Expected %s", ty->str);
      else
        return -1;
    }
    *ptr = SWIG_TypeCast(tc, *ptr);
  }
  return 0;
}

/* Convert a pointer value, signal an exception on a type mismatch */
static SWIGINLINE void *
SWIG_Ruby_MustGetPtr(VALUE obj, swig_type_info *ty, int argnum, int flags)
{
  void *result;
  SWIG_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
  return result;
}

/* Check convert */
static SWIGINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c)
    return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

static VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
static void
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return;

type_error:

  if (flags) {
    if (ty) {
      rb_raise(rb_eTypeError, "Type error. Expected %s", ty->name);
    } else {
      rb_raise(rb_eTypeError, "Expected a pointer");
    }
  }
}

static swig_module_info *SWIG_Ruby_GetModule() {
    VALUE pointer;
    swig_module_info *ret = 0;

   /* first check if pointer already created */
    pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
    if (pointer != Qnil) {
      Data_Get_Struct(pointer, swig_module_info, ret);
    }
    return ret;
}

static void SWIG_Ruby_SetModule(swig_module_info *pointer) {
      /* register a new class */
      VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
      /* create and store the structure pointer to a global variable */
      swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
      rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

#ifdef __cplusplus
}
#endif



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_char swig_types[0]
#define SWIGTYPE_p_AGAngle swig_types[1]
#define SWIGTYPE_p_AGApplication swig_types[2]
#define SWIGTYPE_p_AGBackground swig_types[3]
#define SWIGTYPE_p_AGBorder swig_types[4]
#define SWIGTYPE_p_AGBox3 swig_types[5]
#define SWIGTYPE_p_AGButton swig_types[6]
#define SWIGTYPE_p_AGCPPListener swig_types[7]
#define SWIGTYPE_p_AGCaption swig_types[8]
#define SWIGTYPE_p_AGCheckBox swig_types[9]
#define SWIGTYPE_p_AGCircle2 swig_types[10]
#define SWIGTYPE_p_AGCollisionData swig_types[11]
#define SWIGTYPE_p_AGColor swig_types[12]
#define SWIGTYPE_p_AGColorButton swig_types[13]
#define SWIGTYPE_p_AGDecryptor swig_types[14]
#define SWIGTYPE_p_AGDialog swig_types[15]
#define SWIGTYPE_p_AGEdit swig_types[16]
#define SWIGTYPE_p_AGEditLine swig_types[17]
#define SWIGTYPE_p_AGEvent swig_types[18]
#define SWIGTYPE_p_AGFont swig_types[19]
#define SWIGTYPE_p_AGFontEngine swig_types[20]
#define SWIGTYPE_p_AGGLTexture swig_types[21]
#define SWIGTYPE_p_AGGLWidget swig_types[22]
#define SWIGTYPE_p_AGImage swig_types[23]
#define SWIGTYPE_p_AGInternalSurface swig_types[24]
#define SWIGTYPE_p_AGLayout swig_types[25]
#define SWIGTYPE_p_AGLayoutCreator swig_types[26]
#define SWIGTYPE_p_AGLayoutFactory swig_types[27]
#define SWIGTYPE_p_AGLine2 swig_types[28]
#define SWIGTYPE_p_AGLine3 swig_types[29]
#define SWIGTYPE_p_AGListBox swig_types[30]
#define SWIGTYPE_p_AGListBoxItem swig_types[31]
#define SWIGTYPE_p_AGListener swig_types[32]
#define SWIGTYPE_p_AGMain swig_types[33]
#define SWIGTYPE_p_AGMatrix3 swig_types[34]
#define SWIGTYPE_p_AGMatrix4 swig_types[35]
#define SWIGTYPE_p_AGMenu swig_types[36]
#define SWIGTYPE_p_AGMenuItem swig_types[37]
#define SWIGTYPE_p_AGMessageObject swig_types[38]
#define SWIGTYPE_p_AGMutex swig_types[39]
#define SWIGTYPE_p_AGPaintTarget swig_types[40]
#define SWIGTYPE_p_AGPainter swig_types[41]
#define SWIGTYPE_p_AGProjection swig_types[42]
#define SWIGTYPE_p_AGRadio swig_types[43]
#define SWIGTYPE_p_AGRadioGroup swig_types[44]
#define SWIGTYPE_p_AGRect2 swig_types[45]
#define SWIGTYPE_p_AGRect3 swig_types[46]
#define SWIGTYPE_p_AGRenderContext swig_types[47]
#define SWIGTYPE_p_AGRubyObject swig_types[48]
#define SWIGTYPE_p_AGScreen swig_types[49]
#define SWIGTYPE_p_AGSignal swig_types[50]
#define SWIGTYPE_p_AGSound swig_types[51]
#define SWIGTYPE_p_AGSubMenu swig_types[52]
#define SWIGTYPE_p_AGSurface swig_types[53]
#define SWIGTYPE_p_AGSurfaceManager swig_types[54]
#define SWIGTYPE_p_AGTable swig_types[55]
#define SWIGTYPE_p_AGText swig_types[56]
#define SWIGTYPE_p_AGTexture swig_types[57]
#define SWIGTYPE_p_AGTextureCache swig_types[58]
#define SWIGTYPE_p_AGTheme swig_types[59]
#define SWIGTYPE_p_AGTooltip swig_types[60]
#define SWIGTYPE_p_AGTriangle2 swig_types[61]
#define SWIGTYPE_p_AGTriangle3 swig_types[62]
#define SWIGTYPE_p_AGVector2 swig_types[63]
#define SWIGTYPE_p_AGVector3 swig_types[64]
#define SWIGTYPE_p_AGVector4 swig_types[65]
#define SWIGTYPE_p_AGWidget swig_types[66]
#define SWIGTYPE_p_AGWindow swig_types[67]
#define SWIGTYPE_p_AnimMesh swig_types[68]
#define SWIGTYPE_p_AnimMeshData swig_types[69]
#define SWIGTYPE_p_Animation swig_types[70]
#define SWIGTYPE_p_AntEntity swig_types[71]
#define SWIGTYPE_p_AntEntityPtr swig_types[72]
#define SWIGTYPE_p_AntFragProgram swig_types[73]
#define SWIGTYPE_p_AntMap swig_types[74]
#define SWIGTYPE_p_AntShaderParameter swig_types[75]
#define SWIGTYPE_p_AntShaderProgram swig_types[76]
#define SWIGTYPE_p_AntShadowShader swig_types[77]
#define SWIGTYPE_p_AntVertexProgram swig_types[78]
#define SWIGTYPE_p_AntWaterShader swig_types[79]
#define SWIGTYPE_p_Attributes swig_types[80]
#define SWIGTYPE_p_BinaryFileIn swig_types[81]
#define SWIGTYPE_p_BinaryFileOut swig_types[82]
#define SWIGTYPE_p_BinaryIn swig_types[83]
#define SWIGTYPE_p_BinaryOut swig_types[84]
#define SWIGTYPE_p_BinaryStringIn swig_types[85]
#define SWIGTYPE_p_BinaryStringOut swig_types[86]
#define SWIGTYPE_p_Bone swig_types[87]
#define SWIGTYPE_p_Document swig_types[88]
#define SWIGTYPE_p_DomParser swig_types[89]
#define SWIGTYPE_p_EntityList swig_types[90]
#define SWIGTYPE_p_GLApp swig_types[91]
#define SWIGTYPE_p_GLint swig_types[92]
#define SWIGTYPE_p_GLuint swig_types[93]
#define SWIGTYPE_p_HeightMap swig_types[94]
#define SWIGTYPE_p_KeyFrame swig_types[95]
#define SWIGTYPE_p_Mesh swig_types[96]
#define SWIGTYPE_p_MeshData swig_types[97]
#define SWIGTYPE_p_MeshOptimizer swig_types[98]
#define SWIGTYPE_p_MeshVertex swig_types[99]
#define SWIGTYPE_p_Meshes swig_types[100]
#define SWIGTYPE_p_MiniMap swig_types[101]
#define SWIGTYPE_p_NewDecal swig_types[102]
#define SWIGTYPE_p_Node swig_types[103]
#define SWIGTYPE_p_NodeList swig_types[104]
#define SWIGTYPE_p_NodeVector swig_types[105]
#define SWIGTYPE_p_Node__NodeVector__const_iterator swig_types[106]
#define SWIGTYPE_p_Node__NodeVector__iterator swig_types[107]
#define SWIGTYPE_p_Parser swig_types[108]
#define SWIGTYPE_p_PickNode swig_types[109]
#define SWIGTYPE_p_PickResult swig_types[110]
#define SWIGTYPE_p_Renderer swig_types[111]
#define SWIGTYPE_p_Resource swig_types[112]
#define SWIGTYPE_p_SDLKey swig_types[113]
#define SWIGTYPE_p_SDLMod swig_types[114]
#define SWIGTYPE_p_SDL_Event swig_types[115]
#define SWIGTYPE_p_SDL_PixelFormat swig_types[116]
#define SWIGTYPE_p_SDL_Rect swig_types[117]
#define SWIGTYPE_p_SDL_Surface swig_types[118]
#define SWIGTYPE_p_Scene swig_types[119]
#define SWIGTYPE_p_SceneNode swig_types[120]
#define SWIGTYPE_p_SerialException swig_types[121]
#define SWIGTYPE_p_Sint32 swig_types[122]
#define SWIGTYPE_p_Smoke swig_types[123]
#define SWIGTYPE_p_Terrain swig_types[124]
#define SWIGTYPE_p_TerrainPieceVA swig_types[125]
#define SWIGTYPE_p_Uint16 swig_types[126]
#define SWIGTYPE_p_Uint32 swig_types[127]
#define SWIGTYPE_p_Uint8 swig_types[128]
#define SWIGTYPE_p_VertexArray swig_types[129]
#define SWIGTYPE_p_VertexArrayShader swig_types[130]
#define SWIGTYPE_p_Viewport swig_types[131]
#define SWIGTYPE_p_WaterPiece swig_types[132]
#define SWIGTYPE_p_const_iterator swig_types[133]
#define SWIGTYPE_p_float swig_types[134]
#define SWIGTYPE_p_iterator swig_types[135]
#define SWIGTYPE_p_p_AnimMesh swig_types[136]
#define SWIGTYPE_p_p_Mesh swig_types[137]
#define SWIGTYPE_p_p_NewDecal swig_types[138]
#define SWIGTYPE_p_p_Node swig_types[139]
#define SWIGTYPE_p_p_SceneNode swig_types[140]
#define SWIGTYPE_p_p_Smoke swig_types[141]
#define SWIGTYPE_p_p_TerrainPieceVA swig_types[142]
#define SWIGTYPE_p_p_WaterPiece swig_types[143]
#define SWIGTYPE_p_std__listTAGRect2_t swig_types[144]
#define SWIGTYPE_p_std__listTAntEntity_p_t swig_types[145]
#define SWIGTYPE_p_std__listTSceneNode_p_t swig_types[146]
#define SWIGTYPE_p_std__mapTstd__string_float_t swig_types[147]
#define SWIGTYPE_p_std__mapTstd__string_std__string_t swig_types[148]
#define SWIGTYPE_p_std__ostringstream swig_types[149]
#define SWIGTYPE_p_std__pairTAGRect2_AGRect2_t swig_types[150]
#define SWIGTYPE_p_std__pairTstd__string_bool_t swig_types[151]
#define SWIGTYPE_p_std__setTScene_p_t swig_types[152]
#define SWIGTYPE_p_std__string swig_types[153]
#define SWIGTYPE_p_std__vectorTAGBox3_t swig_types[154]
#define SWIGTYPE_p_std__vectorTAGLine2_t swig_types[155]
#define SWIGTYPE_p_std__vectorTAGMatrix4_t swig_types[156]
#define SWIGTYPE_p_std__vectorTAGRect3_t swig_types[157]
#define SWIGTYPE_p_std__vectorTAGVector2_t swig_types[158]
#define SWIGTYPE_p_std__vectorTAGVector4_t swig_types[159]
#define SWIGTYPE_p_std__vectorTAntEntityPtr_t swig_types[160]
#define SWIGTYPE_p_std__vectorTKeyFrame_t swig_types[161]
#define SWIGTYPE_p_std__vectorTNode_p_t swig_types[162]
#define SWIGTYPE_p_std__vectorTNode_t swig_types[163]
#define SWIGTYPE_p_std__vectorTPickNode_t swig_types[164]
#define SWIGTYPE_p_std__vectorTSceneNodePtr_t swig_types[165]
#define SWIGTYPE_p_std__vectorTfloat_t swig_types[166]
#define SWIGTYPE_p_std__vectorTstd__pairTAGRect2_AGVector4_t_t swig_types[167]
#define SWIGTYPE_p_std__vectorTstd__string_t swig_types[168]
#define SWIGTYPE_p_unsigned_long swig_types[169]
static swig_type_info *swig_types[171];
static swig_module_info swig_module = {swig_types, 170, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_libantargis
#define SWIG_name    "Libantargis"

static VALUE mLibantargis;

static void SWIG_AsVal(VALUE obj, int *val)
{
    *val = (int) NUM2INT(obj);
}


#ifdef __cplusplus
extern "C" {
#endif
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
struct timeval rb_time_timeval(VALUE);
#endif
#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
#include "rubyio.h"
#ifdef __cplusplus
}
#endif


#include "scene.h"
#include "antargisgui.h"


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


SWIGINTERN void SWIG_exception_(int code, const char *msg) {
    switch (code) {
        case SWIG_MemoryError:
            rb_raise(rb_eNoMemError, msg);
            break;
        case SWIG_IOError:
            rb_raise(rb_eIOError, msg);
            break;
        case SWIG_RuntimeError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        case SWIG_IndexError:
            rb_raise(rb_eIndexError, msg);
            break;
        case SWIG_TypeError:
            rb_raise(rb_eTypeError, msg);
            break;
        case SWIG_DivisionByZero:
            rb_raise(rb_eZeroDivError, msg);
            break;
        case SWIG_OverflowError:
            rb_raise(rb_eRangeError, msg);
            break;
        case SWIG_SyntaxError:
            rb_raise(rb_eSyntaxError, msg);
            break;
        case SWIG_ValueError:
            rb_raise(rb_eArgError, msg);
            break;
        case SWIG_SystemError:
            rb_raise(rb_eFatal, msg);
            break;
        case SWIG_UnknownError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        default:
            break;
    }
}

#define SWIG_exception(a, b) SWIG_exception_((a), (b))


#include <stdexcept>


#include <string>


#include <string>

#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))

bool SWIG_BOOL_P(VALUE) {
    // dummy test, RTEST should take care of everything
    return true;
}
bool SWIG_RB2BOOL(VALUE x) {
    return RTEST(x);
}
VALUE SWIG_BOOL2RB(bool b) {
    return b ? Qtrue : Qfalse;
}
double SWIG_NUM2DBL(VALUE x) {
    return (FIXNUM_P(x) ? FIX2INT(x) : NUM2DBL(x));
}
bool SWIG_STRING_P(VALUE x) {
    return TYPE(x) == T_STRING;
}
std::string SWIG_RB2STR(VALUE x) {
    return std::string(StringValuePtr(x));
}
VALUE SWIG_STR2RB(const std::string& s) {
    return rb_str_new2(s.c_str());
}


#include <vector>
#include <algorithm>
#include <stdexcept>


#include <map>
#include <algorithm>
#include <stdexcept>

static std::string std_vector_Sl_std_string_Sg__pop(std::vector<std::string > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                std::string x = self->back();
                self->pop_back();
                return x;
            }
static std::string std_vector_Sl_std_string_Sg____getitem__(std::vector<std::string > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_std_string_Sg____setitem__(std::vector<std::string > *self,int i,std::string x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_std_string_Sg__each(std::vector<std::string > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(SWIG_STR2RB((*self)[i]));
            }
static SceneNodePtr std_vector_Sl_SceneNodePtr_Sg__pop(std::vector<SceneNodePtr > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                SceneNodePtr x = self->back();
                self->pop_back();
                return x;
            }
static SceneNodePtr &std_vector_Sl_SceneNodePtr_Sg____getitem__(std::vector<SceneNodePtr > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_SceneNodePtr_Sg____setitem__(std::vector<SceneNodePtr > *self,int i,SceneNodePtr const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_SceneNodePtr_Sg__each(std::vector<SceneNodePtr > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    SceneNodePtr* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_p_SceneNode, 0));
                }
            }
static PickNode std_vector_Sl_PickNode_Sg__pop(std::vector<PickNode > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                PickNode x = self->back();
                self->pop_back();
                return x;
            }
static PickNode &std_vector_Sl_PickNode_Sg____getitem__(std::vector<PickNode > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_PickNode_Sg____setitem__(std::vector<PickNode > *self,int i,PickNode const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_PickNode_Sg__each(std::vector<PickNode > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    PickNode* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_PickNode, 0));
                }
            }
static AntEntityPtr std_vector_Sl_AntEntityPtr_Sg__pop(std::vector<AntEntityPtr > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                AntEntityPtr x = self->back();
                self->pop_back();
                return x;
            }
static AntEntityPtr &std_vector_Sl_AntEntityPtr_Sg____getitem__(std::vector<AntEntityPtr > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AntEntityPtr_Sg____setitem__(std::vector<AntEntityPtr > *self,int i,AntEntityPtr const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AntEntityPtr_Sg__each(std::vector<AntEntityPtr > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    AntEntityPtr* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_AntEntityPtr, 0));
                }
            }
static float std_map_Sl_std_string_Sc_float_Sg____getitem__(std::map<std::string,float > *self,std::string key){
                std::map<std::string,float >::iterator i = self->find(key);
                if (i != self->end())
                    return i->second;
                else
                    throw std::out_of_range("key not found");
            }
static void std_map_Sl_std_string_Sc_float_Sg____setitem__(std::map<std::string,float > *self,std::string key,float x){
                (*self)[key] = x;
            }
static float std_map_Sl_std_string_Sc_float_Sg____delitem__(std::map<std::string,float > *self,std::string key){
                std::map<std::string,float >::iterator i = self->find(key);
                if (i != self->end()) {
                    float x = i->second;
                    self->erase(i);
                    return x;
                } else
                    throw std::out_of_range("key not found");
            }
static bool std_map_Sl_std_string_Sc_float_Sg__has_key(std::map<std::string,float > *self,std::string key){
                std::map<std::string,float >::iterator i = self->find(key);
                return i != self->end();
            }
static VALUE std_map_Sl_std_string_Sc_float_Sg__keys(std::map<std::string,float > *self){
                VALUE keyList = rb_ary_new2(self->size());
                std::map<std::string,float >::iterator i;
                unsigned int j;
                for (i=self->begin(), j=0; i!=self->end(); ++i, ++j) {
                    rb_ary_store(keyList,j,
                                 SWIG_STR2RB(i->first));
                }
                return keyList;
            }
static VALUE std_map_Sl_std_string_Sc_float_Sg__values(std::map<std::string,float > *self){
                VALUE valueList = rb_ary_new2(self->size());
                std::map<std::string,float >::iterator i;
                unsigned int j;
                for (i=self->begin(), j=0; i!=self->end(); ++i, ++j) {
                    rb_ary_store(valueList,j,
                                 rb_float_new(i->second));
                }
                return valueList;
            }
static void std_map_Sl_std_string_Sc_float_Sg__each(std::map<std::string,float > *self){
                std::map<std::string,float >::iterator i;
                for (i=self->begin(); i!=self->end(); ++i) {
                    VALUE entry = rb_ary_new2(2);
                    rb_ary_store(entry,0,SWIG_STR2RB(i->first));
                    rb_ary_store(entry,1,rb_float_new(i->second));
                    rb_yield(entry);
                }
            }
static Node std_vector_Sl_Node_Sg__pop(std::vector<Node > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                Node x = self->back();
                self->pop_back();
                return x;
            }
static Node &std_vector_Sl_Node_Sg____getitem__(std::vector<Node > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sg____setitem__(std::vector<Node > *self,int i,Node const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sg__each(std::vector<Node > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    Node* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_Node, 0));
                }
            }
static Node *std_vector_Sl_Node_Sm__Sg__pop(std::vector<Node * > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                Node* x = self->back();
                self->pop_back();
                return x;
            }
static Node *std_vector_Sl_Node_Sm__Sg____getitem__(std::vector<Node * > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sm__Sg____setitem__(std::vector<Node * > *self,int i,Node *x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sm__Sg__each(std::vector<Node * > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    Node* x = (*self)[i];
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_Node, 0));
                }
            }
/***********************************************************************
 * director.swg
 *
 * This file contains support for director classes that proxy
 * method calls from C++ to Ruby extensions.
 *
 * Author : Lyle Johnson (lyle@users.sourceforge.net)
 *          Based on the original Python implementation by
 *          Mark Rose (mrose@stm.lbl.gov).
 ************************************************************************/

#ifdef __cplusplus

#include <string>

namespace Swig {
  struct body_args {
    VALUE recv;
    ID id;
    int argc;
    VALUE *argv;
  };

  /* Base class for director exceptions */
  class DirectorException {
    protected:
      VALUE swig_error;
    protected:
      DirectorException(VALUE error=Qnil) : swig_error(error) {}
    public:
      VALUE getType() const  { 
        return CLASS_OF(swig_error); 
      }
      VALUE getError() const {
        return swig_error;
      }
      virtual ~DirectorException() {}
  };

  /* Type mismatch in the return value from a Ruby method call */
  class DirectorTypeMismatchException : public Swig::DirectorException {
    public:
      DirectorTypeMismatchException(const char *msg="") {
        VALUE str = rb_str_new2("Swig director type mismatch: ");
        rb_str_concat(str, rb_str_new2(msg));
        swig_error = rb_exc_new3(rb_eTypeError, str);
      }
  };

  /* Any Ruby exception that occurs during a director method call */
  class DirectorMethodException : public Swig::DirectorException {
    public:
      DirectorMethodException(VALUE error) : Swig::DirectorException(error) {}
  };

  /* Attempted to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public Swig::DirectorException {};


  /* Simple thread abstraction for pthreads on win32 */
#ifdef __THREAD__
#define __PTHREAD__
#if defined(_WIN32) || defined(__WIN32__)
#define pthread_mutex_lock EnterCriticalSection
#define pthread_mutex_unlock LeaveCriticalSection
#define pthread_mutex_t CRITICAL_SECTION
#define MUTEX_INIT(var) CRITICAL_SECTION var
#else
#include <pthread.h>
#define MUTEX_INIT(var) pthread_mutex_t var = PTHREAD_MUTEX_INITIALIZER 
#endif
#endif

  /* director base class */
  class Director {
    private:
      /* pointer to the wrapped Ruby object */
      VALUE swig_self;
      /* flag indicating whether the object is owned by Ruby or c++ */
      mutable bool swig_disown_flag;
      /* shared flag for breaking recursive director calls */
      static bool swig_up;

#ifdef __PTHREAD__
      /* locks for sharing the swig_up flag in a threaded environment */
      static pthread_mutex_t swig_mutex_up;
      static bool swig_mutex_active;
      static pthread_t swig_mutex_thread;
#endif

      /* reset the swig_up flag once the routing direction has been determined */
#ifdef __PTHREAD__
      void swig_clear_up() const { 
        Swig::Director::swig_up = false; 
        Swig::Director::swig_mutex_active = false;
        pthread_mutex_unlock(&swig_mutex_up);
      }
#else
      void swig_clear_up() const { 
        Swig::Director::swig_up = false; 
      }
#endif

    public:
      /* wrap a Ruby object, optionally taking ownership */
      Director(VALUE self) : swig_self(self), swig_disown_flag(false) {
      }

      /* discard our reference at destruction */
      virtual ~Director() {
      }

      /* return a pointer to the wrapped Ruby object */
      VALUE swig_get_self() const { 
        return swig_self; 
      }

      /* get the swig_up flag to determine if the method call should be routed
       * to the c++ base class or through the wrapped Ruby object
       */
#ifdef __PTHREAD__
      bool swig_get_up() const { 
        if (Swig::Director::swig_mutex_active) {
          if (pthread_equal(Swig::Director::swig_mutex_thread, pthread_self())) {
            bool up = swig_up;
            swig_clear_up();
            return up;
          }
        }
        return false;
      }
#else 
      bool swig_get_up() const { 
        bool up = swig_up;
        swig_up = false;
        return up;
      }
#endif

      /* set the swig_up flag if the next method call should be directed to
       * the c++ base class rather than the wrapped Ruby object
       */
#ifdef __PTHREAD__
      void swig_set_up() const { 
        pthread_mutex_lock(&Swig::Director::swig_mutex_up);
        Swig::Director::swig_mutex_thread = pthread_self();
        Swig::Director::swig_mutex_active = true;
        Swig::Director::swig_up = true;
      }
#else 
      void swig_set_up() const { 
        Swig::Director::swig_up = true; 
      }
#endif

      /* acquire ownership of the wrapped Ruby object (the sense of "disown"
       * is from Ruby) */
      void swig_disown() const { 
        if (!swig_disown_flag) { 
          swig_disown_flag = true;
        } 
      }
  };

  bool Swig::Director::swig_up = false;

#ifdef __PTHREAD__
  MUTEX_INIT(Swig::Director::swig_mutex_up);
  pthread_t Swig::Director::swig_mutex_thread;
  bool Swig::Director::swig_mutex_active = false;
#endif

}

#endif /* __cplusplus */




/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "swig.h"

SwigDirector_AGRubyObject::SwigDirector_AGRubyObject(VALUE self): AGRubyObject(), Swig::Director(self) {
    
}



SwigDirector_AGRubyObject::~SwigDirector_AGRubyObject() {
}

SwigDirector_AGEvent::SwigDirector_AGEvent(VALUE self, AGListener *pCaller, std::string const &pName, SDL_Event const *pEvent): AGEvent(pCaller, pName, pEvent), Swig::Director(self) {
    
}



SwigDirector_AGEvent::~SwigDirector_AGEvent() {
}

SwigDirector_AGListener::SwigDirector_AGListener(VALUE self): AGListener(), Swig::Director(self) {
    
}



SwigDirector_AGListener::~SwigDirector_AGListener() {
}

bool SwigDirector_AGListener::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCPPListener::SwigDirector_AGCPPListener(VALUE self) : Swig::Director(self) {
    
}



SwigDirector_AGCPPListener::~SwigDirector_AGCPPListener() {
}

bool SwigDirector_AGCPPListener::signal(AGEvent *m) const {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        throw Swig::DirectorPureVirtualException();
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self): AGSignal(), Swig::Director(self) {
    
}



SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self, AGMessageObject *pCaller): AGSignal(pCaller), Swig::Director(self) {
    
}



SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self, AGMessageObject *pCaller, std::string const &pName): AGSignal(pCaller, pName), Swig::Director(self) {
    
}



SwigDirector_AGSignal::~SwigDirector_AGSignal() {
}

SwigDirector_AGMessageObject::SwigDirector_AGMessageObject(VALUE self): AGMessageObject(), Swig::Director(self) {
    
}



bool SwigDirector_AGMessageObject::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGMessageObject::~SwigDirector_AGMessageObject() {
}

Uint8 SwigDirector_AGMessageObject::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


AGVector2 SwigDirector_AGMessageObject::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


SwigDirector_AGWidget::SwigDirector_AGWidget(VALUE self, AGWidget *pParent, AGRect2 const &r): AGWidget(pParent, r), Swig::Director(self) {
    
}



bool SwigDirector_AGWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGWidget::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGWidget::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGWidget::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGWidget::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGWidget::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGWidget::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGWidget::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGWidget::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGWidget::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGWidget::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGWidget::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGWidget::~SwigDirector_AGWidget() {
}

bool SwigDirector_AGWidget::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGWidget::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGWidget::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGWidget::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGWidget::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGColorButton::SwigDirector_AGColorButton(VALUE self, AGWidget *pParent, AGRect2 const &r, int x, int y): AGColorButton(pParent, r, x, y), Swig::Director(self) {
    
}



bool SwigDirector_AGColorButton::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGColorButton::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGColorButton::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGColorButton::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGColorButton::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGColorButton::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGColorButton::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGColorButton::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGColorButton::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGColorButton::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGColorButton::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGColorButton::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGColorButton::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGColorButton::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGColorButton::~SwigDirector_AGColorButton() {
}

bool SwigDirector_AGColorButton::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGColorButton::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGColorButton::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGColorButton::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGColorButton::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGColorButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGColorButton::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGColorButton::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGColorButton::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGColorButton::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGGLWidget::SwigDirector_AGGLWidget(VALUE self, AGWidget *pParent, AGRect2 const &r): AGGLWidget(pParent, r), Swig::Director(self) {
    
}



bool SwigDirector_AGGLWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGGLWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGGLWidget::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGGLWidget::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGGLWidget::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGGLWidget::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGGLWidget::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGGLWidget::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGGLWidget::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGGLWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGGLWidget::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGGLWidget::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGGLWidget::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGGLWidget::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGGLWidget::~SwigDirector_AGGLWidget() {
}

bool SwigDirector_AGGLWidget::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGGLWidget::drawGL() {
    VALUE result;
    
    if (swig_get_up()) {
        AGGLWidget::drawGL();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawGL"), 0, NULL);
}


void SwigDirector_AGGLWidget::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGGLWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGGLWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGGLWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


bool SwigDirector_AGGLWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGGLWidget::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGGLWidget::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGGLWidget::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_Parser::SwigDirector_Parser(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_Parser::simpleTag(std::string const &pName, Node::Attributes const &pAttributes) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::simpleTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj((void *) &pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("simpleTag"), 2,obj0,obj1);
}


SwigDirector_Parser::~SwigDirector_Parser() {
}

void SwigDirector_Parser::startTag(std::string const &pName, Node::Attributes const &pAttributes) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::startTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj((void *) &pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("startTag"), 2,obj0,obj1);
}


void SwigDirector_Parser::endTag(std::string const &pName) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::endTag(pName);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("endTag"), 1,obj0);
}


void SwigDirector_Parser::text(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::text(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("text"), 1,obj0);
}


void SwigDirector_Parser::comment(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::comment(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("comment"), 1,obj0);
}


void SwigDirector_Parser::header(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::header(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("header"), 1,obj0);
}


SwigDirector_DomParser::SwigDirector_DomParser(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_DomParser::simpleTag(std::string const &pName, Node::Attributes const &pAttributes) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::simpleTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj((void *) &pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("simpleTag"), 2,obj0,obj1);
}


SwigDirector_DomParser::~SwigDirector_DomParser() {
}

void SwigDirector_DomParser::startTag(std::string const &pName, Node::Attributes const &pAttributes) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::startTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj((void *) &pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("startTag"), 2,obj0,obj1);
}


void SwigDirector_DomParser::endTag(std::string const &pName) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::endTag(pName);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("endTag"), 1,obj0);
}


void SwigDirector_DomParser::text(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::text(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("text"), 1,obj0);
}


void SwigDirector_DomParser::comment(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::comment(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("comment"), 1,obj0);
}


void SwigDirector_DomParser::header(std::string const &pText) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::header(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("header"), 1,obj0);
}


SwigDirector_AGLayout::SwigDirector_AGLayout(VALUE self, AGWidget *pgParent, std::string const &pXMLData): AGLayout(pgParent, pXMLData), Swig::Director(self) {
    
}



bool SwigDirector_AGLayout::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGLayout::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGLayout::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGLayout::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGLayout::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGLayout::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGLayout::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGLayout::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGLayout::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGLayout::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGLayout::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGLayout::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGLayout::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGLayout::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGLayout::~SwigDirector_AGLayout() {
}

bool SwigDirector_AGLayout::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGLayout::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGLayout::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGLayout::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGLayout::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGLayout::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGLayout::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGLayout::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGLayout::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGDialog::SwigDirector_AGDialog(VALUE self, AGWidget *pgParent, std::string const &pXMLData): AGDialog(pgParent, pXMLData), Swig::Director(self) {
    
}



bool SwigDirector_AGDialog::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGDialog::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGDialog::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGDialog::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGDialog::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGDialog::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGDialog::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGDialog::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGDialog::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGDialog::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGDialog::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGDialog::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGDialog::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGDialog::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGDialog::~SwigDirector_AGDialog() {
}

bool SwigDirector_AGDialog::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGLayout::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventOk(AGEvent *event) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventOk(event);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventOk"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventCancel(AGEvent *event) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventCancel(event);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventCancel"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventClose(AGEvent *event) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventClose(event);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventClose"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGDialog::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGDialog::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGDialog::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGDialog::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGDialog::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGDialog::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGDialog::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGApplication::SwigDirector_AGApplication(VALUE self): AGApplication(), Swig::Director(self) {
    
}



bool SwigDirector_AGApplication::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventKeyDown(AGEvent *m2) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventKeyDown(m2);
    }
    obj0 = SWIG_NewPointerObj((void *) m2, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


bool SwigDirector_AGApplication::eventFrame(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrame(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrame"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventFrameEnd(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrameEnd(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrameEnd"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::eventChangedRes() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::eventChangedRes();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventChangedRes"), 0, NULL);
}


SwigDirector_AGApplication::~SwigDirector_AGApplication() {
}

bool SwigDirector_AGApplication::eventIdle() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventIdle();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventIdle"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::tryQuit() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::tryQuit();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("tryQuit"), 0, NULL);
}


Uint8 SwigDirector_AGApplication::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


AGVector2 SwigDirector_AGApplication::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


void SwigDirector_AGApplication::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_AGApplication::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


SwigDirector_AGButton::SwigDirector_AGButton(VALUE self, AGWidget *pParent, AGRect2 const &r, std::string const &pText, int id): AGButton(pParent, r, pText, id), Swig::Director(self) {
    
}



bool SwigDirector_AGButton::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


void SwigDirector_AGButton::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGButton::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGButton::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGButton::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGButton::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGButton::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


float SwigDirector_AGButton::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGButton::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


AGRect2 SwigDirector_AGButton::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGButton::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGButton::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGButton::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


std::string SwigDirector_AGButton::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGButton::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGButton::~SwigDirector_AGButton() {
}

bool SwigDirector_AGButton::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_AGButton::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGButton::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGButton::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGButton::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGButton::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGButton::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGButton::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGText::SwigDirector_AGText(VALUE self, AGWidget *pParent, AGRect2 const &pRect, std::string const &pText, AGFont const &pFont): AGText(pParent, pRect, pText, pFont), Swig::Director(self) {
    
}



bool SwigDirector_AGText::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGText::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGText::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGText::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGText::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGText::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGText::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGText::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGText::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGText::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGText::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGText::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGText::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGText::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGText::~SwigDirector_AGText() {
}

bool SwigDirector_AGText::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGText::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGText::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGText::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGText::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGText::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGText::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGText::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGText::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGCaption::SwigDirector_AGCaption(VALUE self, AGWidget *pParent, AGRect2 const &pRect, std::string const &pText, AGFont const &pFont, AGBackground const &pBG): AGCaption(pParent, pRect, pText, pFont, pBG), Swig::Director(self) {
    
}



bool SwigDirector_AGCaption::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGCaption::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGCaption::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGCaption::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGCaption::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGCaption::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGCaption::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGCaption::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGCaption::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGCaption::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGCaption::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGCaption::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGCaption::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGCaption::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCaption::~SwigDirector_AGCaption() {
}

bool SwigDirector_AGCaption::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGCaption::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGCaption::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGCaption::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGCaption::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGCaption::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGCaption::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGCaption::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGCaption::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGCheckBox::SwigDirector_AGCheckBox(VALUE self, AGWidget *pParent, AGRect2 pRect): AGCheckBox(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGCheckBox::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


void SwigDirector_AGCheckBox::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGCheckBox::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGCheckBox::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGCheckBox::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGCheckBox::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGCheckBox::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


float SwigDirector_AGCheckBox::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGCheckBox::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


AGRect2 SwigDirector_AGCheckBox::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGCheckBox::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGCheckBox::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGCheckBox::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


std::string SwigDirector_AGCheckBox::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGCheckBox::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCheckBox::~SwigDirector_AGCheckBox() {
}

bool SwigDirector_AGCheckBox::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGCheckBox::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_AGCheckBox::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGCheckBox::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGCheckBox::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGCheckBox::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGCheckBox::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGCheckBox::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGCheckBox::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGEditLine::SwigDirector_AGEditLine(VALUE self, std::string const &pText, AGFont pFont, bool pHardEnd): AGEditLine(pText, pFont, pHardEnd), Swig::Director(self) {
    
}



SwigDirector_AGEditLine::~SwigDirector_AGEditLine() {
}

void SwigDirector_AGEditLine::draw(AGPainter &p, AGVector2 const &pPoint, AGRect2 const &pClip) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEditLine::draw(p,pPoint,pClip);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    obj1 = SWIG_NewPointerObj((void *) &pPoint, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &pClip, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGEditLine::drawCursor(AGPainter &p, int cx, AGVector2 const &pPoint, AGRect2 const &pClip, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEditLine::drawCursor(p,cx,pPoint,pClip,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    obj1 = INT2NUM(cx);
    obj2 = SWIG_NewPointerObj((void *) &pPoint, SWIGTYPE_p_AGVector2,0);
    obj3 = SWIG_NewPointerObj((void *) &pClip, SWIGTYPE_p_AGRect2,0);
    obj4 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawCursor"), 5,obj0,obj1,obj2,obj3,obj4);
}


SwigDirector_AGEdit::SwigDirector_AGEdit(VALUE self, AGWidget *pParent, AGRect2 const &pRect): AGEdit(pParent, pRect), Swig::Director(self) {
    
}



void SwigDirector_AGEdit::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGEdit::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGEdit::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGEdit::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGEdit::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGEdit::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


float SwigDirector_AGEdit::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGEdit::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


AGRect2 SwigDirector_AGEdit::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGEdit::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGEdit::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGEdit::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGEdit::~SwigDirector_AGEdit() {
}

bool SwigDirector_AGEdit::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGEdit::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGEdit::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGEdit::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGEdit::drawBackground(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::drawBackground(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawBackground"), 1,obj0);
}


bool SwigDirector_AGEdit::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGEdit::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGEdit::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGEdit::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGPaintTarget::SwigDirector_AGPaintTarget(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_AGPaintTarget::fillRects(std::vector<std::pair<AGRect2,AGVector4 > > const &pr) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRects(pr);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_std__vectorTstd__pairTAGRect2_AGVector4_t_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRects"), 1,obj0);
}


AGRect2 SwigDirector_AGPaintTarget::getRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGPaintTarget::getRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


SwigDirector_AGPaintTarget::~SwigDirector_AGPaintTarget() {
}

void SwigDirector_AGPaintTarget::drawLine(AGVector2 const &p0, AGVector2 const &p1, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p0, SWIGTYPE_p_AGVector2,0);
    obj1 = SWIG_NewPointerObj((void *) &p1, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPaintTarget::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGTriangle2,0);
    obj2 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGTriangle2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPaintTarget::fillRect(AGRect2 const &pr, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRect(pr,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRect"), 2,obj0,obj1);
}


void SwigDirector_AGPaintTarget::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


AGColor SwigDirector_AGPaintTarget::getPixel(int x, int y) const {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGPaintTarget::getPixel(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("getPixel"), 2,obj0,obj1);
    {
        AGColor *b;
        Data_Get_Struct(result,AGColor,b);
        c_result=*b;
    }
    return (AGColor) c_result;
}


void SwigDirector_AGPaintTarget::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGPaintTarget::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPaintTarget::blit(AGSurface const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPaintTarget::beginPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::beginPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("beginPaint"), 0, NULL);
}


void SwigDirector_AGPaintTarget::endPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::endPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("endPaint"), 0, NULL);
}


SwigDirector_AGDecryptor::SwigDirector_AGDecryptor(VALUE self) : Swig::Director(self) {
    
}



SwigDirector_AGDecryptor::~SwigDirector_AGDecryptor() {
}

std::string SwigDirector_AGDecryptor::decrypt(std::string const &s, std::string const &n) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDecryptor::decrypt(s,n);
    }
    obj0=rb_str_new2(s.c_str());
    obj1=rb_str_new2(n.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("decrypt"), 2,obj0,obj1);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self): AGSurface(), Swig::Director(self) {
    
}



SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self, int w, int h): AGSurface(w, h), Swig::Director(self) {
    
}



SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self, AGSurface const &p): AGSurface(p), Swig::Director(self) {
    
}



void SwigDirector_AGSurface::endPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::endPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("endPaint"), 0, NULL);
}


void SwigDirector_AGSurface::beginPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::beginPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("beginPaint"), 0, NULL);
}


void SwigDirector_AGSurface::drawLine(AGVector2 const &p0, AGVector2 const &p1, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p0, SWIGTYPE_p_AGVector2,0);
    obj1 = SWIG_NewPointerObj((void *) &p1, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


SwigDirector_AGSurface::~SwigDirector_AGSurface() {
}

AGRect2 SwigDirector_AGSurface::getRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSurface::getRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGColor SwigDirector_AGSurface::getPixel(int x, int y) const {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSurface::getPixel(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("getPixel"), 2,obj0,obj1);
    {
        AGColor *b;
        Data_Get_Struct(result,AGColor,b);
        c_result=*b;
    }
    return (AGColor) c_result;
}


void SwigDirector_AGSurface::fillRects(std::vector<std::pair<AGRect2,AGVector4 > > const &pr) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRects(pr);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_std__vectorTstd__pairTAGRect2_AGVector4_t_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRects"), 1,obj0);
}


void SwigDirector_AGSurface::blit(AGSurface const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGSurface::blit(AGSurface const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGSurface::fillRect(AGRect2 const &pr, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRect(pr,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRect"), 2,obj0,obj1);
}


void SwigDirector_AGSurface::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGTriangle2,0);
    obj2 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGTriangle2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


SwigDirector_AGTexture::SwigDirector_AGTexture(VALUE self): AGTexture(), Swig::Director(self) {
    
}



SwigDirector_AGTexture::SwigDirector_AGTexture(VALUE self, AGSurface const &pSurface, bool p3d): AGTexture(pSurface, p3d), Swig::Director(self) {
    
}



SwigDirector_AGTexture::SwigDirector_AGTexture(VALUE self, AGTexture const &t): AGTexture(t), Swig::Director(self) {
    
}



SwigDirector_AGTexture::SwigDirector_AGTexture(VALUE self, int W, int H): AGTexture(W, H), Swig::Director(self) {
    
}



void SwigDirector_AGTexture::endPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::endPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("endPaint"), 0, NULL);
}


void SwigDirector_AGTexture::beginPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::beginPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("beginPaint"), 0, NULL);
}


void SwigDirector_AGTexture::drawLine(AGVector2 const &p0, AGVector2 const &p1, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p0, SWIGTYPE_p_AGVector2,0);
    obj1 = SWIG_NewPointerObj((void *) &p1, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


SwigDirector_AGTexture::~SwigDirector_AGTexture() {
}

void SwigDirector_AGTexture::drawGradientAlpha(AGRect2 const &rect, AGColor const &ul, AGColor const &ur, AGColor const &dl, AGColor const &dr) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::drawGradientAlpha(rect,ul,ur,dl,dr);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &rect, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &ul, SWIGTYPE_p_AGColor,0);
    obj2 = SWIG_NewPointerObj((void *) &ur, SWIGTYPE_p_AGColor,0);
    obj3 = SWIG_NewPointerObj((void *) &dl, SWIGTYPE_p_AGColor,0);
    obj4 = SWIG_NewPointerObj((void *) &dr, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawGradientAlpha"), 5,obj0,obj1,obj2,obj3,obj4);
}


AGColor SwigDirector_AGTexture::getPixel(int x, int y) const {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGTexture::getPixel(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("getPixel"), 2,obj0,obj1);
    {
        AGColor *b;
        Data_Get_Struct(result,AGColor,b);
        c_result=*b;
    }
    return (AGColor) c_result;
}


AGRect2 SwigDirector_AGTexture::getRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGTexture::getRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


void SwigDirector_AGTexture::drawGradient(AGRect2 const &rect, AGColor const &ul, AGColor const &ur, AGColor const &dl, AGColor const &dr) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::drawGradient(rect,ul,ur,dl,dr);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &rect, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &ul, SWIGTYPE_p_AGColor,0);
    obj2 = SWIG_NewPointerObj((void *) &ur, SWIGTYPE_p_AGColor,0);
    obj3 = SWIG_NewPointerObj((void *) &dl, SWIGTYPE_p_AGColor,0);
    obj4 = SWIG_NewPointerObj((void *) &dr, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawGradient"), 5,obj0,obj1,obj2,obj3,obj4);
}


void SwigDirector_AGTexture::fillRects(std::vector<std::pair<AGRect2,AGVector4 > > const &pr) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRects(pr);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_std__vectorTstd__pairTAGRect2_AGVector4_t_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRects"), 1,obj0);
}


void SwigDirector_AGTexture::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGTexture::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGTexture::blit(AGSurface const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGTexture::fillRect(AGRect2 const &pRect, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::fillRect(pRect,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pRect, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRect"), 2,obj0,obj1);
}


void SwigDirector_AGTexture::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTexture::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGTexture::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGTriangle2,0);
    obj2 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGTriangle2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


SwigDirector_AGImage::SwigDirector_AGImage(VALUE self, AGWidget *pParent, AGRect2 const &r, AGSurface pSurface, bool pTile, AGRect2 const &pRect): AGImage(pParent, r, pSurface, pTile, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGImage::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGImage::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGImage::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGImage::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGImage::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGImage::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGImage::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGImage::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGImage::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGImage::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGImage::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGImage::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGImage::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGImage::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGImage::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGImage::~SwigDirector_AGImage() {
}

bool SwigDirector_AGImage::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGImage::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGImage::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGImage::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGImage::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGImage::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGImage::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGImage::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGImage::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGLayoutCreator::SwigDirector_AGLayoutCreator(VALUE self, std::string const &pName): AGLayoutCreator(pName), Swig::Director(self) {
    
}



SwigDirector_AGLayoutCreator::~SwigDirector_AGLayoutCreator() {
}

AGWidget *SwigDirector_AGLayoutCreator::create(AGWidget *pParent, AGRect2 const &pRect, xmlpp::Node const &pNode) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    AGWidget *c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGLayoutCreator::create(pParent,pRect,pNode);
    }
    obj0 = SWIG_NewPointerObj((void *) pParent, SWIGTYPE_p_AGWidget,0);
    obj1 = SWIG_NewPointerObj((void *) &pRect, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pNode, SWIGTYPE_p_Node,0);
    result = rb_funcall(swig_get_self(), rb_intern("create"), 3,obj0,obj1,obj2);
    if ((SWIG_ConvertPtr(result,(void **) &c_result, SWIGTYPE_p_AGWidget,SWIG_POINTER_EXCEPTION | 0 )) == -1) throw Swig::DirectorTypeMismatchException("Pointer conversion failed.");
    return (AGWidget *) c_result;
}


SwigDirector_AGListBox::SwigDirector_AGListBox(VALUE self, AGWidget *pParent, AGRect2 const &pRect): AGListBox(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGListBox::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGListBox::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGListBox::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGListBox::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGListBox::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGListBox::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGListBox::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGListBox::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGListBox::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGListBox::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGListBox::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGListBox::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGListBox::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGListBox::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGListBox::~SwigDirector_AGListBox() {
}

bool SwigDirector_AGListBox::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListBox::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListBox::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGListBox::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGListBox::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGListBox::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGListBox::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGListBox::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGListBox::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGListBox::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGListBox::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGMain::SwigDirector_AGMain(VALUE self, int w, int h, int d, bool fs, bool gl): AGMain(w, h, d, fs, gl), Swig::Director(self) {
    
}



SwigDirector_AGMain::~SwigDirector_AGMain() {
}

SwigDirector_AGMenuItem::SwigDirector_AGMenuItem(VALUE self, AGWidget *pParent, std::string const &pText): AGMenuItem(pParent, pText), Swig::Director(self) {
    
}



bool SwigDirector_AGMenuItem::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGMenuItem::~SwigDirector_AGMenuItem() {
}

bool SwigDirector_AGMenuItem::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenuItem::eventSelect() {
    VALUE result;
    
    if (swig_get_up()) {
        AGMenuItem::eventSelect();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSelect"), 0, NULL);
}


void SwigDirector_AGMenuItem::eventUnselect() {
    VALUE result;
    
    if (swig_get_up()) {
        AGMenuItem::eventUnselect();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventUnselect"), 0, NULL);
}


bool SwigDirector_AGMenuItem::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSubMenu::SwigDirector_AGSubMenu(VALUE self, AGWidget *pParent, std::string const &ptext): AGSubMenu(pParent, ptext), Swig::Director(self) {
    
}



bool SwigDirector_AGSubMenu::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSubMenu::~SwigDirector_AGSubMenu() {
}

bool SwigDirector_AGSubMenu::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMenuItem::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSubMenu::eventSelect() {
    VALUE result;
    
    if (swig_get_up()) {
        AGSubMenu::eventSelect();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSelect"), 0, NULL);
}


void SwigDirector_AGSubMenu::eventUnselect() {
    VALUE result;
    
    if (swig_get_up()) {
        AGSubMenu::eventUnselect();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventUnselect"), 0, NULL);
}


bool SwigDirector_AGSubMenu::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSubMenu::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSound::SwigDirector_AGSound(VALUE self): AGSound(), Swig::Director(self) {
    
}



bool SwigDirector_AGSound::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGSound::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGSound::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGSound::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGSound::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGSound::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGSound::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGSound::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGSound::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGSound::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGSound::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGSound::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGSound::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGSound::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSound::~SwigDirector_AGSound() {
}

bool SwigDirector_AGSound::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGSound::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGSound::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGSound::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGSound::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGSound::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGSound::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGSound::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGRadioGroup::SwigDirector_AGRadioGroup(VALUE self, AGWidget *pParent, AGRect2 const &pr): AGRadioGroup(pParent, pr), Swig::Director(self) {
    
}



bool SwigDirector_AGRadioGroup::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGRadioGroup::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGRadioGroup::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGRadioGroup::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGRadioGroup::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGRadioGroup::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGRadioGroup::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGRadioGroup::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGRadioGroup::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGRadioGroup::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGRadioGroup::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::eventChange(std::string const &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGRadioGroup::eventChange(p);
        return;
    }
    obj0=rb_str_new2(p.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("eventChange"), 1,obj0);
}


SwigDirector_AGRadioGroup::~SwigDirector_AGRadioGroup() {
}

bool SwigDirector_AGRadioGroup::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGRadioGroup::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGRadioGroup::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGRadioGroup::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGRadioGroup::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGRadioGroup::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGRadioGroup::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGRadioGroup::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGRadio::SwigDirector_AGRadio(VALUE self, AGWidget *pParent, AGRect2 pRect): AGRadio(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGRadio::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


void SwigDirector_AGRadio::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGRadio::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGRadio::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGRadio::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGRadio::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGRadio::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGRadio::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


float SwigDirector_AGRadio::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGRadio::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


AGRect2 SwigDirector_AGRadio::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGRadio::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGRadio::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGRadio::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


std::string SwigDirector_AGRadio::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGRadio::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGRadio::~SwigDirector_AGRadio() {
}

bool SwigDirector_AGRadio::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGRadio::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_AGRadio::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGRadio::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGRadio::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGRadio::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGRadio::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGRadio::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGRadio::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGScreen::SwigDirector_AGScreen(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_AGScreen::endPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::endPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("endPaint"), 0, NULL);
}


void SwigDirector_AGScreen::beginPaint() {
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::beginPaint();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("beginPaint"), 0, NULL);
}


void SwigDirector_AGScreen::drawLine(AGVector2 const &p0, AGVector2 const &p1, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p0, SWIGTYPE_p_AGVector2,0);
    obj1 = SWIG_NewPointerObj((void *) &p1, SWIGTYPE_p_AGVector2,0);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


SwigDirector_AGScreen::~SwigDirector_AGScreen() {
}

AGColor SwigDirector_AGScreen::getPixel(int x, int y) const {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGPaintTarget::getPixel(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("getPixel"), 2,obj0,obj1);
    {
        AGColor *b;
        Data_Get_Struct(result,AGColor,b);
        c_result=*b;
    }
    return (AGColor) c_result;
}


AGRect2 SwigDirector_AGScreen::getRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGPaintTarget::getRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


size_t SwigDirector_AGScreen::getWidth() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGScreen::getWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getWidth"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


size_t SwigDirector_AGScreen::getHeight() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGScreen::getHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getHeight"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_AGScreen::fillRects(std::vector<std::pair<AGRect2,AGVector4 > > const &pr) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRects(pr);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_std__vectorTstd__pairTAGRect2_AGVector4_t_t,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRects"), 1,obj0);
}


void SwigDirector_AGScreen::begin() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::begin();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("begin"), 0, NULL);
}


void SwigDirector_AGScreen::blit(AGSurface const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGSurface,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGScreen::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGScreen::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc, AGColor const &pColor) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGRect2,0);
    obj2 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGRect2,0);
    obj3 = SWIG_NewPointerObj((void *) &pColor, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGScreen::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGScreen::fillRect(AGRect2 const &pr, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::fillRect(pr,c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pr, SWIGTYPE_p_AGRect2,0);
    obj1 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_p_AGColor,0);
    result = rb_funcall(swig_get_self(), rb_intern("fillRect"), 2,obj0,obj1);
}


void SwigDirector_AGScreen::flip() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::flip();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("flip"), 0, NULL);
}


void SwigDirector_AGScreen::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPaintTarget::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pSource, SWIGTYPE_p_AGTexture,0);
    obj1 = SWIG_NewPointerObj((void *) &pSrc, SWIGTYPE_p_AGTriangle2,0);
    obj2 = SWIG_NewPointerObj((void *) &pDest, SWIGTYPE_p_AGTriangle2,0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


SwigDirector_AGTable::SwigDirector_AGTable(VALUE self, AGWidget *pWidget, AGRect2 const &pRect): AGTable(pWidget, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGTable::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGTable::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGTable::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGTable::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_AGTable::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGTable::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


float SwigDirector_AGTable::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGTable::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGTable::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGTable::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_AGTable::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGTable::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGTable::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGTable::~SwigDirector_AGTable() {
}

bool SwigDirector_AGTable::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGTable::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGTable::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGTable::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGTable::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGTable::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGTable::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGTable::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_AGTheme::SwigDirector_AGTheme(VALUE self): AGTheme(), Swig::Director(self) {
    
}



SwigDirector_AGTheme::~SwigDirector_AGTheme() {
}

SwigDirector_AGWindow::SwigDirector_AGWindow(VALUE self, AGWidget *pWidget, AGRect2 const &pRect, std::string const &pTitle, std::string const &pTheme): AGWindow(pWidget, pRect, pTitle, pTheme), Swig::Director(self) {
    
}



bool SwigDirector_AGWindow::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_AGWindow::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGWindow::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGWindow::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


void SwigDirector_AGWindow::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGWindow::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


bool SwigDirector_AGWindow::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_AGWindow::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_AGWindow::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_AGWindow::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGVector2 SwigDirector_AGWindow::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_AGWindow::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_AGWindow::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_AGWindow::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


SwigDirector_AGWindow::~SwigDirector_AGWindow() {
}

bool SwigDirector_AGWindow::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AGWindow::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGWindow::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_AGWindow::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_AGWindow::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGWindow::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGWindow::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWindow::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGWindow::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_SceneNode::SwigDirector_SceneNode(VALUE self, Scene *s, AGVector4 const &pPos, AGBox3 const &pBox): SceneNode(s, pPos, pBox), Swig::Director(self) {
    
}



void SwigDirector_SceneNode::setPos(AGVector3 const &pPos) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setPos(pPos);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pPos, SWIGTYPE_p_AGVector3,0);
    result = rb_funcall(swig_get_self(), rb_intern("setPos"), 1,obj0);
}


bool SwigDirector_SceneNode::transparent() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::transparent();
    }
    result = rb_funcall(swig_get_self(), rb_intern("transparent"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_SceneNode::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_SceneNode::setRotation(float r) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setRotation(r);
        return;
    }
    obj0 = rb_float_new(r);
    result = rb_funcall(swig_get_self(), rb_intern("setRotation"), 1,obj0);
}


void SwigDirector_SceneNode::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_SceneNode::sort(AGVector4 const &pCamera) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pCamera, SWIGTYPE_p_AGVector4,0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_SceneNode::drawPick() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawPick();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawPick"), 0, NULL);
}


void SwigDirector_SceneNode::resetScene() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::resetScene();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("resetScene"), 0, NULL);
}


SwigDirector_SceneNode::~SwigDirector_SceneNode() {
}

size_t SwigDirector_SceneNode::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


AGVector4 SwigDirector_SceneNode::lineHit(AGLine3 const &pLine) const {
    VALUE obj0 = Qnil ;
    AGVector4 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::lineHit(pLine);
    }
    obj0 = SWIG_NewPointerObj((void *) &pLine, SWIGTYPE_p_AGLine3,0);
    result = rb_funcall(swig_get_self(), rb_intern("lineHit"), 1,obj0);
    {
        AGVector4 *b;
        Data_Get_Struct(result,AGVector4,b);
        c_result=*b;
    }
    return (AGVector4) c_result;
}


void SwigDirector_SceneNode::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_SceneNode::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


void SwigDirector_SceneNode::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


SwigDirector_AnimMesh::SwigDirector_AnimMesh(VALUE self, Scene *pScene, AnimMeshData *data): AnimMesh(pScene, data), Swig::Director(self) {
    
}



void SwigDirector_AnimMesh::setPos(AGVector3 const &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AnimMesh::setPos(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGVector3,0);
    result = rb_funcall(swig_get_self(), rb_intern("setPos"), 1,obj0);
}


void SwigDirector_AnimMesh::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AnimMesh::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


bool SwigDirector_AnimMesh::transparent() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::transparent();
    }
    result = rb_funcall(swig_get_self(), rb_intern("transparent"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AnimMesh::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AnimMesh::setRotation(float r) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AnimMesh::setRotation(r);
        return;
    }
    obj0 = rb_float_new(r);
    result = rb_funcall(swig_get_self(), rb_intern("setRotation"), 1,obj0);
}


void SwigDirector_AnimMesh::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AnimMesh::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_AnimMesh::sort(AGVector4 const &pCamera) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pCamera, SWIGTYPE_p_AGVector4,0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_AnimMesh::drawPick() {
    VALUE result;
    
    if (swig_get_up()) {
        AnimMesh::drawPick();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawPick"), 0, NULL);
}


void SwigDirector_AnimMesh::resetScene() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::resetScene();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("resetScene"), 0, NULL);
}


SwigDirector_AnimMesh::~SwigDirector_AnimMesh() {
}

size_t SwigDirector_AnimMesh::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AnimMesh::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


AGVector4 SwigDirector_AnimMesh::lineHit(AGLine3 const &pLine) const {
    VALUE obj0 = Qnil ;
    AGVector4 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::lineHit(pLine);
    }
    obj0 = SWIG_NewPointerObj((void *) &pLine, SWIGTYPE_p_AGLine3,0);
    result = rb_funcall(swig_get_self(), rb_intern("lineHit"), 1,obj0);
    {
        AGVector4 *b;
        Data_Get_Struct(result,AGVector4,b);
        c_result=*b;
    }
    return (AGVector4) c_result;
}


void SwigDirector_AnimMesh::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


void SwigDirector_AnimMesh::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        AnimMesh::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_AnimMesh::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        AnimMesh::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


SwigDirector_AnimMeshData::SwigDirector_AnimMeshData(VALUE self, std::string const &xmlfile): AnimMeshData(xmlfile), Swig::Director(self) {
    
}



SwigDirector_AnimMeshData::~SwigDirector_AnimMeshData() {
}

SwigDirector_GLApp::SwigDirector_GLApp(VALUE self, int w, int h): GLApp(w, h), Swig::Director(self) {
    
}



bool SwigDirector_GLApp::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_GLApp::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        GLApp::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


bool SwigDirector_GLApp::eventFrameEnd(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrameEnd(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrameEnd"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventFrame(float t) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventFrame(t);
    }
    obj0 = rb_float_new(t);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrame"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_GLApp::eventChangedRes() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::eventChangedRes();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventChangedRes"), 0, NULL);
}


void SwigDirector_GLApp::eventClick(Scene::PickResult const &pNodes, int button) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        GLApp::eventClick(pNodes,button);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pNodes, SWIGTYPE_p_std__vectorTPickNode_t,0);
    obj1 = INT2NUM(button);
    result = rb_funcall(swig_get_self(), rb_intern("eventClick"), 2,obj0,obj1);
}


void SwigDirector_GLApp::eventHover(Scene::PickResult const &pNodes, int button) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        GLApp::eventHover(pNodes,button);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pNodes, SWIGTYPE_p_std__vectorTPickNode_t,0);
    obj1 = INT2NUM(button);
    result = rb_funcall(swig_get_self(), rb_intern("eventHover"), 2,obj0,obj1);
}


SwigDirector_GLApp::~SwigDirector_GLApp() {
}

bool SwigDirector_GLApp::eventIdle() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventIdle();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventIdle"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_GLApp::tryQuit() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::tryQuit();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("tryQuit"), 0, NULL);
}


Uint8 SwigDirector_GLApp::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


AGVector2 SwigDirector_GLApp::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


void SwigDirector_GLApp::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


void SwigDirector_GLApp::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        GLApp::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_GLApp::setCamera(AGVector2 const &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        GLApp::setCamera(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("setCamera"), 1,obj0);
}


SwigDirector_BinaryIn::SwigDirector_BinaryIn(VALUE self): BinaryIn(), Swig::Director(self) {
    
}



char SwigDirector_BinaryIn::read() {
    char c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return BinaryIn::read();
    }
    result = rb_funcall(swig_get_self(), rb_intern("read"), 0, NULL);
    c_result = (char) NUM2INT(result);
    return (char) c_result;
}


SwigDirector_BinaryIn::~SwigDirector_BinaryIn() {
}

bool SwigDirector_BinaryIn::eof() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return BinaryIn::eof();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eof"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_BinaryOut::SwigDirector_BinaryOut(VALUE self): BinaryOut(), Swig::Director(self) {
    
}



SwigDirector_BinaryOut::~SwigDirector_BinaryOut() {
}

void SwigDirector_BinaryOut::write(char c) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        BinaryOut::write(c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_char,0);
    result = rb_funcall(swig_get_self(), rb_intern("write"), 1,obj0);
}


SwigDirector_BinaryFileIn::SwigDirector_BinaryFileIn(VALUE self, std::string const &pName): BinaryFileIn(pName), Swig::Director(self) {
    
}



char SwigDirector_BinaryFileIn::read() {
    char c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return BinaryFileIn::read();
    }
    result = rb_funcall(swig_get_self(), rb_intern("read"), 0, NULL);
    c_result = (char) NUM2INT(result);
    return (char) c_result;
}


SwigDirector_BinaryFileIn::~SwigDirector_BinaryFileIn() {
}

bool SwigDirector_BinaryFileIn::eof() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return BinaryFileIn::eof();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eof"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_BinaryFileOut::SwigDirector_BinaryFileOut(VALUE self, std::string const &pName): BinaryFileOut(pName), Swig::Director(self) {
    
}



SwigDirector_BinaryFileOut::~SwigDirector_BinaryFileOut() {
}

void SwigDirector_BinaryFileOut::write(char c) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        BinaryFileOut::write(c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_char,0);
    result = rb_funcall(swig_get_self(), rb_intern("write"), 1,obj0);
}


SwigDirector_BinaryStringIn::SwigDirector_BinaryStringIn(VALUE self, std::string const &pText): BinaryStringIn(pText), Swig::Director(self) {
    
}



char SwigDirector_BinaryStringIn::read() {
    char c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return BinaryStringIn::read();
    }
    result = rb_funcall(swig_get_self(), rb_intern("read"), 0, NULL);
    c_result = (char) NUM2INT(result);
    return (char) c_result;
}


SwigDirector_BinaryStringIn::~SwigDirector_BinaryStringIn() {
}

bool SwigDirector_BinaryStringIn::eof() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return BinaryStringIn::eof();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eof"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_BinaryStringOut::SwigDirector_BinaryStringOut(VALUE self): BinaryStringOut(), Swig::Director(self) {
    
}



SwigDirector_BinaryStringOut::~SwigDirector_BinaryStringOut() {
}

void SwigDirector_BinaryStringOut::write(char c) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        BinaryStringOut::write(c);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &c, SWIGTYPE_char,0);
    result = rb_funcall(swig_get_self(), rb_intern("write"), 1,obj0);
}


SwigDirector_AntEntity::SwigDirector_AntEntity(VALUE self): AntEntity(), Swig::Director(self) {
    
}



SwigDirector_AntEntity::SwigDirector_AntEntity(VALUE self, AGVector3 const &p): AntEntity(p), Swig::Director(self) {
    
}



SwigDirector_AntEntity::SwigDirector_AntEntity(VALUE self, AGVector2 const &p): AntEntity(p), Swig::Director(self) {
    
}



void SwigDirector_AntEntity::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


void SwigDirector_AntEntity::animationEvent(std::string const &pName) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::animationEvent(pName);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("animationEvent"), 1,obj0);
}


void SwigDirector_AntEntity::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_AntEntity::move(float pTime) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::move(pTime);
        return;
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("move"), 1,obj0);
}


void SwigDirector_AntEntity::eventNoJob() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventNoJob();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventNoJob"), 0, NULL);
}


void SwigDirector_AntEntity::delJob() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::delJob();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("delJob"), 0, NULL);
}


void SwigDirector_AntEntity::eventGotNewJob() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventGotNewJob();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotNewJob"), 0, NULL);
}


void SwigDirector_AntEntity::newFetchJob(int p, AntEntity *pTarget, std::string const &pWhat) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newFetchJob(p,pTarget,pWhat);
        return;
    }
    obj0 = INT2NUM(p);
    obj1 = SWIG_NewPointerObj((void *) pTarget, SWIGTYPE_p_AntEntity,0);
    obj2=rb_str_new2(pWhat.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("newFetchJob"), 3,obj0,obj1,obj2);
}


void SwigDirector_AntEntity::newFetchJob(int p, AGVector2 &pTarget, std::string const &pWhat) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newFetchJob(p,pTarget,pWhat);
        return;
    }
    obj0 = INT2NUM(p);
    obj1 = SWIG_NewPointerObj((void *) &pTarget, SWIGTYPE_p_AGVector2,0);
    obj2=rb_str_new2(pWhat.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("newFetchJob"), 3,obj0,obj1,obj2);
}


SwigDirector_AntEntity::~SwigDirector_AntEntity() {
}

void SwigDirector_AntEntity::newMoveJob(int p, AGVector2 const &pTarget, int pnear) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newMoveJob(p,pTarget,pnear);
        return;
    }
    obj0 = INT2NUM(p);
    obj1 = SWIG_NewPointerObj((void *) &pTarget, SWIGTYPE_p_AGVector2,0);
    obj2 = INT2NUM(pnear);
    result = rb_funcall(swig_get_self(), rb_intern("newMoveJob"), 3,obj0,obj1,obj2);
}


std::string SwigDirector_AntEntity::xmlName() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AntEntity::xmlName();
    }
    result = rb_funcall(swig_get_self(), rb_intern("xmlName"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


void SwigDirector_AntEntity::resourceChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::resourceChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("resourceChanged"), 0, NULL);
}


void SwigDirector_AntEntity::eventJobFinished() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventJobFinished();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventJobFinished"), 0, NULL);
}


void SwigDirector_AntEntity::eventDefeated() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventDefeated();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventDefeated"), 0, NULL);
}


void SwigDirector_AntEntity::eventDie() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventDie();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventDie"), 0, NULL);
}


void SwigDirector_AntEntity::loadXML(xmlpp::Node const &node) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::loadXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &node, SWIGTYPE_p_Node,0);
    result = rb_funcall(swig_get_self(), rb_intern("loadXML"), 1,obj0);
}


void SwigDirector_AntEntity::saveXML(xmlpp::Node &node) const {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::saveXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &node, SWIGTYPE_p_Node,0);
    result = rb_funcall(swig_get_self(), rb_intern("saveXML"), 1,obj0);
}


void SwigDirector_AntEntity::newFightJob(int p, AntEntity *target) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newFightJob(p,target);
        return;
    }
    obj0 = INT2NUM(p);
    obj1 = SWIG_NewPointerObj((void *) target, SWIGTYPE_p_AntEntity,0);
    result = rb_funcall(swig_get_self(), rb_intern("newFightJob"), 2,obj0,obj1);
}


void SwigDirector_AntEntity::eventGotFight(AntEntity *pOther) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventGotFight(pOther);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) pOther, SWIGTYPE_p_AntEntity,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFight"), 1,obj0);
}


void SwigDirector_AntEntity::setPos(AGVector2 const &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::setPos(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("setPos"), 1,obj0);
}


void SwigDirector_AntEntity::newRestJob(int pTime) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newRestJob(pTime);
        return;
    }
    obj0 = INT2NUM(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("newRestJob"), 1,obj0);
}


SwigDirector_AntShaderProgram::SwigDirector_AntShaderProgram(VALUE self, std::string const &pVertexFile, std::string const &pFragFile): AntShaderProgram(pVertexFile, pFragFile), Swig::Director(self) {
    
}



void SwigDirector_AntShaderProgram::doUpdate(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntShaderProgram::doUpdate(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("doUpdate"), 1,obj0);
}


SwigDirector_AntShaderProgram::~SwigDirector_AntShaderProgram() {
}

void SwigDirector_AntShaderProgram::enable() {
    VALUE result;
    
    if (swig_get_up()) {
        AntShaderProgram::enable();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("enable"), 0, NULL);
}


void SwigDirector_AntShaderProgram::disable() {
    VALUE result;
    
    if (swig_get_up()) {
        AntShaderProgram::disable();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("disable"), 0, NULL);
}


SwigDirector_AntShadowShader::SwigDirector_AntShadowShader(VALUE self, std::string const &pVertexFile, std::string const &pFragFile): AntShadowShader(pVertexFile, pFragFile), Swig::Director(self) {
    
}



void SwigDirector_AntShadowShader::doUpdate(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntShadowShader::doUpdate(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("doUpdate"), 1,obj0);
}


SwigDirector_AntShadowShader::~SwigDirector_AntShadowShader() {
}

void SwigDirector_AntShadowShader::enable() {
    VALUE result;
    
    if (swig_get_up()) {
        AntShadowShader::enable();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("enable"), 0, NULL);
}


void SwigDirector_AntShadowShader::disable() {
    VALUE result;
    
    if (swig_get_up()) {
        AntShadowShader::disable();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("disable"), 0, NULL);
}


SwigDirector_AntWaterShader::SwigDirector_AntWaterShader(VALUE self): AntWaterShader(), Swig::Director(self) {
    
}



void SwigDirector_AntWaterShader::doUpdate(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntWaterShader::doUpdate(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("doUpdate"), 1,obj0);
}


SwigDirector_AntWaterShader::~SwigDirector_AntWaterShader() {
}

void SwigDirector_AntWaterShader::enable() {
    VALUE result;
    
    if (swig_get_up()) {
        AntShaderProgram::enable();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("enable"), 0, NULL);
}


void SwigDirector_AntWaterShader::disable() {
    VALUE result;
    
    if (swig_get_up()) {
        AntShaderProgram::disable();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("disable"), 0, NULL);
}


SwigDirector_HeightMap::SwigDirector_HeightMap(VALUE self, Scene *pScene, int w, int h): HeightMap(pScene, w, h), Swig::Director(self) {
    
}



bool SwigDirector_HeightMap::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_HeightMap::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_HeightMap::~SwigDirector_HeightMap() {
}

Uint8 SwigDirector_HeightMap::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


AGVector2 SwigDirector_HeightMap::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


void SwigDirector_HeightMap::newMap(int w, int h) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        HeightMap::newMap(w,h);
        return;
    }
    obj0 = INT2NUM(w);
    obj1 = INT2NUM(h);
    result = rb_funcall(swig_get_self(), rb_intern("newMap"), 2,obj0,obj1);
}


void SwigDirector_HeightMap::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        HeightMap::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


void SwigDirector_HeightMap::saveXML(Node &node) const {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        HeightMap::saveXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &node, SWIGTYPE_p_Node,0);
    result = rb_funcall(swig_get_self(), rb_intern("saveXML"), 1,obj0);
}


void SwigDirector_HeightMap::loadXML(Node const &node) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        HeightMap::loadXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &node, SWIGTYPE_p_Node,0);
    result = rb_funcall(swig_get_self(), rb_intern("loadXML"), 1,obj0);
}


SwigDirector_AntMap::SwigDirector_AntMap(VALUE self, Scene *pScene, int w, int h): AntMap(pScene, w, h), Swig::Director(self) {
    
}



bool SwigDirector_AntMap::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AntMap::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AntMap::loadMap(std::string const &pFilename) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::loadMap(pFilename);
        return;
    }
    obj0=rb_str_new2(pFilename.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("loadMap"), 1,obj0);
}


void SwigDirector_AntMap::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


void SwigDirector_AntMap::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


SwigDirector_AntMap::~SwigDirector_AntMap() {
}

Uint8 SwigDirector_AntMap::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


AGVector2 SwigDirector_AntMap::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


void SwigDirector_AntMap::newMap(int w, int h) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::newMap(w,h);
        return;
    }
    obj0 = INT2NUM(w);
    obj1 = INT2NUM(h);
    result = rb_funcall(swig_get_self(), rb_intern("newMap"), 2,obj0,obj1);
}


void SwigDirector_AntMap::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


AntEntity *SwigDirector_AntMap::loadEntity(xmlpp::Node const &node) {
    VALUE obj0 = Qnil ;
    AntEntity *c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AntMap::loadEntity(node);
    }
    obj0 = SWIG_NewPointerObj((void *) &node, SWIGTYPE_p_Node,0);
    result = rb_funcall(swig_get_self(), rb_intern("loadEntity"), 1,obj0);
    if ((SWIG_ConvertPtr(result,(void **) &c_result, SWIGTYPE_p_AntEntity,SWIG_POINTER_EXCEPTION | 0 )) == -1) throw Swig::DirectorTypeMismatchException("Pointer conversion failed.");
    return (AntEntity *) c_result;
}


void SwigDirector_AntMap::insertEntity(AntEntity *e) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::insertEntity(e);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) e, SWIGTYPE_p_AntEntity,0);
    result = rb_funcall(swig_get_self(), rb_intern("insertEntity"), 1,obj0);
}


void SwigDirector_AntMap::removeEntity(AntEntity *p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::removeEntity(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) p, SWIGTYPE_p_AntEntity,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeEntity"), 1,obj0);
}


void SwigDirector_AntMap::saveXML(xmlpp::Node &node) const {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::saveXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &node, SWIGTYPE_p_Node,0);
    result = rb_funcall(swig_get_self(), rb_intern("saveXML"), 1,obj0);
}


void SwigDirector_AntMap::loadXML(xmlpp::Node const &node) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::loadXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &node, SWIGTYPE_p_Node,0);
    result = rb_funcall(swig_get_self(), rb_intern("loadXML"), 1,obj0);
}


SwigDirector_MeshData::SwigDirector_MeshData(VALUE self, std::string const &filename, float zoom, std::string const &pTexture, bool pShadow): MeshData(filename, zoom, pTexture, pShadow), Swig::Director(self) {
    
}



SwigDirector_MeshData::SwigDirector_MeshData(VALUE self, VertexArray const &va, std::string const &pTexture, bool pShadow): MeshData(va, pTexture, pShadow), Swig::Director(self) {
    
}



size_t SwigDirector_MeshData::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return MeshData::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


SwigDirector_MeshData::~SwigDirector_MeshData() {
}

AGVector4 SwigDirector_MeshData::lineHit(AGLine3 const &pLine) const {
    VALUE obj0 = Qnil ;
    AGVector4 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return MeshData::lineHit(pLine);
    }
    obj0 = SWIG_NewPointerObj((void *) &pLine, SWIGTYPE_p_AGLine3,0);
    result = rb_funcall(swig_get_self(), rb_intern("lineHit"), 1,obj0);
    {
        AGVector4 *b;
        Data_Get_Struct(result,AGVector4,b);
        c_result=*b;
    }
    return (AGVector4) c_result;
}


bool SwigDirector_MeshData::transparent() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return MeshData::transparent();
    }
    result = rb_funcall(swig_get_self(), rb_intern("transparent"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_Mesh::SwigDirector_Mesh(VALUE self, Scene *pScene): Mesh(pScene), Swig::Director(self) {
    
}



SwigDirector_Mesh::SwigDirector_Mesh(VALUE self, Scene *pScene, MeshData &data, AGVector4 const &pPos, float pRot): Mesh(pScene, data, pPos, pRot), Swig::Director(self) {
    
}



void SwigDirector_Mesh::setPos(AGVector3 const &pPos) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setPos(pPos);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pPos, SWIGTYPE_p_AGVector3,0);
    result = rb_funcall(swig_get_self(), rb_intern("setPos"), 1,obj0);
}


void SwigDirector_Mesh::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        Mesh::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


void SwigDirector_Mesh::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_Mesh::transparent() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return Mesh::transparent();
    }
    result = rb_funcall(swig_get_self(), rb_intern("transparent"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_Mesh::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_Mesh::setRotation(float r) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Mesh::setRotation(r);
        return;
    }
    obj0 = rb_float_new(r);
    result = rb_funcall(swig_get_self(), rb_intern("setRotation"), 1,obj0);
}


void SwigDirector_Mesh::sort(AGVector4 const &pCamera) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pCamera, SWIGTYPE_p_AGVector4,0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_Mesh::drawPick() {
    VALUE result;
    
    if (swig_get_up()) {
        Mesh::drawPick();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawPick"), 0, NULL);
}


void SwigDirector_Mesh::resetScene() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::resetScene();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("resetScene"), 0, NULL);
}


SwigDirector_Mesh::~SwigDirector_Mesh() {
}

size_t SwigDirector_Mesh::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return Mesh::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_Mesh::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        Mesh::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_Mesh::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        Mesh::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_Mesh::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        Mesh::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


AGVector4 SwigDirector_Mesh::lineHit(AGLine3 const &pLine) const {
    VALUE obj0 = Qnil ;
    AGVector4 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return Mesh::lineHit(pLine);
    }
    obj0 = SWIG_NewPointerObj((void *) &pLine, SWIGTYPE_p_AGLine3,0);
    result = rb_funcall(swig_get_self(), rb_intern("lineHit"), 1,obj0);
    {
        AGVector4 *b;
        Data_Get_Struct(result,AGVector4,b);
        c_result=*b;
    }
    return (AGVector4) c_result;
}


SwigDirector_MiniMap::SwigDirector_MiniMap(VALUE self, AGWidget *p, AGRect2 const &r, AntMap *pMap): MiniMap(p, r, pMap), Swig::Director(self) {
    
}



bool SwigDirector_MiniMap::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_MiniMap::useTextures() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::useTextures();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("useTextures"), 0, NULL);
}


bool SwigDirector_MiniMap::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_MiniMap::setLeft(float x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = rb_float_new(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_MiniMap::setTop(float y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = rb_float_new(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_MiniMap::setHeight(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_MiniMap::setWidth(float w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = rb_float_new(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_MiniMap::prepareDraw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::prepareDraw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("prepareDraw"), 0, NULL);
}


bool SwigDirector_MiniMap::eventDragBy(AGEvent *event, AGVector2 const &pDiff) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    obj0 = SWIG_NewPointerObj((void *) event, SWIGTYPE_p_AGEvent,0);
    obj1 = SWIG_NewPointerObj((void *) &pDiff, SWIGTYPE_p_AGVector2,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


float SwigDirector_MiniMap::minHeight() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


float SwigDirector_MiniMap::minWidth() const {
    float c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (float) NUM2DBL(result);
    return (float) c_result;
}


bool SwigDirector_MiniMap::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


AGRect2 SwigDirector_MiniMap::getClientRect() const {
    AGRect2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::getClientRect();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getClientRect"), 0, NULL);
    {
        AGRect2 *b;
        Data_Get_Struct(result,AGRect2,b);
        c_result=*b;
    }
    return (AGRect2) c_result;
}


AGVector2 SwigDirector_MiniMap::getMousePosition() const {
    AGVector2 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getMousePosition();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getMousePosition"), 0, NULL);
    {
        AGVector2 *b;
        Data_Get_Struct(result,AGVector2,b);
        c_result=*b;
    }
    return (AGVector2) c_result;
}


Uint8 SwigDirector_MiniMap::getButtonState() const {
    Uint8 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::getButtonState();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getButtonState"), 0, NULL);
    {
        c_result=NUM2INT(result);
    }
    return (Uint8) c_result;
}


bool SwigDirector_MiniMap::redraw() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::redraw();
    }
    result = rb_funcall(swig_get_self(), rb_intern("redraw"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_MiniMap::~SwigDirector_MiniMap() {
}

bool SwigDirector_MiniMap::eventMouseButtonUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventMouseButtonDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventMouseMotion(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::signal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::acceptEvent(SDL_Event const *pEvent) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj((void *) pEvent, SWIGTYPE_p_SDL_Event,0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventActive(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventKeyDown(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventKeyUp(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventQuit(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventQuitModal(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventSysWM(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventResize(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventMouseClick(AGEvent *m) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return MiniMap::eventMouseClick(m);
    }
    obj0 = SWIG_NewPointerObj((void *) m, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_MiniMap::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_MiniMap::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_MiniMap::drawAfter(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAfter(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAfter"), 1,obj0);
}


void SwigDirector_MiniMap::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        MiniMap::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &p, SWIGTYPE_p_AGPainter,0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


bool SwigDirector_MiniMap::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_MiniMap::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_MiniMap::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_MiniMap::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_MiniMap::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) w, SWIGTYPE_p_AGWidget,0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_MiniMap::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_NewDecal::SwigDirector_NewDecal(VALUE self, Scene *pScene, AGVector2 pos, float size, HeightMap *pMap, std::string const &pTexture): NewDecal(pScene, pos, size, pMap, pTexture), Swig::Director(self) {
    
}



void SwigDirector_NewDecal::setPos(AGVector3 const &pPos) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        NewDecal::setPos(pPos);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pPos, SWIGTYPE_p_AGVector3,0);
    result = rb_funcall(swig_get_self(), rb_intern("setPos"), 1,obj0);
}


bool SwigDirector_NewDecal::transparent() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::transparent();
    }
    result = rb_funcall(swig_get_self(), rb_intern("transparent"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_NewDecal::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_NewDecal::setRotation(float r) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setRotation(r);
        return;
    }
    obj0 = rb_float_new(r);
    result = rb_funcall(swig_get_self(), rb_intern("setRotation"), 1,obj0);
}


void SwigDirector_NewDecal::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_NewDecal::sort(AGVector4 const &pCamera) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pCamera, SWIGTYPE_p_AGVector4,0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_NewDecal::drawPick() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawPick();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawPick"), 0, NULL);
}


void SwigDirector_NewDecal::resetScene() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::resetScene();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("resetScene"), 0, NULL);
}


SwigDirector_NewDecal::~SwigDirector_NewDecal() {
}

size_t SwigDirector_NewDecal::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_NewDecal::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        NewDecal::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


AGVector4 SwigDirector_NewDecal::lineHit(AGLine3 const &pLine) const {
    VALUE obj0 = Qnil ;
    AGVector4 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::lineHit(pLine);
    }
    obj0 = SWIG_NewPointerObj((void *) &pLine, SWIGTYPE_p_AGLine3,0);
    result = rb_funcall(swig_get_self(), rb_intern("lineHit"), 1,obj0);
    {
        AGVector4 *b;
        Data_Get_Struct(result,AGVector4,b);
        c_result=*b;
    }
    return (AGVector4) c_result;
}


void SwigDirector_NewDecal::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


void SwigDirector_NewDecal::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_NewDecal::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        NewDecal::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


SwigDirector_Scene::SwigDirector_Scene(VALUE self, int w, int h): Scene(w, h), Swig::Director(self) {
    
}



void SwigDirector_Scene::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        Scene::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


SwigDirector_Scene::~SwigDirector_Scene() {
}

void SwigDirector_Scene::mark() {
    VALUE result;
    
    if (swig_get_up()) {
        Scene::mark();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mark"), 0, NULL);
}


SwigDirector_Smoke::SwigDirector_Smoke(VALUE self, Scene *pScene, float f): Smoke(pScene, f), Swig::Director(self) {
    
}



void SwigDirector_Smoke::setPos(AGVector3 const &pPos) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setPos(pPos);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pPos, SWIGTYPE_p_AGVector3,0);
    result = rb_funcall(swig_get_self(), rb_intern("setPos"), 1,obj0);
}


void SwigDirector_Smoke::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_Smoke::transparent() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return Smoke::transparent();
    }
    result = rb_funcall(swig_get_self(), rb_intern("transparent"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_Smoke::setRotation(float r) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setRotation(r);
        return;
    }
    obj0 = rb_float_new(r);
    result = rb_funcall(swig_get_self(), rb_intern("setRotation"), 1,obj0);
}


void SwigDirector_Smoke::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Smoke::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_Smoke::sort(AGVector4 const &pCamera) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pCamera, SWIGTYPE_p_AGVector4,0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_Smoke::drawPick() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawPick();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawPick"), 0, NULL);
}


void SwigDirector_Smoke::resetScene() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::resetScene();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("resetScene"), 0, NULL);
}


SwigDirector_Smoke::~SwigDirector_Smoke() {
}

size_t SwigDirector_Smoke::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


AGVector4 SwigDirector_Smoke::lineHit(AGLine3 const &pLine) const {
    VALUE obj0 = Qnil ;
    AGVector4 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::lineHit(pLine);
    }
    obj0 = SWIG_NewPointerObj((void *) &pLine, SWIGTYPE_p_AGLine3,0);
    result = rb_funcall(swig_get_self(), rb_intern("lineHit"), 1,obj0);
    {
        AGVector4 *b;
        Data_Get_Struct(result,AGVector4,b);
        c_result=*b;
    }
    return (AGVector4) c_result;
}


void SwigDirector_Smoke::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


void SwigDirector_Smoke::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_Smoke::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        Smoke::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


SwigDirector_TerrainPieceVA::SwigDirector_TerrainPieceVA(VALUE self, Scene *pScene, Terrain *t, HeightMap &map, int x, int y, int w, int h, AGVector4 const &pPos): TerrainPieceVA(pScene, t, map, x, y, w, h, pPos), Swig::Director(self) {
    
}



void SwigDirector_TerrainPieceVA::setPos(AGVector3 const &pPos) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setPos(pPos);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pPos, SWIGTYPE_p_AGVector3,0);
    result = rb_funcall(swig_get_self(), rb_intern("setPos"), 1,obj0);
}


bool SwigDirector_TerrainPieceVA::transparent() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::transparent();
    }
    result = rb_funcall(swig_get_self(), rb_intern("transparent"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_TerrainPieceVA::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


void SwigDirector_TerrainPieceVA::setRotation(float r) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setRotation(r);
        return;
    }
    obj0 = rb_float_new(r);
    result = rb_funcall(swig_get_self(), rb_intern("setRotation"), 1,obj0);
}


void SwigDirector_TerrainPieceVA::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_TerrainPieceVA::sort(AGVector4 const &pCamera) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pCamera, SWIGTYPE_p_AGVector4,0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_TerrainPieceVA::drawPick() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainPieceVA::drawPick();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawPick"), 0, NULL);
}


void SwigDirector_TerrainPieceVA::resetScene() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::resetScene();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("resetScene"), 0, NULL);
}


SwigDirector_TerrainPieceVA::~SwigDirector_TerrainPieceVA() {
}

size_t SwigDirector_TerrainPieceVA::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return TerrainPieceVA::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_TerrainPieceVA::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainPieceVA::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


void SwigDirector_TerrainPieceVA::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainPieceVA::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_TerrainPieceVA::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainPieceVA::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


void SwigDirector_TerrainPieceVA::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainPieceVA::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


AGVector4 SwigDirector_TerrainPieceVA::lineHit(AGLine3 const &pLine) const {
    VALUE obj0 = Qnil ;
    AGVector4 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return TerrainPieceVA::lineHit(pLine);
    }
    obj0 = SWIG_NewPointerObj((void *) &pLine, SWIGTYPE_p_AGLine3,0);
    result = rb_funcall(swig_get_self(), rb_intern("lineHit"), 1,obj0);
    {
        AGVector4 *b;
        Data_Get_Struct(result,AGVector4,b);
        c_result=*b;
    }
    return (AGVector4) c_result;
}


SwigDirector_Terrain::SwigDirector_Terrain(VALUE self, Scene *pScene, HeightMap &map): Terrain(pScene, map), Swig::Director(self) {
    
}



void SwigDirector_Terrain::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        Terrain::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


SwigDirector_Terrain::~SwigDirector_Terrain() {
}

void SwigDirector_Terrain::mapChangedComplete() {
    VALUE result;
    
    if (swig_get_up()) {
        Terrain::mapChangedComplete();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChangedComplete"), 0, NULL);
}


bool SwigDirector_Terrain::slotMapChanged(AGEvent *e) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return Terrain::slotMapChanged(e);
    }
    obj0 = SWIG_NewPointerObj((void *) e, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("slotMapChanged"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_Terrain::slotMapChangedComplete(AGEvent *e) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return Terrain::slotMapChangedComplete(e);
    }
    obj0 = SWIG_NewPointerObj((void *) e, SWIGTYPE_p_AGEvent,0);
    result = rb_funcall(swig_get_self(), rb_intern("slotMapChangedComplete"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_VertexArray::SwigDirector_VertexArray(VALUE self): VertexArray(), Swig::Director(self) {
    
}



SwigDirector_VertexArray::~SwigDirector_VertexArray() {
}

void SwigDirector_VertexArray::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        VertexArray::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


SwigDirector_VertexArrayShader::SwigDirector_VertexArrayShader(VALUE self, AntShaderProgram *_p): VertexArrayShader(_p), Swig::Director(self) {
    
}



SwigDirector_VertexArrayShader::~SwigDirector_VertexArrayShader() {
}

void SwigDirector_VertexArrayShader::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        VertexArrayShader::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


SwigDirector_WaterPiece::SwigDirector_WaterPiece(VALUE self, Scene *pScene, HeightMap &map, int x, int y, int w, int h, AGVector4 const &pos): WaterPiece(pScene, map, x, y, w, h, pos), Swig::Director(self) {
    
}



void SwigDirector_WaterPiece::setPos(AGVector3 const &pPos) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setPos(pPos);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pPos, SWIGTYPE_p_AGVector3,0);
    result = rb_funcall(swig_get_self(), rb_intern("setPos"), 1,obj0);
}


void SwigDirector_WaterPiece::clear() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::clear();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("clear"), 0, NULL);
}


bool SwigDirector_WaterPiece::transparent() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return WaterPiece::transparent();
    }
    result = rb_funcall(swig_get_self(), rb_intern("transparent"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_WaterPiece::setRotation(float r) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::setRotation(r);
        return;
    }
    obj0 = rb_float_new(r);
    result = rb_funcall(swig_get_self(), rb_intern("setRotation"), 1,obj0);
}


void SwigDirector_WaterPiece::advance(float t) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        WaterPiece::advance(t);
        return;
    }
    obj0 = rb_float_new(t);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_WaterPiece::sort(AGVector4 const &pCamera) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj((void *) &pCamera, SWIGTYPE_p_AGVector4,0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_WaterPiece::drawPick() {
    VALUE result;
    
    if (swig_get_up()) {
        WaterPiece::drawPick();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawPick"), 0, NULL);
}


void SwigDirector_WaterPiece::resetScene() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::resetScene();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("resetScene"), 0, NULL);
}


SwigDirector_WaterPiece::~SwigDirector_WaterPiece() {
}

size_t SwigDirector_WaterPiece::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return WaterPiece::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_WaterPiece::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        WaterPiece::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


AGVector4 SwigDirector_WaterPiece::lineHit(AGLine3 const &pLine) const {
    VALUE obj0 = Qnil ;
    AGVector4 c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::lineHit(pLine);
    }
    obj0 = SWIG_NewPointerObj((void *) &pLine, SWIGTYPE_p_AGLine3,0);
    result = rb_funcall(swig_get_self(), rb_intern("lineHit"), 1,obj0);
    {
        AGVector4 *b;
        Data_Get_Struct(result,AGVector4,b);
        c_result=*b;
    }
    return (AGVector4) c_result;
}


void SwigDirector_WaterPiece::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


void SwigDirector_WaterPiece::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_WaterPiece::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        WaterPiece::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


swig_class cStringVector;

static VALUE
_wrap_new_StringVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<std::string > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<std::string > *)new std::vector<std::string >(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_StringVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<std::string > *)new std::vector<std::string >();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_StringVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::string *arg2 = 0 ;
    std::vector<std::string > *result;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (std::vector<std::string > *)new std::vector<std::string >(arg1,(std::string const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_StringVector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_StringVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTstd__string_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_StringVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = 0 ;
    std::vector<std::string > *result;
    std::vector<std::string > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (std::vector<std::string > *)new std::vector<std::string >((std::vector<std::string > const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_StringVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_StringVector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if (SWIG_STRING_P(o))
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<std::string >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTstd__string_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_StringVector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_StringVector'");
    return Qnil;
}


static VALUE
_wrap_StringVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    unsigned int result;
    std::vector<std::string > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (unsigned int)((std::vector<std::string > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_StringVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    bool result;
    std::vector<std::string > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (bool)((std::vector<std::string > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_StringVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_StringVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->push_back(arg2);
    
    return Qnil;
}


static VALUE
_wrap_StringVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    try {
        result = std_vector_Sl_std_string_Sg__pop(arg1);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_StringVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    int arg2 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    arg2 = NUM2INT(argv[0]);
    try {
        result = std_vector_Sl_std_string_Sg____getitem__(arg1,arg2);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_StringVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    int arg2 ;
    std::string arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    arg2 = NUM2INT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg3 = std::string(StringValuePtr(argv[1]));
            arg3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    try {
        std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,arg3);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    return Qnil;
}


static VALUE
_wrap_StringVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    std_vector_Sl_std_string_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_std_string_Sg_(std::vector<std::string > *arg1) {
    delete arg1;
}

swig_class cSceneNodeVector;

static VALUE
_wrap_new_SceneNodeVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<SceneNodePtr > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<SceneNodePtr > *)new std::vector<SceneNodePtr >(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_SceneNodeVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<SceneNodePtr > *)new std::vector<SceneNodePtr >();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_SceneNodeVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    SceneNodePtr *arg2 = 0 ;
    std::vector<SceneNodePtr > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_p_SceneNode, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<SceneNodePtr > *)new std::vector<SceneNodePtr >(arg1,(SceneNode *const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_SceneNodeVector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_SceneNodeVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTSceneNodePtr_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_SceneNodeVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = 0 ;
    std::vector<SceneNodePtr > *result;
    std::vector<SceneNodePtr > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<SceneNodePtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                SceneNodePtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_p_SceneNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNodePtr_t, 1);
        }
    }
    result = (std::vector<SceneNodePtr > *)new std::vector<SceneNodePtr >((std::vector<SceneNodePtr > const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_SceneNodeVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_SceneNodeVector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_SceneNodeVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    SceneNodePtr* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_p_SceneNode,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<SceneNodePtr >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTSceneNodePtr_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_SceneNodeVector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_p_SceneNode, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_SceneNodeVector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_SceneNodeVector'");
    return Qnil;
}


static VALUE
_wrap_SceneNodeVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    unsigned int result;
    std::vector<SceneNodePtr > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<SceneNodePtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                SceneNodePtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_p_SceneNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNodePtr_t, 1);
        }
    }
    result = (unsigned int)((std::vector<SceneNodePtr > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_SceneNodeVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    bool result;
    std::vector<SceneNodePtr > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<SceneNodePtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                SceneNodePtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_p_SceneNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNodePtr_t, 1);
        }
    }
    result = (bool)((std::vector<SceneNodePtr > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_SceneNodeVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNodePtr_t, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_SceneNodeVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    SceneNodePtr *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNodePtr_t, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_p_SceneNode, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((SceneNode *const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNodeVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    SceneNodePtr result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNodePtr_t, 0);
    try {
        result = (SceneNodePtr)std_vector_Sl_SceneNodePtr_Sg__pop(arg1);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<AnimMesh*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AnimMesh,0);
                else if(dynamic_cast<WaterPiece*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_WaterPiece,0);
                else if(dynamic_cast<Mesh*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
                else if(dynamic_cast<NewDecal*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewDecal,0);
                else if(dynamic_cast<Smoke*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Smoke,0);
                else if(dynamic_cast<TerrainPieceVA*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainPieceVA,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SceneNode,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_SceneNodeVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    int arg2 ;
    SceneNodePtr *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNodePtr_t, 0);
    arg2 = NUM2INT(argv[0]);
    try {
        {
            SceneNodePtr &_result_ref = std_vector_Sl_SceneNodePtr_Sg____getitem__(arg1,arg2);
            result = (SceneNodePtr *) &_result_ref;
        }
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_SceneNode,0);
    return vresult;
}


static VALUE
_wrap_SceneNodeVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    int arg2 ;
    SceneNodePtr *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNodePtr_t, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_p_SceneNode, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    try {
        std_vector_Sl_SceneNodePtr_Sg____setitem__(arg1,arg2,(SceneNode *const &)*arg3);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    return Qnil;
}


static VALUE
_wrap_SceneNodeVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNodePtr_t, 0);
    std_vector_Sl_SceneNodePtr_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_SceneNodePtr_Sg_(std::vector<SceneNodePtr > *arg1) {
    delete arg1;
}

swig_class cPickResult;

static VALUE
_wrap_new_PickResult__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<PickNode > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<PickNode > *)new std::vector<PickNode >(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_PickResult__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<PickNode > *)new std::vector<PickNode >();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_PickResult__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    PickNode *arg2 = 0 ;
    std::vector<PickNode > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_PickNode, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<PickNode > *)new std::vector<PickNode >(arg1,(PickNode const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_PickResult_allocate(VALUE self) {
#else
    static VALUE
    _wrap_PickResult_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTPickNode_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_PickResult__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = 0 ;
    std::vector<PickNode > *result;
    std::vector<PickNode > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<PickNode >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                PickNode* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_PickNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
        }
    }
    result = (std::vector<PickNode > *)new std::vector<PickNode >((std::vector<PickNode > const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_PickResult(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_PickResult__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_PickResult__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    PickNode* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_PickNode,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<PickNode >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTPickNode_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_PickResult__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PickNode, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_PickResult__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_PickResult'");
    return Qnil;
}


static VALUE
_wrap_PickResult___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    unsigned int result;
    std::vector<PickNode > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<PickNode >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                PickNode* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_PickNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
        }
    }
    result = (unsigned int)((std::vector<PickNode > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_PickResult_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    bool result;
    std::vector<PickNode > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<PickNode >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                PickNode* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_PickNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
        }
    }
    result = (bool)((std::vector<PickNode > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_PickResult_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_PickResult_push(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    PickNode *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_PickNode, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((PickNode const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_PickResult_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    PickNode result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 0);
    try {
        result = std_vector_Sl_PickNode_Sg__pop(arg1);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    {
        PickNode * resultptr;
        resultptr = new PickNode((PickNode &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PickNode, 1);
    }
    return vresult;
}


static VALUE
_wrap_PickResult___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    int arg2 ;
    PickNode *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 0);
    arg2 = NUM2INT(argv[0]);
    try {
        {
            PickNode &_result_ref = std_vector_Sl_PickNode_Sg____getitem__(arg1,arg2);
            result = (PickNode *) &_result_ref;
        }
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PickNode,0);
    return vresult;
}


static VALUE
_wrap_PickResult___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    int arg2 ;
    PickNode *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_PickNode, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    try {
        std_vector_Sl_PickNode_Sg____setitem__(arg1,arg2,(PickNode const &)*arg3);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    return Qnil;
}


static VALUE
_wrap_PickResult_each(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 0);
    std_vector_Sl_PickNode_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_PickNode_Sg_(std::vector<PickNode > *arg1) {
    delete arg1;
}

swig_class cEntityVector;

static VALUE
_wrap_new_EntityVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<AntEntityPtr > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<AntEntityPtr > *)new std::vector<AntEntityPtr >(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_EntityVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<AntEntityPtr > *)new std::vector<AntEntityPtr >();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_EntityVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    AntEntityPtr *arg2 = 0 ;
    std::vector<AntEntityPtr > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AntEntityPtr, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<AntEntityPtr > *)new std::vector<AntEntityPtr >(arg1,(AntEntityPtr const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_EntityVector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_EntityVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTAntEntityPtr_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_EntityVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = 0 ;
    std::vector<AntEntityPtr > *result;
    std::vector<AntEntityPtr > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<AntEntityPtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                AntEntityPtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AntEntityPtr, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
        }
    }
    result = (std::vector<AntEntityPtr > *)new std::vector<AntEntityPtr >((std::vector<AntEntityPtr > const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_EntityVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_EntityVector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_EntityVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    AntEntityPtr* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_AntEntityPtr,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<AntEntityPtr >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTAntEntityPtr_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_EntityVector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AntEntityPtr, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_EntityVector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_EntityVector'");
    return Qnil;
}


static VALUE
_wrap_EntityVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    unsigned int result;
    std::vector<AntEntityPtr > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AntEntityPtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AntEntityPtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AntEntityPtr, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
        }
    }
    result = (unsigned int)((std::vector<AntEntityPtr > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_EntityVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    bool result;
    std::vector<AntEntityPtr > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AntEntityPtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AntEntityPtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AntEntityPtr, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
        }
    }
    result = (bool)((std::vector<AntEntityPtr > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_EntityVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_EntityVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    AntEntityPtr *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntityPtr, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((AntEntityPtr const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_EntityVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    AntEntityPtr result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 0);
    try {
        result = std_vector_Sl_AntEntityPtr_Sg__pop(arg1);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    {
        AntEntityPtr * resultptr;
        resultptr = new AntEntityPtr((AntEntityPtr &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AntEntityPtr, 1);
    }
    return vresult;
}


static VALUE
_wrap_EntityVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    int arg2 ;
    AntEntityPtr *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 0);
    arg2 = NUM2INT(argv[0]);
    try {
        {
            AntEntityPtr &_result_ref = std_vector_Sl_AntEntityPtr_Sg____getitem__(arg1,arg2);
            result = (AntEntityPtr *) &_result_ref;
        }
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntityPtr,0);
    return vresult;
}


static VALUE
_wrap_EntityVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    int arg2 ;
    AntEntityPtr *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AntEntityPtr, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    try {
        std_vector_Sl_AntEntityPtr_Sg____setitem__(arg1,arg2,(AntEntityPtr const &)*arg3);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    return Qnil;
}


static VALUE
_wrap_EntityVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 0);
    std_vector_Sl_AntEntityPtr_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_AntEntityPtr_Sg_(std::vector<AntEntityPtr > *arg1) {
    delete arg1;
}

swig_class cResourceMap;

static VALUE
_wrap_new_ResourceMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::map<std::string,float > *)new std::map<std::string,float >();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_ResourceMap_allocate(VALUE self) {
#else
    static VALUE
    _wrap_ResourceMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__mapTstd__string_float_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_ResourceMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = 0 ;
    std::map<std::string,float > *result;
    std::map<std::string,float > temp1 ;
    std::map<std::string,float > *m1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cHash)) {
            temp1 = std::map<std::string,float >();
            arg1 = &temp1;
            VALUE keys = rb_funcall(argv[0],rb_intern("keys"),0);
            unsigned int size = RARRAY(keys)->len;
            for (unsigned int i=0; i<size; i++) {
                VALUE key = RARRAY(keys)->ptr[i];
                VALUE val = rb_hash_aref(argv[0],key);
                if (!(SWIG_STRING_P(key) && SWIG_FLOAT_P(val)))
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected map<""std::string" ",""float" ">)");
                temp1[SWIG_RB2STR(key)] = SWIG_NUM2DBL(val);
            }
        } else {
            SWIG_ConvertPtr(argv[0],(void **) &m1, SWIGTYPE_p_std__mapTstd__string_float_t,1);
            arg1 = m1;
        }
    }
    result = (std::map<std::string,float > *)new std::map<std::string,float >((std::map<std::string,float > const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_ResourceMap(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_ResourceMap__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            // native sequence?
            if (rb_obj_is_kind_of(argv[0],rb_cHash)) {
                VALUE keys = rb_funcall(argv[0],rb_intern("keys"),0);
                unsigned int size = RARRAY(keys)->len;
                if (size == 0) {
                    // an empty dictionary can be of any type
                    _v = 1;
                } else {
                    // check the first element only
                    VALUE key = RARRAY(keys)->ptr[0];
                    VALUE val = rb_hash_aref(argv[0],key);
                    if (SWIG_STRING_P(key) && SWIG_FLOAT_P(val))
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                // wrapped map?
                std::map<std::string,float >* m;
                if (SWIG_ConvertPtr(argv[0],(void **) &m,
                SWIGTYPE_p_std__mapTstd__string_float_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_ResourceMap__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_ResourceMap'");
    return Qnil;
}


static VALUE
_wrap_ResourceMap___len__(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    unsigned int result;
    std::map<std::string,float > temp1 ;
    std::map<std::string,float > *m1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cHash)) {
            temp1 = std::map<std::string,float >();
            arg1 = &temp1;
            VALUE keys = rb_funcall(self,rb_intern("keys"),0);
            unsigned int size = RARRAY(keys)->len;
            for (unsigned int i=0; i<size; i++) {
                VALUE key = RARRAY(keys)->ptr[i];
                VALUE val = rb_hash_aref(self,key);
                if (!(SWIG_STRING_P(key) && SWIG_FLOAT_P(val)))
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected map<""std::string" ",""float" ">)");
                temp1[SWIG_RB2STR(key)] = SWIG_NUM2DBL(val);
            }
        } else {
            SWIG_ConvertPtr(self,(void **) &m1, SWIGTYPE_p_std__mapTstd__string_float_t,1);
            arg1 = m1;
        }
    }
    result = (unsigned int)((std::map<std::string,float > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_ResourceMap_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    bool result;
    std::map<std::string,float > temp1 ;
    std::map<std::string,float > *m1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cHash)) {
            temp1 = std::map<std::string,float >();
            arg1 = &temp1;
            VALUE keys = rb_funcall(self,rb_intern("keys"),0);
            unsigned int size = RARRAY(keys)->len;
            for (unsigned int i=0; i<size; i++) {
                VALUE key = RARRAY(keys)->ptr[i];
                VALUE val = rb_hash_aref(self,key);
                if (!(SWIG_STRING_P(key) && SWIG_FLOAT_P(val)))
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected map<""std::string" ",""float" ">)");
                temp1[SWIG_RB2STR(key)] = SWIG_NUM2DBL(val);
            }
        } else {
            SWIG_ConvertPtr(self,(void **) &m1, SWIGTYPE_p_std__mapTstd__string_float_t,1);
            arg1 = m1;
        }
    }
    result = (bool)((std::map<std::string,float > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_ResourceMap_clear(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_ResourceMap___getitem__(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    std::string arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    try {
        result = (float)std_map_Sl_std_string_Sc_float_Sg____getitem__(arg1,arg2);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_ResourceMap___setitem__(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    std::string arg2 ;
    float arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    std_map_Sl_std_string_Sc_float_Sg____setitem__(arg1,arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_ResourceMap_delete(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    std::string arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    try {
        result = (float)std_map_Sl_std_string_Sc_float_Sg____delitem__(arg1,arg2);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_ResourceMap_has_keyq___(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    std::string arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)std_map_Sl_std_string_Sc_float_Sg__has_key(arg1,arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_ResourceMap_keys(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 0);
    result = (VALUE)std_map_Sl_std_string_Sc_float_Sg__keys(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_ResourceMap_values(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 0);
    result = (VALUE)std_map_Sl_std_string_Sc_float_Sg__values(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_ResourceMap_each(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 0);
    std_map_Sl_std_string_Sc_float_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_map_Sl_std_string_Sc_float_Sg_(std::map<std::string,float > *arg1) {
    delete arg1;
}

swig_class cAGNodeList;

static VALUE
_wrap_new_AGNodeList__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<Node > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<Node > *)new std::vector<Node >(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGNodeList__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<Node > *)new std::vector<Node >();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGNodeList__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    Node *arg2 = 0 ;
    std::vector<Node > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<Node > *)new std::vector<Node >(arg1,(Node const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGNodeList_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGNodeList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTNode_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGNodeList__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = 0 ;
    std::vector<Node > *result;
    std::vector<Node > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<Node >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
        }
    }
    result = (std::vector<Node > *)new std::vector<Node >((std::vector<Node > const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGNodeList(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGNodeList__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGNodeList__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    Node* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_Node,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<Node >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTNode_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGNodeList__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGNodeList__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGNodeList'");
    return Qnil;
}


static VALUE
_wrap_AGNodeList___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    unsigned int result;
    std::vector<Node > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
        }
    }
    result = (unsigned int)((std::vector<Node > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGNodeList_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    bool result;
    std::vector<Node > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
        }
    }
    result = (bool)((std::vector<Node > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGNodeList_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGNodeList_push(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGNodeList_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    Node result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 0);
    try {
        result = std_vector_Sl_Node_Sg__pop(arg1);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    {
        Node * resultptr;
        resultptr = new Node((Node &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGNodeList___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    int arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 0);
    arg2 = NUM2INT(argv[0]);
    try {
        {
            Node &_result_ref = std_vector_Sl_Node_Sg____getitem__(arg1,arg2);
            result = (Node *) &_result_ref;
        }
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_AGNodeList___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    int arg2 ;
    Node *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Node, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    try {
        std_vector_Sl_Node_Sg____setitem__(arg1,arg2,(Node const &)*arg3);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    return Qnil;
}


static VALUE
_wrap_AGNodeList_each(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 0);
    std_vector_Sl_Node_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_Node_Sg_(std::vector<Node > *arg1) {
    delete arg1;
}

swig_class cAGNodePList;

static VALUE
_wrap_new_AGNodePList__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<Node * > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<Node * > *)new std::vector<Node * >(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGNodePList__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<Node * > *)new std::vector<Node * >();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGNodePList__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    Node **arg2 = 0 ;
    std::vector<Node * > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<Node * > *)new std::vector<Node * >(arg1,*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGNodePList_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGNodePList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTNode_p_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGNodePList__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = 0 ;
    std::vector<Node * > *result;
    std::vector<Node * > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (std::vector<Node * > *)new std::vector<Node * >((std::vector<Node * > const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGNodePList(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGNodePList__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGNodePList__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    Node* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_Node,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<Node* >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTNode_p_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGNodePList__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_p_Node, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGNodePList__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGNodePList'");
    return Qnil;
}


static VALUE
_wrap_AGNodePList___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    unsigned int result;
    std::vector<Node * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (unsigned int)((std::vector<Node * > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGNodePList_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    bool result;
    std::vector<Node * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (bool)((std::vector<Node * > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGNodePList_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGNodePList_push(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    Node *arg2 = (Node *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0);
    (arg1)->push_back(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGNodePList_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    try {
        result = (Node *)std_vector_Sl_Node_Sm__Sg__pop(arg1);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_AGNodePList___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    int arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    arg2 = NUM2INT(argv[0]);
    try {
        result = (Node *)std_vector_Sl_Node_Sm__Sg____getitem__(arg1,arg2);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_AGNodePList___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    int arg2 ;
    Node *arg3 = (Node *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Node, 0);
    try {
        std_vector_Sl_Node_Sm__Sg____setitem__(arg1,arg2,arg3);
    }
    catch(std::out_of_range &_e) {
        SWIG_exception(SWIG_IndexError, (&_e)->what()); 
    }
    
    return Qnil;
}


static VALUE
_wrap_AGNodePList_each(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 0);
    std_vector_Sl_Node_Sm__Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_Node_Sm__Sg_(std::vector<Node * > *arg1) {
    delete arg1;
}

swig_class cAGRubyObject;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRubyObject_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRubyObject_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRubyObject);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRubyObject(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGRubyObject *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::AGRubyObject";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGRubyObject *)new SwigDirector_AGRubyObject(arg1);
            
        } else {
            result = (AGRubyObject *)new AGRubyObject();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGRubyObject(AGRubyObject *arg1) {
    delete arg1;
}

static VALUE
_wrap_general_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, SWIG_POINTER_EXCEPTION|0);
    general_markfunc(arg1);
    
    return Qnil;
}


static VALUE
_wrap_saveDelete(int argc, VALUE *argv, VALUE self) {
    AGRubyObject *arg1 = (AGRubyObject *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRubyObject, 0);
    result = (bool)saveDelete(arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGRubyObject(int argc, VALUE *argv, VALUE self) {
    AGRubyObject *arg1 = (AGRubyObject *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRubyObject, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGEvent;

static VALUE
_wrap_new_AGEvent__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    std::string *arg3 = 0 ;
    SDL_Event *arg4 = (SDL_Event *) 0 ;
    AGEvent *result;
    std::string temp3 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_SDL_Event, 0);
    char *classname = "Libantargis::AGEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEvent *)new SwigDirector_AGEvent(arg1,arg2,(std::string const &)*arg3,(SDL_Event const *)arg4);
        
    } else {
        result = (AGEvent *)new AGEvent(arg2,(std::string const &)*arg3,(SDL_Event const *)arg4);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEvent__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    std::string *arg3 = 0 ;
    AGEvent *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::AGEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEvent *)new SwigDirector_AGEvent(arg1,arg2,(std::string const &)*arg3);
        
    } else {
        result = (AGEvent *)new AGEvent(arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGEvent(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGEvent__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_SDL_Event, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGEvent__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGEvent'");
    return Qnil;
}


static void
free_AGEvent(AGEvent *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGEvent_getCaller(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    AGListener *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (AGListener *)((AGEvent const *)arg1)->getCaller();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<AGCaption*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                else if(dynamic_cast<AGWindow*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                else if(dynamic_cast<AGSound*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                else if(dynamic_cast<AGDialog*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                else if(dynamic_cast<AGImage*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                else if(dynamic_cast<AGRadioGroup*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                else if(dynamic_cast<AGGLWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                else if(dynamic_cast<AGEdit*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                else if(dynamic_cast<AGListBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                else if(dynamic_cast<AGSubMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                else if(dynamic_cast<AGColorButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                else if(dynamic_cast<AGMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                else if(dynamic_cast<MiniMap*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
                else if(dynamic_cast<AGRadio*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                else if(dynamic_cast<GLApp*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GLApp,0);
                else if(dynamic_cast<AntMap*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
                else if(dynamic_cast<AGText*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                else if(dynamic_cast<AGCheckBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                else if(dynamic_cast<AGMenuItem*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                else if(dynamic_cast<AGApplication*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGApplication,0);
                else if(dynamic_cast<AGLayout*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                else if(dynamic_cast<HeightMap*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_HeightMap,0);
                else if(dynamic_cast<AGButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                else if(dynamic_cast<AGTable*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                else if(dynamic_cast<AGWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                else if(dynamic_cast<AGMessageObject*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMessageObject,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListener,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_AGEvent_setCaller(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    AGListener *arg2 = (AGListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0);
    (arg1)->setCaller(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEvent_getName(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = ((AGEvent const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGEvent_getMousePosition(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = ((AGEvent const *)arg1)->getMousePosition();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEvent_getKey(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    SDLKey result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (SDLKey)((AGEvent const *)arg1)->getKey();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEvent_getMod(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    SDLMod result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (SDLMod)((AGEvent const *)arg1)->getMod();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEvent_getButton(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (int)((AGEvent const *)arg1)->getButton();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEvent_get(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    SDL_Event *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (SDL_Event *)((AGEvent const *)arg1)->get();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Event,0);
    return vresult;
}


static VALUE
_wrap_AGEvent_isSDLEvent(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    result = (bool)((AGEvent const *)arg1)->isSDLEvent();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEvent_setName(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGEvent(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEvent, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGListener;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListener_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListener_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListener);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListener(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::AGListener";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGListener *)new SwigDirector_AGListener(arg1);
            
        } else {
            result = (AGListener *)new AGListener();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGListener(AGListener *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGListener_signal(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListener, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->signal(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGListener(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListener, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGCPPListener;

static void
free_AGCPPListener(AGCPPListener *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGCPPListener_signal(int argc, VALUE *argv, VALUE self) {
    AGCPPListener *arg1 = (AGCPPListener *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCPPListener, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGCPPListener const *)arg1)->signal(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCPPListener_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCPPListener_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCPPListener);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCPPListener(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGCPPListener *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGCPPListener";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGCPPListener *)new SwigDirector_AGCPPListener(arg1);
        
    } else {
        rb_raise(rb_eNameError,"accessing abstract class or protected constructor"); 
        return Qnil;
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_disown_AGCPPListener(int argc, VALUE *argv, VALUE self) {
    AGCPPListener *arg1 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCPPListener, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSignal;

static VALUE
_wrap_new_AGSignal__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSignal *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1);
        
    } else {
        result = (AGSignal *)new AGSignal();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGSignal__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *arg2 = (AGMessageObject *) 0 ;
    AGSignal *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMessageObject, 0);
    char *classname = "Libantargis::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1,arg2);
        
    } else {
        result = (AGSignal *)new AGSignal(arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSignal_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSignal_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSignal);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSignal__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *arg2 = (AGMessageObject *) 0 ;
    std::string *arg3 = 0 ;
    AGSignal *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMessageObject, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1,arg2,(std::string const &)*arg3);
        
    } else {
        result = (AGSignal *)new AGSignal(arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGSignal(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGSignal__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMessageObject, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGSignal__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMessageObject, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGSignal__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGSignal'");
    return Qnil;
}


static void
free_AGSignal(AGSignal *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGSignal_connect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGListener *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->connect(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSignal_disconnect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGListener *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->disconnect(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSignal_connect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGCPPListener *arg2 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGCPPListener, 0);
    (arg1)->connect(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSignal_connect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_connect__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGCPPListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_connect__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSignal_connect'");
    return Qnil;
}


static VALUE
_wrap_AGSignal_disconnect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGCPPListener *arg2 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGCPPListener, 0);
    (arg1)->disconnect(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSignal_disconnect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_disconnect__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGCPPListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_disconnect__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSignal_disconnect'");
    return Qnil;
}


static VALUE
_wrap_AGSignal_signal(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->signal(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSignal___call__(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->operator ()(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGSignal(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSignal, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGMessageObject;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMessageObject_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMessageObject_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMessageObject);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMessageObject(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::AGMessageObject";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGMessageObject *)new SwigDirector_AGMessageObject(arg1);
            
        } else {
            result = (AGMessageObject *)new AGMessageObject();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGMessageObject(AGMessageObject *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGMessageObject_processEvent(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->processEvent(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_acceptEvent(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    SDL_Event *arg2 = (SDL_Event *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Event, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->acceptEvent((SDL_Event const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventActive(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventActive(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventKeyUp(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventQuit(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuit(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventQuitModal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuitModal(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventSysWM(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventSysWM(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventResize(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventResize(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_getButtonState(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    Uint8 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGMessageObject const *)arg1)->getButtonState();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMessageObject_getMousePosition(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGVector2 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGMessageObject const *)arg1)->getMousePosition();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigActive_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigActive = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigActive_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigActive);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigKeyDown_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigKeyDown = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigKeyDown_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigKeyDown);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigKeyUp_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigKeyUp = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigKeyUp_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigKeyUp);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseMotion_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseMotion = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseMotion_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigMouseMotion);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonDown_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseButtonDown = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonDown_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigMouseButtonDown);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonUp_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseButtonUp = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonUp_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigMouseButtonUp);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigQuit_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigQuit = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigQuit_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigQuit);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigSysWM_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigSysWM = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigSysWM_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigSysWM);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigVideoResize_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigVideoResize = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigVideoResize_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGSignal *)& ((arg1)->sigVideoResize);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_pushSignal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    (arg1)->pushSignal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_popSignal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    (arg1)->popSignal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGMessageObject(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_newEvent(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    std::string *arg2 = 0 ;
    SDL_Event *arg3 = (SDL_Event *) 0 ;
    AGEvent *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListener, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_SDL_Event, 0);
    result = (AGEvent *)newEvent(arg1,(std::string const &)*arg2,(SDL_Event const *)arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEvent,0);
    return vresult;
}


swig_class cAGAngle;

static VALUE
_wrap_AGAngle_angle_set(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = (AGAngle *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGAngle, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->angle = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGAngle_angle_get(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = (AGAngle *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGAngle, 0);
    result = (float) ((arg1)->angle);
    
    vresult = rb_float_new(result);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGAngle_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGAngle_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGAngle);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGAngle(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    AGAngle *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    result = (AGAngle *)new AGAngle(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGAngle(AGAngle *arg1) {
    delete arg1;
}

swig_class cAGVector2;

static VALUE
_wrap_AGVector2_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 0);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector2_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGVector2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector2 *)new AGVector2(arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGVector2 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector2 *)new AGVector2((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector2__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector2 *)new AGVector2((AGVector2 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector2__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector2 *)new AGVector2();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGVector2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector2__SWIG_3(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector2__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector2__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector2__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector2'");
    return Qnil;
}


static VALUE
_wrap_AGVector2_setX(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_setY(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_x(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float)((AGVector2 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_y(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float)((AGVector2 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_getAngle(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    SwigValueWrapper<AGAngle > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = ((AGVector2 const *)arg1)->getAngle();
    
    {
        AGAngle * resultptr;
        resultptr = new AGAngle((AGAngle &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGAngle, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector2 const *)arg1)->operator -((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___add__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector2 const *)arg1)->operator +((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector2 const *)arg1)->operator *((AGVector2 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector2 const *)arg1)->operator *(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector2___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector2___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector2___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector2___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector2___div__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector2 const *)arg1)->operator /(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector2 const *)arg1)->operator ==((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector2_length(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float)((AGVector2 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_length2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (float)((AGVector2 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = ((AGVector2 const *)arg1)->normalized();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_normal(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = ((AGVector2 const *)arg1)->normal();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___getitem__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    int arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    arg2 = NUM2INT(argv[0]);
    result = (float)((AGVector2 const *)arg1)->operator [](arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = (bool)((AGVector2 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector2_saveXML(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((AGVector2 const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_loadXML(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 0);
    result = ((AGVector2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGVector2(AGVector2 *arg1) {
    delete arg1;
}

swig_class cAGVector3;

static VALUE
_wrap_AGVector3_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 0);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector3_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    float arg2 ;
    AGVector3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector3 *)new AGVector3((AGVector2 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGVector2 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGVector3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGVector3 *)new AGVector3(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_3(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGVector3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector3 *)new AGVector3(arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector3__SWIG_6(int argc, VALUE *argv, VALUE self) {
    AGVector3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector3 *)new AGVector3();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGVector3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector3__SWIG_6(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_4(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_5(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector3__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector3__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVector3__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector3'");
    return Qnil;
}


static VALUE
_wrap_AGVector3_setX(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_setY(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_setZ(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setZ(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_x(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_y(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_z(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->getZ();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_getAngle(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    SwigValueWrapper<AGAngle > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->getAngle();
    
    {
        AGAngle * resultptr;
        resultptr = new AGAngle((AGAngle &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGAngle, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___neg__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->operator -();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator -((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___add__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator +((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_add(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector3 &_result_ref = (arg1)->operator +=((AGVector3 const &)*arg2);
        result = (AGVector3 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3_sub(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector3 &_result_ref = (arg1)->operator -=((AGVector3 const &)*arg2);
        result = (AGVector3 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector3 const *)arg1)->operator *((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector3 const *)arg1)->operator *(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector3___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector3___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector3___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector3___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector3___div__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector3 const *)arg1)->operator /(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___mod__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator %((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector3 const *)arg1)->operator ==((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3_length(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_length2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (float)((AGVector3 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->normalized();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_normal(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->normal();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = (bool)((AGVector3 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3_saveXML(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((AGVector3 const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_loadXML(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_dim2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->dim2();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 0);
    result = ((AGVector3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGVector3(AGVector3 *arg1) {
    delete arg1;
}

swig_class cAGMatrix3;

static VALUE
_wrap_new_AGMatrix3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMatrix3 *)new AGMatrix3();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGMatrix3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGMatrix3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix3 *)new AGMatrix3((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMatrix3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMatrix3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMatrix3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMatrix3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGMatrix3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix3 *)new AGMatrix3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGMatrix3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGMatrix3__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix3__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix3__SWIG_2(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGMatrix3'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3_set(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGMatrix3_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix3 const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix3_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->get(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix3_get(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix3_get__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix3_get__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix3_get'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix3 const *)arg1)->operator *((AGMatrix3 const &)*arg2);
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix3 const *)arg1)->operator *((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE _wrap_AGMatrix3___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix3___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix3___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix3___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3___neg__(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    result = ((AGMatrix3 const *)arg1)->operator -();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_inverted(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    result = ((AGMatrix3 const *)arg1)->inverted();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_transposed(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    result = ((AGMatrix3 const *)arg1)->transposed();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_to_s(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 0);
    result = ((AGMatrix3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGMatrix3(AGMatrix3 *arg1) {
    delete arg1;
}

swig_class cAGLine2;

static VALUE
_wrap_new_AGLine2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGLine2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLine2 *)new AGLine2();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLine2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLine2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLine2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLine2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *arg2 = 0 ;
    AGLine2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGLine2 *)new AGLine2((AGVector2 const &)*arg1,(AGVector2 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGLine2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGLine2__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGLine2__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGLine2'");
    return Qnil;
}


static VALUE
_wrap_AGLine2_getV0(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->getV0();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_getV1(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->getV1();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_has(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->has((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_collide(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->collide((AGLine2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_collisionPoint(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGLine2 const *)arg1)->collisionPoint((AGLine2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_collisionPointNI(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGLine2 const *)arg1)->collisionPointNI((AGLine2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_includes(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->includes((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_getBBox(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->getBBox();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_normal(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->normal();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_direction(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->direction();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_distance(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGLine2 const *)arg1)->distance((AGVector2 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGLine2_to_s(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 0);
    result = ((AGLine2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGLine2(AGLine2 *arg1) {
    delete arg1;
}

swig_class cAGLine3;

static VALUE
_wrap_new_AGLine3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGLine3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLine3 *)new AGLine3();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLine3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLine3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLine3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLine3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGLine3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGLine3 *)new AGLine3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGLine3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGLine3__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGLine3__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGLine3'");
    return Qnil;
}


static VALUE
_wrap_AGLine3_getV0(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    result = ((AGLine3 const *)arg1)->getV0();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_getV1(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    result = ((AGLine3 const *)arg1)->getV1();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_has(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine3 const *)arg1)->has((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine3_direction(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    result = ((AGLine3 const *)arg1)->direction();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_distance(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGLine3 const *)arg1)->distance((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGLine3_to_s(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 0);
    result = ((AGLine3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGLine3(AGLine3 *arg1) {
    delete arg1;
}

swig_class cAGCollisionData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCollisionData_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCollisionData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCollisionData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCollisionData(int argc, VALUE *argv, VALUE self) {
    AGCollisionData *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGCollisionData *)new AGCollisionData();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGCollisionData(AGCollisionData *arg1) {
    delete arg1;
}

swig_class cAGTriangle2;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTriangle2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTriangle2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTriangle2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTriangle2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 *arg3 = 0 ;
    AGTriangle2 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTriangle2 *)new AGTriangle2((AGVector2 const &)*arg1,(AGVector2 const &)*arg2,(AGVector2 const &)*arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGTriangle2_get(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    int arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    arg2 = NUM2INT(argv[0]);
    result = ((AGTriangle2 const *)arg1)->get(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_collide(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGTriangle2 const *)arg1)->collide((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getNormals(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    SwigValueWrapper<std::vector<AGVector2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    result = ((AGTriangle2 const *)arg1)->getNormals();
    
    {
        std::vector<AGVector2 > * resultptr;
        resultptr = new std::vector<AGVector2 >((std::vector<AGVector2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_apply(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->apply((AGMatrix3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTriangle2_applied(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    SwigValueWrapper<AGTriangle2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->applied((AGMatrix3 const &)*arg2);
    
    {
        AGTriangle2 * resultptr;
        resultptr = new AGTriangle2((AGTriangle2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTriangle2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_touchPoint(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->touchPoint((AGTriangle2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_touchVector(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->touchVector((AGTriangle2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_collisionPoints(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    SwigValueWrapper<std::vector<AGVector2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->collisionPoints((AGLine2 const &)*arg2);
    
    {
        std::vector<AGVector2 > * resultptr;
        resultptr = new std::vector<AGVector2 >((std::vector<AGVector2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_contains(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGTriangle2 const *)arg1)->contains((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getBBox(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    result = ((AGTriangle2 const *)arg1)->getBBox();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_nearestLine(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGLine2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->nearestLine((AGVector2 const &)*arg2);
    
    {
        AGLine2 * resultptr;
        resultptr = new AGLine2((AGLine2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGLine2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getLines(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    SwigValueWrapper<std::vector<AGLine2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    result = ((AGTriangle2 const *)arg1)->getLines();
    
    {
        std::vector<AGLine2 > * resultptr;
        resultptr = new std::vector<AGLine2 >((std::vector<AGLine2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_to_s(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 0);
    result = ((AGTriangle2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGTriangle2(AGTriangle2 *arg1) {
    delete arg1;
}

swig_class cAGCircle2;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCircle2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCircle2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCircle2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCircle2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    float arg2 ;
    AGCircle2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGCircle2 *)new AGCircle2((AGVector3 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGCircle2_inCircle__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->inCircle((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGCircle2_outCircle__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->outCircle((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGCircle2_inCircle__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->inCircle((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGCircle2_inCircle(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTriangle2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_inCircle__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_inCircle__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGCircle2_inCircle'");
    return Qnil;
}


static VALUE
_wrap_AGCircle2_outCircle__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->outCircle((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGCircle2_outCircle(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTriangle2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_outCircle__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_outCircle__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGCircle2_outCircle'");
    return Qnil;
}


static VALUE
_wrap_AGCircle2_getPos(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    result = ((AGCircle2 const *)arg1)->getPos();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGCircle2_getRadius(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 0);
    result = (float)((AGCircle2 const *)arg1)->getRadius();
    
    vresult = rb_float_new(result);
    return vresult;
}


static void
free_AGCircle2(AGCircle2 *arg1) {
    delete arg1;
}

swig_class cAGTriangle3;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTriangle3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTriangle3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTriangle3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTriangle3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *arg3 = 0 ;
    AGTriangle3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_AGVector3, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTriangle3 *)new AGTriangle3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2,(AGVector3 const &)*arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGTriangle3_collide(int argc, VALUE *argv, VALUE self) {
    AGTriangle3 *arg1 = (AGTriangle3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle3 const *)arg1)->collide((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle3_toString(int argc, VALUE *argv, VALUE self) {
    AGTriangle3 *arg1 = (AGTriangle3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle3, 0);
    result = ((AGTriangle3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGTriangle3(AGTriangle3 *arg1) {
    delete arg1;
}

swig_class cAGRect2;

static VALUE
_wrap_new_AGRect2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGRect2 *)new AGRect2();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGRect2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *arg2 = 0 ;
    AGRect2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect2 *)new AGRect2((AGVector2 const &)*arg1,(AGVector2 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGRect2__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    AGRect2 *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    arg4 = (float) NUM2DBL(argv[3]);
    result = (AGRect2 *)new AGRect2(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGRect2__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGRect2 *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGRect2 *)new AGRect2((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect2__SWIG_4(int argc, VALUE *argv, VALUE self) {
    SDL_Rect *arg1 = 0 ;
    AGRect2 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SDL_Rect, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect2 *)new AGRect2((SDL_Rect const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGRect2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGRect2__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SDL_Rect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGRect2__SWIG_4(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGRect2__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGRect2__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FLOAT) || (TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGRect2__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGRect2'");
    return Qnil;
}


static VALUE
_wrap_AGRect2_collide(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->collide((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2_include(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->include((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2___add__(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect2 const *)arg1)->operator +((AGVector2 const &)*arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_contains__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->contains((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2_contains__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->contains((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGRect2_contains(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect2_contains__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect2_contains__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGRect2_contains'");
    return Qnil;
}


static VALUE
_wrap_AGRect2_split(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    SwigValueWrapper<std::list<AGRect2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->split();
    
    {
        std::list<AGRect2 > * resultptr;
        resultptr = new std::list<AGRect2 >((std::list<AGRect2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTAGRect2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->getV0();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->getV1();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV01(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->getV01();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV10(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->getV10();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_shrink(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGRect2 const *)arg1)->shrink(arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_grow(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGRect2 const *)arg1)->grow(arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_setX(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setY(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setLeft(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setLeft(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setTop(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setTop(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setRight(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setRight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setBottom(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setBottom(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setWidth(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = (float)(arg1)->setWidth(arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_setHeight(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = (float)(arg1)->setHeight(arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_x(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->x();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_y(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->y();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_w(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->w();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_h(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->h();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_width(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->width();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_height(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->height();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_x0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->x0();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_y0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->y0();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_x1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->x1();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_y1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = (float)((AGRect2 const *)arg1)->y1();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_origin(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->origin();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_intersect(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect2 const *)arg1)->intersect((AGRect2 const &)*arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_sdl(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    SDL_Rect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->sdl();
    
    {
        SDL_Rect * resultptr;
        resultptr = new SDL_Rect((SDL_Rect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_SDL_Rect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2___eq__(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->operator ==((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2_check(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    ((AGRect2 const *)arg1)->check();
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_alignGrid(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->alignGrid();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_to_s(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 0);
    result = ((AGRect2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGRect2(AGRect2 *arg1) {
    delete arg1;
}

swig_class cAGVector4;

static VALUE
_wrap_AGVector4_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 0);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector4_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector4__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    AGVector4 *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    arg4 = (float) NUM2DBL(argv[3]);
    result = (AGVector4 *)new AGVector4(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGVector4 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGVector4 *)new AGVector4(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = 0 ;
    AGVector4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector4, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector4 *)new AGVector4((AGVector4 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    float arg2 ;
    AGVector4 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector4 *)new AGVector4((AGVector3 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector4_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector4__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGVector4 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector4 *)new AGVector4();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGVector4(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector4__SWIG_4(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector4__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector4__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVector4__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FLOAT) || (TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGVector4__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector4'");
    return Qnil;
}


static VALUE
_wrap_AGVector4_setX(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setY(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setZ(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setZ(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setW(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setW(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_x(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_y(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_z(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->getZ();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_w(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->getW();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator -((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___add__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator +((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_add(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector4 &_result_ref = (arg1)->operator +=((AGVector4 const &)*arg2);
        result = (AGVector4 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4_sub(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector4 &_result_ref = (arg1)->operator -=((AGVector4 const &)*arg2);
        result = (AGVector4 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector4 const *)arg1)->operator *((AGVector4 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector4 const *)arg1)->operator *(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector4___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector4___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector4___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector4___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector4___div__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector4 const *)arg1)->operator /(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___neg__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->operator -();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector4 const *)arg1)->operator ==((AGVector4 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4_length(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_length2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_length3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (float)((AGVector4 const *)arg1)->length3();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->normalized();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_normalized3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->normalized3();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_normalize3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    (arg1)->normalize3();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = (bool)((AGVector4 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4___mod__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator %((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_cross(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->cross((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_dim3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->dim3();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_dim2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->dim2();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 0);
    result = ((AGVector4 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGVector4(AGVector4 *arg1) {
    delete arg1;
}

swig_class cAGMatrix4;

static VALUE
_wrap_new_AGMatrix4__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMatrix4 *)new AGMatrix4();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGMatrix4__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float *arg1 ;
    AGMatrix4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_float, 0);
    result = (AGMatrix4 *)new AGMatrix4(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGMatrix4__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    AGVector3 *arg2 = 0 ;
    AGMatrix4 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix4 *)new AGMatrix4(arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMatrix4_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMatrix4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMatrix4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMatrix4__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = 0 ;
    AGMatrix4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector4, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix4 *)new AGMatrix4((AGVector4 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGMatrix4(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGMatrix4__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_float, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix4__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix4__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGMatrix4__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGMatrix4'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_set(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix4 const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix4_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->get(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix4_get(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4_get__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4_get__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4_get'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 *arg2 = 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix4 const *)arg1)->operator *((AGMatrix4 const &)*arg2);
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_get3x3(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = ((AGMatrix4 const *)arg1)->get3x3(arg2,arg3);
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix4 const *)arg1)->operator *((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE _wrap_AGMatrix4___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix4___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix4___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4___call____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix4 const *)arg1)->operator ()(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix4___call____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->operator ()(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix4___call__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4___call____SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4___call____SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4___call__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_inverted(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    result = ((AGMatrix4 const *)arg1)->inverted();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_transposed(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    result = ((AGMatrix4 const *)arg1)->transposed();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_to_s(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    result = ((AGMatrix4 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_getRow(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 0);
    arg2 = NUM2ULONG(argv[0]);
    result = ((AGMatrix4 const *)arg1)->getRow(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static void
free_AGMatrix4(AGMatrix4 *arg1) {
    delete arg1;
}

swig_class cAGRect3;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGRect3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect3 *)new AGRect3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGRect3_collides(int argc, VALUE *argv, VALUE self) {
    AGRect3 *arg1 = (AGRect3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect3 const *)arg1)->collides((AGLine3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect3_toString(int argc, VALUE *argv, VALUE self) {
    AGRect3 *arg1 = (AGRect3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect3, 0);
    result = ((AGRect3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGRect3(AGRect3 *arg1) {
    delete arg1;
}

swig_class cAGBox3;

static VALUE
_wrap_AGBox3_base_set(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0);
    if (arg1) (arg1)->base = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_base_get(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = (AGVector3 *)& ((arg1)->base);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGBox3_dir_set(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0);
    if (arg1) (arg1)->dir = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_dir_get(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = (AGVector3 *)& ((arg1)->dir);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_new_AGBox3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGBox3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGBox3 *)new AGBox3();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBox3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBox3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBox3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBox3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGBox3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGBox3 *)new AGBox3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGBox3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGBox3__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGBox3__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGBox3'");
    return Qnil;
}


static VALUE
_wrap_AGBox3_include(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->include((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_includes(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGBox3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBox3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)(arg1)->includes((AGBox3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGLine3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGBox3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBox3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGBox3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_getSides(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGRect3 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = ((AGBox3 const *)arg1)->getSides();
    
    {
        std::vector<AGRect3 > * resultptr;
        resultptr = new std::vector<AGRect3 >((std::vector<AGRect3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGRect3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_toString(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = ((AGBox3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_split(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGBox3 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = ((AGBox3 const *)arg1)->split();
    
    {
        std::vector<AGBox3 > * resultptr;
        resultptr = new std::vector<AGBox3 >((std::vector<AGBox3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGBox3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGMatrix4 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGMatrix4 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGBox3_collides(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGLine3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_3(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGBox3_collides'");
    return Qnil;
}


static VALUE
_wrap_AGBox3_getVertices(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGVector4 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = ((AGBox3 const *)arg1)->getVertices();
    
    {
        std::vector<AGVector4 > * resultptr;
        resultptr = new std::vector<AGVector4 >((std::vector<AGVector4 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3___add__(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGBox3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGBox3 const *)arg1)->operator +((AGVector3 const &)*arg2);
    
    {
        AGBox3 * resultptr;
        resultptr = new AGBox3((AGBox3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGBox3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3___sub__(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGBox3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGBox3 const *)arg1)->operator -((AGVector3 const &)*arg2);
    
    {
        AGBox3 * resultptr;
        resultptr = new AGBox3((AGBox3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGBox3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_valid(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 0);
    result = (bool)((AGBox3 const *)arg1)->valid();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGBox3(AGBox3 *arg1) {
    delete arg1;
}

swig_class cAGFont;

static VALUE
_wrap_new_AGFont__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGFont *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGFont *)new AGFont();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGFont__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    int arg2 ;
    AGFont *result;
    std::string temp1 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg2 = NUM2INT(argv[1]);
    result = (AGFont *)new AGFont((std::string const &)*arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFont_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFont_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFont);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFont__SWIG_2(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGFont *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGFont *)new AGFont((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGFont(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGFont__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGFont__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGFont__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGFont'");
    return Qnil;
}


static VALUE
_wrap_AGFont_setColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setBorderColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setBorderColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getBorderColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getBorderColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setBorder(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setBorder(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getBorder(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = (int)((AGFont const *)arg1)->getBorder();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_setAlpha(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setAlpha(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getAlpha(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getAlpha();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setSize(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSize(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getSize(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getSize();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setStyle(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGFont::Style *arg2 = 0 ;
    AGFont::Style temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    temp2 = (AGFont::Style) NUM2INT(argv[0]);
    arg2 = &temp2;
    (arg1)->setStyle((enum AGFont::Style const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getStyle(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGFont::Style result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = (AGFont::Style)((AGFont const *)arg1)->getStyle();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_setName(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getName(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setEmbossed(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setEmbossed(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getEmbossed(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = (bool)((AGFont const *)arg1)->getEmbossed();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGFont_setInset(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setInset(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getInset(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = (bool)((AGFont const *)arg1)->getInset();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGFont_getWidth(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)((AGFont const *)arg1)->getWidth((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_getHeight(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)((AGFont const *)arg1)->getHeight((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_toString(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 0);
    result = ((AGFont const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGFont(AGFont *arg1) {
    delete arg1;
}

swig_class cAGColor;

static VALUE
_wrap_new_AGColor__SWIG_0(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    AGColor *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    arg4 = NUM2INT(argv[3]);
    result = (AGColor *)new AGColor(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_1(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    AGColor *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    result = (AGColor *)new AGColor(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = 0 ;
    AGColor *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColor, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGColor *)new AGColor((AGColor const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = 0 ;
    AGColor *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector4, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGColor *)new AGColor((AGVector4 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_4(int argc, VALUE *argv, VALUE self) {
    Uint32 arg1 ;
    AGSurface *arg2 = 0 ;
    AGColor *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        Uint32 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint32, 0);
        if (ptr) arg1 = *ptr;
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGColor *)new AGColor(arg1,(AGSurface const &)*arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_5(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGColor *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGColor *)new AGColor((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGColor_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGColor_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGColor);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGColor__SWIG_6(int argc, VALUE *argv, VALUE self) {
    AGColor *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGColor *)new AGColor();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGColor(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGColor__SWIG_6(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGColor__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGColor__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGColor__SWIG_5(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Uint32, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGColor__SWIG_4(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGColor__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGColor__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGColor'");
    return Qnil;
}


static VALUE
_wrap_AGColor___mul__(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    float arg2 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGColor const *)arg1)->operator *(arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor___add__(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    AGColor *arg2 = 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGColor const *)arg1)->operator +((AGColor const &)*arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_mapRGB(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    SDL_PixelFormat *arg2 = (SDL_PixelFormat *) 0 ;
    Uint32 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_PixelFormat, 0);
    result = ((AGColor const *)arg1)->mapRGB(arg2);
    
    {
        Uint32 * resultptr;
        resultptr = new Uint32((Uint32 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint32, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_toString(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    result = ((AGColor const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGColor_toVec(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    result = ((AGColor const *)arg1)->toVec();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_grey(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    result = ((AGColor const *)arg1)->grey();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_brightness(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    result = ((AGColor const *)arg1)->brightness();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_light(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->light(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColor_a_set(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg2 = *ptr;
    }
    if (arg1) (arg1)->a = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGColor_a_get(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 0);
    result =  ((arg1)->a);
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static void
free_AGColor(AGColor *arg1) {
    delete arg1;
}

static VALUE
_wrap_toInt__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Uint8 arg1 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 0);
        if (ptr) arg1 = *ptr;
    }
    result = (int)toInt(arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


swig_class cAGWidget;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AGWidget *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWidget *)new SwigDirector_AGWidget(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGWidget *)new AGWidget(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGWidget(AGWidget *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGWidget_draw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_drawAfter(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAfter(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_drawAll(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAll(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = ((AGWidget const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect2 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGWidget const *)arg1)->getClientRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setRect((AGRect2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setParent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->setParent(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getParent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (AGWidget *)(arg1)->getParent();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<MiniMap*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_eventShow(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventShow();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventHide(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventHide();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventGotFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventGotFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventLostFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventLostFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_canFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGWidget const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_processEvent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->processEvent(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_sigMouseEnter_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseEnter = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigMouseEnter_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (AGSignal *)& ((arg1)->sigMouseEnter);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_sigMouseLeave_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMouseLeave = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigMouseLeave_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (AGSignal *)& ((arg1)->sigMouseLeave);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_sigClick_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigClick = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigClick_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (AGSignal *)& ((arg1)->sigClick);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_minWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (float)((AGWidget const *)arg1)->minWidth();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_minHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (float)((AGWidget const *)arg1)->minHeight();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_width(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->width();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_height(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->height();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_top(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->top();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_left(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->left();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_bottom(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->bottom();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_right(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (float)((AGWidget const *)arg1)->right();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_visible(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->visible();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_setWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setTop(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setTop(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setLeft(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setLeft(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_fixedWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->fixedWidth();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_fixedHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->fixedHeight();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_show(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->show();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_hide(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->hide();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_mark(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_addChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_addChildBack(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChildBack(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_removeChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->removeChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_redraw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGWidget const *)arg1)->redraw();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_prepareDraw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->prepareDraw();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setCaching(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setCaching(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_checkRedraw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->checkRedraw();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_setDrawn(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->setDrawn();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_queryRedraw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->queryRedraw();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getChangeRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (arg1)->getChangeRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_useTextures(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->useTextures();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_useTexturesRecursive(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->useTexturesRecursive();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_clear(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getScreenRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = ((AGWidget const *)arg1)->getScreenRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_getScreenPosition(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = ((AGWidget const *)arg1)->getScreenPosition();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_fromScreen(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGWidget const *)arg1)->fromScreen((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_gainFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->gainFocus(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->gainFocus();
    
    return Qnil;
}


static VALUE _wrap_AGWidget_gainFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_gainFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_gainFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_gainFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainCompleteFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->gainCompleteFocus(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainCompleteFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    (arg1)->gainCompleteFocus();
    
    return Qnil;
}


static VALUE _wrap_AGWidget_gainCompleteFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_gainCompleteFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_gainCompleteFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_gainCompleteFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_eventDragBy(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    AGVector2 *arg3 = 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventDragBy(arg2,(AGVector2 const &)*arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_getFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)((AGWidget const *)arg1)->getFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_hasFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    result = (bool)(arg1)->hasFocus((AGWidget const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_hasFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (bool)(arg1)->hasFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGWidget_hasFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_hasFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_hasFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_hasFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_getLayout(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGLayout *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (AGLayout *)(arg1)->getLayout();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<AGDialog*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_getName(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = ((AGWidget const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setName(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string *arg2 = 0 ;
    AGWidget *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGWidget *)(arg1)->getChild((std::string const &)*arg2);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<MiniMap*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setModal(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setModal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_erase(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->erase(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_eventChildrenDeleted(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->eventChildrenDeleted(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setTooltip(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setTooltip((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGWidget(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGWidget(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGWidget *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMessageObject, 0);
    result = (AGWidget *)toAGWidget(arg1);
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<AGCaption*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                else if(dynamic_cast<AGWindow*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                else if(dynamic_cast<AGSound*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                else if(dynamic_cast<AGDialog*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                else if(dynamic_cast<AGImage*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                else if(dynamic_cast<AGRadioGroup*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                else if(dynamic_cast<AGGLWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                else if(dynamic_cast<AGEdit*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                else if(dynamic_cast<AGListBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                else if(dynamic_cast<AGSubMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                else if(dynamic_cast<AGColorButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                else if(dynamic_cast<AGMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                else if(dynamic_cast<MiniMap*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
                else if(dynamic_cast<AGRadio*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                else if(dynamic_cast<AGText*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                else if(dynamic_cast<AGCheckBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                else if(dynamic_cast<AGMenuItem*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                else if(dynamic_cast<AGLayout*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                else if(dynamic_cast<AGButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                else if(dynamic_cast<AGTable*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
agNoParent_get(VALUE self) {
    VALUE _val;
    
    _val = SWIG_NewPointerObj((void *) agNoParent, SWIGTYPE_p_AGWidget,0);    return _val;
}


static VALUE
agNoParent_set(VALUE self, VALUE _val) {
    SWIG_ConvertPtr(_val, (void **) &agNoParent, SWIGTYPE_p_AGWidget, 1);
    return _val;
}


swig_class cAGColorButton;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGColorButton_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGColorButton_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGColorButton);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGColorButton(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    int arg4 ;
    int arg5 ;
    AGColorButton *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = NUM2INT(argv[2]);
    arg5 = NUM2INT(argv[3]);
    {
        char *classname = "Libantargis::AGColorButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGColorButton *)new SwigDirector_AGColorButton(arg1,arg2,(AGRect2 const &)*arg3,arg4,arg5);
            
        } else {
            result = (AGColorButton *)new AGColorButton(arg2,(AGRect2 const &)*arg3,arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGColorButton_draw(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColorButton_getColor(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    result = ((AGColorButton const *)arg1)->getColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColorButton_setColor__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColorButton_setColor__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGColorButton_setColor(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColorButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGColorButton_setColor__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColorButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGColorButton_setColor__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGColorButton_setColor'");
    return Qnil;
}


static VALUE
_wrap_AGColorButton_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGColorButton(AGColorButton *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGColorButton(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColorButton, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGColorButton(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGColorButton *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGColorButton &_result_ref = toAGColorButton(*arg1);
        result = (AGColorButton *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
    return vresult;
}


swig_class cAGGLWidget;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGGLWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGGLWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGGLWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGGLWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AGGLWidget *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGGLWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGGLWidget *)new SwigDirector_AGGLWidget(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGGLWidget *)new AGGLWidget(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGGLWidget_drawGL(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGL();
    
    return Qnil;
}


static VALUE
_wrap_AGGLWidget_drawAll(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAll(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGGLWidget_getRatio(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    result = (float)((AGGLWidget const *)arg1)->getRatio();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGGLWidget_setPerspective(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->setPerspective(arg2,arg3,arg4);
    
    return Qnil;
}


static void
free_AGGLWidget(AGGLWidget *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGGLWidget(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGGLWidget, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cNode;

static VALUE
_wrap_new_Node__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Node *)new Node();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_Node__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Node *)new Node(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_Node__SWIG_2(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = 0 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Node, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (Node *)new Node((Node const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Node_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Node_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Node);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Node__SWIG_3(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (Node *)new Node((Node const *)arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_Node(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Node__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Node'");
    return Qnil;
}


static void
free_Node(Node *arg1) {
    delete arg1;
}

static VALUE
_wrap_Node_setName(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_getChildren__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::NodeVector result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->getChildren();
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            Node* x = new Node(((Node::NodeVector &)result)[i]);
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_Node, 0));
        }
    }
    return vresult;
}


static VALUE
_wrap_Node_getChildren__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    Node::NodeVector result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->getChildren(arg2);
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            Node* x = new Node(((Node::NodeVector &)result)[i]);
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_Node, 0));
        }
    }
    return vresult;
}


static VALUE _wrap_Node_getChildren(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_getChildren__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_getChildren__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getChildren'");
    return Qnil;
}


static VALUE
_wrap_Node_getName(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_setAttributes(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::Attributes *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setAttributes((std::map<std::string,std::string > const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_addChild(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    Node *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        Node &_result_ref = (arg1)->addChild((std::string const &)*arg2);
        result = (Node *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Node_removeChild(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->removeChild(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_begin__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (arg1)->begin();
    
    {
        Node::iterator * resultptr;
        resultptr = new Node::iterator((Node::iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__iterator, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_begin__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::const_iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->begin();
    
    {
        Node::const_iterator * resultptr;
        resultptr = new Node::const_iterator((Node::const_iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__const_iterator, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_begin(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_begin__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_begin__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_begin'");
    return Qnil;
}


static VALUE
_wrap_Node_end__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (arg1)->end();
    
    {
        Node::iterator * resultptr;
        resultptr = new Node::iterator((Node::iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__iterator, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_end__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::const_iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->end();
    
    {
        Node::const_iterator * resultptr;
        resultptr = new Node::const_iterator((Node::const_iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__const_iterator, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_end(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_end__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_end__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_end'");
    return Qnil;
}


static VALUE
_wrap_Node_setContent(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setContent((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_getContent__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->getContent();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_set(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->set((std::string const &)*arg2,(std::string const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_get(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->get((std::string const &)*arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_clear(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_Node_escape(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = Node::escape((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_unescape(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = Node::unescape((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_getStart__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    bool arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = RTEST(argv[1]);
    ((Node const *)arg1)->getStart(*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_getStart__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((Node const *)arg1)->getStart(*arg2);
    
    return Qnil;
}


static VALUE _wrap_Node_getStart(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_getStart__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Node_getStart__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getStart'");
    return Qnil;
}


static VALUE
_wrap_Node_getEnd(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((Node const *)arg1)->getEnd(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_indent(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    ((Node const *)arg1)->indent(*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_getContent__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    ((Node const *)arg1)->getContent(*arg2,arg3);
    
    return Qnil;
}


static VALUE _wrap_Node_getContent(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_getContent__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Node_getContent__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getContent'");
    return Qnil;
}


static VALUE
_wrap_Node_toString__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool arg2 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    arg2 = RTEST(argv[0]);
    result = ((Node const *)arg1)->toString(arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_toString__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE _wrap_Node_toString(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_toString__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_toString__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_toString'");
    return Qnil;
}


static VALUE
_wrap_Node_isTextNode(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (bool)((Node const *)arg1)->isTextNode();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Node_getText(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_hasTextNode(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = (bool)((Node const *)arg1)->hasTextNode();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Node_size(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 0);
    result = ((Node const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


swig_class cDocument;

static VALUE
_wrap_new_Document__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Document *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Document *)new Document();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Document_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Document_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Document);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Document__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    Document *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Document *)new Document(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_Document(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Document__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Document__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Document'");
    return Qnil;
}


static void
free_Document(Document *arg1) {
    delete arg1;
}

static VALUE
_wrap_Document_parseFile(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)(arg1)->parseFile(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Document_root(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 0);
    {
        Node &_result_ref = (arg1)->root();
        result = (Node *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Document_toString(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 0);
    result = ((Document const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Document_parseMemory(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parseMemory((std::string const &)*arg2);
    
    return Qnil;
}


swig_class cParser;

static void
free_Parser(Parser *arg1) {
    delete arg1;
}

static VALUE
_wrap_Parser_parse(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parse((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_getLine(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    result = ((Parser const *)arg1)->getLine();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Parser_simpleTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->simpleTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Parser_startTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->startTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Parser_endTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endTag((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_text(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->text((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_comment(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->comment((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_header(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->header((std::string const &)*arg2);
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Parser_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Parser_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Parser);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Parser(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Parser *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::Parser";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (Parser *)new SwigDirector_Parser(arg1);
        
    } else {
        result = (Parser *)new Parser();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_disown_Parser(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Parser, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cDomParser;

static VALUE
_wrap_DomParser_simpleTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->simpleTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_startTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->startTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_endTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endTag((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_text(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->text((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_comment(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->comment((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_header(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->header((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_parse__SWIG_0(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Document *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Document *)(arg1)->parse((std::string const &)*arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


static VALUE
_wrap_DomParser_parse__SWIG_1(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Document *arg3 = (Document *) 0 ;
    Document *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Document, 0);
    result = (Document *)(arg1)->parse((std::string const &)*arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


static VALUE _wrap_DomParser_parse(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_DomParser, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_DomParser_parse__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_DomParser, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_Document, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_DomParser_parse__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'DomParser_parse'");
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_DomParser_allocate(VALUE self) {
#else
    static VALUE
    _wrap_DomParser_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_DomParser);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_DomParser(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    DomParser *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::DomParser";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (DomParser *)new SwigDirector_DomParser(arg1);
        
    } else {
        result = (DomParser *)new DomParser();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_DomParser(DomParser *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_DomParser(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_DomParser, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGLayout;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLayout_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLayout_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLayout);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLayout(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGLayout *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGLayout";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGLayout *)new SwigDirector_AGLayout(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGLayout *)new AGLayout(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGLayout_addTabIndex(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    int arg2 ;
    AGWidget *arg3 = (AGWidget *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayout, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGWidget, 0);
    (arg1)->addTabIndex(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGLayout_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayout, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLayout_getNextTabIndex(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayout, 0);
    result = (int)((AGLayout const *)arg1)->getNextTabIndex();
    
    vresult = INT2NUM(result);
    return vresult;
}


static void
free_AGLayout(AGLayout *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGLayout(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGLayout, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_parseNode(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AGWidget *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGWidget *)parseNode(arg1,(Node const &)*arg2);
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<AGCaption*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                else if(dynamic_cast<AGWindow*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                else if(dynamic_cast<AGSound*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                else if(dynamic_cast<AGDialog*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                else if(dynamic_cast<AGImage*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                else if(dynamic_cast<AGRadioGroup*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                else if(dynamic_cast<AGGLWidget*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                else if(dynamic_cast<AGEdit*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                else if(dynamic_cast<AGListBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                else if(dynamic_cast<AGSubMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                else if(dynamic_cast<AGColorButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                else if(dynamic_cast<AGMenu*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                else if(dynamic_cast<MiniMap*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
                else if(dynamic_cast<AGRadio*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                else if(dynamic_cast<AGText*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                else if(dynamic_cast<AGCheckBox*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                else if(dynamic_cast<AGMenuItem*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                else if(dynamic_cast<AGLayout*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                else if(dynamic_cast<AGButton*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                else if(dynamic_cast<AGTable*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_parseChildren(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    parseChildren(arg1,(Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_getLayoutGeometry(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = getLayoutGeometry(arg1,(Node const &)*arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


swig_class cAGDialog;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGDialog_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGDialog_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGDialog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGDialog(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGDialog *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGDialog";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGDialog *)new SwigDirector_AGDialog(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGDialog *)new AGDialog(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGDialog_eventOk(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventOk(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGDialog_eventCancel(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventCancel(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGDialog_eventClose(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventClose(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGDialog(AGDialog *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGDialog(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGDialog, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGMutex;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMutex_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMutex_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMutex);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMutex(int argc, VALUE *argv, VALUE self) {
    AGMutex *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMutex *)new AGMutex();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGMutex(AGMutex *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGMutex_enter(int argc, VALUE *argv, VALUE self) {
    AGMutex *arg1 = (AGMutex *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMutex, 0);
    (arg1)->enter();
    
    return Qnil;
}


static VALUE
_wrap_AGMutex_leave(int argc, VALUE *argv, VALUE self) {
    AGMutex *arg1 = (AGMutex *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMutex, 0);
    (arg1)->leave();
    
    return Qnil;
}


swig_class cAGApplication;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGApplication_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGApplication_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGApplication);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGApplication(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGApplication *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::AGApplication";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGApplication *)new SwigDirector_AGApplication(arg1);
            
        } else {
            result = (AGApplication *)new AGApplication();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGApplication(AGApplication *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGApplication_run(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    result = (bool)(arg1)->run();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventIdle(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventIdle();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventFrame(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrame(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventFrameEnd(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrameEnd(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventQuit(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuit(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventChangedRes(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventChangedRes();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_setMainWidget(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    (arg1)->setMainWidget(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_draw(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_prepareDraw(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->prepareDraw();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_tryQuit(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tryQuit();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_getTicks(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    long result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    result = (long)((AGApplication const *)arg1)->getTicks();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGApplication_delay(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->delay(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_setTooltip(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGTooltip *arg2 = (AGTooltip *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTooltip, 0);
    (arg1)->setTooltip(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_resetTooltip(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGTooltip *arg2 = (AGTooltip *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTooltip, 0);
    (arg1)->resetTooltip(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_setCursor(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGTexture *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setCursor((AGTexture const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_setNormalCursor(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    (arg1)->setNormalCursor();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_mark(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static VALUE
_wrap_disown_AGApplication(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGApplication, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getApplication(int argc, VALUE *argv, VALUE self) {
    AGApplication *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGApplication *)getApplication();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<GLApp*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GLApp,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGApplication,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_disableKeyrepeat(int argc, VALUE *argv, VALUE self) {
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    disableKeyrepeat();
    
    return Qnil;
}


swig_class cAGBackground;

static VALUE
_wrap_new_AGBackground__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    AGBackground *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGBackground *)new AGBackground(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGBackground__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBackground *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGBackground *)new AGBackground();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBackground_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBackground_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBackground);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBackground__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = 0 ;
    AGBackground *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColor, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGBackground *)new AGBackground((AGColor const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGBackground(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGBackground__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBackground__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBackground__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGBackground'");
    return Qnil;
}


static VALUE
_wrap_AGBackground_draw(int argc, VALUE *argv, VALUE self) {
    AGBackground *arg1 = (AGBackground *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGPainter *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBackground, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPainter, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw((AGRect2 const &)*arg2,*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGBackground_useTextures(int argc, VALUE *argv, VALUE self) {
    AGBackground *arg1 = (AGBackground *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBackground, 0);
    (arg1)->useTextures();
    
    return Qnil;
}


static void
free_AGBackground(AGBackground *arg1) {
    delete arg1;
}

swig_class cAGBorder;

static VALUE
_wrap_new_AGBorder__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGBorder *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGBorder *)new AGBorder((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBorder_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBorder_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBorder);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBorder__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBorder *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGBorder *)new AGBorder();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGBorder(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGBorder__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBorder__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGBorder'");
    return Qnil;
}


static VALUE
_wrap_AGBorder_draw(int argc, VALUE *argv, VALUE self) {
    AGBorder *arg1 = (AGBorder *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGPainter *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBorder, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPainter, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw((AGRect2 const &)*arg2,*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGBorder_getWidth(int argc, VALUE *argv, VALUE self) {
    AGBorder *arg1 = (AGBorder *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBorder, 0);
    result = ((AGBorder const *)arg1)->getWidth();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGBorder_useTextures(int argc, VALUE *argv, VALUE self) {
    AGBorder *arg1 = (AGBorder *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBorder, 0);
    (arg1)->useTextures();
    
    return Qnil;
}


static void
free_AGBorder(AGBorder *arg1) {
    delete arg1;
}

swig_class cAGButton;

static VALUE
_wrap_new_AGButton__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    std::string *arg4 = 0 ;
    int arg5 ;
    AGButton *result;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg5 = NUM2INT(argv[3]);
    {
        char *classname = "Libantargis::AGButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGButton *)new SwigDirector_AGButton(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,arg5);
            
        } else {
            result = (AGButton *)new AGButton(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGButton_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGButton_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGButton);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGButton__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGButton *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGButton *)new SwigDirector_AGButton(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGButton *)new AGButton(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGButton(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGButton__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = ((TYPE(argv[4]) == T_FIXNUM) || (TYPE(argv[4]) == T_BIGNUM)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGButton__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGButton'");
    return Qnil;
}


static VALUE
_wrap_AGButton_setSurface__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGSurface arg2 ;
    bool arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 0);
        if (ptr) arg2 = *ptr;
    }
    arg3 = RTEST(argv[1]);
    (arg1)->setSurface(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setSurface__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGSurface arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSurface(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGButton_setSurface(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGButton_setSurface__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGButton_setSurface__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGButton_setSurface'");
    return Qnil;
}


static VALUE
_wrap_AGButton_draw(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_setWidth(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setHeight(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_getCaption(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGButton const *)arg1)->getCaption();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGButton_setEnabled(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setEnabled(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setTheme(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setTheme((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setCaption(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setCaption((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setState(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGButton::State *arg2 = 0 ;
    AGButton::State temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    temp2 = (AGButton::State) NUM2INT(argv[0]);
    arg2 = &temp2;
    (arg1)->setState((enum AGButton::State const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setChecked(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    arg2 = RTEST(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setChecked(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_isChecked(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    result = (bool)((AGButton const *)arg1)->isChecked();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_canFocus(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGButton const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_useTextures(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->useTextures();
    
    return Qnil;
}


static void
free_AGButton(AGButton *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGButton(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGButton, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGButton(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGButton *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGButton &_result_ref = toAGButton(*arg1);
        result = (AGButton *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
    return vresult;
}


swig_class cAGText;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGText_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGText_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGText);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGText(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGFont *arg5 = 0 ;
    AGText *result;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGFont, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGText";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGText *)new SwigDirector_AGText(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5);
            
        } else {
            result = (AGText *)new AGText(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGText_setDeriveRect(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    (arg1)->setDeriveRect();
    
    return Qnil;
}


static VALUE
_wrap_AGText_draw(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGText_setText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGText_getText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    result = ((AGText const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGText_setFont(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static void
free_AGText(AGText *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGText, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGText(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGText *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGText &_result_ref = toAGText(*arg1);
        result = (AGText *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
    return vresult;
}


swig_class cAGCaption;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCaption_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCaption_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCaption);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCaption(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGFont *arg5 = 0 ;
    AGBackground *arg6 = 0 ;
    AGCaption *result;
    std::string temp4 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGFont, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGBackground, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGCaption";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGCaption *)new SwigDirector_AGCaption(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5,(AGBackground const &)*arg6);
            
        } else {
            result = (AGCaption *)new AGCaption(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5,(AGBackground const &)*arg6);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGCaption_draw(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCaption, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGCaption_setBackground(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    AGBackground arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCaption, 0);
    {
        AGBackground * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGBackground, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setBackground(arg2);
    
    return Qnil;
}


static void
free_AGCaption(AGCaption *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGCaption(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCaption, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGCheckBox;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCheckBox_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCheckBox_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCheckBox);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCheckBox(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 arg3 ;
    AGCheckBox *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        AGRect2 * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect2, 0);
        if (ptr) arg3 = *ptr;
    }
    {
        char *classname = "Libantargis::AGCheckBox";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGCheckBox *)new SwigDirector_AGCheckBox(arg1,arg2,arg3);
            
        } else {
            result = (AGCheckBox *)new AGCheckBox(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGCheckBox_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGCheckBox *arg1 = (AGCheckBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCheckBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGCheckBox(AGCheckBox *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGCheckBox(int argc, VALUE *argv, VALUE self) {
    AGCheckBox *arg1 = (AGCheckBox *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCheckBox, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGEditLine;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEditLine_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEditLine_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEditLine);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEditLine(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    AGFont arg3 ;
    bool arg4 ;
    AGEditLine *result;
    std::string temp2 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGFont * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGFont, 0);
        if (ptr) arg3 = *ptr;
    }
    arg4 = RTEST(argv[2]);
    char *classname = "Libantargis::AGEditLine";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEditLine *)new SwigDirector_AGEditLine(arg1,(std::string const &)*arg2,arg3,arg4);
        
    } else {
        result = (AGEditLine *)new AGEditLine((std::string const &)*arg2,arg3,arg4);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGEditLine(AGEditLine *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGEditLine_setAlign(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = (AGAlign) NUM2INT(argv[0]);
    (arg1)->setAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_setVAlign(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGVAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = (AGVAlign) NUM2INT(argv[0]);
    (arg1)->setVAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_draw(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGPainter *arg2 = 0 ;
    AGVector2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2,(AGVector2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_drawCursor(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGPainter *arg2 = 0 ;
    int arg3 ;
    AGVector2 *arg4 = 0 ;
    AGRect2 *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGVector2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGRect2, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawCursor(*arg2,arg3,(AGVector2 const &)*arg4,(AGRect2 const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_height(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = (int)((AGEditLine const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_width(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = (int)((AGEditLine const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_insert(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    char arg2 ;
    int arg3 ;
    bool arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2CHR(argv[0]);
    arg3 = NUM2INT(argv[1]);
    arg4 = RTEST(argv[2]);
    (arg1)->insert(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_doDelete(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->doDelete(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_split(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    SwigValueWrapper<AGEditLine > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2INT(argv[0]);
    result = (arg1)->split(arg2);
    
    {
        AGEditLine * resultptr;
        resultptr = new AGEditLine((AGEditLine &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGEditLine, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_length(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = (int)((AGEditLine const *)arg1)->length();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_append(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->append(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_prepend(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->prepend(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_getText(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = ((AGEditLine const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_getFont(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGFont result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = ((AGEditLine const *)arg1)->getFont();
    
    {
        AGFont * resultptr;
        resultptr = new AGFont((AGFont &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGFont, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_setText(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_hardEnd(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    result = (bool)((AGEditLine const *)arg1)->hardEnd();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEditLine_setHardEnd(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setHardEnd(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_checkUnwrap(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    std::string arg3 ;
    std::pair<std::string,bool > result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2INT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg3 = std::string(StringValuePtr(argv[1]));
            arg3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->checkUnwrap(arg2,arg3);
    
    {
        std::pair<std::string,bool > * resultptr;
        resultptr = new std::pair<std::string,bool >((std::pair<std::string,bool > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTstd__string_bool_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_checkWrap(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    std::pair<std::string,bool > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    arg2 = NUM2INT(argv[0]);
    result = (arg1)->checkWrap(arg2);
    
    {
        std::pair<std::string,bool > * resultptr;
        resultptr = new std::pair<std::string,bool >((std::pair<std::string,bool > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTstd__string_bool_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_setFont(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGEditLine(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEditLine, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGEdit;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEdit_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEdit_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEdit);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEdit(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AGEdit *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGEdit";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGEdit *)new SwigDirector_AGEdit(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGEdit *)new AGEdit(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGEdit_draw(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_drawBackground(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawBackground(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_eventKeyUp(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_setMulti(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setMulti(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_insert(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    char arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = NUM2CHR(argv[0]);
    result = (bool)(arg1)->insert(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_doDelete(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->doDelete(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setText(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setFont(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_clear(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setMutable(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setMutable(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setAlign(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = (AGAlign) NUM2INT(argv[0]);
    (arg1)->setAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setVAlign(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGVAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = (AGVAlign) NUM2INT(argv[0]);
    (arg1)->setVAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setBackground__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setBackground(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setBackground__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGBackground *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBackground, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setBackground((AGBackground const &)*arg2);
    
    return Qnil;
}


static VALUE _wrap_AGEdit_setBackground(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGEdit, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGBackground, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGEdit_setBackground__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGEdit, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGEdit_setBackground__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGEdit_setBackground'");
    return Qnil;
}


static VALUE
_wrap_AGEdit_setTheme(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setTheme((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_canFocus(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGEdit const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_getText(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    result = ((AGEdit const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGEdit_setMaxLength(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setMaxLength(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_eventGotFocus(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventGotFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_eventLostFocus(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventLostFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_prepareDraw(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->prepareDraw();
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setInsert(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setInsert(arg2);
    
    return Qnil;
}


static void
free_AGEdit(AGEdit *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGEdit(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEdit, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGEdit(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGEdit *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGEdit &_result_ref = toAGEdit(*arg1);
        result = (AGEdit *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
    return vresult;
}


swig_class cAGFontEngine;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFontEngine_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFontEngine_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFontEngine);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFontEngine(int argc, VALUE *argv, VALUE self) {
    AGFontEngine *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGFontEngine *)new AGFontEngine();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGFontEngine(AGFontEngine *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGFontEngine_renderText(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    std::string *arg3 = 0 ;
    AGFont *arg4 = 0 ;
    AGTexture *result;
    std::string temp3 ;
    VALUE vresult = Qnil;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[2]));
            temp3 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg4, SWIGTYPE_p_AGFont, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTexture *)AGFontEngine::renderText(arg1,arg2,(std::string const &)*arg3,(AGFont const &)*arg4);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
    return vresult;
}


static VALUE
_wrap_AGFontEngine_getWidth(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGFont, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)AGFontEngine::getWidth((AGFont const &)*arg1,(std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFontEngine_getHeight(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGFont, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)AGFontEngine::getHeight((AGFont const &)*arg1,(std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_initFS(int argc, VALUE *argv, VALUE self) {
    char *arg1 = (char *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = StringValuePtr(argv[0]);
    initFS((char const *)arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = loadFile((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_saveFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    saveFile((std::string const &)*arg1,(std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_fileExists(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    bool result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)fileExists((std::string const &)*arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_getDirectory(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::vector<std::string > result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = getDirectory((std::string const &)*arg1);
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++)
        rb_ary_store(vresult,i,SWIG_STR2RB(((std::vector<std::string > &)result)[i]));
    }
    return vresult;
}


static VALUE
_wrap_checkFileName(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = checkFileName(arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_getWriteDir(int argc, VALUE *argv, VALUE self) {
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = getWriteDir();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_findFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = findFile((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_addPath(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    addPath((std::string const &)*arg1);
    
    return Qnil;
}


swig_class cAGPaintTarget;

static void
free_AGPaintTarget(AGPaintTarget *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGPaintTarget_blitTri(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGTexture *arg2 = 0 ;
    AGTriangle2 *arg3 = 0 ;
    AGTriangle2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGTriangle2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGTriangle2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blitTri((AGTexture const &)*arg2,(AGTriangle2 const &)*arg3,(AGTriangle2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_blit__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPaintTarget_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPaintTarget_blit__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPaintTarget_blit__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGPaintTarget_blit__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPaintTarget_blit'");
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_drawLine(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawLine((AGVector2 const &)*arg2,(AGVector2 const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_fillRect(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->fillRect((AGRect2 const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_fillRects(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    std::vector<std::pair<AGRect2,AGVector4 > > *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTstd__pairTAGRect2_AGVector4_t_t, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->fillRects((std::vector<std::pair<AGRect2,AGVector4 > > const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_getRect(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    AGRect2 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGPaintTarget const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPaintTarget_putPixel(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_getPixel(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGPaintTarget const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPaintTarget_beginPaint(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->beginPaint();
    
    return Qnil;
}


static VALUE
_wrap_AGPaintTarget_endPaint(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endPaint();
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPaintTarget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPaintTarget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPaintTarget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPaintTarget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGPaintTarget *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGPaintTarget";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGPaintTarget *)new SwigDirector_AGPaintTarget(arg1);
        
    } else {
        result = (AGPaintTarget *)new AGPaintTarget();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_disown_AGPaintTarget(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = (AGPaintTarget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_beginRender(int argc, VALUE *argv, VALUE self) {
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    beginRender();
    
    return Qnil;
}


static VALUE
_wrap_endRender(int argc, VALUE *argv, VALUE self) {
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    endRender();
    
    return Qnil;
}


static VALUE
_wrap_isRendering(int argc, VALUE *argv, VALUE self) {
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (bool)isRendering();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


swig_class cAGInternalSurface;

static VALUE
_wrap_AGInternalSurface_sdlTexture_set(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    AGInternalSurface *arg2 = (AGInternalSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGInternalSurface, SWIG_POINTER_DISOWN);
    if (arg1) (arg1)->sdlTexture = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGInternalSurface_sdlTexture_get(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    AGInternalSurface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    result = (AGInternalSurface *) ((arg1)->sdlTexture);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGInternalSurface,0);
    return vresult;
}


static VALUE
_wrap_AGInternalSurface_glTexture_set(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    AGGLTexture *arg2 = (AGGLTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGGLTexture, SWIG_POINTER_DISOWN);
    if (arg1) (arg1)->glTexture = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGInternalSurface_glTexture_get(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    AGGLTexture *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    result = (AGGLTexture *) ((arg1)->glTexture);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLTexture,0);
    return vresult;
}


static VALUE
_wrap_AGInternalSurface_surface_set(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    SDL_Surface *arg2 = (SDL_Surface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Surface, SWIG_POINTER_DISOWN);
    if (arg1) (arg1)->surface = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGInternalSurface_surface_get(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    SDL_Surface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    result = (SDL_Surface *) ((arg1)->surface);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


static VALUE
_wrap_AGInternalSurface_version_set(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    size_t arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    arg2 = NUM2ULONG(argv[0]);
    if (arg1) (arg1)->version = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGInternalSurface_version_get(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *arg1 = (AGInternalSurface *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGInternalSurface, 0);
    result =  ((arg1)->version);
    
    vresult = UINT2NUM(result);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGInternalSurface_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGInternalSurface_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGInternalSurface);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGInternalSurface(int argc, VALUE *argv, VALUE self) {
    AGInternalSurface *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGInternalSurface *)new AGInternalSurface();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGInternalSurface(AGInternalSurface *arg1) {
    delete arg1;
}

swig_class cAGDecryptor;

static void
free_AGDecryptor(AGDecryptor *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGDecryptor_decrypt(int argc, VALUE *argv, VALUE self) {
    AGDecryptor *arg1 = (AGDecryptor *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string result;
    std::string temp2 ;
    std::string temp3 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDecryptor, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (arg1)->decrypt((std::string const &)*arg2,(std::string const &)*arg3);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGDecryptor_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGDecryptor_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGDecryptor);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGDecryptor(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGDecryptor *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGDecryptor";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGDecryptor *)new SwigDirector_AGDecryptor(arg1);
        
    } else {
        result = (AGDecryptor *)new AGDecryptor();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_disown_AGDecryptor(int argc, VALUE *argv, VALUE self) {
    AGDecryptor *arg1 = (AGDecryptor *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGDecryptor, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSurface;

static VALUE
_wrap_new_AGSurface__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1);
        
    } else {
        result = (AGSurface *)new AGSurface();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGSurface__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    AGSurface *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    char *classname = "Libantargis::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1,arg2,arg3);
        
    } else {
        result = (AGSurface *)new AGSurface(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSurface_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSurface_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSurface);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSurface__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *arg2 = 0 ;
    AGSurface *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargis::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1,(AGSurface const &)*arg2);
        
    } else {
        result = (AGSurface *)new AGSurface((AGSurface const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGSurface(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGSurface__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGSurface__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGSurface__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGSurface'");
    return Qnil;
}


static void
free_AGSurface(AGSurface *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGSurface_copy(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = ((AGSurface const *)arg1)->copy();
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_width(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = (int)((AGSurface const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSurface_height(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = (int)((AGSurface const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSurface_getRect(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect2 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSurface const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_getSubSurface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGSurface result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGSurface const *)arg1)->getSubSurface((AGRect2 const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_valid(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = (bool)((AGSurface const *)arg1)->valid();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSurface_scale(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int arg2 ;
    int arg3 ;
    AGSurface result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = ((AGSurface const *)arg1)->scale(arg2,arg3);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_blit(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradient((AGRect2 const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawGradientAlpha(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradientAlpha((AGRect2 const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect2 *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawBorder((AGRect2 const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_putPixel(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_getPixel(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSurface const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_save(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    ((AGSurface const *)arg1)->save((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_load(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGSurface result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = AGSurface::load((std::string const &)*arg1);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_loadDRM(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGDecryptor *arg2 = 0 ;
    AGSurface result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGDecryptor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = AGSurface::loadDRM((std::string const &)*arg1,*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_surface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGInternalSurface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    result = (AGInternalSurface *)((AGSurface const *)arg1)->surface();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGInternalSurface,0);
    return vresult;
}


static VALUE
_wrap_disown_AGSurface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSurface, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_AGFreeSurface(int argc, VALUE *argv, VALUE self) {
    SDL_Surface *arg1 = (SDL_Surface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SDL_Surface, 0);
    AGFreeSurface(arg1);
    
    return Qnil;
}


swig_class cAGTexture;

static VALUE
_wrap_new_AGTexture__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGTexture *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1);
        
    } else {
        result = (AGTexture *)new AGTexture();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGTexture__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *arg2 = 0 ;
    bool arg3 ;
    AGTexture *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = RTEST(argv[1]);
    char *classname = "Libantargis::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1,(AGSurface const &)*arg2,arg3);
        
    } else {
        result = (AGTexture *)new AGTexture((AGSurface const &)*arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGTexture__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *arg2 = 0 ;
    AGTexture *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargis::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1,(AGSurface const &)*arg2);
        
    } else {
        result = (AGTexture *)new AGTexture((AGSurface const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGTexture__SWIG_3(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGTexture *arg2 = 0 ;
    AGTexture *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargis::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1,(AGTexture const &)*arg2);
        
    } else {
        result = (AGTexture *)new AGTexture((AGTexture const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTexture_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTexture_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTexture);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTexture__SWIG_4(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    AGTexture *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    char *classname = "Libantargis::AGTexture";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTexture *)new SwigDirector_AGTexture(arg1,arg2,arg3);
        
    } else {
        result = (AGTexture *)new AGTexture(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGTexture(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGTexture__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGTexture__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGTexture__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGTexture__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGTexture__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGTexture'");
    return Qnil;
}


static void
free_AGTexture(AGTexture *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGTexture_copy(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGTexture result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = ((AGTexture const *)arg1)->copy();
    
    {
        AGTexture * resultptr;
        resultptr = new AGTexture((AGTexture &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTexture, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_width(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (int)((AGTexture const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_height(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (int)((AGTexture const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getRect(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGRect2 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGTexture const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_getPixel(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGTexture const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_getSurfaceWidth(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getSurfaceWidth();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getSurfaceHeight(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getSurfaceHeight();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTextureWidth(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getTextureWidth();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTextureHeight(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getTextureHeight();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTW(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getTW();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTH(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (float)((AGTexture const *)arg1)->getTH();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_hasTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (bool)((AGTexture const *)arg1)->hasTexture();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTexture_textureUsed(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (bool)((AGTexture const *)arg1)->textureUsed();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTexture_clearTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    (arg1)->clearTexture();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_clearTextureUsed(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    (arg1)->clearTextureUsed();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_useTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    (arg1)->useTexture();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_beginPaint(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->beginPaint();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_endPaint(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endPaint();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_putPixel(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_fillRect(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->fillRect((AGRect2 const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE _wrap_AGTexture_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGTexture_blit__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGTexture_blit__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGTexture_blit'");
    return Qnil;
}


static VALUE
_wrap_AGTexture_drawLine(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawLine((AGVector2 const &)*arg2,(AGVector2 const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGradient((AGRect2 const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_drawGradientAlpha(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGradientAlpha((AGRect2 const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_setWrapping(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setWrapping(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_setFilter(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    GLuint arg2 ;
    GLuint arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg2 = *ptr;
    }
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setFilter(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_setClamp(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    GLuint arg2 ;
    GLuint arg3 ;
    GLuint arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg2 = *ptr;
    }
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg3 = *ptr;
    }
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_GLuint, 0);
        if (ptr) arg4 = *ptr;
    }
    (arg1)->setClamp(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_glTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGGLTexture *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (AGGLTexture *)(arg1)->glTexture();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLTexture,0);
    return vresult;
}


static VALUE
_wrap_AGTexture_sdlTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGInternalSurface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (AGInternalSurface *)(arg1)->sdlTexture();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGInternalSurface,0);
    return vresult;
}


static VALUE
_wrap_AGTexture_is3d(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    result = (bool)((AGTexture const *)arg1)->is3d();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTexture, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSurfaceManager;

static void
free_AGSurfaceManager(AGSurfaceManager *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGSurfaceManager_registerMe__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGSurface *arg2 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0);
    (arg1)->registerMe(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_deregisterMe__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGSurface *arg2 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0);
    (arg1)->deregisterMe(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_registerMe__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGTexture *arg2 = (AGTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0);
    (arg1)->registerMe(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_deregisterMe__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGTexture *arg2 = (AGTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0);
    (arg1)->deregisterMe(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_registerMe__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGInternalSurface *arg2 = (AGInternalSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGInternalSurface, 0);
    (arg1)->registerMe(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_deregisterMe__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGInternalSurface *arg2 = (AGInternalSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGInternalSurface, 0);
    (arg1)->deregisterMe(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_registerMe__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGRenderContext *arg2 = (AGRenderContext *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRenderContext, 0);
    (arg1)->registerMe(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_deregisterMe__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGRenderContext *arg2 = (AGRenderContext *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRenderContext, 0);
    (arg1)->deregisterMe(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_registerMe__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGGLTexture *arg2 = (AGGLTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGGLTexture, 0);
    (arg1)->registerMe(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSurfaceManager_registerMe(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_registerMe__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_registerMe__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGInternalSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_registerMe__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRenderContext, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_registerMe__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGGLTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_registerMe__SWIG_4(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSurfaceManager_registerMe'");
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_deregisterMe__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGGLTexture *arg2 = (AGGLTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGGLTexture, 0);
    (arg1)->deregisterMe(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSurfaceManager_deregisterMe(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_deregisterMe__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_deregisterMe__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGInternalSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_deregisterMe__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRenderContext, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_deregisterMe__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGGLTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_deregisterMe__SWIG_4(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSurfaceManager_deregisterMe'");
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_cleanup__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->cleanup(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_cleanup__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    (arg1)->cleanup();
    
    return Qnil;
}


static VALUE _wrap_AGSurfaceManager_cleanup(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGSurfaceManager_cleanup__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurfaceManager, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSurfaceManager_cleanup__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSurfaceManager_cleanup'");
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_clear(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_getUsedTexMem(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 0);
    result = ((AGSurfaceManager const *)arg1)->getUsedTexMem();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_getSurfaceManager(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGSurfaceManager *)getSurfaceManager();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSurfaceManager,0);
    return vresult;
}


swig_class cAGImage;

static VALUE
_wrap_new_AGImage__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AGSurface arg4 ;
    bool arg5 ;
    AGRect2 *arg6 = 0 ;
    AGImage *result;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGSurface, 0);
        if (ptr) arg4 = *ptr;
    }
    arg5 = RTEST(argv[3]);
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGRect2, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGImage";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGImage *)new SwigDirector_AGImage(arg1,arg2,(AGRect2 const &)*arg3,arg4,arg5,(AGRect2 const &)*arg6);
            
        } else {
            result = (AGImage *)new AGImage(arg2,(AGRect2 const &)*arg3,arg4,arg5,(AGRect2 const &)*arg6);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGImage_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGImage_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGImage);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGImage__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AGSurface arg4 ;
    bool arg5 ;
    AGImage *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGSurface, 0);
        if (ptr) arg4 = *ptr;
    }
    arg5 = RTEST(argv[3]);
    {
        char *classname = "Libantargis::AGImage";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGImage *)new SwigDirector_AGImage(arg1,arg2,(AGRect2 const &)*arg3,arg4,arg5);
            
        } else {
            result = (AGImage *)new AGImage(arg2,(AGRect2 const &)*arg3,arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGImage(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[7];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 6); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGImage__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    if (argc == 6) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            {
                                void *ptr;
                                _v = (NIL_P(argv[5]) || (TYPE(argv[5]) == T_DATA && SWIG_ConvertPtr(argv[5], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                            }
                            if (_v) {
                                return _wrap_new_AGImage__SWIG_0(nargs, args, self);
                            }
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGImage'");
    return Qnil;
}


static void
free_AGImage(AGImage *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGImage_draw(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGImage_setSurface(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGSurface *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setSurface((AGSurface const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGImage_setTexture(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGTexture *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setTexture((AGTexture const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGImage_useTextures(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->useTextures();
    
    return Qnil;
}


static VALUE
_wrap_AGImage_setCenter(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setCenter(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGImage(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGImage, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGLayoutCreator;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLayoutCreator_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLayoutCreator_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLayoutCreator);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLayoutCreator(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    AGLayoutCreator *result;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::AGLayoutCreator";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGLayoutCreator *)new SwigDirector_AGLayoutCreator(arg1,(std::string const &)*arg2);
        
    } else {
        result = (AGLayoutCreator *)new AGLayoutCreator((std::string const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGLayoutCreator(AGLayoutCreator *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGLayoutCreator_create(int argc, VALUE *argv, VALUE self) {
    AGLayoutCreator *arg1 = (AGLayoutCreator *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    xmlpp::Node *arg4 = 0 ;
    AGWidget *result;
    Swig::Director *director = 0;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutCreator, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_Node, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (AGWidget *)(arg1)->create(arg2,(AGRect2 const &)*arg3,(Node const &)*arg4);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<MiniMap*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_disown_AGLayoutCreator(int argc, VALUE *argv, VALUE self) {
    AGLayoutCreator *arg1 = (AGLayoutCreator *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGLayoutCreator, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGLayoutFactory;

static void
free_AGLayoutFactory(AGLayoutFactory *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGLayoutFactory_addCreator(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *arg1 = (AGLayoutFactory *) 0 ;
    std::string *arg2 = 0 ;
    AGLayoutCreator *arg3 = (AGLayoutCreator *) 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutFactory, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGLayoutCreator, 0);
    (arg1)->addCreator((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGLayoutFactory_create(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *arg1 = (AGLayoutFactory *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    xmlpp::Node *arg4 = 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutFactory, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_Node, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGWidget *)(arg1)->create(arg2,(AGRect2 const &)*arg3,(Node const &)*arg4);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<MiniMap*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_getLayoutFactory(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLayoutFactory *)getLayoutFactory();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayoutFactory,0);
    return vresult;
}


swig_class cAGListBoxItem;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListBoxItem_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListBoxItem_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListBoxItem);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListBoxItem(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    std::string arg2 ;
    AGListBoxItem *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[1]));
            arg2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGListBoxItem *)new AGListBoxItem(arg1,arg2);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGListBoxItem_id_set(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 0);
    if (arg1) (arg1)->id = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBoxItem_id_get(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 0);
    result = (std::string *)& ((arg1)->id);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_AGListBoxItem_value_set(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 0);
    if (arg1) (arg1)->value = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBoxItem_value_get(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 0);
    result = (std::string *)& ((arg1)->value);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static void
free_AGListBoxItem(AGListBoxItem *arg1) {
    delete arg1;
}

swig_class cAGListBox;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListBox_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListBox_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListBox);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListBox(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AGListBox *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGListBox";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGListBox *)new SwigDirector_AGListBox(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGListBox *)new AGListBox(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGListBox_insertItem(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string arg2 ;
    std::string arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg3 = std::string(StringValuePtr(argv[1]));
            arg3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->insertItem(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_selectItem(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->selectItem(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_getSelectedID(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    result = ((AGListBox const *)arg1)->getSelectedID();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGListBox_getSelectedValue(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    result = ((AGListBox const *)arg1)->getSelectedValue();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGListBox_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGListBox_sigSelect_set(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigSelect = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_sigSelect_get(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    result = (AGSignal *)& ((arg1)->sigSelect);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGListBox_sigDoubleClick_set(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigDoubleClick = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_sigDoubleClick_get(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    result = (AGSignal *)& ((arg1)->sigDoubleClick);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGListBox_draw(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGListBox_clearList(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    (arg1)->clearList();
    
    return Qnil;
}


static void
free_AGListBox(AGListBox *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGListBox(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListBox, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGListBox(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGListBox *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGListBox &_result_ref = toAGListBox(*arg1);
        result = (AGListBox *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
    return vresult;
}


swig_class cAGMain;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMain_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMain_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMain);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMain(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    bool arg5 ;
    bool arg6 ;
    AGMain *result;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    arg5 = RTEST(argv[3]);
    arg6 = RTEST(argv[4]);
    {
        char *classname = "Libantargis::AGMain";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGMain *)new SwigDirector_AGMain(arg1,arg2,arg3,arg4,arg5,arg6);
            
        } else {
            result = (AGMain *)new AGMain(arg2,arg3,arg4,arg5,arg6);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGMain(AGMain *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGMain_flip(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGMain_changeRes(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    bool arg5 ;
    bool arg6 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    arg5 = RTEST(argv[3]);
    arg6 = RTEST(argv[4]);
    (arg1)->changeRes(arg2,arg3,arg4,arg5,arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGMain_toggleFull(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    (arg1)->toggleFull();
    
    return Qnil;
}


static VALUE
_wrap_AGMain_width(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    result = (int)((AGMain const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGMain_height(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    result = (int)((AGMain const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGMain_setIcon(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setIcon((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMain_setCaption(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setCaption((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMain_fullscreen(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    result = (bool)((AGMain const *)arg1)->fullscreen();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGMain(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMain, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getMain(int argc, VALUE *argv, VALUE self) {
    AGMain *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMain *)getMain();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMain,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_hasQuit(int argc, VALUE *argv, VALUE self) {
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (bool)hasQuit();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


swig_class cAGMenu;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMenu_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMenu_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMenu);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMenu(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGVector2 arg2 ;
    std::string *arg3 = 0 ;
    AGMenu *result;
    std::string temp3 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    {
        AGVector2 * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGVector2, 0);
        if (ptr) arg2 = *ptr;
    }
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[2]));
            temp3 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        result = (AGMenu *)new AGMenu(arg1,arg2,(std::string const &)*arg3);
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGMenu_show(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGVector2 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        AGVector2 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGVector2, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->show(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_addItem(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->addItem((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_addMenu(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    AGMenu *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGMenu &_result_ref = (arg1)->addMenu((std::string const &)*arg2);
        result = (AGMenu *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
    return vresult;
}


static VALUE
_wrap_AGMenu_draw(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGPainter *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_eventItemSelected(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->eventItemSelected((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_eventItemClicked(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->eventItemClicked((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_sigSelected_set(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigSelected = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_sigSelected_get(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 0);
    result = (AGSignal *)& ((arg1)->sigSelected);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static void
free_AGMenu(AGMenu *arg1) {
    delete arg1;
}

swig_class cAGMenuItem;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMenuItem_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMenuItem_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMenuItem);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMenuItem(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGMenuItem *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGMenuItem";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGMenuItem *)new SwigDirector_AGMenuItem(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGMenuItem *)new AGMenuItem(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGMenuItem(AGMenuItem *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGMenuItem_draw(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    AGPainter *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenuItem_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMenuItem_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMenuItem_getSelected(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    result = (bool)((AGMenuItem const *)arg1)->getSelected();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMenuItem_unSelect(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    (arg1)->unSelect();
    
    return Qnil;
}


static VALUE
_wrap_AGMenuItem_getName(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    result = ((AGMenuItem const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGMenuItem_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMenuItem_eventSelect(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventSelect();
    
    return Qnil;
}


static VALUE
_wrap_AGMenuItem_eventUnselect(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventUnselect();
    
    return Qnil;
}


static VALUE
_wrap_disown_AGMenuItem(int argc, VALUE *argv, VALUE self) {
    AGMenuItem *arg1 = (AGMenuItem *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMenuItem, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSubMenu;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSubMenu_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSubMenu_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSubMenu);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSubMenu(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGSubMenu *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGSubMenu";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGSubMenu *)new SwigDirector_AGSubMenu(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGSubMenu *)new AGSubMenu(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGSubMenu(AGSubMenu *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGSubMenu_getMenu(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    AGMenu *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    result = (AGMenu *)(arg1)->getMenu();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_AGSubMenu_eventSelect(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventSelect();
    
    return Qnil;
}


static VALUE
_wrap_AGSubMenu_eventUnselect(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventUnselect();
    
    return Qnil;
}


static VALUE
_wrap_AGSubMenu_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGSubMenu(int argc, VALUE *argv, VALUE self) {
    AGSubMenu *arg1 = (AGSubMenu *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSubMenu, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSound;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSound_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSound_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSound);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSound(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSound *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::AGSound";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGSound *)new SwigDirector_AGSound(arg1);
            
        } else {
            result = (AGSound *)new AGSound();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGSound(AGSound *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGSound_playMp3(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)(arg1)->playMp3((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSound_stopMp3(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    (arg1)->stopMp3();
    
    return Qnil;
}


static VALUE
_wrap_AGSound_checkFinished(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    (arg1)->checkFinished();
    
    return Qnil;
}


static VALUE
_wrap_AGSound_fadeOutMusic(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->fadeOutMusic(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_playWave__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->playWave((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_playWave__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->playWave((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSound_playWave(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSound_playWave__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSound_playWave__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSound_playWave'");
    return Qnil;
}


static VALUE
_wrap_AGSound_loopPlay__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    result = (int)(arg1)->loopPlay((std::string const &)*arg2,arg3);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSound_loopPlay__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)(arg1)->loopPlay((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE _wrap_AGSound_loopPlay(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSound_loopPlay__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSound_loopPlay__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSound_loopPlay'");
    return Qnil;
}


static VALUE
_wrap_AGSound_stopChannel__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    int arg2 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    (arg1)->stopChannel(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_stopChannel__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->stopChannel(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSound_stopChannel(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSound_stopChannel__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSound_stopChannel__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSound_stopChannel'");
    return Qnil;
}


static VALUE
_wrap_AGSound_stopAllChannels__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->stopAllChannels(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_stopAllChannels__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    (arg1)->stopAllChannels();
    
    return Qnil;
}


static VALUE _wrap_AGSound_stopAllChannels(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGSound_stopAllChannels__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSound, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSound_stopAllChannels__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSound_stopAllChannels'");
    return Qnil;
}


static VALUE
_wrap_AGSound_volumeSound(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->volumeSound(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_volumeMusic(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->volumeMusic(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_loadWave(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->loadWave((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSound_sigMp3Finished_set(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMp3Finished = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGSound_sigMp3Finished_get(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    result = (AGSignal *)& ((arg1)->sigMp3Finished);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_getSoundManager(int argc, VALUE *argv, VALUE self) {
    AGSound *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGSound *)getSoundManager();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_disown_AGSound(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSound, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGProjection;

static VALUE
_wrap_AGProjection_a_set(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGMatrix3 *arg2 = (AGMatrix3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 0);
    if (arg1) (arg1)->a = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGProjection_a_get(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGMatrix3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    result = (AGMatrix3 *)& ((arg1)->a);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMatrix3,0);
    return vresult;
}


static VALUE
_wrap_AGProjection_clip_set(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 *arg2 = (AGRect2 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0);
    if (arg1) (arg1)->clip = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGProjection_clip_get(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    result = (AGRect2 *)& ((arg1)->clip);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRect2,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGProjection_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGProjection_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGProjection);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGProjection(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = 0 ;
    AGProjection *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRect2, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGProjection *)new AGProjection((AGRect2 const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AGProjection_project__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGProjection const *)arg1)->project((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGProjection_pointOk(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGProjection const *)arg1)->pointOk((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGProjection_project__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGProjection const *)arg1)->project((AGRect2 const &)*arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE _wrap_AGProjection_project(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGProjection, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGProjection_project__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGProjection, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGProjection_project__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGProjection_project'");
    return Qnil;
}


static VALUE
_wrap_AGProjection_clipRect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 arg2 ;
    AGRect2 arg3 ;
    SwigValueWrapper<std::pair<AGRect2,AGRect2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    {
        AGRect2 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGRect2, 0);
        if (ptr) arg2 = *ptr;
    }
    {
        AGRect2 * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect2, 0);
        if (ptr) arg3 = *ptr;
    }
    result = ((AGProjection const *)arg1)->clipRect(arg2,arg3);
    
    {
        std::pair<AGRect2,AGRect2 > * resultptr;
        resultptr = new std::pair<AGRect2,AGRect2 >((std::pair<AGRect2,AGRect2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTAGRect2_AGRect2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGProjection_clipRect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 arg2 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    {
        AGRect2 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGRect2, 0);
        if (ptr) arg2 = *ptr;
    }
    result = ((AGProjection const *)arg1)->clipRect(arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE _wrap_AGProjection_clipRect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGProjection, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGProjection_clipRect__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGProjection, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGProjection_clipRect__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGProjection_clipRect'");
    return Qnil;
}


static VALUE
_wrap_AGProjection_clipLine(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGLine2 arg2 ;
    AGLine2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    {
        AGLine2 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGLine2, 0);
        if (ptr) arg2 = *ptr;
    }
    result = ((AGProjection const *)arg1)->clipLine(arg2);
    
    {
        AGLine2 * resultptr;
        resultptr = new AGLine2((AGLine2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGLine2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGProjection_translate(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGVector2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->translate((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGProjection_setClip(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setClip((AGRect2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGProjection_getRect(int argc, VALUE *argv, VALUE self) {
    AGProjection *arg1 = (AGProjection *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGProjection, 0);
    result = ((AGProjection const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static void
free_AGProjection(AGProjection *arg1) {
    delete arg1;
}

swig_class cAGPainter;

static VALUE
_wrap_new_AGPainter__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGPainter *)new AGPainter();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AGPainter__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = 0 ;
    AGPainter *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGPainter, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGPainter *)new AGPainter((AGPainter const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPainter_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPainter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPainter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPainter__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPaintTarget *arg1 = 0 ;
    AGPainter *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGPaintTarget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGPainter *)new AGPainter(*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AGPainter(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGPainter__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGPainter__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGPainter__SWIG_2(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGPainter'");
    return Qnil;
}


static void
free_AGPainter(AGPainter *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGPainter_putPixel(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->putPixel((AGVector2 const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_getPixel(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = (arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_drawCircle(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    float arg3 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = (float) NUM2DBL(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawCircle((AGVector2 const &)*arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blitTri(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGTriangle2 *arg3 = 0 ;
    AGTriangle2 *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGTriangle2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGTriangle2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blitTri((AGTexture const &)*arg2,(AGTriangle2 const &)*arg3,(AGTriangle2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGTexture const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGTexture const &)*arg2,(AGRect2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGSurface const &)*arg2,(AGRect2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->blit((AGSurface const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPainter_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_blit__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_blit__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_5(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGPainter_blit__SWIG_3(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPainter_blit'");
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGSurface const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGSurface const &)*arg2,(AGRect2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->tile((AGSurface const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPainter_tile(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGPainter_tile__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGPainter_tile__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_tile__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_tile__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_tile__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_tile__SWIG_5(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPainter_tile'");
    return Qnil;
}


static VALUE
_wrap_AGPainter_renderText(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    std::string *arg2 = 0 ;
    AGVector2 *arg3 = 0 ;
    AGFont *arg4 = 0 ;
    std::string temp2 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGFont, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->renderText((std::string const &)*arg2,(AGVector2 const &)*arg3,(AGFont const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_getRect(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    result = ((AGPainter const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 0); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradient((AGRect2 const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect2 *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 0); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawBorder((AGRect2 const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_fillRect(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->fillRect((AGRect2 const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawLine(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawLine((AGVector2 const &)*arg2,(AGVector2 const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawPoint(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->drawPoint((AGVector2 const &)*arg2,(AGColor const &)*arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_fillRects(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    std::vector<std::pair<AGRect2,AGVector4 > > *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTstd__pairTAGRect2_AGVector4_t_t, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->fillRects((std::vector<std::pair<AGRect2,AGVector4 > > const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_pushMatrix(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    (arg1)->pushMatrix();
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_popMatrix(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    (arg1)->popMatrix();
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_translate(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->translate((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_scale(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->scale((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_clip(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->clip((AGRect2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_transform(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->transform((AGRect2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_project(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGPainter const *)arg1)->project((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_pointOk(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGPainter const *)arg1)->pointOk((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_toPNG(int argc, VALUE *argv, VALUE self) {
    SDL_Surface *arg1 = (SDL_Surface *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SDL_Surface, 0);
    result = toPNG((SDL_Surface const *)arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_fromPNG(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    SDL_Surface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (SDL_Surface *)fromPNG(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


swig_class cAGRadioGroup;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRadioGroup_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRadioGroup_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRadioGroup);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRadioGroup(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AGRadioGroup *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGRadioGroup";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGRadioGroup *)new SwigDirector_AGRadioGroup(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGRadioGroup *)new AGRadioGroup(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGRadioGroup(AGRadioGroup *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGRadioGroup_eventChange(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventChange((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_add(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGRadio *arg2 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadio, 0);
    (arg1)->add(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_erase(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGRadio *arg2 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadio, 0);
    (arg1)->erase(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_sigChanged_set(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigChanged = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_sigChanged_get(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    result = (AGSignal *)& ((arg1)->sigChanged);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_disown_AGRadioGroup(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGRadio;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRadio_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRadio_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRadio);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRadio(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 arg3 ;
    AGRadio *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    {
        AGRect2 * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect2, 0);
        if (ptr) arg3 = *ptr;
    }
    {
        char *classname = "Libantargis::AGRadio";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGRadio *)new SwigDirector_AGRadio(arg1,arg2,arg3);
            
        } else {
            result = (AGRadio *)new AGRadio(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGRadio(AGRadio *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGRadio_setGroup(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    AGRadioGroup *arg2 = (AGRadioGroup *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadioGroup, 0);
    (arg1)->setGroup(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadio_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRadio_deselect(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    (arg1)->deselect();
    
    return Qnil;
}


static VALUE
_wrap_AGRadio_setChecked(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    bool arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    arg2 = RTEST(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setChecked(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGRadio(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRadio, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGScreen;

static VALUE
_wrap_AGScreen_begin(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->begin();
    
    return Qnil;
}


static VALUE
_wrap_AGScreen_flip(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGScreen_getWidth(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGScreen const *)arg1)->getWidth();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGScreen_getHeight(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGScreen const *)arg1)->getHeight();
    
    vresult = UINT2NUM(result);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGScreen_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGScreen_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGScreen);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGScreen(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGScreen *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGScreen";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGScreen *)new SwigDirector_AGScreen(arg1);
        
    } else {
        result = (AGScreen *)new AGScreen();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGScreen(AGScreen *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        AGScreen &_result_ref = getScreen();
        result = (AGScreen *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreen,0);
    return vresult;
}


static VALUE
_wrap_setScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 0);
    setScreen(arg1);
    
    return Qnil;
}


swig_class cAGTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTable_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTable(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AGTable *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGTable";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGTable *)new SwigDirector_AGTable(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGTable *)new AGTable(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGTable(AGTable *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGTable_addFixedColumn(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addFixedColumn(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addFixedRow(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addFixedRow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addColumn(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addColumn(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addRow(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addRow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addChild(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    int arg3 ;
    AGWidget *arg4 = (AGWidget *) 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGWidget, 0);
    (arg1)->addChild(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    int arg3 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = ((AGTable const *)arg1)->getClientRect(arg2,arg3);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTable_arrange(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    (arg1)->arrange();
    
    return Qnil;
}


static VALUE
_wrap_AGTable_setWidth(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_setHeight(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_getRows(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    result = ((AGTable const *)arg1)->getRows();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTable_getColumns(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    result = ((AGTable const *)arg1)->getColumns();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_disown_AGTable(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTable, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGTextureCache;

static VALUE
_wrap_AGTextureCache_get(int argc, VALUE *argv, VALUE self) {
    AGTextureCache *arg1 = (AGTextureCache *) 0 ;
    std::string *arg2 = 0 ;
    AGTexture *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureCache, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGTexture const &_result_ref = (arg1)->get((std::string const &)*arg2);
        result = (AGTexture *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
    }
    return vresult;
}


static VALUE
_wrap_AGTextureCache_get3D(int argc, VALUE *argv, VALUE self) {
    AGTextureCache *arg1 = (AGTextureCache *) 0 ;
    std::string *arg2 = 0 ;
    AGTexture *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureCache, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGTexture const &_result_ref = (arg1)->get3D((std::string const &)*arg2);
        result = (AGTexture *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
    }
    return vresult;
}


static VALUE
_wrap_getTextureCache(int argc, VALUE *argv, VALUE self) {
    AGTextureCache *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTextureCache *)getTextureCache();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTextureCache,0);
    return vresult;
}


static void
free_AGTextureCache(AGTextureCache *arg1) {
    delete arg1;
}

swig_class cAGTheme;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTheme_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTheme_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTheme);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTheme(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGTheme *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGTheme";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTheme *)new SwigDirector_AGTheme(arg1);
        
    } else {
        result = (AGTheme *)new AGTheme();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AGTheme(AGTheme *arg1) {
    delete arg1;
}

static VALUE
_wrap_AGTheme_getFont(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGFont result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getFont((std::string const &)*arg2);
    
    {
        AGFont * resultptr;
        resultptr = new AGFont((AGFont &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGFont, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_getColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGColor result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getColor((std::string const &)*arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setFont(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGFont arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGFont * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGFont, 0);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setFont((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_setColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGColor arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGColor * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGColor, 0);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setColor((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getInt(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)(arg1)->getInt((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTheme_setInt(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = NUM2INT(argv[1]);
    (arg1)->setInt((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getSurface((std::string const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGSurface, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setSurface((std::string const &)*arg2,(AGSurface const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getSurfaceName(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getSurfaceName((std::string const &)*arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setSurfaceName(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setSurfaceName((std::string const &)*arg2,(std::string const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_hasSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)((AGTheme const *)arg1)->hasSurface((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTheme_hasColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)((AGTheme const *)arg1)->hasColor((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTheme, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTheme *)getTheme();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTheme,0);
    return vresult;
}


static VALUE
_wrap_setTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTheme, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    setTheme((AGTheme const &)*arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadTheme(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    loadTheme((std::string const &)*arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadThemeFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    bool result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)loadThemeFile((std::string const &)*arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_addPoint(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = addPoint((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_toInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    int result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)toInt((std::string const &)*arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE _wrap_toInt(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Uint8, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_toInt__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_toInt__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'toInt'");
    return Qnil;
}


static VALUE
_wrap_toFloat(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    float result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (float)toFloat((std::string const &)*arg1);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_fromHex(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    int result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)fromHex((std::string const &)*arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_toHex(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2INT(argv[0]);
    result = toHex(arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


swig_class cAGWindow;

static VALUE
_wrap_new_AGWindow__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    AGWindow *result;
    std::string temp4 ;
    std::string temp5 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[3]) == T_STRING) {
            //            temp5 = std::string(StringValuePtr(argv[3]));
            temp5 = std::string(RSTRING(argv[3])->ptr,RSTRING(argv[3])->len);
            arg5 = &temp5;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_new_AGWindow__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGWindow *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect2 const &)*arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGWindow_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGWindow_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGWindow);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGWindow__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AGWindow *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect2 const &)*arg3);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect2 const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGWindow(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGWindow__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGWindow__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (TYPE(argv[4]) == T_STRING) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGWindow__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGWindow'");
    return Qnil;
}


static VALUE
_wrap_AGWindow_addChild(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_getClient(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    result = (AGWidget *)(arg1)->getClient();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AGCaption*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
                    else if(dynamic_cast<AGWindow*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
                    else if(dynamic_cast<AGSound*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
                    else if(dynamic_cast<AGDialog*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
                    else if(dynamic_cast<AGImage*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
                    else if(dynamic_cast<AGRadioGroup*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
                    else if(dynamic_cast<AGGLWidget*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
                    else if(dynamic_cast<AGEdit*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
                    else if(dynamic_cast<AGListBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
                    else if(dynamic_cast<AGSubMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
                    else if(dynamic_cast<AGColorButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
                    else if(dynamic_cast<AGMenu*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
                    else if(dynamic_cast<MiniMap*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
                    else if(dynamic_cast<AGRadio*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
                    else if(dynamic_cast<AGText*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
                    else if(dynamic_cast<AGCheckBox*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
                    else if(dynamic_cast<AGMenuItem*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
                    else if(dynamic_cast<AGLayout*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
                    else if(dynamic_cast<AGButton*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
                    else if(dynamic_cast<AGTable*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AGWindow_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_eventDragBy(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    AGVector2 *arg3 = 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventDragBy(arg2,(AGVector2 const &)*arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_close(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    (arg1)->close();
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_tryClose(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->tryClose(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGRect2 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGWindow const *)arg1)->getClientRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWindow_sigClose_set(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigClose = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_sigClose_get(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    result = (AGSignal *)& ((arg1)->sigClose);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static void
free_AGWindow(AGWindow *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AGWindow(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWindow, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGWindow(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGWindow *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGWindow &_result_ref = toAGWindow(*arg1);
        result = (AGWindow *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
    return vresult;
}


swig_class cSceneNode;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_SceneNode_allocate(VALUE self) {
#else
    static VALUE
    _wrap_SceneNode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SceneNode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_SceneNode(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    AGVector4 *arg3 = 0 ;
    AGBox3 *arg4 = 0 ;
    SceneNode *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector4, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGBox3, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::SceneNode";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (SceneNode *)new SwigDirector_SceneNode(arg1,arg2,(AGVector4 const &)*arg3,(AGBox3 const &)*arg4);
            
        } else {
            result = (SceneNode *)new SceneNode(arg2,(AGVector4 const &)*arg3,(AGBox3 const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_SceneNode(SceneNode *arg1) {
    delete arg1;
}

static VALUE
_wrap_SceneNode_resetScene(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->resetScene();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_drawShadow(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_drawDepth(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_draw(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_drawPick(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawPick();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_advance(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->advance(arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_getTriangles(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((SceneNode const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_SceneNode_lineHit(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((SceneNode const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_SceneNode_sort(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    AGVector4 *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->sort((AGVector4 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNode___eq__(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    SceneNode *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((SceneNode const *)arg1)->operator ==((SceneNode const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_SceneNode_setPos(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    AGVector3 *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setPos((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_getPos(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    result = ((SceneNode const *)arg1)->getPos();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_SceneNode_setRotation(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setRotation(arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_setBBox(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    AGBox3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBox3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setBBox((AGBox3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_transparent(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->transparent();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_SceneNode_bbox(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    AGBox3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    result = ((SceneNode const *)arg1)->bbox();
    
    {
        AGBox3 * resultptr;
        resultptr = new AGBox3((AGBox3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGBox3, 1);
    }
    return vresult;
}


static VALUE
_wrap_SceneNode_getRect(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    result = ((SceneNode const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_SceneNode_clear(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_getScene(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Scene *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    result = (Scene *)(arg1)->getScene();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_SceneNode_setVisible(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setVisible(arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_visible(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    result = (bool)((SceneNode const *)arg1)->visible();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_SceneNode_setOrder(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setOrder(arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_getOrder(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    result = (int)((SceneNode const *)arg1)->getOrder();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_disown_SceneNode(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAnimMesh;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AnimMesh_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AnimMesh_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AnimMesh);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AnimMesh(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    AnimMeshData *arg3 = (AnimMeshData *) 0 ;
    AnimMesh *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AnimMeshData, 0);
    {
        char *classname = "Libantargis::AnimMesh";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AnimMesh *)new SwigDirector_AnimMesh(arg1,arg2,arg3);
            
        } else {
            result = (AnimMesh *)new AnimMesh(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AnimMesh(AnimMesh *arg1) {
    delete arg1;
}

static VALUE
_wrap_AnimMesh_setTransform(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    AGMatrix4 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setTransform((AGMatrix4 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AnimMesh_getAnimation(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    result = ((AnimMesh const *)arg1)->getAnimation();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AnimMesh_setAnimation(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)(arg1)->setAnimation((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AnimMesh_setPos(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    AGVector3 *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setPos((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AnimMesh_setRotation__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    AGVector3 *arg2 = 0 ;
    float arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->setRotation((AGVector3 const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AnimMesh_setRotation__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setRotation(arg2);
    
    return Qnil;
}


static VALUE _wrap_AnimMesh_setRotation(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AnimMesh, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AnimMesh_setRotation__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AnimMesh, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AnimMesh_setRotation__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AnimMesh_setRotation'");
    return Qnil;
}


static VALUE
_wrap_AnimMesh_getData(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    AnimMeshData *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    result = (AnimMeshData *)(arg1)->getData();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AnimMeshData,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_AnimMesh_draw(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_AnimMesh_drawDepth(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_AnimMesh_drawPick(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawPick();
    
    return Qnil;
}


static VALUE
_wrap_AnimMesh_advance(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->advance(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AnimMesh_mark(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static VALUE
_wrap_AnimMesh_setEntity(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    AntEntity *arg2 = (AntEntity *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntity, 0);
    (arg1)->setEntity(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AnimMesh_getTriangles(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AnimMesh const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_disown_AnimMesh(int argc, VALUE *argv, VALUE self) {
    AnimMesh *arg1 = (AnimMesh *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AnimMesh, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cKeyFrame;

static VALUE
_wrap_KeyFrame_time_set(int argc, VALUE *argv, VALUE self) {
    KeyFrame *arg1 = (KeyFrame *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_KeyFrame, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->time = arg2;
    
    return Qnil;
}


static VALUE
_wrap_KeyFrame_time_get(int argc, VALUE *argv, VALUE self) {
    KeyFrame *arg1 = (KeyFrame *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_KeyFrame, 0);
    result = (float) ((arg1)->time);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_KeyFrame_v_set(int argc, VALUE *argv, VALUE self) {
    KeyFrame *arg1 = (KeyFrame *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_KeyFrame, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0);
    if (arg1) (arg1)->v = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_KeyFrame_v_get(int argc, VALUE *argv, VALUE self) {
    KeyFrame *arg1 = (KeyFrame *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_KeyFrame, 0);
    result = (AGVector3 *)& ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_KeyFrame_allocate(VALUE self) {
#else
    static VALUE
    _wrap_KeyFrame_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_KeyFrame);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_KeyFrame(int argc, VALUE *argv, VALUE self) {
    KeyFrame *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (KeyFrame *)new KeyFrame();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_KeyFrame(KeyFrame *arg1) {
    delete arg1;
}

swig_class cBone;

static VALUE
_wrap_Bone_id_set(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    size_t arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    arg2 = NUM2ULONG(argv[0]);
    if (arg1) (arg1)->id = arg2;
    
    return Qnil;
}


static VALUE
_wrap_Bone_id_get(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    result =  ((arg1)->id);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Bone_pos_set(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0);
    if (arg1) (arg1)->pos = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_Bone_pos_get(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    result = (AGVector3 *)& ((arg1)->pos);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_Bone_rot_set(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0);
    if (arg1) (arg1)->rot = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_Bone_rot_get(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    result = (AGVector3 *)& ((arg1)->rot);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_Bone_mRelative_set(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGMatrix4 *arg2 = (AGMatrix4 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 0);
    if (arg1) (arg1)->mRelative = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_Bone_mRelative_get(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGMatrix4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    result = (AGMatrix4 *)& ((arg1)->mRelative);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMatrix4,0);
    return vresult;
}


static VALUE
_wrap_Bone_mAbsolute_set(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGMatrix4 *arg2 = (AGMatrix4 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 0);
    if (arg1) (arg1)->mAbsolute = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_Bone_mAbsolute_get(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGMatrix4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    result = (AGMatrix4 *)& ((arg1)->mAbsolute);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMatrix4,0);
    return vresult;
}


static VALUE
_wrap_Bone_mFinal_set(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGMatrix4 *arg2 = (AGMatrix4 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 0);
    if (arg1) (arg1)->mFinal = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_Bone_mFinal_get(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    AGMatrix4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    result = (AGMatrix4 *)& ((arg1)->mFinal);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMatrix4,0);
    return vresult;
}


static VALUE
_wrap_Bone_parent_set(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    Bone *arg2 = (Bone *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Bone, SWIG_POINTER_DISOWN);
    if (arg1) (arg1)->parent = arg2;
    
    return Qnil;
}


static VALUE
_wrap_Bone_parent_get(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    Bone *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    result = (Bone *) ((arg1)->parent);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Bone,0);
    return vresult;
}


static VALUE
_wrap_Bone_rFrames_set(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    std::vector<KeyFrame > *arg2 = (std::vector<KeyFrame > *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTKeyFrame_t, 0);
    if (arg1) (arg1)->rFrames = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_Bone_rFrames_get(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    std::vector<KeyFrame > *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    result = (std::vector<KeyFrame > *)& ((arg1)->rFrames);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTKeyFrame_t,0);
    return vresult;
}


static VALUE
_wrap_Bone_tFrames_set(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    std::vector<KeyFrame > *arg2 = (std::vector<KeyFrame > *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTKeyFrame_t, 0);
    if (arg1) (arg1)->tFrames = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_Bone_tFrames_get(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    std::vector<KeyFrame > *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    result = (std::vector<KeyFrame > *)& ((arg1)->tFrames);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTKeyFrame_t,0);
    return vresult;
}


static VALUE
_wrap_Bone_interpolateRot(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = (arg1)->interpolateRot(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_Bone_interpolateTrans(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    result = (arg1)->interpolateTrans(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_Bone_interpolate(int argc, VALUE *argv, VALUE self) {
    Bone *arg1 = (Bone *) 0 ;
    std::vector<KeyFrame > *arg2 = 0 ;
    float arg3 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Bone, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTKeyFrame_t, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = (float) NUM2DBL(argv[1]);
    result = (arg1)->interpolate((std::vector<KeyFrame > const &)*arg2,arg3);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Bone_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Bone_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Bone);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Bone(int argc, VALUE *argv, VALUE self) {
    Bone *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Bone *)new Bone();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_Bone(Bone *arg1) {
    delete arg1;
}

swig_class cAnimation;

static VALUE
_wrap_Animation_begin_set(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->begin = arg2;
    
    return Qnil;
}


static VALUE
_wrap_Animation_begin_get(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    result = (float) ((arg1)->begin);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Animation_end_set(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->end = arg2;
    
    return Qnil;
}


static VALUE
_wrap_Animation_end_get(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    result = (float) ((arg1)->end);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Animation_fps_set(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->fps = arg2;
    
    return Qnil;
}


static VALUE
_wrap_Animation_fps_get(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    result = (float) ((arg1)->fps);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Animation_len_set(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->len = arg2;
    
    return Qnil;
}


static VALUE
_wrap_Animation_len_get(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    result = (float) ((arg1)->len);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Animation_loop_set(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    arg2 = RTEST(argv[0]);
    if (arg1) (arg1)->loop = arg2;
    
    return Qnil;
}


static VALUE
_wrap_Animation_loop_get(int argc, VALUE *argv, VALUE self) {
    Animation *arg1 = (Animation *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Animation, 0);
    result = (bool) ((arg1)->loop);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_new_Animation__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Animation *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Animation *)new Animation();
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Animation_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Animation_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Animation);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Animation__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    Animation *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (Animation *)new Animation(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_Animation(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Animation__SWIG_0(nargs, args, self);
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_Animation__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Animation'");
    return Qnil;
}


static void
free_Animation(Animation *arg1) {
    delete arg1;
}

swig_class cAnimMeshData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AnimMeshData_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AnimMeshData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AnimMeshData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AnimMeshData(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    AnimMeshData *result;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AnimMeshData";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AnimMeshData *)new SwigDirector_AnimMeshData(arg1,(std::string const &)*arg2);
            
        } else {
            result = (AnimMeshData *)new AnimMeshData((std::string const &)*arg2);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AnimMeshData(AnimMeshData *arg1) {
    delete arg1;
}

static VALUE
_wrap_AnimMeshData_bbox(int argc, VALUE *argv, VALUE self) {
    AnimMeshData *arg1 = (AnimMeshData *) 0 ;
    AGBox3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMeshData, 0);
    result = ((AnimMeshData const *)arg1)->bbox();
    
    {
        AGBox3 * resultptr;
        resultptr = new AGBox3((AGBox3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGBox3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AnimMeshData_setEvents(int argc, VALUE *argv, VALUE self) {
    AnimMeshData *arg1 = (AnimMeshData *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMeshData, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setEvents(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AnimMeshData_setTransform(int argc, VALUE *argv, VALUE self) {
    AnimMeshData *arg1 = (AnimMeshData *) 0 ;
    AGMatrix4 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMeshData, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setTransform((AGMatrix4 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AnimMeshData_getTransform(int argc, VALUE *argv, VALUE self) {
    AnimMeshData *arg1 = (AnimMeshData *) 0 ;
    AGMatrix4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AnimMeshData, 0);
    {
        AGMatrix4 const &_result_ref = ((AnimMeshData const *)arg1)->getTransform();
        result = (AGMatrix4 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMatrix4,0);
    return vresult;
}


static VALUE
_wrap_disown_AnimMeshData(int argc, VALUE *argv, VALUE self) {
    AnimMeshData *arg1 = (AnimMeshData *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AnimMeshData, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cGLApp;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_GLApp_allocate(VALUE self) {
#else
    static VALUE
    _wrap_GLApp_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_GLApp);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_GLApp(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    GLApp *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    {
        char *classname = "Libantargis::GLApp";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (GLApp *)new SwigDirector_GLApp(arg1,arg2,arg3);
            
        } else {
            result = (GLApp *)new GLApp(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_GLApp(GLApp *arg1) {
    delete arg1;
}

static VALUE
_wrap_GLApp_draw(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_GLApp_drawGL(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    (arg1)->drawGL();
    
    return Qnil;
}


static VALUE
_wrap_GLApp_eventFrame(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrame(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_eventClick(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    Scene::PickResult *arg2 = 0 ;
    int arg3 ;
    std::vector<PickNode > temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp2 = std::vector<PickNode >(size);
            arg2 = &temp2;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                PickNode* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_PickNode, 1);
                temp2[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTPickNode_t, 1);
        }
    }
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventClick((std::vector<PickNode > const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_GLApp_eventHover(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    Scene::PickResult *arg2 = 0 ;
    int arg3 ;
    std::vector<PickNode > temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp2 = std::vector<PickNode >(size);
            arg2 = &temp2;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                PickNode* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_PickNode, 1);
                temp2[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTPickNode_t, 1);
        }
    }
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventHover((std::vector<PickNode > const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_GLApp_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_getScene(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    Scene *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    {
        Scene &_result_ref = (arg1)->getScene();
        result = (Scene *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
    return vresult;
}


static VALUE
_wrap_GLApp_setCamera(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGVector2 *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setCamera((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_GLApp_getCamera(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    result = ((GLApp const *)arg1)->getCamera();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_GLApp_mark(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static VALUE
_wrap_disown_GLApp(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_GLApp, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cSerialException;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_SerialException_allocate(VALUE self) {
#else
    static VALUE
    _wrap_SerialException_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SerialException);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_SerialException(int argc, VALUE *argv, VALUE self) {
    SerialException *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (SerialException *)new SerialException();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_SerialException(SerialException *arg1) {
    delete arg1;
}

swig_class cBinaryIn;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_BinaryIn_allocate(VALUE self) {
#else
    static VALUE
    _wrap_BinaryIn_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_BinaryIn);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_BinaryIn(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    BinaryIn *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::BinaryIn";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (BinaryIn *)new SwigDirector_BinaryIn(arg1);
        
    } else {
        result = (BinaryIn *)new BinaryIn();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_BinaryIn(BinaryIn *arg1) {
    delete arg1;
}

static VALUE
_wrap_BinaryIn_eof(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eof();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_BinaryIn_read(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    char result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (char)(arg1)->read();
    
    vresult = rb_str_new(&result,1);
    return vresult;
}


static VALUE
_wrap_BinaryIn___rshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    Sint32 *arg2 = 0 ;
    BinaryIn *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Sint32, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        BinaryIn &_result_ref = (arg1)->operator >>(*arg2);
        result = (BinaryIn *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryIn,0);
    }
    return vresult;
}


static VALUE
_wrap_BinaryIn___rshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    Uint32 *arg2 = 0 ;
    BinaryIn *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Uint32, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        BinaryIn &_result_ref = (arg1)->operator >>(*arg2);
        result = (BinaryIn *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryIn,0);
    }
    return vresult;
}


static VALUE
_wrap_BinaryIn___rshift____SWIG_2(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    Uint16 *arg2 = 0 ;
    BinaryIn *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Uint16, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        BinaryIn &_result_ref = (arg1)->operator >>(*arg2);
        result = (BinaryIn *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryIn,0);
    }
    return vresult;
}


static VALUE
_wrap_BinaryIn___rshift____SWIG_3(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    float *arg2 = 0 ;
    BinaryIn *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        BinaryIn &_result_ref = (arg1)->operator >>(*arg2);
        result = (BinaryIn *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryIn,0);
    }
    return vresult;
}


static VALUE
_wrap_BinaryIn___rshift____SWIG_4(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    AGVector2 *arg2 = 0 ;
    BinaryIn *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        BinaryIn &_result_ref = (arg1)->operator >>(*arg2);
        result = (BinaryIn *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryIn,0);
    }
    return vresult;
}


static VALUE
_wrap_BinaryIn___rshift____SWIG_5(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    AGVector3 *arg2 = 0 ;
    BinaryIn *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        BinaryIn &_result_ref = (arg1)->operator >>(*arg2);
        result = (BinaryIn *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryIn,0);
    }
    return vresult;
}


static VALUE
_wrap_BinaryIn___rshift____SWIG_6(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    AGVector4 *arg2 = 0 ;
    BinaryIn *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        BinaryIn &_result_ref = (arg1)->operator >>(*arg2);
        result = (BinaryIn *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryIn,0);
    }
    return vresult;
}


static VALUE _wrap_BinaryIn___rshift__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryIn, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Sint32, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryIn___rshift____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryIn, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Uint32, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryIn___rshift____SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryIn, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Uint16, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryIn___rshift____SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryIn, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_float, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryIn___rshift____SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryIn, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryIn___rshift____SWIG_4(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryIn, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryIn___rshift____SWIG_5(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryIn, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryIn___rshift____SWIG_6(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'BinaryIn___rshift__'");
    return Qnil;
}


static VALUE
_wrap_disown_BinaryIn(int argc, VALUE *argv, VALUE self) {
    BinaryIn *arg1 = (BinaryIn *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_BinaryIn, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cBinaryOut;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_BinaryOut_allocate(VALUE self) {
#else
    static VALUE
    _wrap_BinaryOut_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_BinaryOut);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_BinaryOut(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    BinaryOut *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::BinaryOut";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (BinaryOut *)new SwigDirector_BinaryOut(arg1);
        
    } else {
        result = (BinaryOut *)new BinaryOut();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_BinaryOut(BinaryOut *arg1) {
    delete arg1;
}

static VALUE
_wrap_BinaryOut_write(int argc, VALUE *argv, VALUE self) {
    BinaryOut *arg1 = (BinaryOut *) 0 ;
    char arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryOut, 0);
    arg2 = NUM2CHR(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->write(arg2);
    
    return Qnil;
}


static VALUE
_wrap_BinaryOut___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
    BinaryOut *arg1 = (BinaryOut *) 0 ;
    Sint32 *arg2 = 0 ;
    BinaryOut *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryOut, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Sint32, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        BinaryOut &_result_ref = (arg1)->operator <<((Sint32 const &)*arg2);
        result = (BinaryOut *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryOut,0);
    }
    return vresult;
}


static VALUE
_wrap_BinaryOut___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
    BinaryOut *arg1 = (BinaryOut *) 0 ;
    Uint32 *arg2 = 0 ;
    BinaryOut *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryOut, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Uint32, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        BinaryOut &_result_ref = (arg1)->operator <<((Uint32 const &)*arg2);
        result = (BinaryOut *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryOut,0);
    }
    return vresult;
}


static VALUE
_wrap_BinaryOut___lshift____SWIG_2(int argc, VALUE *argv, VALUE self) {
    BinaryOut *arg1 = (BinaryOut *) 0 ;
    float *arg2 = 0 ;
    BinaryOut *result;
    float temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryOut, 0);
    temp2 = (float) NUM2DBL(argv[0]);
    arg2 = &temp2;
    {
        BinaryOut &_result_ref = (arg1)->operator <<((float const &)*arg2);
        result = (BinaryOut *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BinaryOut,0);
    }
    return vresult;
}


static VALUE _wrap_BinaryOut___lshift__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryOut, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Sint32, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryOut___lshift____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryOut, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Uint32, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryOut___lshift____SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_BinaryOut, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_BinaryOut___lshift____SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'BinaryOut___lshift__'");
    return Qnil;
}


static VALUE
_wrap_disown_BinaryOut(int argc, VALUE *argv, VALUE self) {
    BinaryOut *arg1 = (BinaryOut *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_BinaryOut, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cBinaryFileIn;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_BinaryFileIn_allocate(VALUE self) {
#else
    static VALUE
    _wrap_BinaryFileIn_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_BinaryFileIn);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_BinaryFileIn(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    BinaryFileIn *result;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::BinaryFileIn";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (BinaryFileIn *)new SwigDirector_BinaryFileIn(arg1,(std::string const &)*arg2);
        
    } else {
        result = (BinaryFileIn *)new BinaryFileIn((std::string const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_BinaryFileIn(BinaryFileIn *arg1) {
    delete arg1;
}

static VALUE
_wrap_BinaryFileIn_eof(int argc, VALUE *argv, VALUE self) {
    BinaryFileIn *arg1 = (BinaryFileIn *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryFileIn, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eof();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_BinaryFileIn_read(int argc, VALUE *argv, VALUE self) {
    BinaryFileIn *arg1 = (BinaryFileIn *) 0 ;
    char result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryFileIn, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (char)(arg1)->read();
    
    vresult = rb_str_new(&result,1);
    return vresult;
}


static VALUE
_wrap_BinaryFileIn_pos(int argc, VALUE *argv, VALUE self) {
    BinaryFileIn *arg1 = (BinaryFileIn *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryFileIn, 0);
    result = ((BinaryFileIn const *)arg1)->pos();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_disown_BinaryFileIn(int argc, VALUE *argv, VALUE self) {
    BinaryFileIn *arg1 = (BinaryFileIn *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_BinaryFileIn, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cBinaryFileOut;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_BinaryFileOut_allocate(VALUE self) {
#else
    static VALUE
    _wrap_BinaryFileOut_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_BinaryFileOut);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_BinaryFileOut(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    BinaryFileOut *result;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::BinaryFileOut";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (BinaryFileOut *)new SwigDirector_BinaryFileOut(arg1,(std::string const &)*arg2);
        
    } else {
        result = (BinaryFileOut *)new BinaryFileOut((std::string const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_BinaryFileOut(BinaryFileOut *arg1) {
    delete arg1;
}

static VALUE
_wrap_BinaryFileOut_write(int argc, VALUE *argv, VALUE self) {
    BinaryFileOut *arg1 = (BinaryFileOut *) 0 ;
    char arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryFileOut, 0);
    arg2 = NUM2CHR(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->write(arg2);
    
    return Qnil;
}


static VALUE
_wrap_BinaryFileOut_flush(int argc, VALUE *argv, VALUE self) {
    BinaryFileOut *arg1 = (BinaryFileOut *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryFileOut, 0);
    (arg1)->flush();
    
    return Qnil;
}


static VALUE
_wrap_BinaryFileOut_pos(int argc, VALUE *argv, VALUE self) {
    BinaryFileOut *arg1 = (BinaryFileOut *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryFileOut, 0);
    result = ((BinaryFileOut const *)arg1)->pos();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_disown_BinaryFileOut(int argc, VALUE *argv, VALUE self) {
    BinaryFileOut *arg1 = (BinaryFileOut *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_BinaryFileOut, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cBinaryStringIn;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_BinaryStringIn_allocate(VALUE self) {
#else
    static VALUE
    _wrap_BinaryStringIn_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_BinaryStringIn);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_BinaryStringIn(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    BinaryStringIn *result;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::BinaryStringIn";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (BinaryStringIn *)new SwigDirector_BinaryStringIn(arg1,(std::string const &)*arg2);
        
    } else {
        result = (BinaryStringIn *)new BinaryStringIn((std::string const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_BinaryStringIn_eof(int argc, VALUE *argv, VALUE self) {
    BinaryStringIn *arg1 = (BinaryStringIn *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryStringIn, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eof();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_BinaryStringIn_read(int argc, VALUE *argv, VALUE self) {
    BinaryStringIn *arg1 = (BinaryStringIn *) 0 ;
    char result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryStringIn, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (char)(arg1)->read();
    
    vresult = rb_str_new(&result,1);
    return vresult;
}


static void
free_BinaryStringIn(BinaryStringIn *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_BinaryStringIn(int argc, VALUE *argv, VALUE self) {
    BinaryStringIn *arg1 = (BinaryStringIn *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_BinaryStringIn, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cBinaryStringOut;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_BinaryStringOut_allocate(VALUE self) {
#else
    static VALUE
    _wrap_BinaryStringOut_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_BinaryStringOut);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_BinaryStringOut(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    BinaryStringOut *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::BinaryStringOut";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (BinaryStringOut *)new SwigDirector_BinaryStringOut(arg1);
        
    } else {
        result = (BinaryStringOut *)new BinaryStringOut();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_BinaryStringOut(BinaryStringOut *arg1) {
    delete arg1;
}

static VALUE
_wrap_BinaryStringOut_write(int argc, VALUE *argv, VALUE self) {
    BinaryStringOut *arg1 = (BinaryStringOut *) 0 ;
    char arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryStringOut, 0);
    arg2 = NUM2CHR(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->write(arg2);
    
    return Qnil;
}


static VALUE
_wrap_BinaryStringOut_getString(int argc, VALUE *argv, VALUE self) {
    BinaryStringOut *arg1 = (BinaryStringOut *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_BinaryStringOut, 0);
    result = ((BinaryStringOut const *)arg1)->getString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_disown_BinaryStringOut(int argc, VALUE *argv, VALUE self) {
    BinaryStringOut *arg1 = (BinaryStringOut *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_BinaryStringOut, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAntEntity;

static VALUE
_wrap_AntEntity_mDir_set(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->mDir = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_mDir_get(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (float) ((arg1)->mDir);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_resource_set(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Resource *arg2 = (Resource *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Resource, 0);
    if (arg1) (arg1)->resource = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_resource_get(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Resource *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (Resource *)& ((arg1)->resource);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Resource,0);
    return vresult;
}


static VALUE
_wrap_new_AntEntity__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AntEntity *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::AntEntity";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AntEntity *)new SwigDirector_AntEntity(arg1);
            
        } else {
            result = (AntEntity *)new AntEntity();
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_new_AntEntity__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGVector3 *arg2 = 0 ;
    AntEntity *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AntEntity";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AntEntity *)new SwigDirector_AntEntity(arg1,(AGVector3 const &)*arg2);
            
        } else {
            result = (AntEntity *)new AntEntity((AGVector3 const &)*arg2);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntEntity_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntEntity_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntEntity);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntEntity__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGVector2 *arg2 = 0 ;
    AntEntity *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AntEntity";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AntEntity *)new SwigDirector_AntEntity(arg1,(AGVector2 const &)*arg2);
            
        } else {
            result = (AntEntity *)new AntEntity((AGVector2 const &)*arg2);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AntEntity(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AntEntity__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AntEntity__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AntEntity__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AntEntity'");
    return Qnil;
}


static void
free_AntEntity(AntEntity *arg1) {
    delete arg1;
}

static VALUE
_wrap_AntEntity_setMinimapColor(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setMinimapColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getMinimapColor(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = ((AntEntity const *)arg1)->getMinimapColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_showOnMinimap(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (bool)((AntEntity const *)arg1)->showOnMinimap();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AntEntity_setStrength(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setStrength(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getStrength(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (float)((AntEntity const *)arg1)->getStrength();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_setMoraleStrength(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setMoraleStrength(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getMoraleStrength(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (float)((AntEntity const *)arg1)->getMoraleStrength();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_getPos3D(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = ((AntEntity const *)arg1)->getPos3D();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_getPos2D(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = ((AntEntity const *)arg1)->getPos2D();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_setPos__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGVector2 *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setPos((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setPos__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGVector3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setPos((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE _wrap_AntEntity_setPos(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntEntity_setPos__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntEntity_setPos__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntEntity_setPos'");
    return Qnil;
}


static VALUE
_wrap_AntEntity_getID(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (int)((AntEntity const *)arg1)->getID();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_getName(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = ((AntEntity const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_setName(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setProvide(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = RTEST(argv[1]);
    (arg1)->setProvide((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_provides(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)((AntEntity const *)arg1)->provides((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AntEntity_xmlName(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AntEntity const *)arg1)->xmlName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_saveXML(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    ((AntEntity const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_loadXML(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_newRestJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newRestJob(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_newFetchJob__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AGVector2 *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp4 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newFetchJob(arg2,*arg3,(std::string const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_newFetchJob__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AntEntity *arg3 = (AntEntity *) 0 ;
    std::string *arg4 = 0 ;
    std::string temp4 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AntEntity, 0);
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newFetchJob(arg2,arg3,(std::string const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AntEntity_newFetchJob(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AntEntity_newFetchJob__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AntEntity_newFetchJob__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntEntity_newFetchJob'");
    return Qnil;
}


static VALUE
_wrap_AntEntity_newMoveJob__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AGVector2 *arg3 = 0 ;
    int arg4 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = NUM2INT(argv[2]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newMoveJob(arg2,(AGVector2 const &)*arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_newMoveJob__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AGVector2 *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newMoveJob(arg2,(AGVector2 const &)*arg3);
    
    return Qnil;
}


static VALUE _wrap_AntEntity_newMoveJob(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AntEntity_newMoveJob__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AntEntity_newMoveJob__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntEntity_newMoveJob'");
    return Qnil;
}


static VALUE
_wrap_AntEntity_newFightJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AntEntity *arg3 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newFightJob(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_delJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->delJob();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_resourceChanged(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->resourceChanged();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_hasJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (bool)((AntEntity const *)arg1)->hasJob();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AntEntity_getRect(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = ((AntEntity const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_eventNoJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventNoJob();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventJobFinished(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventJobFinished();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventGotNewJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventGotNewJob();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventGotFight(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AntEntity *arg2 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventGotFight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setSpeed(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setSpeed(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getSpeed(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (float)((AntEntity const *)arg1)->getSpeed();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_getHealSpeed(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (float)((AntEntity const *)arg1)->getHealSpeed();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_setHealSpeed(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setHealSpeed(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setAggression(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setAggression(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getAggression(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (float)((AntEntity const *)arg1)->getAggression();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_eventDie(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventDie();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventDefeated(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventDefeated();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getEnergy(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (float)((AntEntity const *)arg1)->getEnergy();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_getMorale(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (float)((AntEntity const *)arg1)->getMorale();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_setMesh(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 0);
    (arg1)->setMesh(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getMesh(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    SwigValueWrapper<std::list<SceneNode * > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (arg1)->getMesh();
    
    {
        AntEntity::Meshes * resultptr;
        resultptr = new AntEntity::Meshes((AntEntity::Meshes &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTSceneNode_p_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_getFirstMesh(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    SceneNode *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (SceneNode *)(arg1)->getFirstMesh();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else if(dynamic_cast<AnimMesh*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AnimMesh,0);
                    else if(dynamic_cast<WaterPiece*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_WaterPiece,0);
                    else if(dynamic_cast<Mesh*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
                    else if(dynamic_cast<NewDecal*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewDecal,0);
                    else if(dynamic_cast<Smoke*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Smoke,0);
                    else if(dynamic_cast<TerrainPieceVA*>(result))
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainPieceVA,0);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SceneNode,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_addMesh(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    AGVector3 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector3, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->addMesh(arg2,(AGVector3 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setDirection(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setDirection(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getDirection(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (float)((AntEntity const *)arg1)->getDirection();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_decEnergy(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->decEnergy(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_decMorale(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->decMorale(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventMapChanged(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    (arg1)->eventMapChanged();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_move(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->move(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_mark(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_clear(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_clearMeshes(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    (arg1)->clearMeshes();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setVisible(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setVisible(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_animationEvent(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->animationEvent((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AntEntity(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAntEntityPtr;

static VALUE
_wrap_new_AntEntityPtr__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntEntityPtr *arg1 = 0 ;
    AntEntityPtr *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntEntityPtr, 0); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AntEntityPtr *)new AntEntityPtr((AntEntityPtr const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_new_AntEntityPtr__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AntEntityPtr *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntEntity, 0);
    result = (AntEntityPtr *)new AntEntityPtr(arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntEntityPtr_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntEntityPtr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntEntityPtr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntEntityPtr__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AntEntityPtr *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AntEntityPtr *)new AntEntityPtr();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AntEntityPtr(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AntEntityPtr__SWIG_2(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AntEntityPtr__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntityPtr, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AntEntityPtr__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AntEntityPtr'");
    return Qnil;
}


static VALUE
_wrap_AntEntityPtr_get(int argc, VALUE *argv, VALUE self) {
    AntEntityPtr *arg1 = (AntEntityPtr *) 0 ;
    AntEntity *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntityPtr, 0);
    result = (AntEntity *)(arg1)->get();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static void
free_AntEntityPtr(AntEntityPtr *arg1) {
    delete arg1;
}

swig_class cAntVertexProgram;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntVertexProgram_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntVertexProgram_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntVertexProgram);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntVertexProgram(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AntVertexProgram *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AntVertexProgram *)new AntVertexProgram((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AntVertexProgram(AntVertexProgram *arg1) {
    delete arg1;
}

swig_class cAntFragProgram;

static VALUE
_wrap_new_AntFragProgram__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AntFragProgram *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AntFragProgram *)new AntFragProgram((std::string const &)*arg1);
    DATA_PTR(self) = result;
    
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntFragProgram_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntFragProgram_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntFragProgram);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntFragProgram__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntFragProgram *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AntFragProgram *)new AntFragProgram();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE _wrap_new_AntFragProgram(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AntFragProgram__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AntFragProgram__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AntFragProgram'");
    return Qnil;
}


static void
free_AntFragProgram(AntFragProgram *arg1) {
    delete arg1;
}

static VALUE
_wrap_AntFragProgram_valid(int argc, VALUE *argv, VALUE self) {
    AntFragProgram *arg1 = (AntFragProgram *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntFragProgram, 0);
    result = (bool)((AntFragProgram const *)arg1)->valid();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


swig_class cAntShaderParameter;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntShaderParameter_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntShaderParameter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntShaderParameter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntShaderParameter(int argc, VALUE *argv, VALUE self) {
    AntShaderParameter *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AntShaderParameter *)new AntShaderParameter();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AntShaderParameter(AntShaderParameter *arg1) {
    delete arg1;
}

swig_class cAntShaderProgram;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntShaderProgram_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntShaderProgram_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntShaderProgram);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntShaderProgram(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    AntShaderProgram *result;
    std::string temp2 ;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::AntShaderProgram";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AntShaderProgram *)new SwigDirector_AntShaderProgram(arg1,(std::string const &)*arg2,(std::string const &)*arg3);
        
    } else {
        result = (AntShaderProgram *)new AntShaderProgram((std::string const &)*arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_AntShaderProgram(AntShaderProgram *arg1) {
    delete arg1;
}

static VALUE
_wrap_AntShaderProgram_enable(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->enable();
    
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_disable(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->disable();
    
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_update(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->update(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_doUpdate(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->doUpdate(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_getLoc(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    GLint result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getLoc((std::string const &)*arg2);
    
    {
        GLint * resultptr;
        resultptr = new GLint((GLint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_GLint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntShaderProgram_getAttr(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    GLint result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getAttr((std::string const &)*arg2);
    
    {
        GLint * resultptr;
        resultptr = new GLint((GLint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_GLint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntShaderProgram_sendUniform__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = NUM2INT(argv[1]);
    (arg1)->sendUniform((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_sendUniform__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->sendUniform((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_sendUniform__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    AGVector3 *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector3, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendUniform((std::string const &)*arg2,(AGVector3 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_sendUniform__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    AGVector4 *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector4, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendUniform((std::string const &)*arg2,(AGVector4 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_sendUniform__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    AGMatrix4 *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGMatrix4, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendUniform((std::string const &)*arg2,(AGMatrix4 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_sendUniform__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    std::vector<AGMatrix4 > *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTAGMatrix4_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendUniform((std::string const &)*arg2,(std::vector<AGMatrix4 > const &)*arg3);
    
    return Qnil;
}


static VALUE _wrap_AntShaderProgram_sendUniform(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AntShaderProgram_sendUniform__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AntShaderProgram_sendUniform__SWIG_3(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AntShaderProgram_sendUniform__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_std__vectorTAGMatrix4_t, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AntShaderProgram_sendUniform__SWIG_5(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AntShaderProgram_sendUniform__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntShaderProgram, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AntShaderProgram_sendUniform__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntShaderProgram_sendUniform'");
    return Qnil;
}


static VALUE
_wrap_AntShaderProgram_sendAttribute(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    std::string *arg2 = 0 ;
    std::vector<float > *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTfloat_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->sendAttribute((std::string const &)*arg2,(std::vector<float > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_disown_AntShaderProgram(int argc, VALUE *argv, VALUE self) {
    AntShaderProgram *arg1 = (AntShaderProgram *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntShaderProgram, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAntShadowShader;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntShadowShader_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntShadowShader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntShadowShader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntShadowShader(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    AntShadowShader *result;
    std::string temp2 ;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::AntShadowShader";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AntShadowShader *)new SwigDirector_AntShadowShader(arg1,(std::string const &)*arg2,(std::string const &)*arg3);
        
    } else {
        result = (AntShadowShader *)new AntShadowShader((std::string const &)*arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AntShadowShader_doUpdate(int argc, VALUE *argv, VALUE self) {
    AntShadowShader *arg1 = (AntShadowShader *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShadowShader, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->doUpdate(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntShadowShader_enable(int argc, VALUE *argv, VALUE self) {
    AntShadowShader *arg1 = (AntShadowShader *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShadowShader, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->enable();
    
    return Qnil;
}


static VALUE
_wrap_AntShadowShader_disable(int argc, VALUE *argv, VALUE self) {
    AntShadowShader *arg1 = (AntShadowShader *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntShadowShader, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->disable();
    
    return Qnil;
}


static void
free_AntShadowShader(AntShadowShader *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AntShadowShader(int argc, VALUE *argv, VALUE self) {
    AntShadowShader *arg1 = (AntShadowShader *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntShadowShader, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAntWaterShader;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntWaterShader_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntWaterShader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntWaterShader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntWaterShader(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AntWaterShader *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AntWaterShader";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AntWaterShader *)new SwigDirector_AntWaterShader(arg1);
        
    } else {
        result = (AntWaterShader *)new AntWaterShader();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_AntWaterShader_doUpdate(int argc, VALUE *argv, VALUE self) {
    AntWaterShader *arg1 = (AntWaterShader *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntWaterShader, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->doUpdate(arg2);
    
    return Qnil;
}


static void
free_AntWaterShader(AntWaterShader *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_AntWaterShader(int argc, VALUE *argv, VALUE self) {
    AntWaterShader *arg1 = (AntWaterShader *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntWaterShader, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_glslOk(int argc, VALUE *argv, VALUE self) {
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (bool)glslOk();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


swig_class cHeightMap;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_HeightMap_allocate(VALUE self) {
#else
    static VALUE
    _wrap_HeightMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_HeightMap);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_HeightMap(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    int arg3 ;
    int arg4 ;
    HeightMap *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    {
        char *classname = "Libantargis::HeightMap";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (HeightMap *)new SwigDirector_HeightMap(arg1,arg2,arg3,arg4);
            
        } else {
            result = (HeightMap *)new HeightMap(arg2,arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_HeightMap(HeightMap *arg1) {
    delete arg1;
}

static VALUE
_wrap_HeightMap_getHeight(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    float arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    result = (float)((HeightMap const *)arg1)->getHeight(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getNormal(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    int arg2 ;
    int arg3 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = ((HeightMap const *)arg1)->getNormal(arg2,arg3);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_HeightMap_getNormalF(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    float arg3 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    result = ((HeightMap const *)arg1)->getNormalF(arg2,arg3);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_HeightMap_getVertex(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    int arg2 ;
    int arg3 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = (arg1)->getVertex(arg2,arg3);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_HeightMap_get(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((HeightMap const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_setTerrain(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    TerrainType arg4 ;
    float arg5 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (TerrainType) NUM2INT(argv[2]);
    arg5 = (float) NUM2DBL(argv[3]);
    (arg1)->setTerrain(arg2,arg3,arg4,arg5);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_getTerrain__SWIG_0(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    TerrainType arg4 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (TerrainType) NUM2INT(argv[2]);
    result = (float)((HeightMap const *)arg1)->getTerrain(arg2,arg3,arg4);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getMean(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    float arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    result = (float)(arg1)->getMean(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getW(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    result = ((HeightMap const *)arg1)->getW();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getH(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    result = ((HeightMap const *)arg1)->getH();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_truncPos(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((HeightMap const *)arg1)->truncPos((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_HeightMap_saveXML(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    ((HeightMap const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_loadXML(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_setHeight(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_set(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_mapChanged(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_setTerrainScale(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    TerrainType arg2 ;
    float arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = (TerrainType) NUM2INT(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->setTerrainScale(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_getTerrainValue(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    float arg3 ;
    TerrainType arg4 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    arg4 = (TerrainType) NUM2INT(argv[2]);
    result = (float)(arg1)->getTerrainValue(arg2,arg3,arg4);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getTerrain__SWIG_1(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    float arg3 ;
    TerrainType result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    result = (TerrainType)(arg1)->getTerrain(arg2,arg3);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE _wrap_HeightMap_getTerrain(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_HeightMap, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_HeightMap_getTerrain__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_HeightMap, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_HeightMap_getTerrain__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'HeightMap_getTerrain'");
    return Qnil;
}


static VALUE
_wrap_HeightMap_getTerrainWeight(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    float arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    result = (float)(arg1)->getTerrainWeight(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getTerrainScale(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    float arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    result = (float)(arg1)->getTerrainScale(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_addChange(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    AGVector2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->addChange((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_getChangeRect(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    AGRect2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    result = ((HeightMap const *)arg1)->getChangeRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_HeightMap_newMap(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    int arg2 ;
    int arg3 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newMap(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_sigMapChanged_set(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMapChanged = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_sigMapChanged_get(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    result = (AGSignal *)& ((arg1)->sigMapChanged);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_HeightMap_sigMapChangedComplete_set(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 0);
    if (arg1) (arg1)->sigMapChangedComplete = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_sigMapChangedComplete_get(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    result = (AGSignal *)& ((arg1)->sigMapChangedComplete);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_HeightMap_getScene(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    Scene *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    result = (Scene *)(arg1)->getScene();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_disown_HeightMap(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_HeightMap, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAntMap;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntMap_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntMap);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntMap(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    int arg3 ;
    int arg4 ;
    AntMap *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    {
        char *classname = "Libantargis::AntMap";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AntMap *)new SwigDirector_AntMap(arg1,arg2,arg3,arg4);
            
        } else {
            result = (AntMap *)new AntMap(arg2,arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AntMap(AntMap *arg1) {
    delete arg1;
}

static VALUE
_wrap_AntMap_insertEntity(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AntEntity *arg2 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->insertEntity(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_removeEntity(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AntEntity *arg2 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntity, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->removeEntity(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_clear(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AntMap_getNewID(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    result = (int)(arg1)->getNewID();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AntMap_newMap(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    int arg2 ;
    int arg3 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newMap(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_getEntities__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AGRect2 *arg2 = 0 ;
    SwigValueWrapper<std::list<AntEntity * > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (arg1)->getEntities((AGRect2 const &)*arg2);
    
    {
        AntMap::EntityList * resultptr;
        resultptr = new AntMap::EntityList((AntMap::EntityList &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTAntEntity_p_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getAllEntities(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    SwigValueWrapper<std::list<AntEntity * > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    result = (arg1)->getAllEntities();
    
    {
        AntMap::EntityList * resultptr;
        resultptr = new AntMap::EntityList((AntMap::EntityList &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTAntEntity_p_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getAllEntitiesV(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    std::vector<AntEntityPtr > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    result = (arg1)->getAllEntitiesV();
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            AntEntityPtr* x = new AntEntityPtr(((std::vector<AntEntityPtr > &)result)[i]);
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_AntEntityPtr, 1));
        }
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getEntities__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    std::string *arg2 = 0 ;
    std::vector<AntEntityPtr > result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getEntities((std::string const &)*arg2);
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            AntEntityPtr* x = new AntEntityPtr(((std::vector<AntEntityPtr > &)result)[i]);
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_AntEntityPtr, 1));
        }
    }
    return vresult;
}


static VALUE _wrap_AntMap_getEntities(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntMap, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntMap_getEntities__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntMap, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntMap_getEntities__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntMap_getEntities'");
    return Qnil;
}


static VALUE
_wrap_AntMap_getEntity__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    Mesh *arg2 = 0 ;
    AntEntity *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Mesh, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AntEntity *)(arg1)->getEntity((Mesh const &)*arg2);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getEntity__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AnimMesh *arg2 = 0 ;
    AntEntity *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AnimMesh, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AntEntity *)(arg1)->getEntity((AnimMesh const &)*arg2);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getEntity__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    int arg2 ;
    AntEntity *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    arg2 = NUM2INT(argv[0]);
    result = (AntEntity *)((AntMap const *)arg1)->getEntity(arg2);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE _wrap_AntMap_getEntity(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntMap, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Mesh, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntMap_getEntity__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntMap, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AnimMesh, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntMap_getEntity__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntMap, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntMap_getEntity__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntMap_getEntity'");
    return Qnil;
}


static VALUE
_wrap_AntMap_getByName(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    std::string *arg2 = 0 ;
    AntEntity *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AntEntity *)(arg1)->getByName((std::string const &)*arg2);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getNext(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AntEntity *arg2 = (AntEntity *) 0 ;
    std::string *arg3 = 0 ;
    AntEntity *result;
    std::string temp3 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntity, 0);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AntEntity *)(arg1)->getNext(arg2,(std::string const &)*arg3);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AntMap_loadEntity(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AntEntity *result;
    Swig::Director *director = 0;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (AntEntity *)(arg1)->loadEntity((Node const &)*arg2);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_AntMap_saveXML(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    ((AntMap const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_loadXML(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_saveMap(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->saveMap((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_loadMap(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->loadMap((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_move(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->move(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_getPos(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AntMap const *)arg1)->getPos((AGVector2 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntMap_mark(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static VALUE
_wrap_AntMap_mapChanged(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_disown_AntMap(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntMap, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getMap(int argc, VALUE *argv, VALUE self) {
    AntMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AntMap *)getMap();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


swig_class cMeshData;

static VALUE
_wrap_new_MeshData__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string *arg4 = 0 ;
    bool arg5 ;
    MeshData *result;
    std::string temp2 ;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg5 = RTEST(argv[3]);
    {
        char *classname = "Libantargis::MeshData";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (MeshData *)new SwigDirector_MeshData(arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4,arg5);
            
        } else {
            result = (MeshData *)new MeshData((std::string const &)*arg2,arg3,(std::string const &)*arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_new_MeshData__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string *arg4 = 0 ;
    MeshData *result;
    std::string temp2 ;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::MeshData";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (MeshData *)new SwigDirector_MeshData(arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4);
            
        } else {
            result = (MeshData *)new MeshData((std::string const &)*arg2,arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_new_MeshData__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    MeshData *result;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    {
        char *classname = "Libantargis::MeshData";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (MeshData *)new SwigDirector_MeshData(arg1,(std::string const &)*arg2,arg3);
            
        } else {
            result = (MeshData *)new MeshData((std::string const &)*arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_new_MeshData__SWIG_3(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    VertexArray *arg2 = 0 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    MeshData *result;
    std::string temp3 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_VertexArray, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg4 = RTEST(argv[2]);
    {
        char *classname = "Libantargis::MeshData";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (MeshData *)new SwigDirector_MeshData(arg1,(VertexArray const &)*arg2,(std::string const &)*arg3,arg4);
            
        } else {
            result = (MeshData *)new MeshData((VertexArray const &)*arg2,(std::string const &)*arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_MeshData_allocate(VALUE self) {
#else
    static VALUE
    _wrap_MeshData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MeshData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_MeshData__SWIG_4(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    VertexArray *arg2 = 0 ;
    std::string *arg3 = 0 ;
    MeshData *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_VertexArray, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::MeshData";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (MeshData *)new SwigDirector_MeshData(arg1,(VertexArray const &)*arg2,(std::string const &)*arg3);
            
        } else {
            result = (MeshData *)new MeshData((VertexArray const &)*arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_MeshData(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_VertexArray, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_MeshData__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_MeshData__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_VertexArray, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (argv[3] == Qtrue || argv[3] == Qfalse) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_MeshData__SWIG_3(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_MeshData__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_MeshData__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_MeshData'");
    return Qnil;
}


static void
free_MeshData(MeshData *arg1) {
    delete arg1;
}

static VALUE
_wrap_MeshData_draw(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    AGVector4 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw((AGVector4 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshData_drawShadow(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_MeshData_drawDepth(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_MeshData_drawPick(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    (arg1)->drawPick();
    
    return Qnil;
}


static VALUE
_wrap_MeshData_bbox(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    AGBox3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    result = ((MeshData const *)arg1)->bbox();
    
    {
        AGBox3 * resultptr;
        resultptr = new AGBox3((AGBox3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGBox3, 1);
    }
    return vresult;
}


static VALUE
_wrap_MeshData_save(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->save((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshData_getTriangles(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((MeshData const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_MeshData_lineHit(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((MeshData const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_MeshData_texCoordFromPos(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->texCoordFromPos(arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshData_setPickable(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setPickable(arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshData_setTransparent(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setTransparent(arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshData_transparent(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->transparent();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_MeshData_setLighting(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setLighting(arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshData_setOverdraw(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setOverdraw(arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshData_setCulling(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setCulling(arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshData_setColors(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setColors(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_MeshData(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_MeshData, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cMesh;

static VALUE
_wrap_new_Mesh__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    Mesh *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    {
        char *classname = "Libantargis::Mesh";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (Mesh *)new SwigDirector_Mesh(arg1,arg2);
            
        } else {
            result = (Mesh *)new Mesh(arg2);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Mesh_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Mesh_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Mesh);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Mesh__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    MeshData *arg3 = 0 ;
    AGVector4 *arg4 = 0 ;
    float arg5 ;
    Mesh *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_MeshData, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGVector4, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg5 = (float) NUM2DBL(argv[3]);
    {
        char *classname = "Libantargis::Mesh";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (Mesh *)new SwigDirector_Mesh(arg1,arg2,*arg3,(AGVector4 const &)*arg4,arg5);
            
        } else {
            result = (Mesh *)new Mesh(arg2,*arg3,(AGVector4 const &)*arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_Mesh(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Scene, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_Mesh__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Scene, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_MeshData, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = ((TYPE(argv[4]) == T_FLOAT) || (TYPE(argv[4]) == T_FIXNUM) || (TYPE(argv[4]) == T_BIGNUM)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_Mesh__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Mesh'");
    return Qnil;
}


static void
free_Mesh(Mesh *arg1) {
    delete arg1;
}

static VALUE
_wrap_Mesh_draw(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_Mesh_drawDepth(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_Mesh_drawShadow(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_Mesh_drawPick(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawPick();
    
    return Qnil;
}


static VALUE
_wrap_Mesh_lineHit(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((Mesh const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_Mesh_getTriangles(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((Mesh const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Mesh_setRotation(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setRotation(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Mesh_setColor(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    AGVector4 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor((AGVector4 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Mesh_setVisible(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setVisible(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Mesh_getData(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    MeshData *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    result = (MeshData *)(arg1)->getData();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MeshData,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_Mesh_mark(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static VALUE
_wrap_Mesh_transparent(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->transparent();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_Mesh(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Mesh, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toMesh(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Mesh *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SceneNode, 0);
    result = (Mesh *)toMesh(arg1);
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


swig_class cMeshVertex;

static VALUE
_wrap_MeshVertex_v_set(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector4 *arg2 = (AGVector4 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0);
    if (arg1) (arg1)->v = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_MeshVertex_v_get(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 0);
    result = (AGVector4 *)& ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_MeshVertex_c_set(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector4 *arg2 = (AGVector4 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0);
    if (arg1) (arg1)->c = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_MeshVertex_c_get(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 0);
    result = (AGVector4 *)& ((arg1)->c);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_MeshVertex_n_set(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0);
    if (arg1) (arg1)->n = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_MeshVertex_n_get(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 0);
    result = (AGVector3 *)& ((arg1)->n);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_MeshVertex_t_set(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector2 *arg2 = (AGVector2 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 0);
    if (arg1) (arg1)->t = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_MeshVertex_t_get(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector2 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 0);
    result = (AGVector2 *)& ((arg1)->t);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector2,0);
    return vresult;
}


static VALUE
_wrap_MeshVertex___lt__(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    MeshVertex *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_MeshVertex, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((MeshVertex const *)arg1)->operator <((MeshVertex const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_MeshVertex_allocate(VALUE self) {
#else
    static VALUE
    _wrap_MeshVertex_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MeshVertex);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_MeshVertex(int argc, VALUE *argv, VALUE self) {
    MeshVertex *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (MeshVertex *)new MeshVertex();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_MeshVertex(MeshVertex *arg1) {
    delete arg1;
}

swig_class cMeshOptimizer;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_MeshOptimizer_allocate(VALUE self) {
#else
    static VALUE
    _wrap_MeshOptimizer_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MeshOptimizer);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_MeshOptimizer(int argc, VALUE *argv, VALUE self) {
    MeshOptimizer *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (MeshOptimizer *)new MeshOptimizer();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_MeshOptimizer_add(int argc, VALUE *argv, VALUE self) {
    MeshOptimizer *arg1 = (MeshOptimizer *) 0 ;
    MeshVertex *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshOptimizer, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_MeshVertex, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->add((MeshVertex const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshOptimizer_getArray(int argc, VALUE *argv, VALUE self) {
    MeshOptimizer *arg1 = (MeshOptimizer *) 0 ;
    VertexArray result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshOptimizer, 0);
    result = (arg1)->getArray();
    
    {
        VertexArray * resultptr;
        resultptr = new VertexArray((VertexArray &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_VertexArray, 1);
    }
    return vresult;
}


static VALUE
_wrap_MeshOptimizer_getV(int argc, VALUE *argv, VALUE self) {
    MeshOptimizer *arg1 = (MeshOptimizer *) 0 ;
    size_t arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshOptimizer, 0);
    arg2 = NUM2ULONG(argv[0]);
    result = (arg1)->getV(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static void
free_MeshOptimizer(MeshOptimizer *arg1) {
    delete arg1;
}

static VALUE
_wrap_loadFromText(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    bool arg2 ;
    float arg3 ;
    MeshOptimizer result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg2 = RTEST(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = loadFromText((std::string const &)*arg1,arg2,arg3);
    
    {
        MeshOptimizer * resultptr;
        resultptr = new MeshOptimizer((MeshOptimizer &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_MeshOptimizer, 1);
    }
    return vresult;
}


swig_class cMiniMap;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_MiniMap_allocate(VALUE self) {
#else
    static VALUE
    _wrap_MiniMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MiniMap);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_MiniMap(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect2 *arg3 = 0 ;
    AntMap *arg4 = (AntMap *) 0 ;
    MiniMap *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AntMap, 0);
    {
        char *classname = "Libantargis::MiniMap";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (MiniMap *)new SwigDirector_MiniMap(arg1,arg2,(AGRect2 const &)*arg3,arg4);
            
        } else {
            result = (MiniMap *)new MiniMap(arg2,(AGRect2 const &)*arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_MiniMap(MiniMap *arg1) {
    delete arg1;
}

static VALUE
_wrap_MiniMap_mapChanged(int argc, VALUE *argv, VALUE self) {
    MiniMap *arg1 = (MiniMap *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MiniMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->mapChanged(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_MiniMap_mapChangedComplete(int argc, VALUE *argv, VALUE self) {
    MiniMap *arg1 = (MiniMap *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MiniMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    result = (bool)(arg1)->mapChangedComplete(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_MiniMap_draw(int argc, VALUE *argv, VALUE self) {
    MiniMap *arg1 = (MiniMap *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MiniMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_MiniMap_setMap(int argc, VALUE *argv, VALUE self) {
    MiniMap *arg1 = (MiniMap *) 0 ;
    AntMap *arg2 = (AntMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MiniMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntMap, 0);
    (arg1)->setMap(arg2);
    
    return Qnil;
}


static VALUE
_wrap_MiniMap_setScene(int argc, VALUE *argv, VALUE self) {
    MiniMap *arg1 = (MiniMap *) 0 ;
    Scene *arg2 = (Scene *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MiniMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    (arg1)->setScene(arg2);
    
    return Qnil;
}


static VALUE
_wrap_MiniMap_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    MiniMap *arg1 = (MiniMap *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MiniMap, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_MiniMap(int argc, VALUE *argv, VALUE self) {
    MiniMap *arg1 = (MiniMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_MiniMap, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toMiniMap(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    MiniMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 0);
    result = (MiniMap *)toMiniMap(arg1);
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


swig_class cNewDecal;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_NewDecal_allocate(VALUE self) {
#else
    static VALUE
    _wrap_NewDecal_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_NewDecal);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_NewDecal(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    AGVector2 arg3 ;
    float arg4 ;
    HeightMap *arg5 = (HeightMap *) 0 ;
    std::string *arg6 = 0 ;
    NewDecal *result;
    std::string temp6 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    {
        AGVector2 * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGVector2, 0);
        if (ptr) arg3 = *ptr;
    }
    arg4 = (float) NUM2DBL(argv[2]);
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_HeightMap, 0);
    {
        if (TYPE(argv[4]) == T_STRING) {
            //            temp6 = std::string(StringValuePtr(argv[4]));
            temp6 = std::string(RSTRING(argv[4])->ptr,RSTRING(argv[4])->len);
            arg6 = &temp6;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::NewDecal";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (NewDecal *)new SwigDirector_NewDecal(arg1,arg2,arg3,arg4,arg5,(std::string const &)*arg6);
            
        } else {
            result = (NewDecal *)new NewDecal(arg2,arg3,arg4,arg5,(std::string const &)*arg6);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_NewDecal_setPos(int argc, VALUE *argv, VALUE self) {
    NewDecal *arg1 = (NewDecal *) 0 ;
    AGVector3 *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_NewDecal, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setPos((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_NewDecal_draw(int argc, VALUE *argv, VALUE self) {
    NewDecal *arg1 = (NewDecal *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_NewDecal, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_NewDecal_init(int argc, VALUE *argv, VALUE self) {
    NewDecal *arg1 = (NewDecal *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_NewDecal, 0);
    (arg1)->init();
    
    return Qnil;
}


static VALUE
_wrap_NewDecal_mapChanged(int argc, VALUE *argv, VALUE self) {
    NewDecal *arg1 = (NewDecal *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_NewDecal, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static void
free_NewDecal(NewDecal *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_NewDecal(int argc, VALUE *argv, VALUE self) {
    NewDecal *arg1 = (NewDecal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_NewDecal, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cRenderer;

static void
free_Renderer(Renderer *arg1) {
    delete arg1;
}

static VALUE
_wrap_Renderer_canMultitexture(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    result = (bool)(arg1)->canMultitexture();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Renderer_canShadow(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    result = (bool)(arg1)->canShadow();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Renderer_canGLSL(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    result = (bool)(arg1)->canGLSL();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Renderer_getShadowUnit(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    GLint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    result = (arg1)->getShadowUnit();
    
    {
        GLint * resultptr;
        resultptr = new GLint((GLint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_GLint, 1);
    }
    return vresult;
}


static VALUE
_wrap_Renderer_getNormalUnit(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    GLint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    result = (arg1)->getNormalUnit();
    
    {
        GLint * resultptr;
        resultptr = new GLint((GLint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_GLint, 1);
    }
    return vresult;
}


static VALUE
_wrap_Renderer_setCurrentScene(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    Scene *arg2 = (Scene *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    (arg1)->setCurrentScene(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Renderer_getCurrentScene(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    Scene *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    result = (Scene *)(arg1)->getCurrentScene();
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_Renderer_initShadowTexture(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    (arg1)->initShadowTexture();
    
    return Qnil;
}


static VALUE
_wrap_Renderer_beginShadowComputation(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    (arg1)->beginShadowComputation();
    
    return Qnil;
}


static VALUE
_wrap_Renderer_endShadowComputation(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    (arg1)->endShadowComputation();
    
    return Qnil;
}


static VALUE
_wrap_Renderer_beginShadowDrawing(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    (arg1)->beginShadowDrawing();
    
    return Qnil;
}


static VALUE
_wrap_Renderer_endShadowDrawing(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    (arg1)->endShadowDrawing();
    
    return Qnil;
}


static VALUE
_wrap_Renderer_badShadowMap(int argc, VALUE *argv, VALUE self) {
    Renderer *arg1 = (Renderer *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Renderer, 0);
    result = (bool)(arg1)->badShadowMap();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_getRenderer(int argc, VALUE *argv, VALUE self) {
    Renderer *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Renderer *)getRenderer();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Renderer,0);
    return vresult;
}


swig_class cResource;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Resource_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Resource_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Resource);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Resource(int argc, VALUE *argv, VALUE self) {
    Resource *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Resource *)new Resource();
    DATA_PTR(self) = result;
    
    return self;
}


static VALUE
_wrap_Resource_get(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::string *arg2 = 0 ;
    float result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (float)(arg1)->get((std::string const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Resource_add(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->add((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Resource_sub(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->sub((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Resource_set(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->set((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Resource_getAll(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::map<std::string,float > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 0);
    result = ((Resource const *)arg1)->getAll();
    
    {
        vresult = rb_hash_new();
        for (std::map<std::string,float >::iterator i=(&result)->begin(); i!=(&result)->end(); ++i) {
            rb_hash_aset(vresult,
            SWIG_STR2RB(i->first),
            rb_float_new(i->second));
        }
    }
    return vresult;
}


static VALUE
_wrap_Resource_takeAll(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    Resource *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Resource, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->takeAll(*arg2);
    
    return Qnil;
}


static void
free_Resource(Resource *arg1) {
    delete arg1;
}

swig_class cPickNode;

static VALUE
_wrap_PickNode_pos_set(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    AGVector4 *arg2 = (AGVector4 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0);
    if (arg1) (arg1)->pos = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_PickNode_pos_get(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 0);
    result = (AGVector4 *)& ((arg1)->pos);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_PickNode_node_set(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, SWIG_POINTER_DISOWN);
    if (arg1) (arg1)->node = arg2;
    
    return Qnil;
}


static VALUE
_wrap_PickNode_node_get(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    SceneNode *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 0);
    result = (SceneNode *) ((arg1)->node);
    
    {
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                if(false);
                else if(dynamic_cast<AnimMesh*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AnimMesh,0);
                else if(dynamic_cast<WaterPiece*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_WaterPiece,0);
                else if(dynamic_cast<Mesh*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
                else if(dynamic_cast<NewDecal*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewDecal,0);
                else if(dynamic_cast<Smoke*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Smoke,0);
                else if(dynamic_cast<TerrainPieceVA*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainPieceVA,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SceneNode,0);
            }
        }
        else vresult=Qnil;
    }
    return vresult;
}


static VALUE
_wrap_PickNode_camDist_set(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->camDist = arg2;
    
    return Qnil;
}


static VALUE
_wrap_PickNode_camDist_get(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 0);
    result = (float) ((arg1)->camDist);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_PickNode___lt__(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    PickNode *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_PickNode, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((PickNode const *)arg1)->operator <((PickNode const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_PickNode_allocate(VALUE self) {
#else
    static VALUE
    _wrap_PickNode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_PickNode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_PickNode(int argc, VALUE *argv, VALUE self) {
    PickNode *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (PickNode *)new PickNode();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_PickNode(PickNode *arg1) {
    delete arg1;
}

swig_class cViewport;

static VALUE
_wrap_Viewport_viewport_set(int argc, VALUE *argv, VALUE self) {
    Viewport *arg1 = (Viewport *) 0 ;
    GLint *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Viewport, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_GLint, 0);
    {
        size_t ii;
        GLint *b = (GLint *) arg1->viewport;
        for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((GLint *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_Viewport_viewport_get(int argc, VALUE *argv, VALUE self) {
    Viewport *arg1 = (Viewport *) 0 ;
    GLint *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Viewport, 0);
    result = (GLint *)(GLint *) ((arg1)->viewport);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GLint,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Viewport_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Viewport_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Viewport);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Viewport(int argc, VALUE *argv, VALUE self) {
    Viewport *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Viewport *)new Viewport();
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_Viewport(Viewport *arg1) {
    delete arg1;
}

swig_class cScene;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Scene_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Scene_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Scene);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Scene(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    Scene *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    {
        char *classname = "Libantargis::Scene";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (Scene *)new SwigDirector_Scene(arg1,arg2,arg3);
            
        } else {
            result = (Scene *)new Scene(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_Scene(Scene *arg1) {
    delete arg1;
}

static VALUE
_wrap_Scene_draw(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_Scene_setShadow(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setShadow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_getShadow(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = (int)((Scene const *)arg1)->getShadow();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Scene_addNode(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 0);
    (arg1)->addNode(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_removeNode(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 0);
    (arg1)->removeNode(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_prepareUpdate(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 0);
    (arg1)->prepareUpdate(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_updatePos(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 0);
    (arg1)->updatePos(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_clear(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_Scene_setCamera(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGVector4 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    {
        AGVector4 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGVector4, 0);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setCamera(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_getCamera(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = ((Scene const *)arg1)->getCamera();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_Scene_advance(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->advance(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_pick(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    Scene::PickResult result;
    VALUE vresult = Qnil;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    arg5 = (float) NUM2DBL(argv[3]);
    result = (arg1)->pick(arg2,arg3,arg4,arg5);
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            PickNode* x = new PickNode(((Scene::PickResult &)result)[i]);
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_PickNode, 1));
        }
    }
    return vresult;
}


static VALUE
_wrap_Scene_getTriangles(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = ((Scene const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Scene_getCameraDirTo(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((Scene const *)arg1)->getCameraDirTo((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_Scene_getFrustum(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = (arg1)->getFrustum();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_Scene_width(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = (float)((Scene const *)arg1)->width();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Scene_height(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = (float)((Scene const *)arg1)->height();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Scene_mark(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mark();
    
    return Qnil;
}


static VALUE
_wrap_Scene_getLightComplete(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = ((Scene const *)arg1)->getLightComplete();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_Scene_getLightView(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = ((Scene const *)arg1)->getLightView();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_Scene_getLightProj(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = ((Scene const *)arg1)->getLightProj();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_Scene_getInvCameraView(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = ((Scene const *)arg1)->getInvCameraView();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_Scene_getPosition(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((Scene const *)arg1)->getPosition((AGVector4 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_Scene_getCurrentNodes(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    SwigValueWrapper<std::list<SceneNode * > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 0);
    result = (arg1)->getCurrentNodes();
    
    {
        Scene::NodeList * resultptr;
        resultptr = new Scene::NodeList((Scene::NodeList &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTSceneNode_p_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_disown_Scene(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Scene, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getScenes(int argc, VALUE *argv, VALUE self) {
    SwigValueWrapper<std::set<Scene * > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = getScenes();
    
    {
        Scenes * resultptr;
        resultptr = new Scenes((Scenes &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__setTScene_p_t, 1);
    }
    return vresult;
}


swig_class cSmoke;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Smoke_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Smoke_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Smoke);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Smoke(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    float arg3 ;
    Smoke *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    arg3 = (float) NUM2DBL(argv[1]);
    {
        char *classname = "Libantargis::Smoke";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (Smoke *)new SwigDirector_Smoke(arg1,arg2,arg3);
            
        } else {
            result = (Smoke *)new Smoke(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_Smoke_setFire(int argc, VALUE *argv, VALUE self) {
    Smoke *arg1 = (Smoke *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Smoke, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setFire(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Smoke_setMaxTime(int argc, VALUE *argv, VALUE self) {
    Smoke *arg1 = (Smoke *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Smoke, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setMaxTime(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Smoke_advance(int argc, VALUE *argv, VALUE self) {
    Smoke *arg1 = (Smoke *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Smoke, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->advance(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Smoke_transparent(int argc, VALUE *argv, VALUE self) {
    Smoke *arg1 = (Smoke *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Smoke, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->transparent();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Smoke_draw(int argc, VALUE *argv, VALUE self) {
    Smoke *arg1 = (Smoke *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Smoke, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static void
free_Smoke(Smoke *arg1) {
    delete arg1;
}

static VALUE
_wrap_disown_Smoke(int argc, VALUE *argv, VALUE self) {
    Smoke *arg1 = (Smoke *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Smoke, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cTerrainPieceVA;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_TerrainPieceVA_allocate(VALUE self) {
#else
    static VALUE
    _wrap_TerrainPieceVA_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_TerrainPieceVA);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_TerrainPieceVA(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    Terrain *arg3 = (Terrain *) 0 ;
    HeightMap *arg4 = 0 ;
    int arg5 ;
    int arg6 ;
    int arg7 ;
    int arg8 ;
    AGVector4 *arg9 = 0 ;
    TerrainPieceVA *result;
    
    if ((argc < 8) || (argc > 8))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Terrain, 0);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_HeightMap, 0); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg5 = NUM2INT(argv[3]);
    arg6 = NUM2INT(argv[4]);
    arg7 = NUM2INT(argv[5]);
    arg8 = NUM2INT(argv[6]);
    SWIG_ConvertPtr(argv[7], (void **) &arg9, SWIGTYPE_p_AGVector4, 0); if (arg9 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::TerrainPieceVA";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (TerrainPieceVA *)new SwigDirector_TerrainPieceVA(arg1,arg2,arg3,*arg4,arg5,arg6,arg7,arg8,(AGVector4 const &)*arg9);
            
        } else {
            result = (TerrainPieceVA *)new TerrainPieceVA(arg2,arg3,*arg4,arg5,arg6,arg7,arg8,(AGVector4 const &)*arg9);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_TerrainPieceVA(TerrainPieceVA *arg1) {
    delete arg1;
}

static VALUE
_wrap_TerrainPieceVA_draw(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_TerrainPieceVA_drawShadow(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_TerrainPieceVA_drawDepth(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_TerrainPieceVA_drawPick(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawPick();
    
    return Qnil;
}


static VALUE
_wrap_TerrainPieceVA_lineHit(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((TerrainPieceVA const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_TerrainPieceVA_getTriangles(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((TerrainPieceVA const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_TerrainPieceVA_mapChanged(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_disown_TerrainPieceVA(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cTerrain;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Terrain_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Terrain_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Terrain);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Terrain(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    HeightMap *arg3 = 0 ;
    Terrain *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_HeightMap, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargis::Terrain";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (Terrain *)new SwigDirector_Terrain(arg1,arg2,*arg3);
        
    } else {
        result = (Terrain *)new Terrain(arg2,*arg3);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_Terrain(Terrain *arg1) {
    delete arg1;
}

static VALUE
_wrap_Terrain_mapChanged(int argc, VALUE *argv, VALUE self) {
    Terrain *arg1 = (Terrain *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Terrain, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_Terrain_mapChangedComplete(int argc, VALUE *argv, VALUE self) {
    Terrain *arg1 = (Terrain *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Terrain, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChangedComplete();
    
    return Qnil;
}


static VALUE
_wrap_Terrain_slotMapChanged(int argc, VALUE *argv, VALUE self) {
    Terrain *arg1 = (Terrain *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Terrain, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->slotMapChanged(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Terrain_slotMapChangedComplete(int argc, VALUE *argv, VALUE self) {
    Terrain *arg1 = (Terrain *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Terrain, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->slotMapChangedComplete(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Terrain_get3dTexture(int argc, VALUE *argv, VALUE self) {
    Terrain *arg1 = (Terrain *) 0 ;
    AGTexture *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Terrain, 0);
    result = (AGTexture *)(arg1)->get3dTexture();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
    }
    return vresult;
}


static VALUE
_wrap_Terrain_getGrassTexture(int argc, VALUE *argv, VALUE self) {
    Terrain *arg1 = (Terrain *) 0 ;
    AGTexture *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Terrain, 0);
    result = (AGTexture *)(arg1)->getGrassTexture();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
    }
    return vresult;
}


static VALUE
_wrap_Terrain_getScene(int argc, VALUE *argv, VALUE self) {
    Terrain *arg1 = (Terrain *) 0 ;
    Scene *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Terrain, 0);
    result = (Scene *)(arg1)->getScene();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    if(false);
                    else
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
                }
            }
            else vresult=Qnil;
        }
    }
    return vresult;
}


static VALUE
_wrap_disown_Terrain(int argc, VALUE *argv, VALUE self) {
    Terrain *arg1 = (Terrain *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Terrain, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cVertexArray;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_VertexArray_allocate(VALUE self) {
#else
    static VALUE
    _wrap_VertexArray_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_VertexArray);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_VertexArray(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    VertexArray *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::VertexArray";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (VertexArray *)new SwigDirector_VertexArray(arg1);
        
    } else {
        result = (VertexArray *)new VertexArray();
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_VertexArray(VertexArray *arg1) {
    delete arg1;
}

static VALUE
_wrap_VertexArray_addVertex__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    AGVector4 arg2 ;
    AGVector4 arg3 ;
    AGVector3 arg4 ;
    AGVector2 arg5 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    {
        AGVector4 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGVector4, 0);
        if (ptr) arg2 = *ptr;
    }
    {
        AGVector4 * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGVector4, 0);
        if (ptr) arg3 = *ptr;
    }
    {
        AGVector3 * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGVector3, 0);
        if (ptr) arg4 = *ptr;
    }
    {
        AGVector2 * ptr;
        SWIG_ConvertPtr(argv[3], (void **) &ptr, SWIGTYPE_p_AGVector2, 0);
        if (ptr) arg5 = *ptr;
    }
    (arg1)->addVertex(arg2,arg3,arg4,arg5);
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_addVertex__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    AGVector4 arg2 ;
    AGVector4 arg3 ;
    AGVector3 arg4 ;
    AGVector3 arg5 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    {
        AGVector4 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGVector4, 0);
        if (ptr) arg2 = *ptr;
    }
    {
        AGVector4 * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGVector4, 0);
        if (ptr) arg3 = *ptr;
    }
    {
        AGVector3 * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGVector3, 0);
        if (ptr) arg4 = *ptr;
    }
    {
        AGVector3 * ptr;
        SWIG_ConvertPtr(argv[3], (void **) &ptr, SWIGTYPE_p_AGVector3, 0);
        if (ptr) arg5 = *ptr;
    }
    (arg1)->addVertex(arg2,arg3,arg4,arg5);
    
    return Qnil;
}


static VALUE _wrap_VertexArray_addVertex(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_VertexArray, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_VertexArray_addVertex__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_VertexArray, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_VertexArray_addVertex__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'VertexArray_addVertex'");
    return Qnil;
}


static VALUE
_wrap_VertexArray_addTriangle(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    size_t arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = NUM2ULONG(argv[2]);
    (arg1)->addTriangle(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_setColors(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setColors(arg2);
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_setBuffers(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    arg2 = RTEST(argv[0]);
    (arg1)->setBuffers(arg2);
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_draw(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_drawPick(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    (arg1)->drawPick();
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_init(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    (arg1)->init();
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_clear(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_update(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    (arg1)->update();
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_getTriangles(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    result = ((VertexArray const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_VertexArray_getIndex(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    size_t arg2 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    arg2 = NUM2ULONG(argv[0]);
    result = (arg1)->getIndex(arg2);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_VertexArray_getVertex(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    size_t arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    arg2 = NUM2ULONG(argv[0]);
    result = (arg1)->getVertex(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_VertexArray_getColor(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    size_t arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    arg2 = NUM2ULONG(argv[0]);
    result = (arg1)->getColor(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_VertexArray_getNormal(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    size_t arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    arg2 = NUM2ULONG(argv[0]);
    result = (arg1)->getNormal(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_VertexArray_getTexCoord(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    size_t arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    arg2 = NUM2ULONG(argv[0]);
    result = (arg1)->getTexCoord(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_VertexArray_setTexCoord(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    size_t arg2 ;
    AGVector2 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    arg2 = NUM2ULONG(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setTexCoord(arg2,(AGVector2 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_VertexArray_lineHit(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 0); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((VertexArray const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_disown_VertexArray(int argc, VALUE *argv, VALUE self) {
    VertexArray *arg1 = (VertexArray *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_VertexArray, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cVertexArrayShader;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_VertexArrayShader_allocate(VALUE self) {
#else
    static VALUE
    _wrap_VertexArrayShader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_VertexArrayShader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_VertexArrayShader(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AntShaderProgram *arg2 = (AntShaderProgram *) 0 ;
    VertexArrayShader *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntShaderProgram, 0);
    char *classname = "Libantargis::VertexArrayShader";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (VertexArrayShader *)new SwigDirector_VertexArrayShader(arg1,arg2);
        
    } else {
        result = (VertexArrayShader *)new VertexArrayShader(arg2);
        
    }
    DATA_PTR(self) = result;
    
    return self;
}


static void
free_VertexArrayShader(VertexArrayShader *arg1) {
    delete arg1;
}

static VALUE
_wrap_VertexArrayShader_addAttribute(int argc, VALUE *argv, VALUE self) {
    VertexArrayShader *arg1 = (VertexArrayShader *) 0 ;
    std::string *arg2 = 0 ;
    std::vector<float > *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArrayShader, 0);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTfloat_t, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->addAttribute((std::string const &)*arg2,(std::vector<float > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_VertexArrayShader_draw(int argc, VALUE *argv, VALUE self) {
    VertexArrayShader *arg1 = (VertexArrayShader *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_VertexArrayShader, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_disown_VertexArrayShader(int argc, VALUE *argv, VALUE self) {
    VertexArrayShader *arg1 = (VertexArrayShader *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_VertexArrayShader, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cWaterPiece;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_WaterPiece_allocate(VALUE self) {
#else
    static VALUE
    _wrap_WaterPiece_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_WaterPiece);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_WaterPiece(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Scene *arg2 = (Scene *) 0 ;
    HeightMap *arg3 = 0 ;
    int arg4 ;
    int arg5 ;
    int arg6 ;
    int arg7 ;
    AGVector4 *arg8 = 0 ;
    WaterPiece *result;
    
    if ((argc < 7) || (argc > 7))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 0);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_HeightMap, 0); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = NUM2INT(argv[2]);
    arg5 = NUM2INT(argv[3]);
    arg6 = NUM2INT(argv[4]);
    arg7 = NUM2INT(argv[5]);
    SWIG_ConvertPtr(argv[6], (void **) &arg8, SWIGTYPE_p_AGVector4, 0); if (arg8 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::WaterPiece";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (WaterPiece *)new SwigDirector_WaterPiece(arg1,arg2,*arg3,arg4,arg5,arg6,arg7,(AGVector4 const &)*arg8);
            
        } else {
            result = (WaterPiece *)new WaterPiece(arg2,*arg3,arg4,arg5,arg6,arg7,(AGVector4 const &)*arg8);
            
        }
        DATA_PTR(self) = result;
        
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_WaterPiece(WaterPiece *arg1) {
    delete arg1;
}

static VALUE
_wrap_WaterPiece_draw(int argc, VALUE *argv, VALUE self) {
    WaterPiece *arg1 = (WaterPiece *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_WaterPiece, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_WaterPiece_drawPick(int argc, VALUE *argv, VALUE self) {
    WaterPiece *arg1 = (WaterPiece *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_WaterPiece, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawPick();
    
    return Qnil;
}


static VALUE
_wrap_WaterPiece_advance(int argc, VALUE *argv, VALUE self) {
    WaterPiece *arg1 = (WaterPiece *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_WaterPiece, 0);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->advance(arg2);
    
    return Qnil;
}


static VALUE
_wrap_WaterPiece_getTriangles(int argc, VALUE *argv, VALUE self) {
    WaterPiece *arg1 = (WaterPiece *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_WaterPiece, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((WaterPiece const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_WaterPiece_transparent(int argc, VALUE *argv, VALUE self) {
    WaterPiece *arg1 = (WaterPiece *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_WaterPiece, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->transparent();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_WaterPiece_mapChanged(int argc, VALUE *argv, VALUE self) {
    WaterPiece *arg1 = (WaterPiece *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_WaterPiece, 0);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_disown_WaterPiece(int argc, VALUE *argv, VALUE self) {
    WaterPiece *arg1 = (WaterPiece *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_WaterPiece, 0);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_AGDialogTo_p_AGLayout(void *x) {
    return (void *)((AGLayout *)  ((AGDialog *) x));
}
static void *_p_AGSubMenuTo_p_AGMenuItem(void *x) {
    return (void *)((AGMenuItem *)  ((AGSubMenu *) x));
}
static void *_p_GLAppTo_p_AGApplication(void *x) {
    return (void *)((AGApplication *)  ((GLApp *) x));
}
static void *_p_VertexArrayShaderTo_p_VertexArray(void *x) {
    return (void *)((VertexArray *)  ((VertexArrayShader *) x));
}
static void *_p_BinaryStringOutTo_p_BinaryOut(void *x) {
    return (void *)((BinaryOut *)  ((BinaryStringOut *) x));
}
static void *_p_BinaryFileOutTo_p_BinaryOut(void *x) {
    return (void *)((BinaryOut *)  ((BinaryFileOut *) x));
}
static void *_p_DomParserTo_p_Parser(void *x) {
    return (void *)((Parser *)  ((DomParser *) x));
}
static void *_p_AGListBoxTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGListBox *) x));
}
static void *_p_AGWindowTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_AGCaptionTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGApplicationTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *) ((AGApplication *) x));
}
static void *_p_AGButtonTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGButton *) x));
}
static void *_p_AGTableTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGTable *) x));
}
static void *_p_AntMapTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(HeightMap *) ((AntMap *) x));
}
static void *_p_AGWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *) ((AGWidget *) x));
}
static void *_p_HeightMapTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *) ((HeightMap *) x));
}
static void *_p_AGEditTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGColorButton *) x));
}
static void *_p_MiniMapTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((MiniMap *) x));
}
static void *_p_AGGLWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGGLWidget *) x));
}
static void *_p_AGImageTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGImage *) x));
}
static void *_p_AGCheckBoxTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGLayout *) x));
}
static void *_p_GLAppTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGApplication *) ((GLApp *) x));
}
static void *_p_AGMessageObjectTo_p_AGListener(void *x) {
    return (void *)((AGListener *)  ((AGMessageObject *) x));
}
static void *_p_AGDialogTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGRadioTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGTextTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGSound *) x));
}
static void *_p_AGListBoxTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGListBox *) x));
}
static void *_p_AGWindowTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGTable *) ((AGWindow *) x));
}
static void *_p_AGCaptionTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGText *) ((AGCaption *) x));
}
static void *_p_AGButtonTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGButton *) x));
}
static void *_p_AGTableTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGTable *) x));
}
static void *_p_AGEditTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGColorButton *) x));
}
static void *_p_MiniMapTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((MiniMap *) x));
}
static void *_p_AGGLWidgetTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGGLWidget *) x));
}
static void *_p_AGImageTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGImage *) x));
}
static void *_p_AGCheckBoxTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGLayout *) x));
}
static void *_p_AGRadioTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGDialogTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGLayout *) ((AGDialog *) x));
}
static void *_p_AGTextTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGSound *) x));
}
static void *_p_AGSoundTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGSound *) x));
}
static void *_p_AGMainTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *)  ((AGMain *) x));
}
static void *_p_SmokeTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (SceneNode *) ((Smoke *) x));
}
static void *_p_AGDialogTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGApplicationTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *) ((AGApplication *) x));
}
static void *_p_TerrainPieceVATo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (SceneNode *) ((TerrainPieceVA *) x));
}
static void *_p_MiniMapTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((MiniMap *) x));
}
static void *_p_AGButtonTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGButton *) x));
}
static void *_p_AGTextTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGText *) x));
}
static void *_p_AGListenerTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *)  ((AGListener *) x));
}
static void *_p_AGEditTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGEdit *) x));
}
static void *_p_AGImageTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGImage *) x));
}
static void *_p_AGGLWidgetTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGGLWidget *) x));
}
static void *_p_SceneNodeTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *)  ((SceneNode *) x));
}
static void *_p_GLAppTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGApplication *) ((GLApp *) x));
}
static void *_p_MeshTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (SceneNode *) ((Mesh *) x));
}
static void *_p_AntEntityTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *)  ((AntEntity *) x));
}
static void *_p_AGCaptionTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGRadioGroupTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGWindowTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_NewDecalTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (SceneNode *) ((NewDecal *) x));
}
static void *_p_HeightMapTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *) ((HeightMap *) x));
}
static void *_p_AGWidgetTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *) ((AGWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGTableTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGTable *) x));
}
static void *_p_SceneTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *)  ((Scene *) x));
}
static void *_p_AGListBoxTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGListBox *) x));
}
static void *_p_AGMessageObjectTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *) ((AGMessageObject *) x));
}
static void *_p_AntMapTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(HeightMap *) ((AntMap *) x));
}
static void *_p_AnimMeshTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (SceneNode *) ((AnimMesh *) x));
}
static void *_p_MeshDataTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *)  ((MeshData *) x));
}
static void *_p_AnimMeshDataTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *)  ((AnimMeshData *) x));
}
static void *_p_AGLayoutTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGLayout *) x));
}
static void *_p_AGRadioTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGColorButtonTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (AGListener *)(AGMessageObject *)(AGWidget *) ((AGColorButton *) x));
}
static void *_p_WaterPieceTo_p_AGRubyObject(void *x) {
    return (void *)((AGRubyObject *) (SceneNode *) ((WaterPiece *) x));
}
static void *_p_AGListBoxTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGListBox *) x));
}
static void *_p_AGWindowTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_AGCaptionTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGApplicationTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *)  ((AGApplication *) x));
}
static void *_p_AGButtonTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGButton *) x));
}
static void *_p_AGTableTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGTable *) x));
}
static void *_p_AntMapTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (HeightMap *) ((AntMap *) x));
}
static void *_p_AGWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *)  ((AGWidget *) x));
}
static void *_p_HeightMapTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *)  ((HeightMap *) x));
}
static void *_p_AGEditTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGColorButton *) x));
}
static void *_p_MiniMapTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((MiniMap *) x));
}
static void *_p_AGGLWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGGLWidget *) x));
}
static void *_p_AGImageTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGImage *) x));
}
static void *_p_AGCheckBoxTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGLayout *) x));
}
static void *_p_GLAppTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGApplication *) ((GLApp *) x));
}
static void *_p_AGDialogTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGRadioTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGTextTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGSound *) x));
}
static void *_p_AGCaptionTo_p_AGText(void *x) {
    return (void *)((AGText *)  ((AGCaption *) x));
}
static void *_p_AGSurfaceTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGSurface *) x));
}
static void *_p_AGTextureTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGTexture *) x));
}
static void *_p_AGScreenTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGScreen *) x));
}
static void *_p_AntWaterShaderTo_p_AntShaderProgram(void *x) {
    return (void *)((AntShaderProgram *)  ((AntWaterShader *) x));
}
static void *_p_AntShadowShaderTo_p_AntShaderProgram(void *x) {
    return (void *)((AntShaderProgram *)  ((AntShadowShader *) x));
}
static void *_p_AGRadioTo_p_AGButton(void *x) {
    return (void *)((AGButton *) (AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGCheckBoxTo_p_AGButton(void *x) {
    return (void *)((AGButton *)  ((AGCheckBox *) x));
}
static void *_p_BinaryFileInTo_p_BinaryIn(void *x) {
    return (void *)((BinaryIn *)  ((BinaryFileIn *) x));
}
static void *_p_BinaryStringInTo_p_BinaryIn(void *x) {
    return (void *)((BinaryIn *)  ((BinaryStringIn *) x));
}
static void *_p_AGRadioTo_p_AGCheckBox(void *x) {
    return (void *)((AGCheckBox *)  ((AGRadio *) x));
}
static void *_p_p_NewDecalTo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((NewDecal **) x));
}
static void *_p_p_SmokeTo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((Smoke **) x));
}
static void *_p_p_AnimMeshTo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((AnimMesh **) x));
}
static void *_p_p_MeshTo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((Mesh **) x));
}
static void *_p_p_WaterPieceTo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((WaterPiece **) x));
}
static void *_p_p_TerrainPieceVATo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((TerrainPieceVA **) x));
}
static void *_p_NewDecalTo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((NewDecal *) x));
}
static void *_p_SmokeTo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((Smoke *) x));
}
static void *_p_AnimMeshTo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((AnimMesh *) x));
}
static void *_p_MeshTo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((Mesh *) x));
}
static void *_p_WaterPieceTo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((WaterPiece *) x));
}
static void *_p_TerrainPieceVATo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((TerrainPieceVA *) x));
}
static void *_p_AGWindowTo_p_AGTable(void *x) {
    return (void *)((AGTable *)  ((AGWindow *) x));
}
static void *_p_AntMapTo_p_HeightMap(void *x) {
    return (void *)((HeightMap *)  ((AntMap *) x));
}
static swig_type_info _swigt__char = {"_char", "char", 0, 0, 0};
static swig_type_info _swigt__p_AGAngle = {"_p_AGAngle", "AGAngle *", 0, 0, 0};
static swig_type_info _swigt__p_AGApplication = {"_p_AGApplication", "AGApplication *", 0, 0, 0};
static swig_type_info _swigt__p_AGBackground = {"_p_AGBackground", "AGBackground *", 0, 0, 0};
static swig_type_info _swigt__p_AGBorder = {"_p_AGBorder", "AGBorder *", 0, 0, 0};
static swig_type_info _swigt__p_AGBox3 = {"_p_AGBox3", "AGBox3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGButton = {"_p_AGButton", "AGButton *", 0, 0, 0};
static swig_type_info _swigt__p_AGCPPListener = {"_p_AGCPPListener", "AGCPPListener *", 0, 0, 0};
static swig_type_info _swigt__p_AGCaption = {"_p_AGCaption", "AGCaption *", 0, 0, 0};
static swig_type_info _swigt__p_AGCheckBox = {"_p_AGCheckBox", "AGCheckBox *", 0, 0, 0};
static swig_type_info _swigt__p_AGCircle2 = {"_p_AGCircle2", "AGCircle2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGCollisionData = {"_p_AGCollisionData", "AGCollisionData *", 0, 0, 0};
static swig_type_info _swigt__p_AGColor = {"_p_AGColor", "AGColor *", 0, 0, 0};
static swig_type_info _swigt__p_AGColorButton = {"_p_AGColorButton", "AGColorButton *", 0, 0, 0};
static swig_type_info _swigt__p_AGDecryptor = {"_p_AGDecryptor", "AGDecryptor *", 0, 0, 0};
static swig_type_info _swigt__p_AGDialog = {"_p_AGDialog", "AGDialog *", 0, 0, 0};
static swig_type_info _swigt__p_AGEdit = {"_p_AGEdit", "AGEdit *", 0, 0, 0};
static swig_type_info _swigt__p_AGEditLine = {"_p_AGEditLine", "AGEditLine *", 0, 0, 0};
static swig_type_info _swigt__p_AGEvent = {"_p_AGEvent", "AGEvent *", 0, 0, 0};
static swig_type_info _swigt__p_AGFont = {"_p_AGFont", "AGFont *", 0, 0, 0};
static swig_type_info _swigt__p_AGFontEngine = {"_p_AGFontEngine", "AGFontEngine *", 0, 0, 0};
static swig_type_info _swigt__p_AGGLTexture = {"_p_AGGLTexture", "AGGLTexture *", 0, 0, 0};
static swig_type_info _swigt__p_AGGLWidget = {"_p_AGGLWidget", "AGGLWidget *", 0, 0, 0};
static swig_type_info _swigt__p_AGImage = {"_p_AGImage", "AGImage *", 0, 0, 0};
static swig_type_info _swigt__p_AGInternalSurface = {"_p_AGInternalSurface", "AGInternalSurface *", 0, 0, 0};
static swig_type_info _swigt__p_AGLayout = {"_p_AGLayout", "AGLayout *", 0, 0, 0};
static swig_type_info _swigt__p_AGLayoutCreator = {"_p_AGLayoutCreator", "AGLayoutCreator *", 0, 0, 0};
static swig_type_info _swigt__p_AGLayoutFactory = {"_p_AGLayoutFactory", "AGLayoutFactory *", 0, 0, 0};
static swig_type_info _swigt__p_AGLine2 = {"_p_AGLine2", "AGLine2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGLine3 = {"_p_AGLine3", "AGLine3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGListBox = {"_p_AGListBox", "AGListBox *", 0, 0, 0};
static swig_type_info _swigt__p_AGListBoxItem = {"_p_AGListBoxItem", "AGListBoxItem *", 0, 0, 0};
static swig_type_info _swigt__p_AGListener = {"_p_AGListener", "AGListener *", 0, 0, 0};
static swig_type_info _swigt__p_AGMain = {"_p_AGMain", "AGMain *", 0, 0, 0};
static swig_type_info _swigt__p_AGMatrix3 = {"_p_AGMatrix3", "AGMatrix3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGMatrix4 = {"_p_AGMatrix4", "AGMatrix4 *", 0, 0, 0};
static swig_type_info _swigt__p_AGMenu = {"_p_AGMenu", "AGMenu *", 0, 0, 0};
static swig_type_info _swigt__p_AGMenuItem = {"_p_AGMenuItem", "AGMenuItem *", 0, 0, 0};
static swig_type_info _swigt__p_AGMessageObject = {"_p_AGMessageObject", "AGMessageObject *", 0, 0, 0};
static swig_type_info _swigt__p_AGMutex = {"_p_AGMutex", "AGMutex *", 0, 0, 0};
static swig_type_info _swigt__p_AGPaintTarget = {"_p_AGPaintTarget", "AGPaintTarget *", 0, 0, 0};
static swig_type_info _swigt__p_AGPainter = {"_p_AGPainter", "AGPainter *", 0, 0, 0};
static swig_type_info _swigt__p_AGProjection = {"_p_AGProjection", "AGProjection *", 0, 0, 0};
static swig_type_info _swigt__p_AGRadio = {"_p_AGRadio", "AGRadio *", 0, 0, 0};
static swig_type_info _swigt__p_AGRadioGroup = {"_p_AGRadioGroup", "AGRadioGroup *", 0, 0, 0};
static swig_type_info _swigt__p_AGRect2 = {"_p_AGRect2", "AGRect2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGRect3 = {"_p_AGRect3", "AGRect3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGRenderContext = {"_p_AGRenderContext", "AGRenderContext *", 0, 0, 0};
static swig_type_info _swigt__p_AGRubyObject = {"_p_AGRubyObject", "AGRubyObject *", 0, 0, 0};
static swig_type_info _swigt__p_AGScreen = {"_p_AGScreen", "AGScreen *", 0, 0, 0};
static swig_type_info _swigt__p_AGSignal = {"_p_AGSignal", "AGSignal *", 0, 0, 0};
static swig_type_info _swigt__p_AGSound = {"_p_AGSound", "AGSound *", 0, 0, 0};
static swig_type_info _swigt__p_AGSubMenu = {"_p_AGSubMenu", "AGSubMenu *", 0, 0, 0};
static swig_type_info _swigt__p_AGSurface = {"_p_AGSurface", "AGSurface *", 0, 0, 0};
static swig_type_info _swigt__p_AGSurfaceManager = {"_p_AGSurfaceManager", "AGSurfaceManager *", 0, 0, 0};
static swig_type_info _swigt__p_AGTable = {"_p_AGTable", "AGTable *", 0, 0, 0};
static swig_type_info _swigt__p_AGText = {"_p_AGText", "AGText *", 0, 0, 0};
static swig_type_info _swigt__p_AGTexture = {"_p_AGTexture", "AGTexture *", 0, 0, 0};
static swig_type_info _swigt__p_AGTextureCache = {"_p_AGTextureCache", "AGTextureCache *", 0, 0, 0};
static swig_type_info _swigt__p_AGTheme = {"_p_AGTheme", "AGTheme *", 0, 0, 0};
static swig_type_info _swigt__p_AGTooltip = {"_p_AGTooltip", "AGTooltip *", 0, 0, 0};
static swig_type_info _swigt__p_AGTriangle2 = {"_p_AGTriangle2", "AGTriangle2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGTriangle3 = {"_p_AGTriangle3", "AGTriangle3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGVector2 = {"_p_AGVector2", "AGVector2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGVector3 = {"_p_AGVector3", "AGVector3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGVector4 = {"_p_AGVector4", "AGVector4 *", 0, 0, 0};
static swig_type_info _swigt__p_AGWidget = {"_p_AGWidget", "AGWidget *", 0, 0, 0};
static swig_type_info _swigt__p_AGWindow = {"_p_AGWindow", "AGWindow *", 0, 0, 0};
static swig_type_info _swigt__p_AnimMesh = {"_p_AnimMesh", "AnimMesh *", 0, 0, 0};
static swig_type_info _swigt__p_AnimMeshData = {"_p_AnimMeshData", "AnimMeshData *", 0, 0, 0};
static swig_type_info _swigt__p_Animation = {"_p_Animation", "Animation *", 0, 0, 0};
static swig_type_info _swigt__p_AntEntity = {"_p_AntEntity", "AntEntity *", 0, 0, 0};
static swig_type_info _swigt__p_AntEntityPtr = {"_p_AntEntityPtr", "AntEntityPtr *", 0, 0, 0};
static swig_type_info _swigt__p_AntFragProgram = {"_p_AntFragProgram", "AntFragProgram *", 0, 0, 0};
static swig_type_info _swigt__p_AntMap = {"_p_AntMap", "AntMap *", 0, 0, 0};
static swig_type_info _swigt__p_AntShaderParameter = {"_p_AntShaderParameter", "AntShaderParameter *", 0, 0, 0};
static swig_type_info _swigt__p_AntShaderProgram = {"_p_AntShaderProgram", "AntShaderProgram *", 0, 0, 0};
static swig_type_info _swigt__p_AntShadowShader = {"_p_AntShadowShader", "AntShadowShader *", 0, 0, 0};
static swig_type_info _swigt__p_AntVertexProgram = {"_p_AntVertexProgram", "AntVertexProgram *", 0, 0, 0};
static swig_type_info _swigt__p_AntWaterShader = {"_p_AntWaterShader", "AntWaterShader *", 0, 0, 0};
static swig_type_info _swigt__p_Attributes = {"_p_Attributes", "Attributes *", 0, 0, 0};
static swig_type_info _swigt__p_BinaryFileIn = {"_p_BinaryFileIn", "BinaryFileIn *", 0, 0, 0};
static swig_type_info _swigt__p_BinaryFileOut = {"_p_BinaryFileOut", "BinaryFileOut *", 0, 0, 0};
static swig_type_info _swigt__p_BinaryIn = {"_p_BinaryIn", "BinaryIn *", 0, 0, 0};
static swig_type_info _swigt__p_BinaryOut = {"_p_BinaryOut", "BinaryOut *", 0, 0, 0};
static swig_type_info _swigt__p_BinaryStringIn = {"_p_BinaryStringIn", "BinaryStringIn *", 0, 0, 0};
static swig_type_info _swigt__p_BinaryStringOut = {"_p_BinaryStringOut", "BinaryStringOut *", 0, 0, 0};
static swig_type_info _swigt__p_Bone = {"_p_Bone", "Bone *", 0, 0, 0};
static swig_type_info _swigt__p_Document = {"_p_Document", "Document *|xmlpp::Document *", 0, 0, 0};
static swig_type_info _swigt__p_DomParser = {"_p_DomParser", "DomParser *", 0, 0, 0};
static swig_type_info _swigt__p_EntityList = {"_p_EntityList", "EntityList *", 0, 0, 0};
static swig_type_info _swigt__p_GLApp = {"_p_GLApp", "GLApp *", 0, 0, 0};
static swig_type_info _swigt__p_GLint = {"_p_GLint", "GLint *", 0, 0, 0};
static swig_type_info _swigt__p_GLuint = {"_p_GLuint", "GLuint *", 0, 0, 0};
static swig_type_info _swigt__p_HeightMap = {"_p_HeightMap", "HeightMap *", 0, 0, 0};
static swig_type_info _swigt__p_KeyFrame = {"_p_KeyFrame", "KeyFrame *", 0, 0, 0};
static swig_type_info _swigt__p_Mesh = {"_p_Mesh", "Mesh *", 0, 0, 0};
static swig_type_info _swigt__p_MeshData = {"_p_MeshData", "MeshData *", 0, 0, 0};
static swig_type_info _swigt__p_MeshOptimizer = {"_p_MeshOptimizer", "MeshOptimizer *", 0, 0, 0};
static swig_type_info _swigt__p_MeshVertex = {"_p_MeshVertex", "MeshVertex *", 0, 0, 0};
static swig_type_info _swigt__p_Meshes = {"_p_Meshes", "Meshes *", 0, 0, 0};
static swig_type_info _swigt__p_MiniMap = {"_p_MiniMap", "MiniMap *", 0, 0, 0};
static swig_type_info _swigt__p_NewDecal = {"_p_NewDecal", "NewDecal *", 0, 0, 0};
static swig_type_info _swigt__p_Node = {"_p_Node", "Node *|xmlpp::Node *", 0, 0, 0};
static swig_type_info _swigt__p_NodeList = {"_p_NodeList", "NodeList *", 0, 0, 0};
static swig_type_info _swigt__p_NodeVector = {"_p_NodeVector", "NodeVector *", 0, 0, 0};
static swig_type_info _swigt__p_Node__NodeVector__const_iterator = {"_p_Node__NodeVector__const_iterator", "Node::NodeVector::const_iterator *|Node::const_iterator *", 0, 0, 0};
static swig_type_info _swigt__p_Node__NodeVector__iterator = {"_p_Node__NodeVector__iterator", "Node::NodeVector::iterator *|Node::iterator *", 0, 0, 0};
static swig_type_info _swigt__p_Parser = {"_p_Parser", "Parser *", 0, 0, 0};
static swig_type_info _swigt__p_PickNode = {"_p_PickNode", "PickNode *", 0, 0, 0};
static swig_type_info _swigt__p_PickResult = {"_p_PickResult", "PickResult *", 0, 0, 0};
static swig_type_info _swigt__p_Renderer = {"_p_Renderer", "Renderer *", 0, 0, 0};
static swig_type_info _swigt__p_Resource = {"_p_Resource", "Resource *", 0, 0, 0};
static swig_type_info _swigt__p_SDLKey = {"_p_SDLKey", "enum SDLKey *|SDLKey *", 0, 0, 0};
static swig_type_info _swigt__p_SDLMod = {"_p_SDLMod", "enum SDLMod *|SDLMod *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_Event = {"_p_SDL_Event", "SDL_Event *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_PixelFormat = {"_p_SDL_PixelFormat", "SDL_PixelFormat *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_Rect = {"_p_SDL_Rect", "SDL_Rect *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_Surface = {"_p_SDL_Surface", "SDL_Surface *", 0, 0, 0};
static swig_type_info _swigt__p_Scene = {"_p_Scene", "Scene *", 0, 0, 0};
static swig_type_info _swigt__p_SceneNode = {"_p_SceneNode", "SceneNode *", 0, 0, 0};
static swig_type_info _swigt__p_SerialException = {"_p_SerialException", "SerialException *", 0, 0, 0};
static swig_type_info _swigt__p_Sint32 = {"_p_Sint32", "Sint32 *", 0, 0, 0};
static swig_type_info _swigt__p_Smoke = {"_p_Smoke", "Smoke *", 0, 0, 0};
static swig_type_info _swigt__p_Terrain = {"_p_Terrain", "Terrain *", 0, 0, 0};
static swig_type_info _swigt__p_TerrainPieceVA = {"_p_TerrainPieceVA", "TerrainPieceVA *", 0, 0, 0};
static swig_type_info _swigt__p_Uint16 = {"_p_Uint16", "Uint16 *", 0, 0, 0};
static swig_type_info _swigt__p_Uint32 = {"_p_Uint32", "Uint32 *", 0, 0, 0};
static swig_type_info _swigt__p_Uint8 = {"_p_Uint8", "Uint8 *", 0, 0, 0};
static swig_type_info _swigt__p_VertexArray = {"_p_VertexArray", "VertexArray *", 0, 0, 0};
static swig_type_info _swigt__p_VertexArrayShader = {"_p_VertexArrayShader", "VertexArrayShader *", 0, 0, 0};
static swig_type_info _swigt__p_Viewport = {"_p_Viewport", "Viewport *", 0, 0, 0};
static swig_type_info _swigt__p_WaterPiece = {"_p_WaterPiece", "WaterPiece *", 0, 0, 0};
static swig_type_info _swigt__p_const_iterator = {"_p_const_iterator", "const_iterator *", 0, 0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *", 0, 0, 0};
static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, 0};
static swig_type_info _swigt__p_p_Node = {"_p_p_Node", "Node **", 0, 0, 0};
static swig_type_info _swigt__p_p_SceneNode = {"_p_p_SceneNode", "SceneNode **|SceneNodePtr *", 0, 0, 0};
static swig_type_info _swigt__p_p_NewDecal = {"_p_p_NewDecal", 0, 0, 0, 0};
static swig_type_info _swigt__p_p_Smoke = {"_p_p_Smoke", 0, 0, 0, 0};
static swig_type_info _swigt__p_p_Mesh = {"_p_p_Mesh", 0, 0, 0, 0};
static swig_type_info _swigt__p_p_AnimMesh = {"_p_p_AnimMesh", 0, 0, 0, 0};
static swig_type_info _swigt__p_p_WaterPiece = {"_p_p_WaterPiece", 0, 0, 0, 0};
static swig_type_info _swigt__p_p_TerrainPieceVA = {"_p_p_TerrainPieceVA", 0, 0, 0, 0};
static swig_type_info _swigt__p_std__listTAGRect2_t = {"_p_std__listTAGRect2_t", "std::list<AGRect2 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__listTAntEntity_p_t = {"_p_std__listTAntEntity_p_t", "std::list<AntEntity * > *|AntMap::EntityList *", 0, 0, 0};
static swig_type_info _swigt__p_std__listTSceneNode_p_t = {"_p_std__listTSceneNode_p_t", "std::list<SceneNode * > *|Scene::NodeList *", 0, 0, 0};
static swig_type_info _swigt__p_std__mapTstd__string_float_t = {"_p_std__mapTstd__string_float_t", "std::map<std::string,float > *", 0, 0, 0};
static swig_type_info _swigt__p_std__mapTstd__string_std__string_t = {"_p_std__mapTstd__string_std__string_t", "std::map<std::string,std::string > *|Node::Attributes *", 0, 0, 0};
static swig_type_info _swigt__p_std__ostringstream = {"_p_std__ostringstream", "std::ostringstream *", 0, 0, 0};
static swig_type_info _swigt__p_std__pairTAGRect2_AGRect2_t = {"_p_std__pairTAGRect2_AGRect2_t", "std::pair<AGRect2,AGRect2 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__pairTstd__string_bool_t = {"_p_std__pairTstd__string_bool_t", "std::pair<std::string,bool > *", 0, 0, 0};
static swig_type_info _swigt__p_std__setTScene_p_t = {"_p_std__setTScene_p_t", "std::set<Scene * > *|Scenes *", 0, 0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGBox3_t = {"_p_std__vectorTAGBox3_t", "std::vector<AGBox3 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGLine2_t = {"_p_std__vectorTAGLine2_t", "std::vector<AGLine2 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGMatrix4_t = {"_p_std__vectorTAGMatrix4_t", "std::vector<AGMatrix4 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGRect3_t = {"_p_std__vectorTAGRect3_t", "std::vector<AGRect3 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGVector2_t = {"_p_std__vectorTAGVector2_t", "std::vector<AGVector2 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGVector4_t = {"_p_std__vectorTAGVector4_t", "std::vector<AGVector4 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAntEntityPtr_t = {"_p_std__vectorTAntEntityPtr_t", "std::vector<AntEntityPtr > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTKeyFrame_t = {"_p_std__vectorTKeyFrame_t", "std::vector<KeyFrame > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTNode_p_t = {"_p_std__vectorTNode_p_t", "std::vector<Node * > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTNode_t = {"_p_std__vectorTNode_t", "std::vector<Node > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTPickNode_t = {"_p_std__vectorTPickNode_t", "std::vector<PickNode > *|Scene::PickResult *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTSceneNodePtr_t = {"_p_std__vectorTSceneNodePtr_t", "std::vector<SceneNodePtr > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTfloat_t = {"_p_std__vectorTfloat_t", "std::vector<float > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTstd__pairTAGRect2_AGVector4_t_t = {"_p_std__vectorTstd__pairTAGRect2_AGVector4_t_t", "std::vector<std::pair<AGRect2,AGVector4 > > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTstd__string_t = {"_p_std__vectorTstd__string_t", "std::vector<std::string > *", 0, 0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "unsigned long *|VALUE *", 0, 0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__char,
  &_swigt__p_AGAngle,
  &_swigt__p_AGApplication,
  &_swigt__p_AGBackground,
  &_swigt__p_AGBorder,
  &_swigt__p_AGBox3,
  &_swigt__p_AGButton,
  &_swigt__p_AGCPPListener,
  &_swigt__p_AGCaption,
  &_swigt__p_AGCheckBox,
  &_swigt__p_AGCircle2,
  &_swigt__p_AGCollisionData,
  &_swigt__p_AGColor,
  &_swigt__p_AGColorButton,
  &_swigt__p_AGDecryptor,
  &_swigt__p_AGDialog,
  &_swigt__p_AGEdit,
  &_swigt__p_AGEditLine,
  &_swigt__p_AGEvent,
  &_swigt__p_AGFont,
  &_swigt__p_AGFontEngine,
  &_swigt__p_AGGLTexture,
  &_swigt__p_AGGLWidget,
  &_swigt__p_AGImage,
  &_swigt__p_AGInternalSurface,
  &_swigt__p_AGLayout,
  &_swigt__p_AGLayoutCreator,
  &_swigt__p_AGLayoutFactory,
  &_swigt__p_AGLine2,
  &_swigt__p_AGLine3,
  &_swigt__p_AGListBox,
  &_swigt__p_AGListBoxItem,
  &_swigt__p_AGListener,
  &_swigt__p_AGMain,
  &_swigt__p_AGMatrix3,
  &_swigt__p_AGMatrix4,
  &_swigt__p_AGMenu,
  &_swigt__p_AGMenuItem,
  &_swigt__p_AGMessageObject,
  &_swigt__p_AGMutex,
  &_swigt__p_AGPaintTarget,
  &_swigt__p_AGPainter,
  &_swigt__p_AGProjection,
  &_swigt__p_AGRadio,
  &_swigt__p_AGRadioGroup,
  &_swigt__p_AGRect2,
  &_swigt__p_AGRect3,
  &_swigt__p_AGRenderContext,
  &_swigt__p_AGRubyObject,
  &_swigt__p_AGScreen,
  &_swigt__p_AGSignal,
  &_swigt__p_AGSound,
  &_swigt__p_AGSubMenu,
  &_swigt__p_AGSurface,
  &_swigt__p_AGSurfaceManager,
  &_swigt__p_AGTable,
  &_swigt__p_AGText,
  &_swigt__p_AGTexture,
  &_swigt__p_AGTextureCache,
  &_swigt__p_AGTheme,
  &_swigt__p_AGTooltip,
  &_swigt__p_AGTriangle2,
  &_swigt__p_AGTriangle3,
  &_swigt__p_AGVector2,
  &_swigt__p_AGVector3,
  &_swigt__p_AGVector4,
  &_swigt__p_AGWidget,
  &_swigt__p_AGWindow,
  &_swigt__p_AnimMesh,
  &_swigt__p_AnimMeshData,
  &_swigt__p_Animation,
  &_swigt__p_AntEntity,
  &_swigt__p_AntEntityPtr,
  &_swigt__p_AntFragProgram,
  &_swigt__p_AntMap,
  &_swigt__p_AntShaderParameter,
  &_swigt__p_AntShaderProgram,
  &_swigt__p_AntShadowShader,
  &_swigt__p_AntVertexProgram,
  &_swigt__p_AntWaterShader,
  &_swigt__p_Attributes,
  &_swigt__p_BinaryFileIn,
  &_swigt__p_BinaryFileOut,
  &_swigt__p_BinaryIn,
  &_swigt__p_BinaryOut,
  &_swigt__p_BinaryStringIn,
  &_swigt__p_BinaryStringOut,
  &_swigt__p_Bone,
  &_swigt__p_Document,
  &_swigt__p_DomParser,
  &_swigt__p_EntityList,
  &_swigt__p_GLApp,
  &_swigt__p_GLint,
  &_swigt__p_GLuint,
  &_swigt__p_HeightMap,
  &_swigt__p_KeyFrame,
  &_swigt__p_Mesh,
  &_swigt__p_MeshData,
  &_swigt__p_MeshOptimizer,
  &_swigt__p_MeshVertex,
  &_swigt__p_Meshes,
  &_swigt__p_MiniMap,
  &_swigt__p_NewDecal,
  &_swigt__p_Node,
  &_swigt__p_NodeList,
  &_swigt__p_NodeVector,
  &_swigt__p_Node__NodeVector__const_iterator,
  &_swigt__p_Node__NodeVector__iterator,
  &_swigt__p_Parser,
  &_swigt__p_PickNode,
  &_swigt__p_PickResult,
  &_swigt__p_Renderer,
  &_swigt__p_Resource,
  &_swigt__p_SDLKey,
  &_swigt__p_SDLMod,
  &_swigt__p_SDL_Event,
  &_swigt__p_SDL_PixelFormat,
  &_swigt__p_SDL_Rect,
  &_swigt__p_SDL_Surface,
  &_swigt__p_Scene,
  &_swigt__p_SceneNode,
  &_swigt__p_SerialException,
  &_swigt__p_Sint32,
  &_swigt__p_Smoke,
  &_swigt__p_Terrain,
  &_swigt__p_TerrainPieceVA,
  &_swigt__p_Uint16,
  &_swigt__p_Uint32,
  &_swigt__p_Uint8,
  &_swigt__p_VertexArray,
  &_swigt__p_VertexArrayShader,
  &_swigt__p_Viewport,
  &_swigt__p_WaterPiece,
  &_swigt__p_const_iterator,
  &_swigt__p_float,
  &_swigt__p_iterator,
  &_swigt__p_p_AnimMesh,
  &_swigt__p_p_Mesh,
  &_swigt__p_p_NewDecal,
  &_swigt__p_p_Node,
  &_swigt__p_p_SceneNode,
  &_swigt__p_p_Smoke,
  &_swigt__p_p_TerrainPieceVA,
  &_swigt__p_p_WaterPiece,
  &_swigt__p_std__listTAGRect2_t,
  &_swigt__p_std__listTAntEntity_p_t,
  &_swigt__p_std__listTSceneNode_p_t,
  &_swigt__p_std__mapTstd__string_float_t,
  &_swigt__p_std__mapTstd__string_std__string_t,
  &_swigt__p_std__ostringstream,
  &_swigt__p_std__pairTAGRect2_AGRect2_t,
  &_swigt__p_std__pairTstd__string_bool_t,
  &_swigt__p_std__setTScene_p_t,
  &_swigt__p_std__string,
  &_swigt__p_std__vectorTAGBox3_t,
  &_swigt__p_std__vectorTAGLine2_t,
  &_swigt__p_std__vectorTAGMatrix4_t,
  &_swigt__p_std__vectorTAGRect3_t,
  &_swigt__p_std__vectorTAGVector2_t,
  &_swigt__p_std__vectorTAGVector4_t,
  &_swigt__p_std__vectorTAntEntityPtr_t,
  &_swigt__p_std__vectorTKeyFrame_t,
  &_swigt__p_std__vectorTNode_p_t,
  &_swigt__p_std__vectorTNode_t,
  &_swigt__p_std__vectorTPickNode_t,
  &_swigt__p_std__vectorTSceneNodePtr_t,
  &_swigt__p_std__vectorTfloat_t,
  &_swigt__p_std__vectorTstd__pairTAGRect2_AGVector4_t_t,
  &_swigt__p_std__vectorTstd__string_t,
  &_swigt__p_unsigned_long,
};

static swig_cast_info _swigc__char[] = {  {&_swigt__char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGAngle[] = {  {&_swigt__p_AGAngle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGApplication[] = {  {&_swigt__p_AGApplication, 0, 0, 0},  {&_swigt__p_GLApp, _p_GLAppTo_p_AGApplication, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGBackground[] = {  {&_swigt__p_AGBackground, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGBorder[] = {  {&_swigt__p_AGBorder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGBox3[] = {  {&_swigt__p_AGBox3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGButton[] = {  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGButton, 0, 0},  {&_swigt__p_AGButton, 0, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGButton, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCPPListener[] = {  {&_swigt__p_AGCPPListener, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCaption[] = {  {&_swigt__p_AGCaption, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCheckBox[] = {  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGCheckBox, 0, 0},  {&_swigt__p_AGCheckBox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCircle2[] = {  {&_swigt__p_AGCircle2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCollisionData[] = {  {&_swigt__p_AGCollisionData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGColor[] = {  {&_swigt__p_AGColor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGColorButton[] = {  {&_swigt__p_AGColorButton, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGDecryptor[] = {  {&_swigt__p_AGDecryptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGDialog[] = {  {&_swigt__p_AGDialog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGEdit[] = {  {&_swigt__p_AGEdit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGEditLine[] = {  {&_swigt__p_AGEditLine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGEvent[] = {  {&_swigt__p_AGEvent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGFont[] = {  {&_swigt__p_AGFont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGFontEngine[] = {  {&_swigt__p_AGFontEngine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGGLTexture[] = {  {&_swigt__p_AGGLTexture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGGLWidget[] = {  {&_swigt__p_AGGLWidget, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGImage[] = {  {&_swigt__p_AGImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGInternalSurface[] = {  {&_swigt__p_AGInternalSurface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLayout[] = {  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGLayout, 0, 0},  {&_swigt__p_AGLayout, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLayoutCreator[] = {  {&_swigt__p_AGLayoutCreator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLayoutFactory[] = {  {&_swigt__p_AGLayoutFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLine2[] = {  {&_swigt__p_AGLine2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLine3[] = {  {&_swigt__p_AGLine3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGListBox[] = {  {&_swigt__p_AGListBox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGListBoxItem[] = {  {&_swigt__p_AGListBoxItem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGListener[] = {  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGListener, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGListener, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGListener, 0, 0},  {&_swigt__p_AntMap, _p_AntMapTo_p_AGListener, 0, 0},  {&_swigt__p_AGApplication, _p_AGApplicationTo_p_AGListener, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGListener, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGListener, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGListener, 0, 0},  {&_swigt__p_GLApp, _p_GLAppTo_p_AGListener, 0, 0},  {&_swigt__p_AGWidget, _p_AGWidgetTo_p_AGListener, 0, 0},  {&_swigt__p_HeightMap, _p_HeightMapTo_p_AGListener, 0, 0},  {&_swigt__p_MiniMap, _p_MiniMapTo_p_AGListener, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGListener, 0, 0},  {&_swigt__p_AGListener, 0, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGListener, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGListener, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGListener, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGListener, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGListener, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGListener, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGListener, 0, 0},  {&_swigt__p_AGMessageObject, _p_AGMessageObjectTo_p_AGListener, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGListener, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGListener, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMain[] = {  {&_swigt__p_AGMain, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMatrix3[] = {  {&_swigt__p_AGMatrix3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMatrix4[] = {  {&_swigt__p_AGMatrix4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMenu[] = {  {&_swigt__p_AGMenu, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMenuItem[] = {  {&_swigt__p_AGSubMenu, _p_AGSubMenuTo_p_AGMenuItem, 0, 0},  {&_swigt__p_AGMenuItem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMessageObject[] = {  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AntMap, _p_AntMapTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGApplication, _p_AGApplicationTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGMessageObject, 0, 0},  {&_swigt__p_GLApp, _p_GLAppTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGWidget, _p_AGWidgetTo_p_AGMessageObject, 0, 0},  {&_swigt__p_HeightMap, _p_HeightMapTo_p_AGMessageObject, 0, 0},  {&_swigt__p_MiniMap, _p_MiniMapTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGMessageObject, 0, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGMessageObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMutex[] = {  {&_swigt__p_AGMutex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGPaintTarget[] = {  {&_swigt__p_AGPaintTarget, 0, 0, 0},  {&_swigt__p_AGSurface, _p_AGSurfaceTo_p_AGPaintTarget, 0, 0},  {&_swigt__p_AGTexture, _p_AGTextureTo_p_AGPaintTarget, 0, 0},  {&_swigt__p_AGScreen, _p_AGScreenTo_p_AGPaintTarget, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGPainter[] = {  {&_swigt__p_AGPainter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGProjection[] = {  {&_swigt__p_AGProjection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRadio[] = {  {&_swigt__p_AGRadio, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRadioGroup[] = {  {&_swigt__p_AGRadioGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRect2[] = {  {&_swigt__p_AGRect2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRect3[] = {  {&_swigt__p_AGRect3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRenderContext[] = {  {&_swigt__p_AGRenderContext, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRubyObject[] = {  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AntMap, _p_AntMapTo_p_AGRubyObject, 0, 0},  {&_swigt__p_GLApp, _p_GLAppTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGRubyObject, 0, 0},  {&_swigt__p_TerrainPieceVA, _p_TerrainPieceVATo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGApplication, _p_AGApplicationTo_p_AGRubyObject, 0, 0},  {&_swigt__p_MiniMap, _p_MiniMapTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGListener, _p_AGListenerTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGMain, _p_AGMainTo_p_AGRubyObject, 0, 0},  {&_swigt__p_SceneNode, _p_SceneNodeTo_p_AGRubyObject, 0, 0},  {&_swigt__p_Scene, _p_SceneTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AntEntity, _p_AntEntityTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGRubyObject, 0, 0},  {&_swigt__p_NewDecal, _p_NewDecalTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGRubyObject, 0, 0},  {&_swigt__p_HeightMap, _p_HeightMapTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGWidget, _p_AGWidgetTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGMessageObject, _p_AGMessageObjectTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGRubyObject, 0, 0, 0},  {&_swigt__p_AnimMesh, _p_AnimMeshTo_p_AGRubyObject, 0, 0},  {&_swigt__p_Mesh, _p_MeshTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AnimMeshData, _p_AnimMeshDataTo_p_AGRubyObject, 0, 0},  {&_swigt__p_MeshData, _p_MeshDataTo_p_AGRubyObject, 0, 0},  {&_swigt__p_Smoke, _p_SmokeTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGRubyObject, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGRubyObject, 0, 0},  {&_swigt__p_WaterPiece, _p_WaterPieceTo_p_AGRubyObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGScreen[] = {  {&_swigt__p_AGScreen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSignal[] = {  {&_swigt__p_AGSignal, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSound[] = {  {&_swigt__p_AGSound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSubMenu[] = {  {&_swigt__p_AGSubMenu, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSurface[] = {  {&_swigt__p_AGSurface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSurfaceManager[] = {  {&_swigt__p_AGSurfaceManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTable[] = {  {&_swigt__p_AGTable, 0, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGTable, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGText[] = {  {&_swigt__p_AGText, 0, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGText, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTexture[] = {  {&_swigt__p_AGTexture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTextureCache[] = {  {&_swigt__p_AGTextureCache, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTheme[] = {  {&_swigt__p_AGTheme, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTooltip[] = {  {&_swigt__p_AGTooltip, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTriangle2[] = {  {&_swigt__p_AGTriangle2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTriangle3[] = {  {&_swigt__p_AGTriangle3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVector2[] = {  {&_swigt__p_AGVector2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVector3[] = {  {&_swigt__p_AGVector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVector4[] = {  {&_swigt__p_AGVector4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGWidget[] = {  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGWidget, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGWidget, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGWidget, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGWidget, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGWidget, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGWidget, 0, 0},  {&_swigt__p_AGWidget, 0, 0, 0},  {&_swigt__p_MiniMap, _p_MiniMapTo_p_AGWidget, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGWidget, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGWidget, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGWidget, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGWidget, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGWidget, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGWidget, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGWidget, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGWidget, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGWidget, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGWidget, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGWindow[] = {  {&_swigt__p_AGWindow, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AnimMesh[] = {  {&_swigt__p_AnimMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AnimMeshData[] = {  {&_swigt__p_AnimMeshData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Animation[] = {  {&_swigt__p_Animation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AntEntity[] = {  {&_swigt__p_AntEntity, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AntEntityPtr[] = {  {&_swigt__p_AntEntityPtr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AntFragProgram[] = {  {&_swigt__p_AntFragProgram, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AntMap[] = {  {&_swigt__p_AntMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AntShaderParameter[] = {  {&_swigt__p_AntShaderParameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AntShaderProgram[] = {  {&_swigt__p_AntShaderProgram, 0, 0, 0},  {&_swigt__p_AntWaterShader, _p_AntWaterShaderTo_p_AntShaderProgram, 0, 0},  {&_swigt__p_AntShadowShader, _p_AntShadowShaderTo_p_AntShaderProgram, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AntShadowShader[] = {  {&_swigt__p_AntShadowShader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AntVertexProgram[] = {  {&_swigt__p_AntVertexProgram, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AntWaterShader[] = {  {&_swigt__p_AntWaterShader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Attributes[] = {  {&_swigt__p_Attributes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BinaryFileIn[] = {  {&_swigt__p_BinaryFileIn, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BinaryFileOut[] = {  {&_swigt__p_BinaryFileOut, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BinaryIn[] = {  {&_swigt__p_BinaryFileIn, _p_BinaryFileInTo_p_BinaryIn, 0, 0},  {&_swigt__p_BinaryIn, 0, 0, 0},  {&_swigt__p_BinaryStringIn, _p_BinaryStringInTo_p_BinaryIn, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BinaryOut[] = {  {&_swigt__p_BinaryStringOut, _p_BinaryStringOutTo_p_BinaryOut, 0, 0},  {&_swigt__p_BinaryOut, 0, 0, 0},  {&_swigt__p_BinaryFileOut, _p_BinaryFileOutTo_p_BinaryOut, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BinaryStringIn[] = {  {&_swigt__p_BinaryStringIn, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BinaryStringOut[] = {  {&_swigt__p_BinaryStringOut, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Bone[] = {  {&_swigt__p_Bone, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Document[] = {  {&_swigt__p_Document, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DomParser[] = {  {&_swigt__p_DomParser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EntityList[] = {  {&_swigt__p_EntityList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLApp[] = {  {&_swigt__p_GLApp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLint[] = {  {&_swigt__p_GLint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLuint[] = {  {&_swigt__p_GLuint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_HeightMap[] = {  {&_swigt__p_AntMap, _p_AntMapTo_p_HeightMap, 0, 0},  {&_swigt__p_HeightMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_KeyFrame[] = {  {&_swigt__p_KeyFrame, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Mesh[] = {  {&_swigt__p_Mesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MeshData[] = {  {&_swigt__p_MeshData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MeshOptimizer[] = {  {&_swigt__p_MeshOptimizer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MeshVertex[] = {  {&_swigt__p_MeshVertex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Meshes[] = {  {&_swigt__p_Meshes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MiniMap[] = {  {&_swigt__p_MiniMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NewDecal[] = {  {&_swigt__p_NewDecal, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Node[] = {  {&_swigt__p_Node, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NodeList[] = {  {&_swigt__p_NodeList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NodeVector[] = {  {&_swigt__p_NodeVector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Node__NodeVector__const_iterator[] = {  {&_swigt__p_Node__NodeVector__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Node__NodeVector__iterator[] = {  {&_swigt__p_Node__NodeVector__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Parser[] = {  {&_swigt__p_Parser, 0, 0, 0},  {&_swigt__p_DomParser, _p_DomParserTo_p_Parser, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PickNode[] = {  {&_swigt__p_PickNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PickResult[] = {  {&_swigt__p_PickResult, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Renderer[] = {  {&_swigt__p_Renderer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Resource[] = {  {&_swigt__p_Resource, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDLKey[] = {  {&_swigt__p_SDLKey, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDLMod[] = {  {&_swigt__p_SDLMod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_Event[] = {  {&_swigt__p_SDL_Event, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_PixelFormat[] = {  {&_swigt__p_SDL_PixelFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_Rect[] = {  {&_swigt__p_SDL_Rect, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_Surface[] = {  {&_swigt__p_SDL_Surface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Scene[] = {  {&_swigt__p_Scene, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SceneNode[] = {  {&_swigt__p_NewDecal, _p_NewDecalTo_p_SceneNode, 0, 0},  {&_swigt__p_SceneNode, 0, 0, 0},  {&_swigt__p_Smoke, _p_SmokeTo_p_SceneNode, 0, 0},  {&_swigt__p_Mesh, _p_MeshTo_p_SceneNode, 0, 0},  {&_swigt__p_AnimMesh, _p_AnimMeshTo_p_SceneNode, 0, 0},  {&_swigt__p_WaterPiece, _p_WaterPieceTo_p_SceneNode, 0, 0},  {&_swigt__p_TerrainPieceVA, _p_TerrainPieceVATo_p_SceneNode, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SerialException[] = {  {&_swigt__p_SerialException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Sint32[] = {  {&_swigt__p_Sint32, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Smoke[] = {  {&_swigt__p_Smoke, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Terrain[] = {  {&_swigt__p_Terrain, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TerrainPieceVA[] = {  {&_swigt__p_TerrainPieceVA, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Uint16[] = {  {&_swigt__p_Uint16, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Uint32[] = {  {&_swigt__p_Uint32, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Uint8[] = {  {&_swigt__p_Uint8, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexArray[] = {  {&_swigt__p_VertexArrayShader, _p_VertexArrayShaderTo_p_VertexArray, 0, 0},  {&_swigt__p_VertexArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexArrayShader[] = {  {&_swigt__p_VertexArrayShader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Viewport[] = {  {&_swigt__p_Viewport, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_WaterPiece[] = {  {&_swigt__p_WaterPiece, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_iterator[] = {  {&_swigt__p_const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_Node[] = {  {&_swigt__p_p_Node, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_NewDecal[] = {{&_swigt__p_p_NewDecal, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_Smoke[] = {{&_swigt__p_p_Smoke, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_Mesh[] = {{&_swigt__p_p_Mesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_AnimMesh[] = {{&_swigt__p_p_AnimMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_WaterPiece[] = {{&_swigt__p_p_WaterPiece, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_TerrainPieceVA[] = {{&_swigt__p_p_TerrainPieceVA, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_SceneNode[] = {  {&_swigt__p_p_NewDecal, _p_p_NewDecalTo_p_p_SceneNode, 0, 0},  {&_swigt__p_p_SceneNode, 0, 0, 0},  {&_swigt__p_p_Smoke, _p_p_SmokeTo_p_p_SceneNode, 0, 0},  {&_swigt__p_p_Mesh, _p_p_MeshTo_p_p_SceneNode, 0, 0},  {&_swigt__p_p_AnimMesh, _p_p_AnimMeshTo_p_p_SceneNode, 0, 0},  {&_swigt__p_p_WaterPiece, _p_p_WaterPieceTo_p_p_SceneNode, 0, 0},  {&_swigt__p_p_TerrainPieceVA, _p_p_TerrainPieceVATo_p_p_SceneNode, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listTAGRect2_t[] = {  {&_swigt__p_std__listTAGRect2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listTAntEntity_p_t[] = {  {&_swigt__p_std__listTAntEntity_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listTSceneNode_p_t[] = {  {&_swigt__p_std__listTSceneNode_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTstd__string_float_t[] = {  {&_swigt__p_std__mapTstd__string_float_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTstd__string_std__string_t[] = {  {&_swigt__p_std__mapTstd__string_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostringstream[] = {  {&_swigt__p_std__ostringstream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairTAGRect2_AGRect2_t[] = {  {&_swigt__p_std__pairTAGRect2_AGRect2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairTstd__string_bool_t[] = {  {&_swigt__p_std__pairTstd__string_bool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__setTScene_p_t[] = {  {&_swigt__p_std__setTScene_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGBox3_t[] = {  {&_swigt__p_std__vectorTAGBox3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGLine2_t[] = {  {&_swigt__p_std__vectorTAGLine2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGMatrix4_t[] = {  {&_swigt__p_std__vectorTAGMatrix4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGRect3_t[] = {  {&_swigt__p_std__vectorTAGRect3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGVector2_t[] = {  {&_swigt__p_std__vectorTAGVector2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGVector4_t[] = {  {&_swigt__p_std__vectorTAGVector4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAntEntityPtr_t[] = {  {&_swigt__p_std__vectorTAntEntityPtr_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTKeyFrame_t[] = {  {&_swigt__p_std__vectorTKeyFrame_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTNode_p_t[] = {  {&_swigt__p_std__vectorTNode_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTNode_t[] = {  {&_swigt__p_std__vectorTNode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTPickNode_t[] = {  {&_swigt__p_std__vectorTPickNode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTSceneNodePtr_t[] = {  {&_swigt__p_std__vectorTSceneNodePtr_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTfloat_t[] = {  {&_swigt__p_std__vectorTfloat_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__pairTAGRect2_AGVector4_t_t[] = {  {&_swigt__p_std__vectorTstd__pairTAGRect2_AGVector4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__string_t[] = {  {&_swigt__p_std__vectorTstd__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__char,
  _swigc__p_AGAngle,
  _swigc__p_AGApplication,
  _swigc__p_AGBackground,
  _swigc__p_AGBorder,
  _swigc__p_AGBox3,
  _swigc__p_AGButton,
  _swigc__p_AGCPPListener,
  _swigc__p_AGCaption,
  _swigc__p_AGCheckBox,
  _swigc__p_AGCircle2,
  _swigc__p_AGCollisionData,
  _swigc__p_AGColor,
  _swigc__p_AGColorButton,
  _swigc__p_AGDecryptor,
  _swigc__p_AGDialog,
  _swigc__p_AGEdit,
  _swigc__p_AGEditLine,
  _swigc__p_AGEvent,
  _swigc__p_AGFont,
  _swigc__p_AGFontEngine,
  _swigc__p_AGGLTexture,
  _swigc__p_AGGLWidget,
  _swigc__p_AGImage,
  _swigc__p_AGInternalSurface,
  _swigc__p_AGLayout,
  _swigc__p_AGLayoutCreator,
  _swigc__p_AGLayoutFactory,
  _swigc__p_AGLine2,
  _swigc__p_AGLine3,
  _swigc__p_AGListBox,
  _swigc__p_AGListBoxItem,
  _swigc__p_AGListener,
  _swigc__p_AGMain,
  _swigc__p_AGMatrix3,
  _swigc__p_AGMatrix4,
  _swigc__p_AGMenu,
  _swigc__p_AGMenuItem,
  _swigc__p_AGMessageObject,
  _swigc__p_AGMutex,
  _swigc__p_AGPaintTarget,
  _swigc__p_AGPainter,
  _swigc__p_AGProjection,
  _swigc__p_AGRadio,
  _swigc__p_AGRadioGroup,
  _swigc__p_AGRect2,
  _swigc__p_AGRect3,
  _swigc__p_AGRenderContext,
  _swigc__p_AGRubyObject,
  _swigc__p_AGScreen,
  _swigc__p_AGSignal,
  _swigc__p_AGSound,
  _swigc__p_AGSubMenu,
  _swigc__p_AGSurface,
  _swigc__p_AGSurfaceManager,
  _swigc__p_AGTable,
  _swigc__p_AGText,
  _swigc__p_AGTexture,
  _swigc__p_AGTextureCache,
  _swigc__p_AGTheme,
  _swigc__p_AGTooltip,
  _swigc__p_AGTriangle2,
  _swigc__p_AGTriangle3,
  _swigc__p_AGVector2,
  _swigc__p_AGVector3,
  _swigc__p_AGVector4,
  _swigc__p_AGWidget,
  _swigc__p_AGWindow,
  _swigc__p_AnimMesh,
  _swigc__p_AnimMeshData,
  _swigc__p_Animation,
  _swigc__p_AntEntity,
  _swigc__p_AntEntityPtr,
  _swigc__p_AntFragProgram,
  _swigc__p_AntMap,
  _swigc__p_AntShaderParameter,
  _swigc__p_AntShaderProgram,
  _swigc__p_AntShadowShader,
  _swigc__p_AntVertexProgram,
  _swigc__p_AntWaterShader,
  _swigc__p_Attributes,
  _swigc__p_BinaryFileIn,
  _swigc__p_BinaryFileOut,
  _swigc__p_BinaryIn,
  _swigc__p_BinaryOut,
  _swigc__p_BinaryStringIn,
  _swigc__p_BinaryStringOut,
  _swigc__p_Bone,
  _swigc__p_Document,
  _swigc__p_DomParser,
  _swigc__p_EntityList,
  _swigc__p_GLApp,
  _swigc__p_GLint,
  _swigc__p_GLuint,
  _swigc__p_HeightMap,
  _swigc__p_KeyFrame,
  _swigc__p_Mesh,
  _swigc__p_MeshData,
  _swigc__p_MeshOptimizer,
  _swigc__p_MeshVertex,
  _swigc__p_Meshes,
  _swigc__p_MiniMap,
  _swigc__p_NewDecal,
  _swigc__p_Node,
  _swigc__p_NodeList,
  _swigc__p_NodeVector,
  _swigc__p_Node__NodeVector__const_iterator,
  _swigc__p_Node__NodeVector__iterator,
  _swigc__p_Parser,
  _swigc__p_PickNode,
  _swigc__p_PickResult,
  _swigc__p_Renderer,
  _swigc__p_Resource,
  _swigc__p_SDLKey,
  _swigc__p_SDLMod,
  _swigc__p_SDL_Event,
  _swigc__p_SDL_PixelFormat,
  _swigc__p_SDL_Rect,
  _swigc__p_SDL_Surface,
  _swigc__p_Scene,
  _swigc__p_SceneNode,
  _swigc__p_SerialException,
  _swigc__p_Sint32,
  _swigc__p_Smoke,
  _swigc__p_Terrain,
  _swigc__p_TerrainPieceVA,
  _swigc__p_Uint16,
  _swigc__p_Uint32,
  _swigc__p_Uint8,
  _swigc__p_VertexArray,
  _swigc__p_VertexArrayShader,
  _swigc__p_Viewport,
  _swigc__p_WaterPiece,
  _swigc__p_const_iterator,
  _swigc__p_float,
  _swigc__p_iterator,
  _swigc__p_p_AnimMesh,
  _swigc__p_p_Mesh,
  _swigc__p_p_NewDecal,
  _swigc__p_p_Node,
  _swigc__p_p_SceneNode,
  _swigc__p_p_Smoke,
  _swigc__p_p_TerrainPieceVA,
  _swigc__p_p_WaterPiece,
  _swigc__p_std__listTAGRect2_t,
  _swigc__p_std__listTAntEntity_p_t,
  _swigc__p_std__listTSceneNode_p_t,
  _swigc__p_std__mapTstd__string_float_t,
  _swigc__p_std__mapTstd__string_std__string_t,
  _swigc__p_std__ostringstream,
  _swigc__p_std__pairTAGRect2_AGRect2_t,
  _swigc__p_std__pairTstd__string_bool_t,
  _swigc__p_std__setTScene_p_t,
  _swigc__p_std__string,
  _swigc__p_std__vectorTAGBox3_t,
  _swigc__p_std__vectorTAGLine2_t,
  _swigc__p_std__vectorTAGMatrix4_t,
  _swigc__p_std__vectorTAGRect3_t,
  _swigc__p_std__vectorTAGVector2_t,
  _swigc__p_std__vectorTAGVector4_t,
  _swigc__p_std__vectorTAntEntityPtr_t,
  _swigc__p_std__vectorTKeyFrame_t,
  _swigc__p_std__vectorTNode_p_t,
  _swigc__p_std__vectorTNode_t,
  _swigc__p_std__vectorTPickNode_t,
  _swigc__p_std__vectorTSceneNodePtr_t,
  _swigc__p_std__vectorTfloat_t,
  _swigc__p_std__vectorTstd__pairTAGRect2_AGVector4_t_t,
  _swigc__p_std__vectorTstd__string_t,
  _swigc__p_unsigned_long,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/*************************************************************************
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.

 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop though that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.

 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
**/

#ifdef __cplusplus
extern "C" {
#endif

SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  swig_type_info *type, *ret;
  swig_cast_info *cast;
  size_t i;
  swig_module_info *module_head;
  static int init_run = 0;

  clientdata = clientdata;

  if (init_run) return;
  init_run = 1;

  /* Initialize the swig_module */
  swig_module.type_initial = swig_type_initial;
  swig_module.cast_initial = swig_cast_initial;

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (module_head) {
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  } else {
    /* This is the first module loaded */
    swig_module.next = &swig_module;
    SWIG_SetModule(clientdata, &swig_module);
  }
		 
  /* Now work on filling in swig_module.types */
  for (i = 0; i < swig_module.size; ++i) {
    type = 0;

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
      if (swig_module.type_initial[i]->clientdata) type->clientdata = swig_module.type_initial[i]->clientdata;
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
      }
      if (ret && type == swig_module.type_initial[i]) {
        cast->type = ret;
        ret = 0;
      }
      
      if (!ret) {
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }

      cast++;
    }

    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_libantargis(void) {
    size_t i;
    
    SWIG_InitRuntime();
    mLibantargis = rb_define_module("Libantargis");
    
    SWIG_InitializeModule(0);
    for (i = 0; i < swig_module.size; i++) {
        SWIG_define_class(swig_module.types[i]);
    }
    
    SWIG_RubyInitializeTrackings();
    
    cStringVector.klass = rb_define_class_under(mLibantargis, "StringVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__string_t, (void *) &cStringVector);
    rb_include_module(cStringVector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cStringVector.klass, _wrap_StringVector_allocate);
    rb_define_method(cStringVector.klass, "initialize", VALUEFUNC(_wrap_new_StringVector), -1);
    rb_define_method(cStringVector.klass, "length", VALUEFUNC(_wrap_StringVector___len__), -1);
    rb_define_method(cStringVector.klass, "empty?", VALUEFUNC(_wrap_StringVector_emptyq___), -1);
    rb_define_method(cStringVector.klass, "clear", VALUEFUNC(_wrap_StringVector_clear), -1);
    rb_define_method(cStringVector.klass, "push", VALUEFUNC(_wrap_StringVector_push), -1);
    rb_define_method(cStringVector.klass, "pop", VALUEFUNC(_wrap_StringVector_pop), -1);
    rb_define_method(cStringVector.klass, "[]", VALUEFUNC(_wrap_StringVector___getitem__), -1);
    rb_define_method(cStringVector.klass, "[]=", VALUEFUNC(_wrap_StringVector___setitem__), -1);
    rb_define_method(cStringVector.klass, "each", VALUEFUNC(_wrap_StringVector_each), -1);
    cStringVector.mark = 0;
    cStringVector.destroy = (void (*)(void *)) free_std_vector_Sl_std_string_Sg_;
    
    cSceneNodeVector.klass = rb_define_class_under(mLibantargis, "SceneNodeVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTSceneNodePtr_t, (void *) &cSceneNodeVector);
    rb_include_module(cSceneNodeVector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cSceneNodeVector.klass, _wrap_SceneNodeVector_allocate);
    rb_define_method(cSceneNodeVector.klass, "initialize", VALUEFUNC(_wrap_new_SceneNodeVector), -1);
    rb_define_method(cSceneNodeVector.klass, "length", VALUEFUNC(_wrap_SceneNodeVector___len__), -1);
    rb_define_method(cSceneNodeVector.klass, "empty?", VALUEFUNC(_wrap_SceneNodeVector_emptyq___), -1);
    rb_define_method(cSceneNodeVector.klass, "clear", VALUEFUNC(_wrap_SceneNodeVector_clear), -1);
    rb_define_method(cSceneNodeVector.klass, "push", VALUEFUNC(_wrap_SceneNodeVector_push), -1);
    rb_define_method(cSceneNodeVector.klass, "pop", VALUEFUNC(_wrap_SceneNodeVector_pop), -1);
    rb_define_method(cSceneNodeVector.klass, "[]", VALUEFUNC(_wrap_SceneNodeVector___getitem__), -1);
    rb_define_method(cSceneNodeVector.klass, "[]=", VALUEFUNC(_wrap_SceneNodeVector___setitem__), -1);
    rb_define_method(cSceneNodeVector.klass, "each", VALUEFUNC(_wrap_SceneNodeVector_each), -1);
    cSceneNodeVector.mark = 0;
    cSceneNodeVector.destroy = (void (*)(void *)) free_std_vector_Sl_SceneNodePtr_Sg_;
    
    cPickResult.klass = rb_define_class_under(mLibantargis, "PickResult", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTPickNode_t, (void *) &cPickResult);
    rb_include_module(cPickResult.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cPickResult.klass, _wrap_PickResult_allocate);
    rb_define_method(cPickResult.klass, "initialize", VALUEFUNC(_wrap_new_PickResult), -1);
    rb_define_method(cPickResult.klass, "length", VALUEFUNC(_wrap_PickResult___len__), -1);
    rb_define_method(cPickResult.klass, "empty?", VALUEFUNC(_wrap_PickResult_emptyq___), -1);
    rb_define_method(cPickResult.klass, "clear", VALUEFUNC(_wrap_PickResult_clear), -1);
    rb_define_method(cPickResult.klass, "push", VALUEFUNC(_wrap_PickResult_push), -1);
    rb_define_method(cPickResult.klass, "pop", VALUEFUNC(_wrap_PickResult_pop), -1);
    rb_define_method(cPickResult.klass, "[]", VALUEFUNC(_wrap_PickResult___getitem__), -1);
    rb_define_method(cPickResult.klass, "[]=", VALUEFUNC(_wrap_PickResult___setitem__), -1);
    rb_define_method(cPickResult.klass, "each", VALUEFUNC(_wrap_PickResult_each), -1);
    cPickResult.mark = 0;
    cPickResult.destroy = (void (*)(void *)) free_std_vector_Sl_PickNode_Sg_;
    
    cEntityVector.klass = rb_define_class_under(mLibantargis, "EntityVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTAntEntityPtr_t, (void *) &cEntityVector);
    rb_include_module(cEntityVector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cEntityVector.klass, _wrap_EntityVector_allocate);
    rb_define_method(cEntityVector.klass, "initialize", VALUEFUNC(_wrap_new_EntityVector), -1);
    rb_define_method(cEntityVector.klass, "length", VALUEFUNC(_wrap_EntityVector___len__), -1);
    rb_define_method(cEntityVector.klass, "empty?", VALUEFUNC(_wrap_EntityVector_emptyq___), -1);
    rb_define_method(cEntityVector.klass, "clear", VALUEFUNC(_wrap_EntityVector_clear), -1);
    rb_define_method(cEntityVector.klass, "push", VALUEFUNC(_wrap_EntityVector_push), -1);
    rb_define_method(cEntityVector.klass, "pop", VALUEFUNC(_wrap_EntityVector_pop), -1);
    rb_define_method(cEntityVector.klass, "[]", VALUEFUNC(_wrap_EntityVector___getitem__), -1);
    rb_define_method(cEntityVector.klass, "[]=", VALUEFUNC(_wrap_EntityVector___setitem__), -1);
    rb_define_method(cEntityVector.klass, "each", VALUEFUNC(_wrap_EntityVector_each), -1);
    cEntityVector.mark = 0;
    cEntityVector.destroy = (void (*)(void *)) free_std_vector_Sl_AntEntityPtr_Sg_;
    
    cResourceMap.klass = rb_define_class_under(mLibantargis, "ResourceMap", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__mapTstd__string_float_t, (void *) &cResourceMap);
    rb_include_module(cResourceMap.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cResourceMap.klass, _wrap_ResourceMap_allocate);
    rb_define_method(cResourceMap.klass, "initialize", VALUEFUNC(_wrap_new_ResourceMap), -1);
    rb_define_method(cResourceMap.klass, "length", VALUEFUNC(_wrap_ResourceMap___len__), -1);
    rb_define_method(cResourceMap.klass, "empty?", VALUEFUNC(_wrap_ResourceMap_emptyq___), -1);
    rb_define_method(cResourceMap.klass, "clear", VALUEFUNC(_wrap_ResourceMap_clear), -1);
    rb_define_method(cResourceMap.klass, "[]", VALUEFUNC(_wrap_ResourceMap___getitem__), -1);
    rb_define_method(cResourceMap.klass, "[]=", VALUEFUNC(_wrap_ResourceMap___setitem__), -1);
    rb_define_method(cResourceMap.klass, "delete", VALUEFUNC(_wrap_ResourceMap_delete), -1);
    rb_define_method(cResourceMap.klass, "has_key?", VALUEFUNC(_wrap_ResourceMap_has_keyq___), -1);
    rb_define_method(cResourceMap.klass, "keys", VALUEFUNC(_wrap_ResourceMap_keys), -1);
    rb_define_method(cResourceMap.klass, "values", VALUEFUNC(_wrap_ResourceMap_values), -1);
    rb_define_method(cResourceMap.klass, "each", VALUEFUNC(_wrap_ResourceMap_each), -1);
    cResourceMap.mark = 0;
    cResourceMap.destroy = (void (*)(void *)) free_std_map_Sl_std_string_Sc_float_Sg_;
    
    cAGNodeList.klass = rb_define_class_under(mLibantargis, "AGNodeList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTNode_t, (void *) &cAGNodeList);
    rb_include_module(cAGNodeList.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGNodeList.klass, _wrap_AGNodeList_allocate);
    rb_define_method(cAGNodeList.klass, "initialize", VALUEFUNC(_wrap_new_AGNodeList), -1);
    rb_define_method(cAGNodeList.klass, "length", VALUEFUNC(_wrap_AGNodeList___len__), -1);
    rb_define_method(cAGNodeList.klass, "empty?", VALUEFUNC(_wrap_AGNodeList_emptyq___), -1);
    rb_define_method(cAGNodeList.klass, "clear", VALUEFUNC(_wrap_AGNodeList_clear), -1);
    rb_define_method(cAGNodeList.klass, "push", VALUEFUNC(_wrap_AGNodeList_push), -1);
    rb_define_method(cAGNodeList.klass, "pop", VALUEFUNC(_wrap_AGNodeList_pop), -1);
    rb_define_method(cAGNodeList.klass, "[]", VALUEFUNC(_wrap_AGNodeList___getitem__), -1);
    rb_define_method(cAGNodeList.klass, "[]=", VALUEFUNC(_wrap_AGNodeList___setitem__), -1);
    rb_define_method(cAGNodeList.klass, "each", VALUEFUNC(_wrap_AGNodeList_each), -1);
    cAGNodeList.mark = 0;
    cAGNodeList.destroy = (void (*)(void *)) free_std_vector_Sl_Node_Sg_;
    
    cAGNodePList.klass = rb_define_class_under(mLibantargis, "AGNodePList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTNode_p_t, (void *) &cAGNodePList);
    rb_include_module(cAGNodePList.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGNodePList.klass, _wrap_AGNodePList_allocate);
    rb_define_method(cAGNodePList.klass, "initialize", VALUEFUNC(_wrap_new_AGNodePList), -1);
    rb_define_method(cAGNodePList.klass, "length", VALUEFUNC(_wrap_AGNodePList___len__), -1);
    rb_define_method(cAGNodePList.klass, "empty?", VALUEFUNC(_wrap_AGNodePList_emptyq___), -1);
    rb_define_method(cAGNodePList.klass, "clear", VALUEFUNC(_wrap_AGNodePList_clear), -1);
    rb_define_method(cAGNodePList.klass, "push", VALUEFUNC(_wrap_AGNodePList_push), -1);
    rb_define_method(cAGNodePList.klass, "pop", VALUEFUNC(_wrap_AGNodePList_pop), -1);
    rb_define_method(cAGNodePList.klass, "[]", VALUEFUNC(_wrap_AGNodePList___getitem__), -1);
    rb_define_method(cAGNodePList.klass, "[]=", VALUEFUNC(_wrap_AGNodePList___setitem__), -1);
    rb_define_method(cAGNodePList.klass, "each", VALUEFUNC(_wrap_AGNodePList_each), -1);
    cAGNodePList.mark = 0;
    cAGNodePList.destroy = (void (*)(void *)) free_std_vector_Sl_Node_Sm__Sg_;
    rb_define_module_function(mLibantargis, "general_markfunc", VALUEFUNC(_wrap_general_markfunc), -1);
    rb_define_module_function(mLibantargis, "saveDelete", VALUEFUNC(_wrap_saveDelete), -1);
    rb_define_module_function(mLibantargis, "disown_AGRubyObject", VALUEFUNC(_wrap_disown_AGRubyObject), -1);
    
    cAGRubyObject.klass = rb_define_class_under(mLibantargis, "AGRubyObject", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRubyObject, (void *) &cAGRubyObject);
    rb_define_alloc_func(cAGRubyObject.klass, _wrap_AGRubyObject_allocate);
    rb_define_method(cAGRubyObject.klass, "initialize", VALUEFUNC(_wrap_new_AGRubyObject), -1);
    cAGRubyObject.mark = (void (*)(void *)) general_markfunc;
    cAGRubyObject.destroy = (void (*)(void *)) free_AGRubyObject;
    rb_define_module_function(mLibantargis, "disown_AGEvent", VALUEFUNC(_wrap_disown_AGEvent), -1);
    
    cAGEvent.klass = rb_define_class_under(mLibantargis, "AGEvent", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGEvent, (void *) &cAGEvent);
    rb_define_alloc_func(cAGEvent.klass, _wrap_AGEvent_allocate);
    rb_define_method(cAGEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGEvent), -1);
    rb_define_method(cAGEvent.klass, "getCaller", VALUEFUNC(_wrap_AGEvent_getCaller), -1);
    rb_define_method(cAGEvent.klass, "setCaller", VALUEFUNC(_wrap_AGEvent_setCaller), -1);
    rb_define_method(cAGEvent.klass, "getName", VALUEFUNC(_wrap_AGEvent_getName), -1);
    rb_define_method(cAGEvent.klass, "getMousePosition", VALUEFUNC(_wrap_AGEvent_getMousePosition), -1);
    rb_define_method(cAGEvent.klass, "getKey", VALUEFUNC(_wrap_AGEvent_getKey), -1);
    rb_define_method(cAGEvent.klass, "getMod", VALUEFUNC(_wrap_AGEvent_getMod), -1);
    rb_define_method(cAGEvent.klass, "getButton", VALUEFUNC(_wrap_AGEvent_getButton), -1);
    rb_define_method(cAGEvent.klass, "get", VALUEFUNC(_wrap_AGEvent_get), -1);
    rb_define_method(cAGEvent.klass, "isSDLEvent", VALUEFUNC(_wrap_AGEvent_isSDLEvent), -1);
    rb_define_method(cAGEvent.klass, "setName", VALUEFUNC(_wrap_AGEvent_setName), -1);
    cAGEvent.mark = 0;
    cAGEvent.destroy = (void (*)(void *)) free_AGEvent;
    rb_define_module_function(mLibantargis, "disown_AGListener", VALUEFUNC(_wrap_disown_AGListener), -1);
    
    cAGListener.klass = rb_define_class_under(mLibantargis, "AGListener", ((swig_class *) SWIGTYPE_p_AGRubyObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGListener, (void *) &cAGListener);
    rb_define_alloc_func(cAGListener.klass, _wrap_AGListener_allocate);
    rb_define_method(cAGListener.klass, "initialize", VALUEFUNC(_wrap_new_AGListener), -1);
    rb_define_method(cAGListener.klass, "signal", VALUEFUNC(_wrap_AGListener_signal), -1);
    cAGListener.mark = (void (*)(void *)) general_markfunc;
    cAGListener.destroy = (void (*)(void *)) free_AGListener;
    rb_define_module_function(mLibantargis, "disown_AGCPPListener", VALUEFUNC(_wrap_disown_AGCPPListener), -1);
    
    cAGCPPListener.klass = rb_define_class_under(mLibantargis, "AGCPPListener", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCPPListener, (void *) &cAGCPPListener);
    rb_define_alloc_func(cAGCPPListener.klass, _wrap_AGCPPListener_allocate);
    rb_define_method(cAGCPPListener.klass, "initialize", VALUEFUNC(_wrap_new_AGCPPListener), -1);
    rb_define_method(cAGCPPListener.klass, "signal", VALUEFUNC(_wrap_AGCPPListener_signal), -1);
    cAGCPPListener.mark = 0;
    cAGCPPListener.destroy = (void (*)(void *)) free_AGCPPListener;
    rb_define_module_function(mLibantargis, "disown_AGSignal", VALUEFUNC(_wrap_disown_AGSignal), -1);
    
    cAGSignal.klass = rb_define_class_under(mLibantargis, "AGSignal", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGSignal, (void *) &cAGSignal);
    rb_define_alloc_func(cAGSignal.klass, _wrap_AGSignal_allocate);
    rb_define_method(cAGSignal.klass, "initialize", VALUEFUNC(_wrap_new_AGSignal), -1);
    rb_define_method(cAGSignal.klass, "connect", VALUEFUNC(_wrap_AGSignal_connect), -1);
    rb_define_method(cAGSignal.klass, "disconnect", VALUEFUNC(_wrap_AGSignal_disconnect), -1);
    rb_define_method(cAGSignal.klass, "signal", VALUEFUNC(_wrap_AGSignal_signal), -1);
    rb_define_method(cAGSignal.klass, "call", VALUEFUNC(_wrap_AGSignal___call__), -1);
    cAGSignal.mark = 0;
    cAGSignal.destroy = (void (*)(void *)) free_AGSignal;
    rb_define_module_function(mLibantargis, "disown_AGMessageObject", VALUEFUNC(_wrap_disown_AGMessageObject), -1);
    
    cAGMessageObject.klass = rb_define_class_under(mLibantargis, "AGMessageObject", ((swig_class *) SWIGTYPE_p_AGListener->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMessageObject, (void *) &cAGMessageObject);
    rb_define_alloc_func(cAGMessageObject.klass, _wrap_AGMessageObject_allocate);
    rb_define_method(cAGMessageObject.klass, "initialize", VALUEFUNC(_wrap_new_AGMessageObject), -1);
    rb_define_method(cAGMessageObject.klass, "processEvent", VALUEFUNC(_wrap_AGMessageObject_processEvent), -1);
    rb_define_method(cAGMessageObject.klass, "acceptEvent", VALUEFUNC(_wrap_AGMessageObject_acceptEvent), -1);
    rb_define_method(cAGMessageObject.klass, "eventActive", VALUEFUNC(_wrap_AGMessageObject_eventActive), -1);
    rb_define_method(cAGMessageObject.klass, "eventKeyDown", VALUEFUNC(_wrap_AGMessageObject_eventKeyDown), -1);
    rb_define_method(cAGMessageObject.klass, "eventKeyUp", VALUEFUNC(_wrap_AGMessageObject_eventKeyUp), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseMotion", VALUEFUNC(_wrap_AGMessageObject_eventMouseMotion), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGMessageObject_eventMouseButtonDown), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGMessageObject_eventMouseButtonUp), -1);
    rb_define_method(cAGMessageObject.klass, "eventQuit", VALUEFUNC(_wrap_AGMessageObject_eventQuit), -1);
    rb_define_method(cAGMessageObject.klass, "eventQuitModal", VALUEFUNC(_wrap_AGMessageObject_eventQuitModal), -1);
    rb_define_method(cAGMessageObject.klass, "eventSysWM", VALUEFUNC(_wrap_AGMessageObject_eventSysWM), -1);
    rb_define_method(cAGMessageObject.klass, "eventResize", VALUEFUNC(_wrap_AGMessageObject_eventResize), -1);
    rb_define_method(cAGMessageObject.klass, "getButtonState", VALUEFUNC(_wrap_AGMessageObject_getButtonState), -1);
    rb_define_method(cAGMessageObject.klass, "getMousePosition", VALUEFUNC(_wrap_AGMessageObject_getMousePosition), -1);
    rb_define_method(cAGMessageObject.klass, "sigActive=", VALUEFUNC(_wrap_AGMessageObject_sigActive_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigActive", VALUEFUNC(_wrap_AGMessageObject_sigActive_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyDown=", VALUEFUNC(_wrap_AGMessageObject_sigKeyDown_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyDown", VALUEFUNC(_wrap_AGMessageObject_sigKeyDown_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyUp=", VALUEFUNC(_wrap_AGMessageObject_sigKeyUp_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyUp", VALUEFUNC(_wrap_AGMessageObject_sigKeyUp_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseMotion=", VALUEFUNC(_wrap_AGMessageObject_sigMouseMotion_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseMotion", VALUEFUNC(_wrap_AGMessageObject_sigMouseMotion_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonDown=", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonDown_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonDown", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonDown_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonUp=", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonUp_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonUp", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonUp_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigQuit=", VALUEFUNC(_wrap_AGMessageObject_sigQuit_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigQuit", VALUEFUNC(_wrap_AGMessageObject_sigQuit_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigSysWM=", VALUEFUNC(_wrap_AGMessageObject_sigSysWM_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigSysWM", VALUEFUNC(_wrap_AGMessageObject_sigSysWM_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigVideoResize=", VALUEFUNC(_wrap_AGMessageObject_sigVideoResize_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigVideoResize", VALUEFUNC(_wrap_AGMessageObject_sigVideoResize_get), -1);
    rb_define_method(cAGMessageObject.klass, "pushSignal", VALUEFUNC(_wrap_AGMessageObject_pushSignal), -1);
    rb_define_method(cAGMessageObject.klass, "popSignal", VALUEFUNC(_wrap_AGMessageObject_popSignal), -1);
    cAGMessageObject.mark = (void (*)(void *)) general_markfunc;
    cAGMessageObject.destroy = (void (*)(void *)) free_AGMessageObject;
    rb_define_module_function(mLibantargis, "newEvent", VALUEFUNC(_wrap_newEvent), -1);
    
    cAGAngle.klass = rb_define_class_under(mLibantargis, "AGAngle", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGAngle, (void *) &cAGAngle);
    rb_define_alloc_func(cAGAngle.klass, _wrap_AGAngle_allocate);
    rb_define_method(cAGAngle.klass, "initialize", VALUEFUNC(_wrap_new_AGAngle), -1);
    rb_define_method(cAGAngle.klass, "angle=", VALUEFUNC(_wrap_AGAngle_angle_set), -1);
    rb_define_method(cAGAngle.klass, "angle", VALUEFUNC(_wrap_AGAngle_angle_get), -1);
    cAGAngle.mark = 0;
    cAGAngle.destroy = (void (*)(void *)) free_AGAngle;
    
    cAGVector2.klass = rb_define_class_under(mLibantargis, "AGVector2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector2, (void *) &cAGVector2);
    rb_define_alloc_func(cAGVector2.klass, _wrap_AGVector2_allocate);
    rb_define_method(cAGVector2.klass, "initialize", VALUEFUNC(_wrap_new_AGVector2), -1);
    rb_define_method(cAGVector2.klass, "v=", VALUEFUNC(_wrap_AGVector2_v_set), -1);
    rb_define_method(cAGVector2.klass, "v", VALUEFUNC(_wrap_AGVector2_v_get), -1);
    rb_define_method(cAGVector2.klass, "setX", VALUEFUNC(_wrap_AGVector2_setX), -1);
    rb_define_method(cAGVector2.klass, "setY", VALUEFUNC(_wrap_AGVector2_setY), -1);
    rb_define_method(cAGVector2.klass, "x", VALUEFUNC(_wrap_AGVector2_x), -1);
    rb_define_method(cAGVector2.klass, "y", VALUEFUNC(_wrap_AGVector2_y), -1);
    rb_define_method(cAGVector2.klass, "getAngle", VALUEFUNC(_wrap_AGVector2_getAngle), -1);
    rb_define_method(cAGVector2.klass, "-", VALUEFUNC(_wrap_AGVector2___sub__), -1);
    rb_define_method(cAGVector2.klass, "+", VALUEFUNC(_wrap_AGVector2___add__), -1);
    rb_define_method(cAGVector2.klass, "*", VALUEFUNC(_wrap_AGVector2___mul__), -1);
    rb_define_method(cAGVector2.klass, "/", VALUEFUNC(_wrap_AGVector2___div__), -1);
    rb_define_method(cAGVector2.klass, "==", VALUEFUNC(_wrap_AGVector2___eq__), -1);
    rb_define_method(cAGVector2.klass, "length", VALUEFUNC(_wrap_AGVector2_length), -1);
    rb_define_method(cAGVector2.klass, "length2", VALUEFUNC(_wrap_AGVector2_length2), -1);
    rb_define_method(cAGVector2.klass, "normalized", VALUEFUNC(_wrap_AGVector2_normalized), -1);
    rb_define_method(cAGVector2.klass, "normalize", VALUEFUNC(_wrap_AGVector2_normalize), -1);
    rb_define_method(cAGVector2.klass, "normal", VALUEFUNC(_wrap_AGVector2_normal), -1);
    rb_define_method(cAGVector2.klass, "[]", VALUEFUNC(_wrap_AGVector2___getitem__), -1);
    rb_define_method(cAGVector2.klass, "nonZero", VALUEFUNC(_wrap_AGVector2_nonZero), -1);
    rb_define_method(cAGVector2.klass, "saveXML", VALUEFUNC(_wrap_AGVector2_saveXML), -1);
    rb_define_method(cAGVector2.klass, "loadXML", VALUEFUNC(_wrap_AGVector2_loadXML), -1);
    rb_define_method(cAGVector2.klass, "to_s", VALUEFUNC(_wrap_AGVector2_to_s), -1);
    cAGVector2.mark = 0;
    cAGVector2.destroy = (void (*)(void *)) free_AGVector2;
    
    cAGVector3.klass = rb_define_class_under(mLibantargis, "AGVector3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector3, (void *) &cAGVector3);
    rb_define_alloc_func(cAGVector3.klass, _wrap_AGVector3_allocate);
    rb_define_method(cAGVector3.klass, "initialize", VALUEFUNC(_wrap_new_AGVector3), -1);
    rb_define_method(cAGVector3.klass, "v=", VALUEFUNC(_wrap_AGVector3_v_set), -1);
    rb_define_method(cAGVector3.klass, "v", VALUEFUNC(_wrap_AGVector3_v_get), -1);
    rb_define_method(cAGVector3.klass, "setX", VALUEFUNC(_wrap_AGVector3_setX), -1);
    rb_define_method(cAGVector3.klass, "setY", VALUEFUNC(_wrap_AGVector3_setY), -1);
    rb_define_method(cAGVector3.klass, "setZ", VALUEFUNC(_wrap_AGVector3_setZ), -1);
    rb_define_method(cAGVector3.klass, "x", VALUEFUNC(_wrap_AGVector3_x), -1);
    rb_define_method(cAGVector3.klass, "y", VALUEFUNC(_wrap_AGVector3_y), -1);
    rb_define_method(cAGVector3.klass, "z", VALUEFUNC(_wrap_AGVector3_z), -1);
    rb_define_method(cAGVector3.klass, "getAngle", VALUEFUNC(_wrap_AGVector3_getAngle), -1);
    rb_define_method(cAGVector3.klass, "-@", VALUEFUNC(_wrap_AGVector3___neg__), -1);
    rb_define_method(cAGVector3.klass, "-", VALUEFUNC(_wrap_AGVector3___sub__), -1);
    rb_define_method(cAGVector3.klass, "+", VALUEFUNC(_wrap_AGVector3___add__), -1);
    rb_define_method(cAGVector3.klass, "add", VALUEFUNC(_wrap_AGVector3_add), -1);
    rb_define_method(cAGVector3.klass, "sub", VALUEFUNC(_wrap_AGVector3_sub), -1);
    rb_define_method(cAGVector3.klass, "*", VALUEFUNC(_wrap_AGVector3___mul__), -1);
    rb_define_method(cAGVector3.klass, "/", VALUEFUNC(_wrap_AGVector3___div__), -1);
    rb_define_method(cAGVector3.klass, "%", VALUEFUNC(_wrap_AGVector3___mod__), -1);
    rb_define_method(cAGVector3.klass, "==", VALUEFUNC(_wrap_AGVector3___eq__), -1);
    rb_define_method(cAGVector3.klass, "length", VALUEFUNC(_wrap_AGVector3_length), -1);
    rb_define_method(cAGVector3.klass, "length2", VALUEFUNC(_wrap_AGVector3_length2), -1);
    rb_define_method(cAGVector3.klass, "normalized", VALUEFUNC(_wrap_AGVector3_normalized), -1);
    rb_define_method(cAGVector3.klass, "normalize", VALUEFUNC(_wrap_AGVector3_normalize), -1);
    rb_define_method(cAGVector3.klass, "normal", VALUEFUNC(_wrap_AGVector3_normal), -1);
    rb_define_method(cAGVector3.klass, "nonZero", VALUEFUNC(_wrap_AGVector3_nonZero), -1);
    rb_define_method(cAGVector3.klass, "saveXML", VALUEFUNC(_wrap_AGVector3_saveXML), -1);
    rb_define_method(cAGVector3.klass, "loadXML", VALUEFUNC(_wrap_AGVector3_loadXML), -1);
    rb_define_method(cAGVector3.klass, "dim2", VALUEFUNC(_wrap_AGVector3_dim2), -1);
    rb_define_method(cAGVector3.klass, "to_s", VALUEFUNC(_wrap_AGVector3_to_s), -1);
    cAGVector3.mark = 0;
    cAGVector3.destroy = (void (*)(void *)) free_AGVector3;
    
    cAGMatrix3.klass = rb_define_class_under(mLibantargis, "AGMatrix3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMatrix3, (void *) &cAGMatrix3);
    rb_define_alloc_func(cAGMatrix3.klass, _wrap_AGMatrix3_allocate);
    rb_define_method(cAGMatrix3.klass, "initialize", VALUEFUNC(_wrap_new_AGMatrix3), -1);
    rb_define_method(cAGMatrix3.klass, "set", VALUEFUNC(_wrap_AGMatrix3_set), -1);
    rb_define_method(cAGMatrix3.klass, "get", VALUEFUNC(_wrap_AGMatrix3_get), -1);
    rb_define_method(cAGMatrix3.klass, "*", VALUEFUNC(_wrap_AGMatrix3___mul__), -1);
    rb_define_method(cAGMatrix3.klass, "-@", VALUEFUNC(_wrap_AGMatrix3___neg__), -1);
    rb_define_method(cAGMatrix3.klass, "inverted", VALUEFUNC(_wrap_AGMatrix3_inverted), -1);
    rb_define_method(cAGMatrix3.klass, "transposed", VALUEFUNC(_wrap_AGMatrix3_transposed), -1);
    rb_define_method(cAGMatrix3.klass, "to_s", VALUEFUNC(_wrap_AGMatrix3_to_s), -1);
    cAGMatrix3.mark = 0;
    cAGMatrix3.destroy = (void (*)(void *)) free_AGMatrix3;
    
    cAGLine2.klass = rb_define_class_under(mLibantargis, "AGLine2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLine2, (void *) &cAGLine2);
    rb_define_alloc_func(cAGLine2.klass, _wrap_AGLine2_allocate);
    rb_define_method(cAGLine2.klass, "initialize", VALUEFUNC(_wrap_new_AGLine2), -1);
    rb_define_method(cAGLine2.klass, "getV0", VALUEFUNC(_wrap_AGLine2_getV0), -1);
    rb_define_method(cAGLine2.klass, "getV1", VALUEFUNC(_wrap_AGLine2_getV1), -1);
    rb_define_method(cAGLine2.klass, "has", VALUEFUNC(_wrap_AGLine2_has), -1);
    rb_define_method(cAGLine2.klass, "collide", VALUEFUNC(_wrap_AGLine2_collide), -1);
    rb_define_method(cAGLine2.klass, "collisionPoint", VALUEFUNC(_wrap_AGLine2_collisionPoint), -1);
    rb_define_method(cAGLine2.klass, "collisionPointNI", VALUEFUNC(_wrap_AGLine2_collisionPointNI), -1);
    rb_define_method(cAGLine2.klass, "includes", VALUEFUNC(_wrap_AGLine2_includes), -1);
    rb_define_method(cAGLine2.klass, "getBBox", VALUEFUNC(_wrap_AGLine2_getBBox), -1);
    rb_define_method(cAGLine2.klass, "normal", VALUEFUNC(_wrap_AGLine2_normal), -1);
    rb_define_method(cAGLine2.klass, "direction", VALUEFUNC(_wrap_AGLine2_direction), -1);
    rb_define_method(cAGLine2.klass, "distance", VALUEFUNC(_wrap_AGLine2_distance), -1);
    rb_define_method(cAGLine2.klass, "to_s", VALUEFUNC(_wrap_AGLine2_to_s), -1);
    cAGLine2.mark = 0;
    cAGLine2.destroy = (void (*)(void *)) free_AGLine2;
    
    cAGLine3.klass = rb_define_class_under(mLibantargis, "AGLine3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLine3, (void *) &cAGLine3);
    rb_define_alloc_func(cAGLine3.klass, _wrap_AGLine3_allocate);
    rb_define_method(cAGLine3.klass, "initialize", VALUEFUNC(_wrap_new_AGLine3), -1);
    rb_define_method(cAGLine3.klass, "getV0", VALUEFUNC(_wrap_AGLine3_getV0), -1);
    rb_define_method(cAGLine3.klass, "getV1", VALUEFUNC(_wrap_AGLine3_getV1), -1);
    rb_define_method(cAGLine3.klass, "has", VALUEFUNC(_wrap_AGLine3_has), -1);
    rb_define_method(cAGLine3.klass, "direction", VALUEFUNC(_wrap_AGLine3_direction), -1);
    rb_define_method(cAGLine3.klass, "distance", VALUEFUNC(_wrap_AGLine3_distance), -1);
    rb_define_method(cAGLine3.klass, "to_s", VALUEFUNC(_wrap_AGLine3_to_s), -1);
    cAGLine3.mark = 0;
    cAGLine3.destroy = (void (*)(void *)) free_AGLine3;
    
    cAGCollisionData.klass = rb_define_class_under(mLibantargis, "AGCollisionData", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCollisionData, (void *) &cAGCollisionData);
    rb_define_alloc_func(cAGCollisionData.klass, _wrap_AGCollisionData_allocate);
    rb_define_method(cAGCollisionData.klass, "initialize", VALUEFUNC(_wrap_new_AGCollisionData), -1);
    cAGCollisionData.mark = 0;
    cAGCollisionData.destroy = (void (*)(void *)) free_AGCollisionData;
    
    cAGTriangle2.klass = rb_define_class_under(mLibantargis, "AGTriangle2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTriangle2, (void *) &cAGTriangle2);
    rb_define_alloc_func(cAGTriangle2.klass, _wrap_AGTriangle2_allocate);
    rb_define_method(cAGTriangle2.klass, "initialize", VALUEFUNC(_wrap_new_AGTriangle2), -1);
    rb_define_method(cAGTriangle2.klass, "get", VALUEFUNC(_wrap_AGTriangle2_get), -1);
    rb_define_method(cAGTriangle2.klass, "collide", VALUEFUNC(_wrap_AGTriangle2_collide), -1);
    rb_define_method(cAGTriangle2.klass, "getNormals", VALUEFUNC(_wrap_AGTriangle2_getNormals), -1);
    rb_define_method(cAGTriangle2.klass, "apply", VALUEFUNC(_wrap_AGTriangle2_apply), -1);
    rb_define_method(cAGTriangle2.klass, "applied", VALUEFUNC(_wrap_AGTriangle2_applied), -1);
    rb_define_method(cAGTriangle2.klass, "touchPoint", VALUEFUNC(_wrap_AGTriangle2_touchPoint), -1);
    rb_define_method(cAGTriangle2.klass, "touchVector", VALUEFUNC(_wrap_AGTriangle2_touchVector), -1);
    rb_define_method(cAGTriangle2.klass, "collisionPoints", VALUEFUNC(_wrap_AGTriangle2_collisionPoints), -1);
    rb_define_method(cAGTriangle2.klass, "contains", VALUEFUNC(_wrap_AGTriangle2_contains), -1);
    rb_define_method(cAGTriangle2.klass, "getBBox", VALUEFUNC(_wrap_AGTriangle2_getBBox), -1);
    rb_define_method(cAGTriangle2.klass, "nearestLine", VALUEFUNC(_wrap_AGTriangle2_nearestLine), -1);
    rb_define_method(cAGTriangle2.klass, "getLines", VALUEFUNC(_wrap_AGTriangle2_getLines), -1);
    rb_define_method(cAGTriangle2.klass, "to_s", VALUEFUNC(_wrap_AGTriangle2_to_s), -1);
    cAGTriangle2.mark = 0;
    cAGTriangle2.destroy = (void (*)(void *)) free_AGTriangle2;
    
    cAGCircle2.klass = rb_define_class_under(mLibantargis, "AGCircle2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCircle2, (void *) &cAGCircle2);
    rb_define_alloc_func(cAGCircle2.klass, _wrap_AGCircle2_allocate);
    rb_define_method(cAGCircle2.klass, "initialize", VALUEFUNC(_wrap_new_AGCircle2), -1);
    rb_define_method(cAGCircle2.klass, "inCircle", VALUEFUNC(_wrap_AGCircle2_inCircle), -1);
    rb_define_method(cAGCircle2.klass, "outCircle", VALUEFUNC(_wrap_AGCircle2_outCircle), -1);
    rb_define_method(cAGCircle2.klass, "getPos", VALUEFUNC(_wrap_AGCircle2_getPos), -1);
    rb_define_method(cAGCircle2.klass, "getRadius", VALUEFUNC(_wrap_AGCircle2_getRadius), -1);
    cAGCircle2.mark = 0;
    cAGCircle2.destroy = (void (*)(void *)) free_AGCircle2;
    
    cAGTriangle3.klass = rb_define_class_under(mLibantargis, "AGTriangle3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTriangle3, (void *) &cAGTriangle3);
    rb_define_alloc_func(cAGTriangle3.klass, _wrap_AGTriangle3_allocate);
    rb_define_method(cAGTriangle3.klass, "initialize", VALUEFUNC(_wrap_new_AGTriangle3), -1);
    rb_define_method(cAGTriangle3.klass, "collide", VALUEFUNC(_wrap_AGTriangle3_collide), -1);
    rb_define_method(cAGTriangle3.klass, "toString", VALUEFUNC(_wrap_AGTriangle3_toString), -1);
    cAGTriangle3.mark = 0;
    cAGTriangle3.destroy = (void (*)(void *)) free_AGTriangle3;
    
    cAGRect2.klass = rb_define_class_under(mLibantargis, "AGRect2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect2, (void *) &cAGRect2);
    rb_define_alloc_func(cAGRect2.klass, _wrap_AGRect2_allocate);
    rb_define_method(cAGRect2.klass, "initialize", VALUEFUNC(_wrap_new_AGRect2), -1);
    rb_define_method(cAGRect2.klass, "collide", VALUEFUNC(_wrap_AGRect2_collide), -1);
    rb_define_method(cAGRect2.klass, "include", VALUEFUNC(_wrap_AGRect2_include), -1);
    rb_define_method(cAGRect2.klass, "+", VALUEFUNC(_wrap_AGRect2___add__), -1);
    rb_define_method(cAGRect2.klass, "contains", VALUEFUNC(_wrap_AGRect2_contains), -1);
    rb_define_method(cAGRect2.klass, "split", VALUEFUNC(_wrap_AGRect2_split), -1);
    rb_define_method(cAGRect2.klass, "getV0", VALUEFUNC(_wrap_AGRect2_getV0), -1);
    rb_define_method(cAGRect2.klass, "getV1", VALUEFUNC(_wrap_AGRect2_getV1), -1);
    rb_define_method(cAGRect2.klass, "getV01", VALUEFUNC(_wrap_AGRect2_getV01), -1);
    rb_define_method(cAGRect2.klass, "getV10", VALUEFUNC(_wrap_AGRect2_getV10), -1);
    rb_define_method(cAGRect2.klass, "shrink", VALUEFUNC(_wrap_AGRect2_shrink), -1);
    rb_define_method(cAGRect2.klass, "grow", VALUEFUNC(_wrap_AGRect2_grow), -1);
    rb_define_method(cAGRect2.klass, "setX", VALUEFUNC(_wrap_AGRect2_setX), -1);
    rb_define_method(cAGRect2.klass, "setY", VALUEFUNC(_wrap_AGRect2_setY), -1);
    rb_define_method(cAGRect2.klass, "setLeft", VALUEFUNC(_wrap_AGRect2_setLeft), -1);
    rb_define_method(cAGRect2.klass, "setTop", VALUEFUNC(_wrap_AGRect2_setTop), -1);
    rb_define_method(cAGRect2.klass, "setRight", VALUEFUNC(_wrap_AGRect2_setRight), -1);
    rb_define_method(cAGRect2.klass, "setBottom", VALUEFUNC(_wrap_AGRect2_setBottom), -1);
    rb_define_method(cAGRect2.klass, "setWidth", VALUEFUNC(_wrap_AGRect2_setWidth), -1);
    rb_define_method(cAGRect2.klass, "setHeight", VALUEFUNC(_wrap_AGRect2_setHeight), -1);
    rb_define_method(cAGRect2.klass, "x", VALUEFUNC(_wrap_AGRect2_x), -1);
    rb_define_method(cAGRect2.klass, "y", VALUEFUNC(_wrap_AGRect2_y), -1);
    rb_define_method(cAGRect2.klass, "w", VALUEFUNC(_wrap_AGRect2_w), -1);
    rb_define_method(cAGRect2.klass, "h", VALUEFUNC(_wrap_AGRect2_h), -1);
    rb_define_method(cAGRect2.klass, "width", VALUEFUNC(_wrap_AGRect2_width), -1);
    rb_define_method(cAGRect2.klass, "height", VALUEFUNC(_wrap_AGRect2_height), -1);
    rb_define_method(cAGRect2.klass, "x0", VALUEFUNC(_wrap_AGRect2_x0), -1);
    rb_define_method(cAGRect2.klass, "y0", VALUEFUNC(_wrap_AGRect2_y0), -1);
    rb_define_method(cAGRect2.klass, "x1", VALUEFUNC(_wrap_AGRect2_x1), -1);
    rb_define_method(cAGRect2.klass, "y1", VALUEFUNC(_wrap_AGRect2_y1), -1);
    rb_define_method(cAGRect2.klass, "origin", VALUEFUNC(_wrap_AGRect2_origin), -1);
    rb_define_method(cAGRect2.klass, "intersect", VALUEFUNC(_wrap_AGRect2_intersect), -1);
    rb_define_method(cAGRect2.klass, "sdl", VALUEFUNC(_wrap_AGRect2_sdl), -1);
    rb_define_method(cAGRect2.klass, "==", VALUEFUNC(_wrap_AGRect2___eq__), -1);
    rb_define_method(cAGRect2.klass, "check", VALUEFUNC(_wrap_AGRect2_check), -1);
    rb_define_method(cAGRect2.klass, "alignGrid", VALUEFUNC(_wrap_AGRect2_alignGrid), -1);
    rb_define_method(cAGRect2.klass, "to_s", VALUEFUNC(_wrap_AGRect2_to_s), -1);
    cAGRect2.mark = 0;
    cAGRect2.destroy = (void (*)(void *)) free_AGRect2;
    
    cAGVector4.klass = rb_define_class_under(mLibantargis, "AGVector4", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector4, (void *) &cAGVector4);
    rb_define_alloc_func(cAGVector4.klass, _wrap_AGVector4_allocate);
    rb_define_method(cAGVector4.klass, "initialize", VALUEFUNC(_wrap_new_AGVector4), -1);
    rb_define_method(cAGVector4.klass, "v=", VALUEFUNC(_wrap_AGVector4_v_set), -1);
    rb_define_method(cAGVector4.klass, "v", VALUEFUNC(_wrap_AGVector4_v_get), -1);
    rb_define_method(cAGVector4.klass, "setX", VALUEFUNC(_wrap_AGVector4_setX), -1);
    rb_define_method(cAGVector4.klass, "setY", VALUEFUNC(_wrap_AGVector4_setY), -1);
    rb_define_method(cAGVector4.klass, "setZ", VALUEFUNC(_wrap_AGVector4_setZ), -1);
    rb_define_method(cAGVector4.klass, "setW", VALUEFUNC(_wrap_AGVector4_setW), -1);
    rb_define_method(cAGVector4.klass, "x", VALUEFUNC(_wrap_AGVector4_x), -1);
    rb_define_method(cAGVector4.klass, "y", VALUEFUNC(_wrap_AGVector4_y), -1);
    rb_define_method(cAGVector4.klass, "z", VALUEFUNC(_wrap_AGVector4_z), -1);
    rb_define_method(cAGVector4.klass, "w", VALUEFUNC(_wrap_AGVector4_w), -1);
    rb_define_method(cAGVector4.klass, "-", VALUEFUNC(_wrap_AGVector4___sub__), -1);
    rb_define_method(cAGVector4.klass, "+", VALUEFUNC(_wrap_AGVector4___add__), -1);
    rb_define_method(cAGVector4.klass, "add", VALUEFUNC(_wrap_AGVector4_add), -1);
    rb_define_method(cAGVector4.klass, "sub", VALUEFUNC(_wrap_AGVector4_sub), -1);
    rb_define_method(cAGVector4.klass, "*", VALUEFUNC(_wrap_AGVector4___mul__), -1);
    rb_define_method(cAGVector4.klass, "/", VALUEFUNC(_wrap_AGVector4___div__), -1);
    rb_define_method(cAGVector4.klass, "-@", VALUEFUNC(_wrap_AGVector4___neg__), -1);
    rb_define_method(cAGVector4.klass, "==", VALUEFUNC(_wrap_AGVector4___eq__), -1);
    rb_define_method(cAGVector4.klass, "length", VALUEFUNC(_wrap_AGVector4_length), -1);
    rb_define_method(cAGVector4.klass, "length2", VALUEFUNC(_wrap_AGVector4_length2), -1);
    rb_define_method(cAGVector4.klass, "length3", VALUEFUNC(_wrap_AGVector4_length3), -1);
    rb_define_method(cAGVector4.klass, "normalized", VALUEFUNC(_wrap_AGVector4_normalized), -1);
    rb_define_method(cAGVector4.klass, "normalize", VALUEFUNC(_wrap_AGVector4_normalize), -1);
    rb_define_method(cAGVector4.klass, "normalized3", VALUEFUNC(_wrap_AGVector4_normalized3), -1);
    rb_define_method(cAGVector4.klass, "normalize3", VALUEFUNC(_wrap_AGVector4_normalize3), -1);
    rb_define_method(cAGVector4.klass, "nonZero", VALUEFUNC(_wrap_AGVector4_nonZero), -1);
    rb_define_method(cAGVector4.klass, "%", VALUEFUNC(_wrap_AGVector4___mod__), -1);
    rb_define_method(cAGVector4.klass, "cross", VALUEFUNC(_wrap_AGVector4_cross), -1);
    rb_define_method(cAGVector4.klass, "dim3", VALUEFUNC(_wrap_AGVector4_dim3), -1);
    rb_define_method(cAGVector4.klass, "dim2", VALUEFUNC(_wrap_AGVector4_dim2), -1);
    rb_define_method(cAGVector4.klass, "to_s", VALUEFUNC(_wrap_AGVector4_to_s), -1);
    cAGVector4.mark = 0;
    cAGVector4.destroy = (void (*)(void *)) free_AGVector4;
    
    cAGMatrix4.klass = rb_define_class_under(mLibantargis, "AGMatrix4", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMatrix4, (void *) &cAGMatrix4);
    rb_define_alloc_func(cAGMatrix4.klass, _wrap_AGMatrix4_allocate);
    rb_define_method(cAGMatrix4.klass, "initialize", VALUEFUNC(_wrap_new_AGMatrix4), -1);
    rb_define_method(cAGMatrix4.klass, "set", VALUEFUNC(_wrap_AGMatrix4_set), -1);
    rb_define_method(cAGMatrix4.klass, "get", VALUEFUNC(_wrap_AGMatrix4_get), -1);
    rb_define_method(cAGMatrix4.klass, "get3x3", VALUEFUNC(_wrap_AGMatrix4_get3x3), -1);
    rb_define_method(cAGMatrix4.klass, "*", VALUEFUNC(_wrap_AGMatrix4___mul__), -1);
    rb_define_method(cAGMatrix4.klass, "call", VALUEFUNC(_wrap_AGMatrix4___call__), -1);
    rb_define_method(cAGMatrix4.klass, "inverted", VALUEFUNC(_wrap_AGMatrix4_inverted), -1);
    rb_define_method(cAGMatrix4.klass, "transposed", VALUEFUNC(_wrap_AGMatrix4_transposed), -1);
    rb_define_method(cAGMatrix4.klass, "to_s", VALUEFUNC(_wrap_AGMatrix4_to_s), -1);
    rb_define_method(cAGMatrix4.klass, "getRow", VALUEFUNC(_wrap_AGMatrix4_getRow), -1);
    cAGMatrix4.mark = 0;
    cAGMatrix4.destroy = (void (*)(void *)) free_AGMatrix4;
    
    cAGRect3.klass = rb_define_class_under(mLibantargis, "AGRect3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect3, (void *) &cAGRect3);
    rb_define_alloc_func(cAGRect3.klass, _wrap_AGRect3_allocate);
    rb_define_method(cAGRect3.klass, "initialize", VALUEFUNC(_wrap_new_AGRect3), -1);
    rb_define_method(cAGRect3.klass, "collides", VALUEFUNC(_wrap_AGRect3_collides), -1);
    rb_define_method(cAGRect3.klass, "toString", VALUEFUNC(_wrap_AGRect3_toString), -1);
    cAGRect3.mark = 0;
    cAGRect3.destroy = (void (*)(void *)) free_AGRect3;
    
    cAGBox3.klass = rb_define_class_under(mLibantargis, "AGBox3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBox3, (void *) &cAGBox3);
    rb_define_alloc_func(cAGBox3.klass, _wrap_AGBox3_allocate);
    rb_define_method(cAGBox3.klass, "initialize", VALUEFUNC(_wrap_new_AGBox3), -1);
    rb_define_method(cAGBox3.klass, "base=", VALUEFUNC(_wrap_AGBox3_base_set), -1);
    rb_define_method(cAGBox3.klass, "base", VALUEFUNC(_wrap_AGBox3_base_get), -1);
    rb_define_method(cAGBox3.klass, "dir=", VALUEFUNC(_wrap_AGBox3_dir_set), -1);
    rb_define_method(cAGBox3.klass, "dir", VALUEFUNC(_wrap_AGBox3_dir_get), -1);
    rb_define_method(cAGBox3.klass, "include", VALUEFUNC(_wrap_AGBox3_include), -1);
    rb_define_method(cAGBox3.klass, "includes", VALUEFUNC(_wrap_AGBox3_includes), -1);
    rb_define_method(cAGBox3.klass, "getSides", VALUEFUNC(_wrap_AGBox3_getSides), -1);
    rb_define_method(cAGBox3.klass, "toString", VALUEFUNC(_wrap_AGBox3_toString), -1);
    rb_define_method(cAGBox3.klass, "split", VALUEFUNC(_wrap_AGBox3_split), -1);
    rb_define_method(cAGBox3.klass, "collides", VALUEFUNC(_wrap_AGBox3_collides), -1);
    rb_define_method(cAGBox3.klass, "getVertices", VALUEFUNC(_wrap_AGBox3_getVertices), -1);
    rb_define_method(cAGBox3.klass, "+", VALUEFUNC(_wrap_AGBox3___add__), -1);
    rb_define_method(cAGBox3.klass, "-", VALUEFUNC(_wrap_AGBox3___sub__), -1);
    rb_define_method(cAGBox3.klass, "valid", VALUEFUNC(_wrap_AGBox3_valid), -1);
    cAGBox3.mark = 0;
    cAGBox3.destroy = (void (*)(void *)) free_AGBox3;
    
    cAGFont.klass = rb_define_class_under(mLibantargis, "AGFont", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGFont, (void *) &cAGFont);
    rb_define_alloc_func(cAGFont.klass, _wrap_AGFont_allocate);
    rb_define_method(cAGFont.klass, "initialize", VALUEFUNC(_wrap_new_AGFont), -1);
    rb_define_const(cAGFont.klass,"NORMAL", INT2NUM(AGFont::NORMAL));
    rb_define_const(cAGFont.klass,"BOLD", INT2NUM(AGFont::BOLD));
    rb_define_const(cAGFont.klass,"UNDERLINE", INT2NUM(AGFont::UNDERLINE));
    rb_define_const(cAGFont.klass,"ITALIC", INT2NUM(AGFont::ITALIC));
    rb_define_method(cAGFont.klass, "setColor", VALUEFUNC(_wrap_AGFont_setColor), -1);
    rb_define_method(cAGFont.klass, "getColor", VALUEFUNC(_wrap_AGFont_getColor), -1);
    rb_define_method(cAGFont.klass, "setBorderColor", VALUEFUNC(_wrap_AGFont_setBorderColor), -1);
    rb_define_method(cAGFont.klass, "getBorderColor", VALUEFUNC(_wrap_AGFont_getBorderColor), -1);
    rb_define_method(cAGFont.klass, "setBorder", VALUEFUNC(_wrap_AGFont_setBorder), -1);
    rb_define_method(cAGFont.klass, "getBorder", VALUEFUNC(_wrap_AGFont_getBorder), -1);
    rb_define_method(cAGFont.klass, "setAlpha", VALUEFUNC(_wrap_AGFont_setAlpha), -1);
    rb_define_method(cAGFont.klass, "getAlpha", VALUEFUNC(_wrap_AGFont_getAlpha), -1);
    rb_define_method(cAGFont.klass, "setSize", VALUEFUNC(_wrap_AGFont_setSize), -1);
    rb_define_method(cAGFont.klass, "getSize", VALUEFUNC(_wrap_AGFont_getSize), -1);
    rb_define_method(cAGFont.klass, "setStyle", VALUEFUNC(_wrap_AGFont_setStyle), -1);
    rb_define_method(cAGFont.klass, "getStyle", VALUEFUNC(_wrap_AGFont_getStyle), -1);
    rb_define_method(cAGFont.klass, "setName", VALUEFUNC(_wrap_AGFont_setName), -1);
    rb_define_method(cAGFont.klass, "getName", VALUEFUNC(_wrap_AGFont_getName), -1);
    rb_define_method(cAGFont.klass, "setEmbossed", VALUEFUNC(_wrap_AGFont_setEmbossed), -1);
    rb_define_method(cAGFont.klass, "getEmbossed", VALUEFUNC(_wrap_AGFont_getEmbossed), -1);
    rb_define_method(cAGFont.klass, "setInset", VALUEFUNC(_wrap_AGFont_setInset), -1);
    rb_define_method(cAGFont.klass, "getInset", VALUEFUNC(_wrap_AGFont_getInset), -1);
    rb_define_method(cAGFont.klass, "getWidth", VALUEFUNC(_wrap_AGFont_getWidth), -1);
    rb_define_method(cAGFont.klass, "getHeight", VALUEFUNC(_wrap_AGFont_getHeight), -1);
    rb_define_method(cAGFont.klass, "toString", VALUEFUNC(_wrap_AGFont_toString), -1);
    cAGFont.mark = 0;
    cAGFont.destroy = (void (*)(void *)) free_AGFont;
    
    cAGColor.klass = rb_define_class_under(mLibantargis, "AGColor", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGColor, (void *) &cAGColor);
    rb_define_alloc_func(cAGColor.klass, _wrap_AGColor_allocate);
    rb_define_method(cAGColor.klass, "initialize", VALUEFUNC(_wrap_new_AGColor), -1);
    rb_define_method(cAGColor.klass, "*", VALUEFUNC(_wrap_AGColor___mul__), -1);
    rb_define_method(cAGColor.klass, "+", VALUEFUNC(_wrap_AGColor___add__), -1);
    rb_define_method(cAGColor.klass, "mapRGB", VALUEFUNC(_wrap_AGColor_mapRGB), -1);
    rb_define_method(cAGColor.klass, "toString", VALUEFUNC(_wrap_AGColor_toString), -1);
    rb_define_method(cAGColor.klass, "toVec", VALUEFUNC(_wrap_AGColor_toVec), -1);
    rb_define_method(cAGColor.klass, "grey", VALUEFUNC(_wrap_AGColor_grey), -1);
    rb_define_method(cAGColor.klass, "brightness", VALUEFUNC(_wrap_AGColor_brightness), -1);
    rb_define_method(cAGColor.klass, "light", VALUEFUNC(_wrap_AGColor_light), -1);
    rb_define_method(cAGColor.klass, "a=", VALUEFUNC(_wrap_AGColor_a_set), -1);
    rb_define_method(cAGColor.klass, "a", VALUEFUNC(_wrap_AGColor_a_get), -1);
    cAGColor.mark = 0;
    cAGColor.destroy = (void (*)(void *)) free_AGColor;
    rb_define_module_function(mLibantargis, "disown_AGWidget", VALUEFUNC(_wrap_disown_AGWidget), -1);
    
    cAGWidget.klass = rb_define_class_under(mLibantargis, "AGWidget", ((swig_class *) SWIGTYPE_p_AGMessageObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGWidget, (void *) &cAGWidget);
    rb_define_alloc_func(cAGWidget.klass, _wrap_AGWidget_allocate);
    rb_define_method(cAGWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGWidget), -1);
    rb_define_method(cAGWidget.klass, "draw", VALUEFUNC(_wrap_AGWidget_draw), -1);
    rb_define_method(cAGWidget.klass, "drawAfter", VALUEFUNC(_wrap_AGWidget_drawAfter), -1);
    rb_define_method(cAGWidget.klass, "drawAll", VALUEFUNC(_wrap_AGWidget_drawAll), -1);
    rb_define_method(cAGWidget.klass, "getRect", VALUEFUNC(_wrap_AGWidget_getRect), -1);
    rb_define_method(cAGWidget.klass, "getClientRect", VALUEFUNC(_wrap_AGWidget_getClientRect), -1);
    rb_define_method(cAGWidget.klass, "setRect", VALUEFUNC(_wrap_AGWidget_setRect), -1);
    rb_define_method(cAGWidget.klass, "setParent", VALUEFUNC(_wrap_AGWidget_setParent), -1);
    rb_define_method(cAGWidget.klass, "getParent", VALUEFUNC(_wrap_AGWidget_getParent), -1);
    rb_define_method(cAGWidget.klass, "eventShow", VALUEFUNC(_wrap_AGWidget_eventShow), -1);
    rb_define_method(cAGWidget.klass, "eventHide", VALUEFUNC(_wrap_AGWidget_eventHide), -1);
    rb_define_method(cAGWidget.klass, "eventMouseMotion", VALUEFUNC(_wrap_AGWidget_eventMouseMotion), -1);
    rb_define_method(cAGWidget.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGWidget_eventMouseEnter), -1);
    rb_define_method(cAGWidget.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGWidget_eventMouseLeave), -1);
    rb_define_method(cAGWidget.klass, "eventMouseClick", VALUEFUNC(_wrap_AGWidget_eventMouseClick), -1);
    rb_define_method(cAGWidget.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGWidget_eventMouseButtonDown), -1);
    rb_define_method(cAGWidget.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGWidget_eventMouseButtonUp), -1);
    rb_define_method(cAGWidget.klass, "eventGotFocus", VALUEFUNC(_wrap_AGWidget_eventGotFocus), -1);
    rb_define_method(cAGWidget.klass, "eventLostFocus", VALUEFUNC(_wrap_AGWidget_eventLostFocus), -1);
    rb_define_method(cAGWidget.klass, "canFocus", VALUEFUNC(_wrap_AGWidget_canFocus), -1);
    rb_define_method(cAGWidget.klass, "processEvent", VALUEFUNC(_wrap_AGWidget_processEvent), -1);
    rb_define_method(cAGWidget.klass, "sigMouseEnter=", VALUEFUNC(_wrap_AGWidget_sigMouseEnter_set), -1);
    rb_define_method(cAGWidget.klass, "sigMouseEnter", VALUEFUNC(_wrap_AGWidget_sigMouseEnter_get), -1);
    rb_define_method(cAGWidget.klass, "sigMouseLeave=", VALUEFUNC(_wrap_AGWidget_sigMouseLeave_set), -1);
    rb_define_method(cAGWidget.klass, "sigMouseLeave", VALUEFUNC(_wrap_AGWidget_sigMouseLeave_get), -1);
    rb_define_method(cAGWidget.klass, "sigClick=", VALUEFUNC(_wrap_AGWidget_sigClick_set), -1);
    rb_define_method(cAGWidget.klass, "sigClick", VALUEFUNC(_wrap_AGWidget_sigClick_get), -1);
    rb_define_method(cAGWidget.klass, "minWidth", VALUEFUNC(_wrap_AGWidget_minWidth), -1);
    rb_define_method(cAGWidget.klass, "minHeight", VALUEFUNC(_wrap_AGWidget_minHeight), -1);
    rb_define_method(cAGWidget.klass, "width", VALUEFUNC(_wrap_AGWidget_width), -1);
    rb_define_method(cAGWidget.klass, "height", VALUEFUNC(_wrap_AGWidget_height), -1);
    rb_define_method(cAGWidget.klass, "top", VALUEFUNC(_wrap_AGWidget_top), -1);
    rb_define_method(cAGWidget.klass, "left", VALUEFUNC(_wrap_AGWidget_left), -1);
    rb_define_method(cAGWidget.klass, "bottom", VALUEFUNC(_wrap_AGWidget_bottom), -1);
    rb_define_method(cAGWidget.klass, "right", VALUEFUNC(_wrap_AGWidget_right), -1);
    rb_define_method(cAGWidget.klass, "visible", VALUEFUNC(_wrap_AGWidget_visible), -1);
    rb_define_method(cAGWidget.klass, "setWidth", VALUEFUNC(_wrap_AGWidget_setWidth), -1);
    rb_define_method(cAGWidget.klass, "setHeight", VALUEFUNC(_wrap_AGWidget_setHeight), -1);
    rb_define_method(cAGWidget.klass, "setTop", VALUEFUNC(_wrap_AGWidget_setTop), -1);
    rb_define_method(cAGWidget.klass, "setLeft", VALUEFUNC(_wrap_AGWidget_setLeft), -1);
    rb_define_method(cAGWidget.klass, "fixedWidth", VALUEFUNC(_wrap_AGWidget_fixedWidth), -1);
    rb_define_method(cAGWidget.klass, "fixedHeight", VALUEFUNC(_wrap_AGWidget_fixedHeight), -1);
    rb_define_method(cAGWidget.klass, "show", VALUEFUNC(_wrap_AGWidget_show), -1);
    rb_define_method(cAGWidget.klass, "hide", VALUEFUNC(_wrap_AGWidget_hide), -1);
    rb_define_method(cAGWidget.klass, "mark", VALUEFUNC(_wrap_AGWidget_mark), -1);
    rb_define_method(cAGWidget.klass, "addChild", VALUEFUNC(_wrap_AGWidget_addChild), -1);
    rb_define_method(cAGWidget.klass, "addChildBack", VALUEFUNC(_wrap_AGWidget_addChildBack), -1);
    rb_define_method(cAGWidget.klass, "removeChild", VALUEFUNC(_wrap_AGWidget_removeChild), -1);
    rb_define_method(cAGWidget.klass, "redraw", VALUEFUNC(_wrap_AGWidget_redraw), -1);
    rb_define_method(cAGWidget.klass, "prepareDraw", VALUEFUNC(_wrap_AGWidget_prepareDraw), -1);
    rb_define_method(cAGWidget.klass, "setCaching", VALUEFUNC(_wrap_AGWidget_setCaching), -1);
    rb_define_method(cAGWidget.klass, "checkRedraw", VALUEFUNC(_wrap_AGWidget_checkRedraw), -1);
    rb_define_method(cAGWidget.klass, "setDrawn", VALUEFUNC(_wrap_AGWidget_setDrawn), -1);
    rb_define_method(cAGWidget.klass, "queryRedraw", VALUEFUNC(_wrap_AGWidget_queryRedraw), -1);
    rb_define_method(cAGWidget.klass, "getChangeRect", VALUEFUNC(_wrap_AGWidget_getChangeRect), -1);
    rb_define_method(cAGWidget.klass, "useTextures", VALUEFUNC(_wrap_AGWidget_useTextures), -1);
    rb_define_method(cAGWidget.klass, "useTexturesRecursive", VALUEFUNC(_wrap_AGWidget_useTexturesRecursive), -1);
    rb_define_method(cAGWidget.klass, "clear", VALUEFUNC(_wrap_AGWidget_clear), -1);
    rb_define_method(cAGWidget.klass, "getScreenRect", VALUEFUNC(_wrap_AGWidget_getScreenRect), -1);
    rb_define_method(cAGWidget.klass, "getScreenPosition", VALUEFUNC(_wrap_AGWidget_getScreenPosition), -1);
    rb_define_method(cAGWidget.klass, "fromScreen", VALUEFUNC(_wrap_AGWidget_fromScreen), -1);
    rb_define_method(cAGWidget.klass, "gainFocus", VALUEFUNC(_wrap_AGWidget_gainFocus), -1);
    rb_define_method(cAGWidget.klass, "gainCompleteFocus", VALUEFUNC(_wrap_AGWidget_gainCompleteFocus), -1);
    rb_define_method(cAGWidget.klass, "eventDragBy", VALUEFUNC(_wrap_AGWidget_eventDragBy), -1);
    rb_define_method(cAGWidget.klass, "getFocus", VALUEFUNC(_wrap_AGWidget_getFocus), -1);
    rb_define_method(cAGWidget.klass, "hasFocus", VALUEFUNC(_wrap_AGWidget_hasFocus), -1);
    rb_define_method(cAGWidget.klass, "getLayout", VALUEFUNC(_wrap_AGWidget_getLayout), -1);
    rb_define_method(cAGWidget.klass, "getName", VALUEFUNC(_wrap_AGWidget_getName), -1);
    rb_define_method(cAGWidget.klass, "setName", VALUEFUNC(_wrap_AGWidget_setName), -1);
    rb_define_method(cAGWidget.klass, "getChild", VALUEFUNC(_wrap_AGWidget_getChild), -1);
    rb_define_method(cAGWidget.klass, "setModal", VALUEFUNC(_wrap_AGWidget_setModal), -1);
    rb_define_method(cAGWidget.klass, "erase", VALUEFUNC(_wrap_AGWidget_erase), -1);
    rb_define_method(cAGWidget.klass, "eventChildrenDeleted", VALUEFUNC(_wrap_AGWidget_eventChildrenDeleted), -1);
    rb_define_method(cAGWidget.klass, "setTooltip", VALUEFUNC(_wrap_AGWidget_setTooltip), -1);
    cAGWidget.mark = (void (*)(void *)) general_markfunc;
    cAGWidget.destroy = (void (*)(void *)) free_AGWidget;
    rb_define_module_function(mLibantargis, "toAGWidget", VALUEFUNC(_wrap_toAGWidget), -1);
    rb_define_singleton_method(mLibantargis, "agNoParent", VALUEFUNC(agNoParent_get), 0);
    rb_define_singleton_method(mLibantargis, "agNoParent=", VALUEFUNC(agNoParent_set), 1);
    rb_define_module_function(mLibantargis, "disown_AGColorButton", VALUEFUNC(_wrap_disown_AGColorButton), -1);
    
    cAGColorButton.klass = rb_define_class_under(mLibantargis, "AGColorButton", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGColorButton, (void *) &cAGColorButton);
    rb_define_alloc_func(cAGColorButton.klass, _wrap_AGColorButton_allocate);
    rb_define_method(cAGColorButton.klass, "initialize", VALUEFUNC(_wrap_new_AGColorButton), -1);
    rb_define_method(cAGColorButton.klass, "draw", VALUEFUNC(_wrap_AGColorButton_draw), -1);
    rb_define_method(cAGColorButton.klass, "getColor", VALUEFUNC(_wrap_AGColorButton_getColor), -1);
    rb_define_method(cAGColorButton.klass, "setColor", VALUEFUNC(_wrap_AGColorButton_setColor), -1);
    rb_define_method(cAGColorButton.klass, "eventMouseClick", VALUEFUNC(_wrap_AGColorButton_eventMouseClick), -1);
    cAGColorButton.mark = (void (*)(void *)) general_markfunc;
    cAGColorButton.destroy = (void (*)(void *)) free_AGColorButton;
    rb_define_module_function(mLibantargis, "toAGColorButton", VALUEFUNC(_wrap_toAGColorButton), -1);
    rb_define_module_function(mLibantargis, "disown_AGGLWidget", VALUEFUNC(_wrap_disown_AGGLWidget), -1);
    
    cAGGLWidget.klass = rb_define_class_under(mLibantargis, "AGGLWidget", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGGLWidget, (void *) &cAGGLWidget);
    rb_define_alloc_func(cAGGLWidget.klass, _wrap_AGGLWidget_allocate);
    rb_define_method(cAGGLWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGGLWidget), -1);
    rb_define_method(cAGGLWidget.klass, "drawGL", VALUEFUNC(_wrap_AGGLWidget_drawGL), -1);
    rb_define_method(cAGGLWidget.klass, "drawAll", VALUEFUNC(_wrap_AGGLWidget_drawAll), -1);
    rb_define_method(cAGGLWidget.klass, "getRatio", VALUEFUNC(_wrap_AGGLWidget_getRatio), -1);
    rb_define_method(cAGGLWidget.klass, "setPerspective", VALUEFUNC(_wrap_AGGLWidget_setPerspective), -1);
    cAGGLWidget.mark = (void (*)(void *)) general_markfunc;
    cAGGLWidget.destroy = (void (*)(void *)) free_AGGLWidget;
    
    cNode.klass = rb_define_class_under(mLibantargis, "Node", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Node, (void *) &cNode);
    rb_define_alloc_func(cNode.klass, _wrap_Node_allocate);
    rb_define_method(cNode.klass, "initialize", VALUEFUNC(_wrap_new_Node), -1);
    rb_define_method(cNode.klass, "setName", VALUEFUNC(_wrap_Node_setName), -1);
    rb_define_method(cNode.klass, "getChildren", VALUEFUNC(_wrap_Node_getChildren), -1);
    rb_define_method(cNode.klass, "getName", VALUEFUNC(_wrap_Node_getName), -1);
    rb_define_method(cNode.klass, "setAttributes", VALUEFUNC(_wrap_Node_setAttributes), -1);
    rb_define_method(cNode.klass, "addChild", VALUEFUNC(_wrap_Node_addChild), -1);
    rb_define_method(cNode.klass, "removeChild", VALUEFUNC(_wrap_Node_removeChild), -1);
    rb_define_method(cNode.klass, "begin", VALUEFUNC(_wrap_Node_begin), -1);
    rb_define_method(cNode.klass, "end", VALUEFUNC(_wrap_Node_end), -1);
    rb_define_method(cNode.klass, "setContent", VALUEFUNC(_wrap_Node_setContent), -1);
    rb_define_method(cNode.klass, "set", VALUEFUNC(_wrap_Node_set), -1);
    rb_define_method(cNode.klass, "get", VALUEFUNC(_wrap_Node_get), -1);
    rb_define_method(cNode.klass, "clear", VALUEFUNC(_wrap_Node_clear), -1);
    rb_define_singleton_method(cNode.klass, "escape", VALUEFUNC(_wrap_Node_escape), -1);
    rb_define_singleton_method(cNode.klass, "unescape", VALUEFUNC(_wrap_Node_unescape), -1);
    rb_define_method(cNode.klass, "getStart", VALUEFUNC(_wrap_Node_getStart), -1);
    rb_define_method(cNode.klass, "getEnd", VALUEFUNC(_wrap_Node_getEnd), -1);
    rb_define_method(cNode.klass, "indent", VALUEFUNC(_wrap_Node_indent), -1);
    rb_define_method(cNode.klass, "getContent", VALUEFUNC(_wrap_Node_getContent), -1);
    rb_define_method(cNode.klass, "toString", VALUEFUNC(_wrap_Node_toString), -1);
    rb_define_method(cNode.klass, "isTextNode", VALUEFUNC(_wrap_Node_isTextNode), -1);
    rb_define_method(cNode.klass, "getText", VALUEFUNC(_wrap_Node_getText), -1);
    rb_define_method(cNode.klass, "hasTextNode", VALUEFUNC(_wrap_Node_hasTextNode), -1);
    rb_define_method(cNode.klass, "size", VALUEFUNC(_wrap_Node_size), -1);
    cNode.mark = 0;
    cNode.destroy = (void (*)(void *)) free_Node;
    
    cDocument.klass = rb_define_class_under(mLibantargis, "Document", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Document, (void *) &cDocument);
    rb_define_alloc_func(cDocument.klass, _wrap_Document_allocate);
    rb_define_method(cDocument.klass, "initialize", VALUEFUNC(_wrap_new_Document), -1);
    rb_define_method(cDocument.klass, "parseFile", VALUEFUNC(_wrap_Document_parseFile), -1);
    rb_define_method(cDocument.klass, "root", VALUEFUNC(_wrap_Document_root), -1);
    rb_define_method(cDocument.klass, "toString", VALUEFUNC(_wrap_Document_toString), -1);
    rb_define_method(cDocument.klass, "parseMemory", VALUEFUNC(_wrap_Document_parseMemory), -1);
    cDocument.mark = 0;
    cDocument.destroy = (void (*)(void *)) free_Document;
    rb_define_module_function(mLibantargis, "disown_Parser", VALUEFUNC(_wrap_disown_Parser), -1);
    
    cParser.klass = rb_define_class_under(mLibantargis, "Parser", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Parser, (void *) &cParser);
    rb_define_alloc_func(cParser.klass, _wrap_Parser_allocate);
    rb_define_method(cParser.klass, "initialize", VALUEFUNC(_wrap_new_Parser), -1);
    rb_define_method(cParser.klass, "parse", VALUEFUNC(_wrap_Parser_parse), -1);
    rb_define_method(cParser.klass, "getLine", VALUEFUNC(_wrap_Parser_getLine), -1);
    rb_define_method(cParser.klass, "simpleTag", VALUEFUNC(_wrap_Parser_simpleTag), -1);
    rb_define_method(cParser.klass, "startTag", VALUEFUNC(_wrap_Parser_startTag), -1);
    rb_define_method(cParser.klass, "endTag", VALUEFUNC(_wrap_Parser_endTag), -1);
    rb_define_method(cParser.klass, "text", VALUEFUNC(_wrap_Parser_text), -1);
    rb_define_method(cParser.klass, "comment", VALUEFUNC(_wrap_Parser_comment), -1);
    rb_define_method(cParser.klass, "header", VALUEFUNC(_wrap_Parser_header), -1);
    cParser.mark = 0;
    cParser.destroy = (void (*)(void *)) free_Parser;
    rb_define_module_function(mLibantargis, "disown_DomParser", VALUEFUNC(_wrap_disown_DomParser), -1);
    
    cDomParser.klass = rb_define_class_under(mLibantargis, "DomParser", ((swig_class *) SWIGTYPE_p_Parser->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_DomParser, (void *) &cDomParser);
    rb_define_alloc_func(cDomParser.klass, _wrap_DomParser_allocate);
    rb_define_method(cDomParser.klass, "initialize", VALUEFUNC(_wrap_new_DomParser), -1);
    rb_define_method(cDomParser.klass, "simpleTag", VALUEFUNC(_wrap_DomParser_simpleTag), -1);
    rb_define_method(cDomParser.klass, "startTag", VALUEFUNC(_wrap_DomParser_startTag), -1);
    rb_define_method(cDomParser.klass, "endTag", VALUEFUNC(_wrap_DomParser_endTag), -1);
    rb_define_method(cDomParser.klass, "text", VALUEFUNC(_wrap_DomParser_text), -1);
    rb_define_method(cDomParser.klass, "comment", VALUEFUNC(_wrap_DomParser_comment), -1);
    rb_define_method(cDomParser.klass, "header", VALUEFUNC(_wrap_DomParser_header), -1);
    rb_define_method(cDomParser.klass, "parse", VALUEFUNC(_wrap_DomParser_parse), -1);
    cDomParser.mark = 0;
    cDomParser.destroy = (void (*)(void *)) free_DomParser;
    rb_define_module_function(mLibantargis, "disown_AGLayout", VALUEFUNC(_wrap_disown_AGLayout), -1);
    
    cAGLayout.klass = rb_define_class_under(mLibantargis, "AGLayout", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayout, (void *) &cAGLayout);
    rb_define_alloc_func(cAGLayout.klass, _wrap_AGLayout_allocate);
    rb_define_method(cAGLayout.klass, "initialize", VALUEFUNC(_wrap_new_AGLayout), -1);
    rb_define_method(cAGLayout.klass, "addTabIndex", VALUEFUNC(_wrap_AGLayout_addTabIndex), -1);
    rb_define_method(cAGLayout.klass, "eventKeyDown", VALUEFUNC(_wrap_AGLayout_eventKeyDown), -1);
    rb_define_method(cAGLayout.klass, "getNextTabIndex", VALUEFUNC(_wrap_AGLayout_getNextTabIndex), -1);
    cAGLayout.mark = (void (*)(void *)) general_markfunc;
    cAGLayout.destroy = (void (*)(void *)) free_AGLayout;
    rb_define_module_function(mLibantargis, "parseNode", VALUEFUNC(_wrap_parseNode), -1);
    rb_define_module_function(mLibantargis, "parseChildren", VALUEFUNC(_wrap_parseChildren), -1);
    rb_define_module_function(mLibantargis, "getLayoutGeometry", VALUEFUNC(_wrap_getLayoutGeometry), -1);
    rb_define_module_function(mLibantargis, "disown_AGDialog", VALUEFUNC(_wrap_disown_AGDialog), -1);
    
    cAGDialog.klass = rb_define_class_under(mLibantargis, "AGDialog", ((swig_class *) SWIGTYPE_p_AGLayout->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGDialog, (void *) &cAGDialog);
    rb_define_alloc_func(cAGDialog.klass, _wrap_AGDialog_allocate);
    rb_define_method(cAGDialog.klass, "initialize", VALUEFUNC(_wrap_new_AGDialog), -1);
    rb_define_method(cAGDialog.klass, "eventOk", VALUEFUNC(_wrap_AGDialog_eventOk), -1);
    rb_define_method(cAGDialog.klass, "eventCancel", VALUEFUNC(_wrap_AGDialog_eventCancel), -1);
    rb_define_method(cAGDialog.klass, "eventClose", VALUEFUNC(_wrap_AGDialog_eventClose), -1);
    cAGDialog.mark = (void (*)(void *)) general_markfunc;
    cAGDialog.destroy = (void (*)(void *)) free_AGDialog;
    
    cAGMutex.klass = rb_define_class_under(mLibantargis, "AGMutex", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMutex, (void *) &cAGMutex);
    rb_define_alloc_func(cAGMutex.klass, _wrap_AGMutex_allocate);
    rb_define_method(cAGMutex.klass, "initialize", VALUEFUNC(_wrap_new_AGMutex), -1);
    rb_define_method(cAGMutex.klass, "enter", VALUEFUNC(_wrap_AGMutex_enter), -1);
    rb_define_method(cAGMutex.klass, "leave", VALUEFUNC(_wrap_AGMutex_leave), -1);
    cAGMutex.mark = 0;
    cAGMutex.destroy = (void (*)(void *)) free_AGMutex;
    rb_define_module_function(mLibantargis, "disown_AGApplication", VALUEFUNC(_wrap_disown_AGApplication), -1);
    
    cAGApplication.klass = rb_define_class_under(mLibantargis, "AGApplication", ((swig_class *) SWIGTYPE_p_AGMessageObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGApplication, (void *) &cAGApplication);
    rb_define_alloc_func(cAGApplication.klass, _wrap_AGApplication_allocate);
    rb_define_method(cAGApplication.klass, "initialize", VALUEFUNC(_wrap_new_AGApplication), -1);
    rb_define_method(cAGApplication.klass, "run", VALUEFUNC(_wrap_AGApplication_run), -1);
    rb_define_method(cAGApplication.klass, "eventIdle", VALUEFUNC(_wrap_AGApplication_eventIdle), -1);
    rb_define_method(cAGApplication.klass, "eventFrame", VALUEFUNC(_wrap_AGApplication_eventFrame), -1);
    rb_define_method(cAGApplication.klass, "eventFrameEnd", VALUEFUNC(_wrap_AGApplication_eventFrameEnd), -1);
    rb_define_method(cAGApplication.klass, "eventQuit", VALUEFUNC(_wrap_AGApplication_eventQuit), -1);
    rb_define_method(cAGApplication.klass, "eventKeyDown", VALUEFUNC(_wrap_AGApplication_eventKeyDown), -1);
    rb_define_method(cAGApplication.klass, "eventMouseMotion", VALUEFUNC(_wrap_AGApplication_eventMouseMotion), -1);
    rb_define_method(cAGApplication.klass, "eventChangedRes", VALUEFUNC(_wrap_AGApplication_eventChangedRes), -1);
    rb_define_method(cAGApplication.klass, "setMainWidget", VALUEFUNC(_wrap_AGApplication_setMainWidget), -1);
    rb_define_method(cAGApplication.klass, "draw", VALUEFUNC(_wrap_AGApplication_draw), -1);
    rb_define_method(cAGApplication.klass, "prepareDraw", VALUEFUNC(_wrap_AGApplication_prepareDraw), -1);
    rb_define_method(cAGApplication.klass, "tryQuit", VALUEFUNC(_wrap_AGApplication_tryQuit), -1);
    rb_define_method(cAGApplication.klass, "getTicks", VALUEFUNC(_wrap_AGApplication_getTicks), -1);
    rb_define_method(cAGApplication.klass, "delay", VALUEFUNC(_wrap_AGApplication_delay), -1);
    rb_define_method(cAGApplication.klass, "setTooltip", VALUEFUNC(_wrap_AGApplication_setTooltip), -1);
    rb_define_method(cAGApplication.klass, "resetTooltip", VALUEFUNC(_wrap_AGApplication_resetTooltip), -1);
    rb_define_method(cAGApplication.klass, "setCursor", VALUEFUNC(_wrap_AGApplication_setCursor), -1);
    rb_define_method(cAGApplication.klass, "setNormalCursor", VALUEFUNC(_wrap_AGApplication_setNormalCursor), -1);
    rb_define_method(cAGApplication.klass, "mark", VALUEFUNC(_wrap_AGApplication_mark), -1);
    cAGApplication.mark = (void (*)(void *)) general_markfunc;
    cAGApplication.destroy = (void (*)(void *)) free_AGApplication;
    rb_define_module_function(mLibantargis, "getApplication", VALUEFUNC(_wrap_getApplication), -1);
    rb_define_module_function(mLibantargis, "disableKeyrepeat", VALUEFUNC(_wrap_disableKeyrepeat), -1);
    
    cAGBackground.klass = rb_define_class_under(mLibantargis, "AGBackground", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBackground, (void *) &cAGBackground);
    rb_define_alloc_func(cAGBackground.klass, _wrap_AGBackground_allocate);
    rb_define_method(cAGBackground.klass, "initialize", VALUEFUNC(_wrap_new_AGBackground), -1);
    rb_define_method(cAGBackground.klass, "draw", VALUEFUNC(_wrap_AGBackground_draw), -1);
    rb_define_method(cAGBackground.klass, "useTextures", VALUEFUNC(_wrap_AGBackground_useTextures), -1);
    cAGBackground.mark = 0;
    cAGBackground.destroy = (void (*)(void *)) free_AGBackground;
    
    cAGBorder.klass = rb_define_class_under(mLibantargis, "AGBorder", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBorder, (void *) &cAGBorder);
    rb_define_alloc_func(cAGBorder.klass, _wrap_AGBorder_allocate);
    rb_define_method(cAGBorder.klass, "initialize", VALUEFUNC(_wrap_new_AGBorder), -1);
    rb_define_method(cAGBorder.klass, "draw", VALUEFUNC(_wrap_AGBorder_draw), -1);
    rb_define_method(cAGBorder.klass, "getWidth", VALUEFUNC(_wrap_AGBorder_getWidth), -1);
    rb_define_method(cAGBorder.klass, "useTextures", VALUEFUNC(_wrap_AGBorder_useTextures), -1);
    cAGBorder.mark = 0;
    cAGBorder.destroy = (void (*)(void *)) free_AGBorder;
    rb_define_module_function(mLibantargis, "disown_AGButton", VALUEFUNC(_wrap_disown_AGButton), -1);
    
    cAGButton.klass = rb_define_class_under(mLibantargis, "AGButton", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGButton, (void *) &cAGButton);
    rb_define_alloc_func(cAGButton.klass, _wrap_AGButton_allocate);
    rb_define_method(cAGButton.klass, "initialize", VALUEFUNC(_wrap_new_AGButton), -1);
    rb_define_const(cAGButton.klass,"NORMAL", INT2NUM(AGButton::NORMAL));
    rb_define_const(cAGButton.klass,"LIGHTED", INT2NUM(AGButton::LIGHTED));
    rb_define_const(cAGButton.klass,"PRESSED", INT2NUM(AGButton::PRESSED));
    rb_define_const(cAGButton.klass,"CHECKED", INT2NUM(AGButton::CHECKED));
    rb_define_const(cAGButton.klass,"CHECKEDLIGHTED", INT2NUM(AGButton::CHECKEDLIGHTED));
    rb_define_const(cAGButton.klass,"CHECKEDPRESSED", INT2NUM(AGButton::CHECKEDPRESSED));
    rb_define_const(cAGButton.klass,"DISABLED", INT2NUM(AGButton::DISABLED));
    rb_define_method(cAGButton.klass, "setSurface", VALUEFUNC(_wrap_AGButton_setSurface), -1);
    rb_define_method(cAGButton.klass, "draw", VALUEFUNC(_wrap_AGButton_draw), -1);
    rb_define_method(cAGButton.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGButton_eventMouseEnter), -1);
    rb_define_method(cAGButton.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGButton_eventMouseLeave), -1);
    rb_define_method(cAGButton.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGButton_eventMouseButtonDown), -1);
    rb_define_method(cAGButton.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGButton_eventMouseButtonUp), -1);
    rb_define_method(cAGButton.klass, "setWidth", VALUEFUNC(_wrap_AGButton_setWidth), -1);
    rb_define_method(cAGButton.klass, "setHeight", VALUEFUNC(_wrap_AGButton_setHeight), -1);
    rb_define_method(cAGButton.klass, "getCaption", VALUEFUNC(_wrap_AGButton_getCaption), -1);
    rb_define_method(cAGButton.klass, "setEnabled", VALUEFUNC(_wrap_AGButton_setEnabled), -1);
    rb_define_method(cAGButton.klass, "setTheme", VALUEFUNC(_wrap_AGButton_setTheme), -1);
    rb_define_method(cAGButton.klass, "setCaption", VALUEFUNC(_wrap_AGButton_setCaption), -1);
    rb_define_method(cAGButton.klass, "setState", VALUEFUNC(_wrap_AGButton_setState), -1);
    rb_define_method(cAGButton.klass, "setChecked", VALUEFUNC(_wrap_AGButton_setChecked), -1);
    rb_define_method(cAGButton.klass, "isChecked", VALUEFUNC(_wrap_AGButton_isChecked), -1);
    rb_define_method(cAGButton.klass, "canFocus", VALUEFUNC(_wrap_AGButton_canFocus), -1);
    rb_define_method(cAGButton.klass, "useTextures", VALUEFUNC(_wrap_AGButton_useTextures), -1);
    cAGButton.mark = (void (*)(void *)) general_markfunc;
    cAGButton.destroy = (void (*)(void *)) free_AGButton;
    rb_define_module_function(mLibantargis, "toAGButton", VALUEFUNC(_wrap_toAGButton), -1);
    rb_define_module_function(mLibantargis, "disown_AGText", VALUEFUNC(_wrap_disown_AGText), -1);
    
    cAGText.klass = rb_define_class_under(mLibantargis, "AGText", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGText, (void *) &cAGText);
    rb_define_alloc_func(cAGText.klass, _wrap_AGText_allocate);
    rb_define_method(cAGText.klass, "initialize", VALUEFUNC(_wrap_new_AGText), -1);
    rb_define_method(cAGText.klass, "setDeriveRect", VALUEFUNC(_wrap_AGText_setDeriveRect), -1);
    rb_define_method(cAGText.klass, "draw", VALUEFUNC(_wrap_AGText_draw), -1);
    rb_define_method(cAGText.klass, "setText", VALUEFUNC(_wrap_AGText_setText), -1);
    rb_define_method(cAGText.klass, "getText", VALUEFUNC(_wrap_AGText_getText), -1);
    rb_define_method(cAGText.klass, "setFont", VALUEFUNC(_wrap_AGText_setFont), -1);
    cAGText.mark = (void (*)(void *)) general_markfunc;
    cAGText.destroy = (void (*)(void *)) free_AGText;
    rb_define_module_function(mLibantargis, "toAGText", VALUEFUNC(_wrap_toAGText), -1);
    rb_define_module_function(mLibantargis, "disown_AGCaption", VALUEFUNC(_wrap_disown_AGCaption), -1);
    
    cAGCaption.klass = rb_define_class_under(mLibantargis, "AGCaption", ((swig_class *) SWIGTYPE_p_AGText->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGCaption, (void *) &cAGCaption);
    rb_define_alloc_func(cAGCaption.klass, _wrap_AGCaption_allocate);
    rb_define_method(cAGCaption.klass, "initialize", VALUEFUNC(_wrap_new_AGCaption), -1);
    rb_define_method(cAGCaption.klass, "draw", VALUEFUNC(_wrap_AGCaption_draw), -1);
    rb_define_method(cAGCaption.klass, "setBackground", VALUEFUNC(_wrap_AGCaption_setBackground), -1);
    cAGCaption.mark = (void (*)(void *)) general_markfunc;
    cAGCaption.destroy = (void (*)(void *)) free_AGCaption;
    rb_define_module_function(mLibantargis, "disown_AGCheckBox", VALUEFUNC(_wrap_disown_AGCheckBox), -1);
    
    cAGCheckBox.klass = rb_define_class_under(mLibantargis, "AGCheckBox", ((swig_class *) SWIGTYPE_p_AGButton->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGCheckBox, (void *) &cAGCheckBox);
    rb_define_alloc_func(cAGCheckBox.klass, _wrap_AGCheckBox_allocate);
    rb_define_method(cAGCheckBox.klass, "initialize", VALUEFUNC(_wrap_new_AGCheckBox), -1);
    rb_define_method(cAGCheckBox.klass, "eventMouseClick", VALUEFUNC(_wrap_AGCheckBox_eventMouseClick), -1);
    cAGCheckBox.mark = (void (*)(void *)) general_markfunc;
    cAGCheckBox.destroy = (void (*)(void *)) free_AGCheckBox;
    rb_define_const(mLibantargis,"EDIT_LEFT", INT2NUM(EDIT_LEFT));
    rb_define_const(mLibantargis,"EDIT_RIGHT", INT2NUM(EDIT_RIGHT));
    rb_define_const(mLibantargis,"EDIT_JUSTIFY", INT2NUM(EDIT_JUSTIFY));
    rb_define_const(mLibantargis,"EDIT_CENTER", INT2NUM(EDIT_CENTER));
    rb_define_const(mLibantargis,"EDIT_TOP", INT2NUM(EDIT_TOP));
    rb_define_const(mLibantargis,"EDIT_BOTTOM", INT2NUM(EDIT_BOTTOM));
    rb_define_const(mLibantargis,"EDIT_VCENTER", INT2NUM(EDIT_VCENTER));
    rb_define_module_function(mLibantargis, "disown_AGEditLine", VALUEFUNC(_wrap_disown_AGEditLine), -1);
    
    cAGEditLine.klass = rb_define_class_under(mLibantargis, "AGEditLine", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGEditLine, (void *) &cAGEditLine);
    rb_define_alloc_func(cAGEditLine.klass, _wrap_AGEditLine_allocate);
    rb_define_method(cAGEditLine.klass, "initialize", VALUEFUNC(_wrap_new_AGEditLine), -1);
    rb_define_method(cAGEditLine.klass, "setAlign", VALUEFUNC(_wrap_AGEditLine_setAlign), -1);
    rb_define_method(cAGEditLine.klass, "setVAlign", VALUEFUNC(_wrap_AGEditLine_setVAlign), -1);
    rb_define_method(cAGEditLine.klass, "draw", VALUEFUNC(_wrap_AGEditLine_draw), -1);
    rb_define_method(cAGEditLine.klass, "drawCursor", VALUEFUNC(_wrap_AGEditLine_drawCursor), -1);
    rb_define_method(cAGEditLine.klass, "height", VALUEFUNC(_wrap_AGEditLine_height), -1);
    rb_define_method(cAGEditLine.klass, "width", VALUEFUNC(_wrap_AGEditLine_width), -1);
    rb_define_method(cAGEditLine.klass, "insert", VALUEFUNC(_wrap_AGEditLine_insert), -1);
    rb_define_method(cAGEditLine.klass, "doDelete", VALUEFUNC(_wrap_AGEditLine_doDelete), -1);
    rb_define_method(cAGEditLine.klass, "split", VALUEFUNC(_wrap_AGEditLine_split), -1);
    rb_define_method(cAGEditLine.klass, "length", VALUEFUNC(_wrap_AGEditLine_length), -1);
    rb_define_method(cAGEditLine.klass, "append", VALUEFUNC(_wrap_AGEditLine_append), -1);
    rb_define_method(cAGEditLine.klass, "prepend", VALUEFUNC(_wrap_AGEditLine_prepend), -1);
    rb_define_method(cAGEditLine.klass, "getText", VALUEFUNC(_wrap_AGEditLine_getText), -1);
    rb_define_method(cAGEditLine.klass, "getFont", VALUEFUNC(_wrap_AGEditLine_getFont), -1);
    rb_define_method(cAGEditLine.klass, "setText", VALUEFUNC(_wrap_AGEditLine_setText), -1);
    rb_define_method(cAGEditLine.klass, "hardEnd", VALUEFUNC(_wrap_AGEditLine_hardEnd), -1);
    rb_define_method(cAGEditLine.klass, "setHardEnd", VALUEFUNC(_wrap_AGEditLine_setHardEnd), -1);
    rb_define_method(cAGEditLine.klass, "checkUnwrap", VALUEFUNC(_wrap_AGEditLine_checkUnwrap), -1);
    rb_define_method(cAGEditLine.klass, "checkWrap", VALUEFUNC(_wrap_AGEditLine_checkWrap), -1);
    rb_define_method(cAGEditLine.klass, "setFont", VALUEFUNC(_wrap_AGEditLine_setFont), -1);
    cAGEditLine.mark = 0;
    cAGEditLine.destroy = (void (*)(void *)) free_AGEditLine;
    rb_define_module_function(mLibantargis, "disown_AGEdit", VALUEFUNC(_wrap_disown_AGEdit), -1);
    
    cAGEdit.klass = rb_define_class_under(mLibantargis, "AGEdit", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGEdit, (void *) &cAGEdit);
    rb_define_alloc_func(cAGEdit.klass, _wrap_AGEdit_allocate);
    rb_define_method(cAGEdit.klass, "initialize", VALUEFUNC(_wrap_new_AGEdit), -1);
    rb_define_method(cAGEdit.klass, "draw", VALUEFUNC(_wrap_AGEdit_draw), -1);
    rb_define_method(cAGEdit.klass, "drawBackground", VALUEFUNC(_wrap_AGEdit_drawBackground), -1);
    rb_define_method(cAGEdit.klass, "eventKeyDown", VALUEFUNC(_wrap_AGEdit_eventKeyDown), -1);
    rb_define_method(cAGEdit.klass, "eventKeyUp", VALUEFUNC(_wrap_AGEdit_eventKeyUp), -1);
    rb_define_method(cAGEdit.klass, "setMulti", VALUEFUNC(_wrap_AGEdit_setMulti), -1);
    rb_define_method(cAGEdit.klass, "insert", VALUEFUNC(_wrap_AGEdit_insert), -1);
    rb_define_method(cAGEdit.klass, "doDelete", VALUEFUNC(_wrap_AGEdit_doDelete), -1);
    rb_define_method(cAGEdit.klass, "setText", VALUEFUNC(_wrap_AGEdit_setText), -1);
    rb_define_method(cAGEdit.klass, "setFont", VALUEFUNC(_wrap_AGEdit_setFont), -1);
    rb_define_method(cAGEdit.klass, "clear", VALUEFUNC(_wrap_AGEdit_clear), -1);
    rb_define_method(cAGEdit.klass, "setMutable", VALUEFUNC(_wrap_AGEdit_setMutable), -1);
    rb_define_method(cAGEdit.klass, "setAlign", VALUEFUNC(_wrap_AGEdit_setAlign), -1);
    rb_define_method(cAGEdit.klass, "setVAlign", VALUEFUNC(_wrap_AGEdit_setVAlign), -1);
    rb_define_method(cAGEdit.klass, "setBackground", VALUEFUNC(_wrap_AGEdit_setBackground), -1);
    rb_define_method(cAGEdit.klass, "setTheme", VALUEFUNC(_wrap_AGEdit_setTheme), -1);
    rb_define_method(cAGEdit.klass, "canFocus", VALUEFUNC(_wrap_AGEdit_canFocus), -1);
    rb_define_method(cAGEdit.klass, "getText", VALUEFUNC(_wrap_AGEdit_getText), -1);
    rb_define_method(cAGEdit.klass, "setMaxLength", VALUEFUNC(_wrap_AGEdit_setMaxLength), -1);
    rb_define_method(cAGEdit.klass, "eventGotFocus", VALUEFUNC(_wrap_AGEdit_eventGotFocus), -1);
    rb_define_method(cAGEdit.klass, "eventLostFocus", VALUEFUNC(_wrap_AGEdit_eventLostFocus), -1);
    rb_define_method(cAGEdit.klass, "prepareDraw", VALUEFUNC(_wrap_AGEdit_prepareDraw), -1);
    rb_define_method(cAGEdit.klass, "setInsert", VALUEFUNC(_wrap_AGEdit_setInsert), -1);
    cAGEdit.mark = (void (*)(void *)) general_markfunc;
    cAGEdit.destroy = (void (*)(void *)) free_AGEdit;
    rb_define_module_function(mLibantargis, "toAGEdit", VALUEFUNC(_wrap_toAGEdit), -1);
    
    cAGFontEngine.klass = rb_define_class_under(mLibantargis, "AGFontEngine", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGFontEngine, (void *) &cAGFontEngine);
    rb_define_alloc_func(cAGFontEngine.klass, _wrap_AGFontEngine_allocate);
    rb_define_method(cAGFontEngine.klass, "initialize", VALUEFUNC(_wrap_new_AGFontEngine), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "renderText", VALUEFUNC(_wrap_AGFontEngine_renderText), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "getWidth", VALUEFUNC(_wrap_AGFontEngine_getWidth), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "getHeight", VALUEFUNC(_wrap_AGFontEngine_getHeight), -1);
    cAGFontEngine.mark = 0;
    cAGFontEngine.destroy = (void (*)(void *)) free_AGFontEngine;
    rb_define_module_function(mLibantargis, "initFS", VALUEFUNC(_wrap_initFS), -1);
    rb_define_module_function(mLibantargis, "loadFile", VALUEFUNC(_wrap_loadFile), -1);
    rb_define_module_function(mLibantargis, "saveFile", VALUEFUNC(_wrap_saveFile), -1);
    rb_define_module_function(mLibantargis, "fileExists", VALUEFUNC(_wrap_fileExists), -1);
    rb_define_module_function(mLibantargis, "getDirectory", VALUEFUNC(_wrap_getDirectory), -1);
    rb_define_module_function(mLibantargis, "checkFileName", VALUEFUNC(_wrap_checkFileName), -1);
    rb_define_module_function(mLibantargis, "getWriteDir", VALUEFUNC(_wrap_getWriteDir), -1);
    rb_define_module_function(mLibantargis, "findFile", VALUEFUNC(_wrap_findFile), -1);
    rb_define_module_function(mLibantargis, "addPath", VALUEFUNC(_wrap_addPath), -1);
    rb_define_module_function(mLibantargis, "disown_AGPaintTarget", VALUEFUNC(_wrap_disown_AGPaintTarget), -1);
    
    cAGPaintTarget.klass = rb_define_class_under(mLibantargis, "AGPaintTarget", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGPaintTarget, (void *) &cAGPaintTarget);
    rb_define_alloc_func(cAGPaintTarget.klass, _wrap_AGPaintTarget_allocate);
    rb_define_method(cAGPaintTarget.klass, "initialize", VALUEFUNC(_wrap_new_AGPaintTarget), -1);
    rb_define_method(cAGPaintTarget.klass, "blitTri", VALUEFUNC(_wrap_AGPaintTarget_blitTri), -1);
    rb_define_method(cAGPaintTarget.klass, "blit", VALUEFUNC(_wrap_AGPaintTarget_blit), -1);
    rb_define_method(cAGPaintTarget.klass, "drawLine", VALUEFUNC(_wrap_AGPaintTarget_drawLine), -1);
    rb_define_method(cAGPaintTarget.klass, "fillRect", VALUEFUNC(_wrap_AGPaintTarget_fillRect), -1);
    rb_define_method(cAGPaintTarget.klass, "fillRects", VALUEFUNC(_wrap_AGPaintTarget_fillRects), -1);
    rb_define_method(cAGPaintTarget.klass, "getRect", VALUEFUNC(_wrap_AGPaintTarget_getRect), -1);
    rb_define_method(cAGPaintTarget.klass, "putPixel", VALUEFUNC(_wrap_AGPaintTarget_putPixel), -1);
    rb_define_method(cAGPaintTarget.klass, "getPixel", VALUEFUNC(_wrap_AGPaintTarget_getPixel), -1);
    rb_define_method(cAGPaintTarget.klass, "beginPaint", VALUEFUNC(_wrap_AGPaintTarget_beginPaint), -1);
    rb_define_method(cAGPaintTarget.klass, "endPaint", VALUEFUNC(_wrap_AGPaintTarget_endPaint), -1);
    cAGPaintTarget.mark = 0;
    cAGPaintTarget.destroy = (void (*)(void *)) free_AGPaintTarget;
    rb_define_module_function(mLibantargis, "beginRender", VALUEFUNC(_wrap_beginRender), -1);
    rb_define_module_function(mLibantargis, "endRender", VALUEFUNC(_wrap_endRender), -1);
    rb_define_module_function(mLibantargis, "isRendering", VALUEFUNC(_wrap_isRendering), -1);
    
    cAGInternalSurface.klass = rb_define_class_under(mLibantargis, "AGInternalSurface", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGInternalSurface, (void *) &cAGInternalSurface);
    rb_define_alloc_func(cAGInternalSurface.klass, _wrap_AGInternalSurface_allocate);
    rb_define_method(cAGInternalSurface.klass, "initialize", VALUEFUNC(_wrap_new_AGInternalSurface), -1);
    rb_define_method(cAGInternalSurface.klass, "sdlTexture=", VALUEFUNC(_wrap_AGInternalSurface_sdlTexture_set), -1);
    rb_define_method(cAGInternalSurface.klass, "sdlTexture", VALUEFUNC(_wrap_AGInternalSurface_sdlTexture_get), -1);
    rb_define_method(cAGInternalSurface.klass, "glTexture=", VALUEFUNC(_wrap_AGInternalSurface_glTexture_set), -1);
    rb_define_method(cAGInternalSurface.klass, "glTexture", VALUEFUNC(_wrap_AGInternalSurface_glTexture_get), -1);
    rb_define_method(cAGInternalSurface.klass, "surface=", VALUEFUNC(_wrap_AGInternalSurface_surface_set), -1);
    rb_define_method(cAGInternalSurface.klass, "surface", VALUEFUNC(_wrap_AGInternalSurface_surface_get), -1);
    rb_define_method(cAGInternalSurface.klass, "version=", VALUEFUNC(_wrap_AGInternalSurface_version_set), -1);
    rb_define_method(cAGInternalSurface.klass, "version", VALUEFUNC(_wrap_AGInternalSurface_version_get), -1);
    cAGInternalSurface.mark = 0;
    cAGInternalSurface.destroy = (void (*)(void *)) free_AGInternalSurface;
    rb_define_module_function(mLibantargis, "disown_AGDecryptor", VALUEFUNC(_wrap_disown_AGDecryptor), -1);
    
    cAGDecryptor.klass = rb_define_class_under(mLibantargis, "AGDecryptor", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGDecryptor, (void *) &cAGDecryptor);
    rb_define_alloc_func(cAGDecryptor.klass, _wrap_AGDecryptor_allocate);
    rb_define_method(cAGDecryptor.klass, "initialize", VALUEFUNC(_wrap_new_AGDecryptor), -1);
    rb_define_method(cAGDecryptor.klass, "decrypt", VALUEFUNC(_wrap_AGDecryptor_decrypt), -1);
    cAGDecryptor.mark = 0;
    cAGDecryptor.destroy = (void (*)(void *)) free_AGDecryptor;
    rb_define_module_function(mLibantargis, "disown_AGSurface", VALUEFUNC(_wrap_disown_AGSurface), -1);
    
    cAGSurface.klass = rb_define_class_under(mLibantargis, "AGSurface", ((swig_class *) SWIGTYPE_p_AGPaintTarget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSurface, (void *) &cAGSurface);
    rb_define_alloc_func(cAGSurface.klass, _wrap_AGSurface_allocate);
    rb_define_method(cAGSurface.klass, "initialize", VALUEFUNC(_wrap_new_AGSurface), -1);
    rb_define_method(cAGSurface.klass, "copy", VALUEFUNC(_wrap_AGSurface_copy), -1);
    rb_define_method(cAGSurface.klass, "width", VALUEFUNC(_wrap_AGSurface_width), -1);
    rb_define_method(cAGSurface.klass, "height", VALUEFUNC(_wrap_AGSurface_height), -1);
    rb_define_method(cAGSurface.klass, "getRect", VALUEFUNC(_wrap_AGSurface_getRect), -1);
    rb_define_method(cAGSurface.klass, "getSubSurface", VALUEFUNC(_wrap_AGSurface_getSubSurface), -1);
    rb_define_method(cAGSurface.klass, "valid", VALUEFUNC(_wrap_AGSurface_valid), -1);
    rb_define_method(cAGSurface.klass, "scale", VALUEFUNC(_wrap_AGSurface_scale), -1);
    rb_define_method(cAGSurface.klass, "blit", VALUEFUNC(_wrap_AGSurface_blit), -1);
    rb_define_method(cAGSurface.klass, "drawGradient", VALUEFUNC(_wrap_AGSurface_drawGradient), -1);
    rb_define_method(cAGSurface.klass, "drawGradientAlpha", VALUEFUNC(_wrap_AGSurface_drawGradientAlpha), -1);
    rb_define_method(cAGSurface.klass, "drawBorder", VALUEFUNC(_wrap_AGSurface_drawBorder), -1);
    rb_define_method(cAGSurface.klass, "putPixel", VALUEFUNC(_wrap_AGSurface_putPixel), -1);
    rb_define_method(cAGSurface.klass, "getPixel", VALUEFUNC(_wrap_AGSurface_getPixel), -1);
    rb_define_method(cAGSurface.klass, "save", VALUEFUNC(_wrap_AGSurface_save), -1);
    rb_define_singleton_method(cAGSurface.klass, "load", VALUEFUNC(_wrap_AGSurface_load), -1);
    rb_define_singleton_method(cAGSurface.klass, "loadDRM", VALUEFUNC(_wrap_AGSurface_loadDRM), -1);
    rb_define_method(cAGSurface.klass, "surface", VALUEFUNC(_wrap_AGSurface_surface), -1);
    cAGSurface.mark = 0;
    cAGSurface.destroy = (void (*)(void *)) free_AGSurface;
    rb_define_module_function(mLibantargis, "AGFreeSurface", VALUEFUNC(_wrap_AGFreeSurface), -1);
    rb_define_module_function(mLibantargis, "disown_AGTexture", VALUEFUNC(_wrap_disown_AGTexture), -1);
    
    cAGTexture.klass = rb_define_class_under(mLibantargis, "AGTexture", ((swig_class *) SWIGTYPE_p_AGPaintTarget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGTexture, (void *) &cAGTexture);
    rb_define_alloc_func(cAGTexture.klass, _wrap_AGTexture_allocate);
    rb_define_method(cAGTexture.klass, "initialize", VALUEFUNC(_wrap_new_AGTexture), -1);
    rb_define_method(cAGTexture.klass, "copy", VALUEFUNC(_wrap_AGTexture_copy), -1);
    rb_define_method(cAGTexture.klass, "width", VALUEFUNC(_wrap_AGTexture_width), -1);
    rb_define_method(cAGTexture.klass, "height", VALUEFUNC(_wrap_AGTexture_height), -1);
    rb_define_method(cAGTexture.klass, "getRect", VALUEFUNC(_wrap_AGTexture_getRect), -1);
    rb_define_method(cAGTexture.klass, "getPixel", VALUEFUNC(_wrap_AGTexture_getPixel), -1);
    rb_define_method(cAGTexture.klass, "getSurfaceWidth", VALUEFUNC(_wrap_AGTexture_getSurfaceWidth), -1);
    rb_define_method(cAGTexture.klass, "getSurfaceHeight", VALUEFUNC(_wrap_AGTexture_getSurfaceHeight), -1);
    rb_define_method(cAGTexture.klass, "getTextureWidth", VALUEFUNC(_wrap_AGTexture_getTextureWidth), -1);
    rb_define_method(cAGTexture.klass, "getTextureHeight", VALUEFUNC(_wrap_AGTexture_getTextureHeight), -1);
    rb_define_method(cAGTexture.klass, "getTW", VALUEFUNC(_wrap_AGTexture_getTW), -1);
    rb_define_method(cAGTexture.klass, "getTH", VALUEFUNC(_wrap_AGTexture_getTH), -1);
    rb_define_method(cAGTexture.klass, "hasTexture", VALUEFUNC(_wrap_AGTexture_hasTexture), -1);
    rb_define_method(cAGTexture.klass, "textureUsed", VALUEFUNC(_wrap_AGTexture_textureUsed), -1);
    rb_define_method(cAGTexture.klass, "clearTexture", VALUEFUNC(_wrap_AGTexture_clearTexture), -1);
    rb_define_method(cAGTexture.klass, "clearTextureUsed", VALUEFUNC(_wrap_AGTexture_clearTextureUsed), -1);
    rb_define_method(cAGTexture.klass, "useTexture", VALUEFUNC(_wrap_AGTexture_useTexture), -1);
    rb_define_method(cAGTexture.klass, "beginPaint", VALUEFUNC(_wrap_AGTexture_beginPaint), -1);
    rb_define_method(cAGTexture.klass, "endPaint", VALUEFUNC(_wrap_AGTexture_endPaint), -1);
    rb_define_method(cAGTexture.klass, "putPixel", VALUEFUNC(_wrap_AGTexture_putPixel), -1);
    rb_define_method(cAGTexture.klass, "fillRect", VALUEFUNC(_wrap_AGTexture_fillRect), -1);
    rb_define_method(cAGTexture.klass, "blit", VALUEFUNC(_wrap_AGTexture_blit), -1);
    rb_define_method(cAGTexture.klass, "drawLine", VALUEFUNC(_wrap_AGTexture_drawLine), -1);
    rb_define_method(cAGTexture.klass, "drawGradient", VALUEFUNC(_wrap_AGTexture_drawGradient), -1);
    rb_define_method(cAGTexture.klass, "drawGradientAlpha", VALUEFUNC(_wrap_AGTexture_drawGradientAlpha), -1);
    rb_define_method(cAGTexture.klass, "setWrapping", VALUEFUNC(_wrap_AGTexture_setWrapping), -1);
    rb_define_method(cAGTexture.klass, "setFilter", VALUEFUNC(_wrap_AGTexture_setFilter), -1);
    rb_define_method(cAGTexture.klass, "setClamp", VALUEFUNC(_wrap_AGTexture_setClamp), -1);
    rb_define_method(cAGTexture.klass, "glTexture", VALUEFUNC(_wrap_AGTexture_glTexture), -1);
    rb_define_method(cAGTexture.klass, "sdlTexture", VALUEFUNC(_wrap_AGTexture_sdlTexture), -1);
    rb_define_method(cAGTexture.klass, "is3d", VALUEFUNC(_wrap_AGTexture_is3d), -1);
    cAGTexture.mark = 0;
    cAGTexture.destroy = (void (*)(void *)) free_AGTexture;
    rb_define_module_function(mLibantargis, "getSurfaceManager", VALUEFUNC(_wrap_getSurfaceManager), -1);
    
    cAGSurfaceManager.klass = rb_define_class_under(mLibantargis, "AGSurfaceManager", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGSurfaceManager, (void *) &cAGSurfaceManager);
    rb_undef_alloc_func(cAGSurfaceManager.klass);
    rb_define_method(cAGSurfaceManager.klass, "registerMe", VALUEFUNC(_wrap_AGSurfaceManager_registerMe), -1);
    rb_define_method(cAGSurfaceManager.klass, "deregisterMe", VALUEFUNC(_wrap_AGSurfaceManager_deregisterMe), -1);
    rb_define_method(cAGSurfaceManager.klass, "cleanup", VALUEFUNC(_wrap_AGSurfaceManager_cleanup), -1);
    rb_define_method(cAGSurfaceManager.klass, "clear", VALUEFUNC(_wrap_AGSurfaceManager_clear), -1);
    rb_define_method(cAGSurfaceManager.klass, "getUsedTexMem", VALUEFUNC(_wrap_AGSurfaceManager_getUsedTexMem), -1);
    cAGSurfaceManager.mark = 0;
    cAGSurfaceManager.destroy = (void (*)(void *)) free_AGSurfaceManager;
    rb_define_module_function(mLibantargis, "disown_AGImage", VALUEFUNC(_wrap_disown_AGImage), -1);
    
    cAGImage.klass = rb_define_class_under(mLibantargis, "AGImage", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGImage, (void *) &cAGImage);
    rb_define_alloc_func(cAGImage.klass, _wrap_AGImage_allocate);
    rb_define_method(cAGImage.klass, "initialize", VALUEFUNC(_wrap_new_AGImage), -1);
    rb_define_method(cAGImage.klass, "draw", VALUEFUNC(_wrap_AGImage_draw), -1);
    rb_define_method(cAGImage.klass, "setSurface", VALUEFUNC(_wrap_AGImage_setSurface), -1);
    rb_define_method(cAGImage.klass, "setTexture", VALUEFUNC(_wrap_AGImage_setTexture), -1);
    rb_define_method(cAGImage.klass, "useTextures", VALUEFUNC(_wrap_AGImage_useTextures), -1);
    rb_define_method(cAGImage.klass, "setCenter", VALUEFUNC(_wrap_AGImage_setCenter), -1);
    cAGImage.mark = (void (*)(void *)) general_markfunc;
    cAGImage.destroy = (void (*)(void *)) free_AGImage;
    rb_define_module_function(mLibantargis, "disown_AGLayoutCreator", VALUEFUNC(_wrap_disown_AGLayoutCreator), -1);
    
    cAGLayoutCreator.klass = rb_define_class_under(mLibantargis, "AGLayoutCreator", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayoutCreator, (void *) &cAGLayoutCreator);
    rb_define_alloc_func(cAGLayoutCreator.klass, _wrap_AGLayoutCreator_allocate);
    rb_define_method(cAGLayoutCreator.klass, "initialize", VALUEFUNC(_wrap_new_AGLayoutCreator), -1);
    rb_define_method(cAGLayoutCreator.klass, "create", VALUEFUNC(_wrap_AGLayoutCreator_create), -1);
    cAGLayoutCreator.mark = 0;
    cAGLayoutCreator.destroy = (void (*)(void *)) free_AGLayoutCreator;
    rb_define_module_function(mLibantargis, "getLayoutFactory", VALUEFUNC(_wrap_getLayoutFactory), -1);
    
    cAGLayoutFactory.klass = rb_define_class_under(mLibantargis, "AGLayoutFactory", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayoutFactory, (void *) &cAGLayoutFactory);
    rb_undef_alloc_func(cAGLayoutFactory.klass);
    rb_define_method(cAGLayoutFactory.klass, "addCreator", VALUEFUNC(_wrap_AGLayoutFactory_addCreator), -1);
    rb_define_method(cAGLayoutFactory.klass, "create", VALUEFUNC(_wrap_AGLayoutFactory_create), -1);
    cAGLayoutFactory.mark = 0;
    cAGLayoutFactory.destroy = (void (*)(void *)) free_AGLayoutFactory;
    
    cAGListBoxItem.klass = rb_define_class_under(mLibantargis, "AGListBoxItem", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGListBoxItem, (void *) &cAGListBoxItem);
    rb_define_alloc_func(cAGListBoxItem.klass, _wrap_AGListBoxItem_allocate);
    rb_define_method(cAGListBoxItem.klass, "initialize", VALUEFUNC(_wrap_new_AGListBoxItem), -1);
    rb_define_method(cAGListBoxItem.klass, "id=", VALUEFUNC(_wrap_AGListBoxItem_id_set), -1);
    rb_define_method(cAGListBoxItem.klass, "id", VALUEFUNC(_wrap_AGListBoxItem_id_get), -1);
    rb_define_method(cAGListBoxItem.klass, "value=", VALUEFUNC(_wrap_AGListBoxItem_value_set), -1);
    rb_define_method(cAGListBoxItem.klass, "value", VALUEFUNC(_wrap_AGListBoxItem_value_get), -1);
    cAGListBoxItem.mark = 0;
    cAGListBoxItem.destroy = (void (*)(void *)) free_AGListBoxItem;
    rb_define_module_function(mLibantargis, "disown_AGListBox", VALUEFUNC(_wrap_disown_AGListBox), -1);
    
    cAGListBox.klass = rb_define_class_under(mLibantargis, "AGListBox", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGListBox, (void *) &cAGListBox);
    rb_define_alloc_func(cAGListBox.klass, _wrap_AGListBox_allocate);
    rb_define_method(cAGListBox.klass, "initialize", VALUEFUNC(_wrap_new_AGListBox), -1);
    rb_define_method(cAGListBox.klass, "insertItem", VALUEFUNC(_wrap_AGListBox_insertItem), -1);
    rb_define_method(cAGListBox.klass, "selectItem", VALUEFUNC(_wrap_AGListBox_selectItem), -1);
    rb_define_method(cAGListBox.klass, "getSelectedID", VALUEFUNC(_wrap_AGListBox_getSelectedID), -1);
    rb_define_method(cAGListBox.klass, "getSelectedValue", VALUEFUNC(_wrap_AGListBox_getSelectedValue), -1);
    rb_define_method(cAGListBox.klass, "eventKeyDown", VALUEFUNC(_wrap_AGListBox_eventKeyDown), -1);
    rb_define_method(cAGListBox.klass, "sigSelect=", VALUEFUNC(_wrap_AGListBox_sigSelect_set), -1);
    rb_define_method(cAGListBox.klass, "sigSelect", VALUEFUNC(_wrap_AGListBox_sigSelect_get), -1);
    rb_define_method(cAGListBox.klass, "sigDoubleClick=", VALUEFUNC(_wrap_AGListBox_sigDoubleClick_set), -1);
    rb_define_method(cAGListBox.klass, "sigDoubleClick", VALUEFUNC(_wrap_AGListBox_sigDoubleClick_get), -1);
    rb_define_method(cAGListBox.klass, "draw", VALUEFUNC(_wrap_AGListBox_draw), -1);
    rb_define_method(cAGListBox.klass, "eventMouseClick", VALUEFUNC(_wrap_AGListBox_eventMouseClick), -1);
    rb_define_method(cAGListBox.klass, "clearList", VALUEFUNC(_wrap_AGListBox_clearList), -1);
    cAGListBox.mark = (void (*)(void *)) general_markfunc;
    cAGListBox.destroy = (void (*)(void *)) free_AGListBox;
    rb_define_module_function(mLibantargis, "toAGListBox", VALUEFUNC(_wrap_toAGListBox), -1);
    rb_define_module_function(mLibantargis, "disown_AGMain", VALUEFUNC(_wrap_disown_AGMain), -1);
    
    cAGMain.klass = rb_define_class_under(mLibantargis, "AGMain", ((swig_class *) SWIGTYPE_p_AGRubyObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMain, (void *) &cAGMain);
    rb_define_alloc_func(cAGMain.klass, _wrap_AGMain_allocate);
    rb_define_method(cAGMain.klass, "initialize", VALUEFUNC(_wrap_new_AGMain), -1);
    rb_define_method(cAGMain.klass, "flip", VALUEFUNC(_wrap_AGMain_flip), -1);
    rb_define_method(cAGMain.klass, "changeRes", VALUEFUNC(_wrap_AGMain_changeRes), -1);
    rb_define_method(cAGMain.klass, "toggleFull", VALUEFUNC(_wrap_AGMain_toggleFull), -1);
    rb_define_method(cAGMain.klass, "width", VALUEFUNC(_wrap_AGMain_width), -1);
    rb_define_method(cAGMain.klass, "height", VALUEFUNC(_wrap_AGMain_height), -1);
    rb_define_method(cAGMain.klass, "setIcon", VALUEFUNC(_wrap_AGMain_setIcon), -1);
    rb_define_method(cAGMain.klass, "setCaption", VALUEFUNC(_wrap_AGMain_setCaption), -1);
    rb_define_method(cAGMain.klass, "fullscreen", VALUEFUNC(_wrap_AGMain_fullscreen), -1);
    cAGMain.mark = (void (*)(void *)) general_markfunc;
    cAGMain.destroy = (void (*)(void *)) free_AGMain;
    rb_define_module_function(mLibantargis, "getMain", VALUEFUNC(_wrap_getMain), -1);
    rb_define_module_function(mLibantargis, "hasQuit", VALUEFUNC(_wrap_hasQuit), -1);
    
    cAGMenu.klass = rb_define_class_under(mLibantargis, "AGMenu", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMenu, (void *) &cAGMenu);
    rb_define_alloc_func(cAGMenu.klass, _wrap_AGMenu_allocate);
    rb_define_method(cAGMenu.klass, "initialize", VALUEFUNC(_wrap_new_AGMenu), -1);
    rb_define_method(cAGMenu.klass, "show", VALUEFUNC(_wrap_AGMenu_show), -1);
    rb_define_method(cAGMenu.klass, "addItem", VALUEFUNC(_wrap_AGMenu_addItem), -1);
    rb_define_method(cAGMenu.klass, "addMenu", VALUEFUNC(_wrap_AGMenu_addMenu), -1);
    rb_define_method(cAGMenu.klass, "draw", VALUEFUNC(_wrap_AGMenu_draw), -1);
    rb_define_method(cAGMenu.klass, "eventItemSelected", VALUEFUNC(_wrap_AGMenu_eventItemSelected), -1);
    rb_define_method(cAGMenu.klass, "eventItemClicked", VALUEFUNC(_wrap_AGMenu_eventItemClicked), -1);
    rb_define_method(cAGMenu.klass, "sigSelected=", VALUEFUNC(_wrap_AGMenu_sigSelected_set), -1);
    rb_define_method(cAGMenu.klass, "sigSelected", VALUEFUNC(_wrap_AGMenu_sigSelected_get), -1);
    cAGMenu.mark = (void (*)(void *)) general_markfunc;
    cAGMenu.destroy = (void (*)(void *)) free_AGMenu;
    rb_define_module_function(mLibantargis, "disown_AGMenuItem", VALUEFUNC(_wrap_disown_AGMenuItem), -1);
    
    cAGMenuItem.klass = rb_define_class_under(mLibantargis, "AGMenuItem", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMenuItem, (void *) &cAGMenuItem);
    rb_define_alloc_func(cAGMenuItem.klass, _wrap_AGMenuItem_allocate);
    rb_define_method(cAGMenuItem.klass, "initialize", VALUEFUNC(_wrap_new_AGMenuItem), -1);
    rb_define_method(cAGMenuItem.klass, "draw", VALUEFUNC(_wrap_AGMenuItem_draw), -1);
    rb_define_method(cAGMenuItem.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGMenuItem_eventMouseEnter), -1);
    rb_define_method(cAGMenuItem.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGMenuItem_eventMouseLeave), -1);
    rb_define_method(cAGMenuItem.klass, "getSelected", VALUEFUNC(_wrap_AGMenuItem_getSelected), -1);
    rb_define_method(cAGMenuItem.klass, "unSelect", VALUEFUNC(_wrap_AGMenuItem_unSelect), -1);
    rb_define_method(cAGMenuItem.klass, "getName", VALUEFUNC(_wrap_AGMenuItem_getName), -1);
    rb_define_method(cAGMenuItem.klass, "eventMouseClick", VALUEFUNC(_wrap_AGMenuItem_eventMouseClick), -1);
    rb_define_method(cAGMenuItem.klass, "eventSelect", VALUEFUNC(_wrap_AGMenuItem_eventSelect), -1);
    rb_define_method(cAGMenuItem.klass, "eventUnselect", VALUEFUNC(_wrap_AGMenuItem_eventUnselect), -1);
    cAGMenuItem.mark = (void (*)(void *)) general_markfunc;
    cAGMenuItem.destroy = (void (*)(void *)) free_AGMenuItem;
    rb_define_module_function(mLibantargis, "disown_AGSubMenu", VALUEFUNC(_wrap_disown_AGSubMenu), -1);
    
    cAGSubMenu.klass = rb_define_class_under(mLibantargis, "AGSubMenu", ((swig_class *) SWIGTYPE_p_AGMenuItem->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSubMenu, (void *) &cAGSubMenu);
    rb_define_alloc_func(cAGSubMenu.klass, _wrap_AGSubMenu_allocate);
    rb_define_method(cAGSubMenu.klass, "initialize", VALUEFUNC(_wrap_new_AGSubMenu), -1);
    rb_define_method(cAGSubMenu.klass, "getMenu", VALUEFUNC(_wrap_AGSubMenu_getMenu), -1);
    rb_define_method(cAGSubMenu.klass, "eventSelect", VALUEFUNC(_wrap_AGSubMenu_eventSelect), -1);
    rb_define_method(cAGSubMenu.klass, "eventUnselect", VALUEFUNC(_wrap_AGSubMenu_eventUnselect), -1);
    rb_define_method(cAGSubMenu.klass, "eventMouseClick", VALUEFUNC(_wrap_AGSubMenu_eventMouseClick), -1);
    cAGSubMenu.mark = (void (*)(void *)) general_markfunc;
    cAGSubMenu.destroy = (void (*)(void *)) free_AGSubMenu;
    rb_define_module_function(mLibantargis, "getSoundManager", VALUEFUNC(_wrap_getSoundManager), -1);
    rb_define_module_function(mLibantargis, "disown_AGSound", VALUEFUNC(_wrap_disown_AGSound), -1);
    
    cAGSound.klass = rb_define_class_under(mLibantargis, "AGSound", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSound, (void *) &cAGSound);
    rb_define_alloc_func(cAGSound.klass, _wrap_AGSound_allocate);
    rb_define_method(cAGSound.klass, "initialize", VALUEFUNC(_wrap_new_AGSound), -1);
    rb_define_method(cAGSound.klass, "playMp3", VALUEFUNC(_wrap_AGSound_playMp3), -1);
    rb_define_method(cAGSound.klass, "stopMp3", VALUEFUNC(_wrap_AGSound_stopMp3), -1);
    rb_define_method(cAGSound.klass, "checkFinished", VALUEFUNC(_wrap_AGSound_checkFinished), -1);
    rb_define_method(cAGSound.klass, "fadeOutMusic", VALUEFUNC(_wrap_AGSound_fadeOutMusic), -1);
    rb_define_method(cAGSound.klass, "playWave", VALUEFUNC(_wrap_AGSound_playWave), -1);
    rb_define_method(cAGSound.klass, "loopPlay", VALUEFUNC(_wrap_AGSound_loopPlay), -1);
    rb_define_method(cAGSound.klass, "stopChannel", VALUEFUNC(_wrap_AGSound_stopChannel), -1);
    rb_define_method(cAGSound.klass, "stopAllChannels", VALUEFUNC(_wrap_AGSound_stopAllChannels), -1);
    rb_define_method(cAGSound.klass, "volumeSound", VALUEFUNC(_wrap_AGSound_volumeSound), -1);
    rb_define_method(cAGSound.klass, "volumeMusic", VALUEFUNC(_wrap_AGSound_volumeMusic), -1);
    rb_define_method(cAGSound.klass, "loadWave", VALUEFUNC(_wrap_AGSound_loadWave), -1);
    rb_define_method(cAGSound.klass, "sigMp3Finished=", VALUEFUNC(_wrap_AGSound_sigMp3Finished_set), -1);
    rb_define_method(cAGSound.klass, "sigMp3Finished", VALUEFUNC(_wrap_AGSound_sigMp3Finished_get), -1);
    cAGSound.mark = (void (*)(void *)) general_markfunc;
    cAGSound.destroy = (void (*)(void *)) free_AGSound;
    
    cAGProjection.klass = rb_define_class_under(mLibantargis, "AGProjection", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGProjection, (void *) &cAGProjection);
    rb_define_alloc_func(cAGProjection.klass, _wrap_AGProjection_allocate);
    rb_define_method(cAGProjection.klass, "initialize", VALUEFUNC(_wrap_new_AGProjection), -1);
    rb_define_method(cAGProjection.klass, "a=", VALUEFUNC(_wrap_AGProjection_a_set), -1);
    rb_define_method(cAGProjection.klass, "a", VALUEFUNC(_wrap_AGProjection_a_get), -1);
    rb_define_method(cAGProjection.klass, "clip=", VALUEFUNC(_wrap_AGProjection_clip_set), -1);
    rb_define_method(cAGProjection.klass, "clip", VALUEFUNC(_wrap_AGProjection_clip_get), -1);
    rb_define_method(cAGProjection.klass, "pointOk", VALUEFUNC(_wrap_AGProjection_pointOk), -1);
    rb_define_method(cAGProjection.klass, "project", VALUEFUNC(_wrap_AGProjection_project), -1);
    rb_define_method(cAGProjection.klass, "clipRect", VALUEFUNC(_wrap_AGProjection_clipRect), -1);
    rb_define_method(cAGProjection.klass, "clipLine", VALUEFUNC(_wrap_AGProjection_clipLine), -1);
    rb_define_method(cAGProjection.klass, "translate", VALUEFUNC(_wrap_AGProjection_translate), -1);
    rb_define_method(cAGProjection.klass, "setClip", VALUEFUNC(_wrap_AGProjection_setClip), -1);
    rb_define_method(cAGProjection.klass, "getRect", VALUEFUNC(_wrap_AGProjection_getRect), -1);
    cAGProjection.mark = 0;
    cAGProjection.destroy = (void (*)(void *)) free_AGProjection;
    
    cAGPainter.klass = rb_define_class_under(mLibantargis, "AGPainter", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGPainter, (void *) &cAGPainter);
    rb_define_alloc_func(cAGPainter.klass, _wrap_AGPainter_allocate);
    rb_define_method(cAGPainter.klass, "initialize", VALUEFUNC(_wrap_new_AGPainter), -1);
    rb_define_method(cAGPainter.klass, "putPixel", VALUEFUNC(_wrap_AGPainter_putPixel), -1);
    rb_define_method(cAGPainter.klass, "getPixel", VALUEFUNC(_wrap_AGPainter_getPixel), -1);
    rb_define_method(cAGPainter.klass, "drawCircle", VALUEFUNC(_wrap_AGPainter_drawCircle), -1);
    rb_define_method(cAGPainter.klass, "blitTri", VALUEFUNC(_wrap_AGPainter_blitTri), -1);
    rb_define_method(cAGPainter.klass, "blit", VALUEFUNC(_wrap_AGPainter_blit), -1);
    rb_define_method(cAGPainter.klass, "tile", VALUEFUNC(_wrap_AGPainter_tile), -1);
    rb_define_method(cAGPainter.klass, "renderText", VALUEFUNC(_wrap_AGPainter_renderText), -1);
    rb_define_method(cAGPainter.klass, "getRect", VALUEFUNC(_wrap_AGPainter_getRect), -1);
    rb_define_method(cAGPainter.klass, "drawGradient", VALUEFUNC(_wrap_AGPainter_drawGradient), -1);
    rb_define_method(cAGPainter.klass, "drawBorder", VALUEFUNC(_wrap_AGPainter_drawBorder), -1);
    rb_define_method(cAGPainter.klass, "fillRect", VALUEFUNC(_wrap_AGPainter_fillRect), -1);
    rb_define_method(cAGPainter.klass, "drawLine", VALUEFUNC(_wrap_AGPainter_drawLine), -1);
    rb_define_method(cAGPainter.klass, "drawPoint", VALUEFUNC(_wrap_AGPainter_drawPoint), -1);
    rb_define_method(cAGPainter.klass, "fillRects", VALUEFUNC(_wrap_AGPainter_fillRects), -1);
    rb_define_method(cAGPainter.klass, "pushMatrix", VALUEFUNC(_wrap_AGPainter_pushMatrix), -1);
    rb_define_method(cAGPainter.klass, "popMatrix", VALUEFUNC(_wrap_AGPainter_popMatrix), -1);
    rb_define_method(cAGPainter.klass, "translate", VALUEFUNC(_wrap_AGPainter_translate), -1);
    rb_define_method(cAGPainter.klass, "scale", VALUEFUNC(_wrap_AGPainter_scale), -1);
    rb_define_method(cAGPainter.klass, "clip", VALUEFUNC(_wrap_AGPainter_clip), -1);
    rb_define_method(cAGPainter.klass, "transform", VALUEFUNC(_wrap_AGPainter_transform), -1);
    rb_define_method(cAGPainter.klass, "project", VALUEFUNC(_wrap_AGPainter_project), -1);
    rb_define_method(cAGPainter.klass, "pointOk", VALUEFUNC(_wrap_AGPainter_pointOk), -1);
    cAGPainter.mark = 0;
    cAGPainter.destroy = (void (*)(void *)) free_AGPainter;
    rb_define_module_function(mLibantargis, "toPNG", VALUEFUNC(_wrap_toPNG), -1);
    rb_define_module_function(mLibantargis, "fromPNG", VALUEFUNC(_wrap_fromPNG), -1);
    rb_define_module_function(mLibantargis, "disown_AGRadioGroup", VALUEFUNC(_wrap_disown_AGRadioGroup), -1);
    
    cAGRadioGroup.klass = rb_define_class_under(mLibantargis, "AGRadioGroup", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGRadioGroup, (void *) &cAGRadioGroup);
    rb_define_alloc_func(cAGRadioGroup.klass, _wrap_AGRadioGroup_allocate);
    rb_define_method(cAGRadioGroup.klass, "initialize", VALUEFUNC(_wrap_new_AGRadioGroup), -1);
    rb_define_method(cAGRadioGroup.klass, "eventChange", VALUEFUNC(_wrap_AGRadioGroup_eventChange), -1);
    rb_define_method(cAGRadioGroup.klass, "add", VALUEFUNC(_wrap_AGRadioGroup_add), -1);
    rb_define_method(cAGRadioGroup.klass, "erase", VALUEFUNC(_wrap_AGRadioGroup_erase), -1);
    rb_define_method(cAGRadioGroup.klass, "sigChanged=", VALUEFUNC(_wrap_AGRadioGroup_sigChanged_set), -1);
    rb_define_method(cAGRadioGroup.klass, "sigChanged", VALUEFUNC(_wrap_AGRadioGroup_sigChanged_get), -1);
    cAGRadioGroup.mark = (void (*)(void *)) general_markfunc;
    cAGRadioGroup.destroy = (void (*)(void *)) free_AGRadioGroup;
    rb_define_module_function(mLibantargis, "disown_AGRadio", VALUEFUNC(_wrap_disown_AGRadio), -1);
    
    cAGRadio.klass = rb_define_class_under(mLibantargis, "AGRadio", ((swig_class *) SWIGTYPE_p_AGCheckBox->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGRadio, (void *) &cAGRadio);
    rb_define_alloc_func(cAGRadio.klass, _wrap_AGRadio_allocate);
    rb_define_method(cAGRadio.klass, "initialize", VALUEFUNC(_wrap_new_AGRadio), -1);
    rb_define_method(cAGRadio.klass, "setGroup", VALUEFUNC(_wrap_AGRadio_setGroup), -1);
    rb_define_method(cAGRadio.klass, "eventMouseClick", VALUEFUNC(_wrap_AGRadio_eventMouseClick), -1);
    rb_define_method(cAGRadio.klass, "deselect", VALUEFUNC(_wrap_AGRadio_deselect), -1);
    rb_define_method(cAGRadio.klass, "setChecked", VALUEFUNC(_wrap_AGRadio_setChecked), -1);
    cAGRadio.mark = (void (*)(void *)) general_markfunc;
    cAGRadio.destroy = (void (*)(void *)) free_AGRadio;
    rb_define_module_function(mLibantargis, "disown_AGScreen", VALUEFUNC(_wrap_disown_AGScreen), -1);
    
    cAGScreen.klass = rb_define_class_under(mLibantargis, "AGScreen", ((swig_class *) SWIGTYPE_p_AGPaintTarget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGScreen, (void *) &cAGScreen);
    rb_define_alloc_func(cAGScreen.klass, _wrap_AGScreen_allocate);
    rb_define_method(cAGScreen.klass, "initialize", VALUEFUNC(_wrap_new_AGScreen), -1);
    rb_define_method(cAGScreen.klass, "begin", VALUEFUNC(_wrap_AGScreen_begin), -1);
    rb_define_method(cAGScreen.klass, "flip", VALUEFUNC(_wrap_AGScreen_flip), -1);
    rb_define_method(cAGScreen.klass, "getWidth", VALUEFUNC(_wrap_AGScreen_getWidth), -1);
    rb_define_method(cAGScreen.klass, "getHeight", VALUEFUNC(_wrap_AGScreen_getHeight), -1);
    cAGScreen.mark = 0;
    cAGScreen.destroy = (void (*)(void *)) free_AGScreen;
    rb_define_module_function(mLibantargis, "getScreen", VALUEFUNC(_wrap_getScreen), -1);
    rb_define_module_function(mLibantargis, "setScreen", VALUEFUNC(_wrap_setScreen), -1);
    rb_define_module_function(mLibantargis, "disown_AGTable", VALUEFUNC(_wrap_disown_AGTable), -1);
    
    cAGTable.klass = rb_define_class_under(mLibantargis, "AGTable", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGTable, (void *) &cAGTable);
    rb_define_alloc_func(cAGTable.klass, _wrap_AGTable_allocate);
    rb_define_method(cAGTable.klass, "initialize", VALUEFUNC(_wrap_new_AGTable), -1);
    rb_define_method(cAGTable.klass, "addFixedColumn", VALUEFUNC(_wrap_AGTable_addFixedColumn), -1);
    rb_define_method(cAGTable.klass, "addFixedRow", VALUEFUNC(_wrap_AGTable_addFixedRow), -1);
    rb_define_method(cAGTable.klass, "addColumn", VALUEFUNC(_wrap_AGTable_addColumn), -1);
    rb_define_method(cAGTable.klass, "addRow", VALUEFUNC(_wrap_AGTable_addRow), -1);
    rb_define_method(cAGTable.klass, "addChild", VALUEFUNC(_wrap_AGTable_addChild), -1);
    rb_define_method(cAGTable.klass, "getClientRect", VALUEFUNC(_wrap_AGTable_getClientRect), -1);
    rb_define_method(cAGTable.klass, "arrange", VALUEFUNC(_wrap_AGTable_arrange), -1);
    rb_define_method(cAGTable.klass, "setWidth", VALUEFUNC(_wrap_AGTable_setWidth), -1);
    rb_define_method(cAGTable.klass, "setHeight", VALUEFUNC(_wrap_AGTable_setHeight), -1);
    rb_define_method(cAGTable.klass, "getRows", VALUEFUNC(_wrap_AGTable_getRows), -1);
    rb_define_method(cAGTable.klass, "getColumns", VALUEFUNC(_wrap_AGTable_getColumns), -1);
    cAGTable.mark = (void (*)(void *)) general_markfunc;
    cAGTable.destroy = (void (*)(void *)) free_AGTable;
    rb_define_module_function(mLibantargis, "getTextureCache", VALUEFUNC(_wrap_getTextureCache), -1);
    
    cAGTextureCache.klass = rb_define_class_under(mLibantargis, "AGTextureCache", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTextureCache, (void *) &cAGTextureCache);
    rb_undef_alloc_func(cAGTextureCache.klass);
    rb_define_method(cAGTextureCache.klass, "get", VALUEFUNC(_wrap_AGTextureCache_get), -1);
    rb_define_method(cAGTextureCache.klass, "get3D", VALUEFUNC(_wrap_AGTextureCache_get3D), -1);
    cAGTextureCache.mark = 0;
    cAGTextureCache.destroy = (void (*)(void *)) free_AGTextureCache;
    rb_define_module_function(mLibantargis, "disown_AGTheme", VALUEFUNC(_wrap_disown_AGTheme), -1);
    
    cAGTheme.klass = rb_define_class_under(mLibantargis, "AGTheme", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTheme, (void *) &cAGTheme);
    rb_define_alloc_func(cAGTheme.klass, _wrap_AGTheme_allocate);
    rb_define_method(cAGTheme.klass, "initialize", VALUEFUNC(_wrap_new_AGTheme), -1);
    rb_define_method(cAGTheme.klass, "getFont", VALUEFUNC(_wrap_AGTheme_getFont), -1);
    rb_define_method(cAGTheme.klass, "getColor", VALUEFUNC(_wrap_AGTheme_getColor), -1);
    rb_define_method(cAGTheme.klass, "setFont", VALUEFUNC(_wrap_AGTheme_setFont), -1);
    rb_define_method(cAGTheme.klass, "setColor", VALUEFUNC(_wrap_AGTheme_setColor), -1);
    rb_define_method(cAGTheme.klass, "getInt", VALUEFUNC(_wrap_AGTheme_getInt), -1);
    rb_define_method(cAGTheme.klass, "setInt", VALUEFUNC(_wrap_AGTheme_setInt), -1);
    rb_define_method(cAGTheme.klass, "getSurface", VALUEFUNC(_wrap_AGTheme_getSurface), -1);
    rb_define_method(cAGTheme.klass, "setSurface", VALUEFUNC(_wrap_AGTheme_setSurface), -1);
    rb_define_method(cAGTheme.klass, "getSurfaceName", VALUEFUNC(_wrap_AGTheme_getSurfaceName), -1);
    rb_define_method(cAGTheme.klass, "setSurfaceName", VALUEFUNC(_wrap_AGTheme_setSurfaceName), -1);
    rb_define_method(cAGTheme.klass, "hasSurface", VALUEFUNC(_wrap_AGTheme_hasSurface), -1);
    rb_define_method(cAGTheme.klass, "hasColor", VALUEFUNC(_wrap_AGTheme_hasColor), -1);
    cAGTheme.mark = 0;
    cAGTheme.destroy = (void (*)(void *)) free_AGTheme;
    rb_define_module_function(mLibantargis, "getTheme", VALUEFUNC(_wrap_getTheme), -1);
    rb_define_module_function(mLibantargis, "setTheme", VALUEFUNC(_wrap_setTheme), -1);
    rb_define_module_function(mLibantargis, "loadTheme", VALUEFUNC(_wrap_loadTheme), -1);
    rb_define_module_function(mLibantargis, "loadThemeFile", VALUEFUNC(_wrap_loadThemeFile), -1);
    rb_define_module_function(mLibantargis, "addPoint", VALUEFUNC(_wrap_addPoint), -1);
    rb_define_module_function(mLibantargis, "toInt", VALUEFUNC(_wrap_toInt), -1);
    rb_define_module_function(mLibantargis, "toFloat", VALUEFUNC(_wrap_toFloat), -1);
    rb_define_module_function(mLibantargis, "fromHex", VALUEFUNC(_wrap_fromHex), -1);
    rb_define_module_function(mLibantargis, "toHex", VALUEFUNC(_wrap_toHex), -1);
    rb_define_module_function(mLibantargis, "disown_AGWindow", VALUEFUNC(_wrap_disown_AGWindow), -1);
    
    cAGWindow.klass = rb_define_class_under(mLibantargis, "AGWindow", ((swig_class *) SWIGTYPE_p_AGTable->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGWindow, (void *) &cAGWindow);
    rb_define_alloc_func(cAGWindow.klass, _wrap_AGWindow_allocate);
    rb_define_method(cAGWindow.klass, "initialize", VALUEFUNC(_wrap_new_AGWindow), -1);
    rb_define_method(cAGWindow.klass, "addChild", VALUEFUNC(_wrap_AGWindow_addChild), -1);
    rb_define_method(cAGWindow.klass, "getClient", VALUEFUNC(_wrap_AGWindow_getClient), -1);
    rb_define_method(cAGWindow.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGWindow_eventMouseButtonDown), -1);
    rb_define_method(cAGWindow.klass, "eventDragBy", VALUEFUNC(_wrap_AGWindow_eventDragBy), -1);
    rb_define_method(cAGWindow.klass, "close", VALUEFUNC(_wrap_AGWindow_close), -1);
    rb_define_method(cAGWindow.klass, "tryClose", VALUEFUNC(_wrap_AGWindow_tryClose), -1);
    rb_define_method(cAGWindow.klass, "getClientRect", VALUEFUNC(_wrap_AGWindow_getClientRect), -1);
    rb_define_method(cAGWindow.klass, "sigClose=", VALUEFUNC(_wrap_AGWindow_sigClose_set), -1);
    rb_define_method(cAGWindow.klass, "sigClose", VALUEFUNC(_wrap_AGWindow_sigClose_get), -1);
    cAGWindow.mark = (void (*)(void *)) general_markfunc;
    cAGWindow.destroy = (void (*)(void *)) free_AGWindow;
    rb_define_module_function(mLibantargis, "toAGWindow", VALUEFUNC(_wrap_toAGWindow), -1);
    rb_define_const(mLibantargis,"TERRAIN_Z", INT2NUM(1));
    rb_define_const(mLibantargis,"WATER_Z", INT2NUM(2));
    rb_define_const(mLibantargis,"DECAL_Z", INT2NUM(3));
    rb_define_const(mLibantargis,"RING_Z", INT2NUM(4));
    rb_define_const(mLibantargis,"MESH_Z", INT2NUM(5));
    rb_define_const(mLibantargis,"TREE_Z", INT2NUM(6));
    rb_define_const(mLibantargis,"PARTICLE_Z", INT2NUM(7));
    rb_define_module_function(mLibantargis, "disown_SceneNode", VALUEFUNC(_wrap_disown_SceneNode), -1);
    
    cSceneNode.klass = rb_define_class_under(mLibantargis, "SceneNode", ((swig_class *) SWIGTYPE_p_AGRubyObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_SceneNode, (void *) &cSceneNode);
    rb_define_alloc_func(cSceneNode.klass, _wrap_SceneNode_allocate);
    rb_define_method(cSceneNode.klass, "initialize", VALUEFUNC(_wrap_new_SceneNode), -1);
    rb_define_method(cSceneNode.klass, "resetScene", VALUEFUNC(_wrap_SceneNode_resetScene), -1);
    rb_define_method(cSceneNode.klass, "drawShadow", VALUEFUNC(_wrap_SceneNode_drawShadow), -1);
    rb_define_method(cSceneNode.klass, "drawDepth", VALUEFUNC(_wrap_SceneNode_drawDepth), -1);
    rb_define_method(cSceneNode.klass, "draw", VALUEFUNC(_wrap_SceneNode_draw), -1);
    rb_define_method(cSceneNode.klass, "drawPick", VALUEFUNC(_wrap_SceneNode_drawPick), -1);
    rb_define_method(cSceneNode.klass, "advance", VALUEFUNC(_wrap_SceneNode_advance), -1);
    rb_define_method(cSceneNode.klass, "getTriangles", VALUEFUNC(_wrap_SceneNode_getTriangles), -1);
    rb_define_method(cSceneNode.klass, "lineHit", VALUEFUNC(_wrap_SceneNode_lineHit), -1);
    rb_define_method(cSceneNode.klass, "sort", VALUEFUNC(_wrap_SceneNode_sort), -1);
    rb_define_method(cSceneNode.klass, "==", VALUEFUNC(_wrap_SceneNode___eq__), -1);
    rb_define_method(cSceneNode.klass, "setPos", VALUEFUNC(_wrap_SceneNode_setPos), -1);
    rb_define_method(cSceneNode.klass, "getPos", VALUEFUNC(_wrap_SceneNode_getPos), -1);
    rb_define_method(cSceneNode.klass, "setRotation", VALUEFUNC(_wrap_SceneNode_setRotation), -1);
    rb_define_method(cSceneNode.klass, "setBBox", VALUEFUNC(_wrap_SceneNode_setBBox), -1);
    rb_define_method(cSceneNode.klass, "transparent", VALUEFUNC(_wrap_SceneNode_transparent), -1);
    rb_define_method(cSceneNode.klass, "bbox", VALUEFUNC(_wrap_SceneNode_bbox), -1);
    rb_define_method(cSceneNode.klass, "getRect", VALUEFUNC(_wrap_SceneNode_getRect), -1);
    rb_define_method(cSceneNode.klass, "clear", VALUEFUNC(_wrap_SceneNode_clear), -1);
    rb_define_method(cSceneNode.klass, "getScene", VALUEFUNC(_wrap_SceneNode_getScene), -1);
    rb_define_method(cSceneNode.klass, "setVisible", VALUEFUNC(_wrap_SceneNode_setVisible), -1);
    rb_define_method(cSceneNode.klass, "visible", VALUEFUNC(_wrap_SceneNode_visible), -1);
    rb_define_method(cSceneNode.klass, "setOrder", VALUEFUNC(_wrap_SceneNode_setOrder), -1);
    rb_define_method(cSceneNode.klass, "getOrder", VALUEFUNC(_wrap_SceneNode_getOrder), -1);
    cSceneNode.mark = (void (*)(void *)) general_markfunc;
    cSceneNode.destroy = (void (*)(void *)) free_SceneNode;
    rb_define_module_function(mLibantargis, "disown_AnimMesh", VALUEFUNC(_wrap_disown_AnimMesh), -1);
    
    cAnimMesh.klass = rb_define_class_under(mLibantargis, "AnimMesh", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AnimMesh, (void *) &cAnimMesh);
    rb_define_alloc_func(cAnimMesh.klass, _wrap_AnimMesh_allocate);
    rb_define_method(cAnimMesh.klass, "initialize", VALUEFUNC(_wrap_new_AnimMesh), -1);
    rb_define_method(cAnimMesh.klass, "setTransform", VALUEFUNC(_wrap_AnimMesh_setTransform), -1);
    rb_define_method(cAnimMesh.klass, "getAnimation", VALUEFUNC(_wrap_AnimMesh_getAnimation), -1);
    rb_define_method(cAnimMesh.klass, "setAnimation", VALUEFUNC(_wrap_AnimMesh_setAnimation), -1);
    rb_define_method(cAnimMesh.klass, "setPos", VALUEFUNC(_wrap_AnimMesh_setPos), -1);
    rb_define_method(cAnimMesh.klass, "setRotation", VALUEFUNC(_wrap_AnimMesh_setRotation), -1);
    rb_define_method(cAnimMesh.klass, "getData", VALUEFUNC(_wrap_AnimMesh_getData), -1);
    rb_define_method(cAnimMesh.klass, "draw", VALUEFUNC(_wrap_AnimMesh_draw), -1);
    rb_define_method(cAnimMesh.klass, "drawDepth", VALUEFUNC(_wrap_AnimMesh_drawDepth), -1);
    rb_define_method(cAnimMesh.klass, "drawPick", VALUEFUNC(_wrap_AnimMesh_drawPick), -1);
    rb_define_method(cAnimMesh.klass, "advance", VALUEFUNC(_wrap_AnimMesh_advance), -1);
    rb_define_method(cAnimMesh.klass, "mark", VALUEFUNC(_wrap_AnimMesh_mark), -1);
    rb_define_method(cAnimMesh.klass, "setEntity", VALUEFUNC(_wrap_AnimMesh_setEntity), -1);
    rb_define_method(cAnimMesh.klass, "getTriangles", VALUEFUNC(_wrap_AnimMesh_getTriangles), -1);
    cAnimMesh.mark = (void (*)(void *)) general_markfunc;
    cAnimMesh.destroy = (void (*)(void *)) free_AnimMesh;
    
    cKeyFrame.klass = rb_define_class_under(mLibantargis, "KeyFrame", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_KeyFrame, (void *) &cKeyFrame);
    rb_define_alloc_func(cKeyFrame.klass, _wrap_KeyFrame_allocate);
    rb_define_method(cKeyFrame.klass, "initialize", VALUEFUNC(_wrap_new_KeyFrame), -1);
    rb_define_method(cKeyFrame.klass, "time=", VALUEFUNC(_wrap_KeyFrame_time_set), -1);
    rb_define_method(cKeyFrame.klass, "time", VALUEFUNC(_wrap_KeyFrame_time_get), -1);
    rb_define_method(cKeyFrame.klass, "v=", VALUEFUNC(_wrap_KeyFrame_v_set), -1);
    rb_define_method(cKeyFrame.klass, "v", VALUEFUNC(_wrap_KeyFrame_v_get), -1);
    cKeyFrame.mark = 0;
    cKeyFrame.destroy = (void (*)(void *)) free_KeyFrame;
    
    cBone.klass = rb_define_class_under(mLibantargis, "Bone", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Bone, (void *) &cBone);
    rb_define_alloc_func(cBone.klass, _wrap_Bone_allocate);
    rb_define_method(cBone.klass, "initialize", VALUEFUNC(_wrap_new_Bone), -1);
    rb_define_method(cBone.klass, "id=", VALUEFUNC(_wrap_Bone_id_set), -1);
    rb_define_method(cBone.klass, "id", VALUEFUNC(_wrap_Bone_id_get), -1);
    rb_define_method(cBone.klass, "pos=", VALUEFUNC(_wrap_Bone_pos_set), -1);
    rb_define_method(cBone.klass, "pos", VALUEFUNC(_wrap_Bone_pos_get), -1);
    rb_define_method(cBone.klass, "rot=", VALUEFUNC(_wrap_Bone_rot_set), -1);
    rb_define_method(cBone.klass, "rot", VALUEFUNC(_wrap_Bone_rot_get), -1);
    rb_define_method(cBone.klass, "mRelative=", VALUEFUNC(_wrap_Bone_mRelative_set), -1);
    rb_define_method(cBone.klass, "mRelative", VALUEFUNC(_wrap_Bone_mRelative_get), -1);
    rb_define_method(cBone.klass, "mAbsolute=", VALUEFUNC(_wrap_Bone_mAbsolute_set), -1);
    rb_define_method(cBone.klass, "mAbsolute", VALUEFUNC(_wrap_Bone_mAbsolute_get), -1);
    rb_define_method(cBone.klass, "mFinal=", VALUEFUNC(_wrap_Bone_mFinal_set), -1);
    rb_define_method(cBone.klass, "mFinal", VALUEFUNC(_wrap_Bone_mFinal_get), -1);
    rb_define_method(cBone.klass, "parent=", VALUEFUNC(_wrap_Bone_parent_set), -1);
    rb_define_method(cBone.klass, "parent", VALUEFUNC(_wrap_Bone_parent_get), -1);
    rb_define_method(cBone.klass, "rFrames=", VALUEFUNC(_wrap_Bone_rFrames_set), -1);
    rb_define_method(cBone.klass, "rFrames", VALUEFUNC(_wrap_Bone_rFrames_get), -1);
    rb_define_method(cBone.klass, "tFrames=", VALUEFUNC(_wrap_Bone_tFrames_set), -1);
    rb_define_method(cBone.klass, "tFrames", VALUEFUNC(_wrap_Bone_tFrames_get), -1);
    rb_define_method(cBone.klass, "interpolateRot", VALUEFUNC(_wrap_Bone_interpolateRot), -1);
    rb_define_method(cBone.klass, "interpolateTrans", VALUEFUNC(_wrap_Bone_interpolateTrans), -1);
    rb_define_method(cBone.klass, "interpolate", VALUEFUNC(_wrap_Bone_interpolate), -1);
    cBone.mark = 0;
    cBone.destroy = (void (*)(void *)) free_Bone;
    
    cAnimation.klass = rb_define_class_under(mLibantargis, "Animation", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Animation, (void *) &cAnimation);
    rb_define_alloc_func(cAnimation.klass, _wrap_Animation_allocate);
    rb_define_method(cAnimation.klass, "initialize", VALUEFUNC(_wrap_new_Animation), -1);
    rb_define_method(cAnimation.klass, "begin=", VALUEFUNC(_wrap_Animation_begin_set), -1);
    rb_define_method(cAnimation.klass, "begin", VALUEFUNC(_wrap_Animation_begin_get), -1);
    rb_define_method(cAnimation.klass, "end=", VALUEFUNC(_wrap_Animation_end_set), -1);
    rb_define_method(cAnimation.klass, "end", VALUEFUNC(_wrap_Animation_end_get), -1);
    rb_define_method(cAnimation.klass, "fps=", VALUEFUNC(_wrap_Animation_fps_set), -1);
    rb_define_method(cAnimation.klass, "fps", VALUEFUNC(_wrap_Animation_fps_get), -1);
    rb_define_method(cAnimation.klass, "len=", VALUEFUNC(_wrap_Animation_len_set), -1);
    rb_define_method(cAnimation.klass, "len", VALUEFUNC(_wrap_Animation_len_get), -1);
    rb_define_method(cAnimation.klass, "loop=", VALUEFUNC(_wrap_Animation_loop_set), -1);
    rb_define_method(cAnimation.klass, "loop", VALUEFUNC(_wrap_Animation_loop_get), -1);
    cAnimation.mark = 0;
    cAnimation.destroy = (void (*)(void *)) free_Animation;
    rb_define_module_function(mLibantargis, "disown_AnimMeshData", VALUEFUNC(_wrap_disown_AnimMeshData), -1);
    
    cAnimMeshData.klass = rb_define_class_under(mLibantargis, "AnimMeshData", ((swig_class *) SWIGTYPE_p_AGRubyObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AnimMeshData, (void *) &cAnimMeshData);
    rb_define_alloc_func(cAnimMeshData.klass, _wrap_AnimMeshData_allocate);
    rb_define_method(cAnimMeshData.klass, "initialize", VALUEFUNC(_wrap_new_AnimMeshData), -1);
    rb_define_method(cAnimMeshData.klass, "bbox", VALUEFUNC(_wrap_AnimMeshData_bbox), -1);
    rb_define_method(cAnimMeshData.klass, "setEvents", VALUEFUNC(_wrap_AnimMeshData_setEvents), -1);
    rb_define_method(cAnimMeshData.klass, "setTransform", VALUEFUNC(_wrap_AnimMeshData_setTransform), -1);
    rb_define_method(cAnimMeshData.klass, "getTransform", VALUEFUNC(_wrap_AnimMeshData_getTransform), -1);
    cAnimMeshData.mark = (void (*)(void *)) general_markfunc;
    cAnimMeshData.destroy = (void (*)(void *)) free_AnimMeshData;
    rb_define_module_function(mLibantargis, "disown_GLApp", VALUEFUNC(_wrap_disown_GLApp), -1);
    
    cGLApp.klass = rb_define_class_under(mLibantargis, "GLApp", ((swig_class *) SWIGTYPE_p_AGApplication->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_GLApp, (void *) &cGLApp);
    rb_define_alloc_func(cGLApp.klass, _wrap_GLApp_allocate);
    rb_define_method(cGLApp.klass, "initialize", VALUEFUNC(_wrap_new_GLApp), -1);
    rb_define_method(cGLApp.klass, "draw", VALUEFUNC(_wrap_GLApp_draw), -1);
    rb_define_method(cGLApp.klass, "drawGL", VALUEFUNC(_wrap_GLApp_drawGL), -1);
    rb_define_method(cGLApp.klass, "eventFrame", VALUEFUNC(_wrap_GLApp_eventFrame), -1);
    rb_define_method(cGLApp.klass, "eventClick", VALUEFUNC(_wrap_GLApp_eventClick), -1);
    rb_define_method(cGLApp.klass, "eventHover", VALUEFUNC(_wrap_GLApp_eventHover), -1);
    rb_define_method(cGLApp.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_GLApp_eventMouseButtonDown), -1);
    rb_define_method(cGLApp.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_GLApp_eventMouseButtonUp), -1);
    rb_define_method(cGLApp.klass, "eventMouseMotion", VALUEFUNC(_wrap_GLApp_eventMouseMotion), -1);
    rb_define_method(cGLApp.klass, "eventKeyDown", VALUEFUNC(_wrap_GLApp_eventKeyDown), -1);
    rb_define_method(cGLApp.klass, "getScene", VALUEFUNC(_wrap_GLApp_getScene), -1);
    rb_define_method(cGLApp.klass, "setCamera", VALUEFUNC(_wrap_GLApp_setCamera), -1);
    rb_define_method(cGLApp.klass, "getCamera", VALUEFUNC(_wrap_GLApp_getCamera), -1);
    rb_define_method(cGLApp.klass, "mark", VALUEFUNC(_wrap_GLApp_mark), -1);
    cGLApp.mark = (void (*)(void *)) general_markfunc;
    cGLApp.destroy = (void (*)(void *)) free_GLApp;
    
    cSerialException.klass = rb_define_class_under(mLibantargis, "SerialException", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_SerialException, (void *) &cSerialException);
    rb_define_alloc_func(cSerialException.klass, _wrap_SerialException_allocate);
    rb_define_method(cSerialException.klass, "initialize", VALUEFUNC(_wrap_new_SerialException), -1);
    cSerialException.mark = 0;
    cSerialException.destroy = (void (*)(void *)) free_SerialException;
    rb_define_module_function(mLibantargis, "disown_BinaryIn", VALUEFUNC(_wrap_disown_BinaryIn), -1);
    
    cBinaryIn.klass = rb_define_class_under(mLibantargis, "BinaryIn", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_BinaryIn, (void *) &cBinaryIn);
    rb_define_alloc_func(cBinaryIn.klass, _wrap_BinaryIn_allocate);
    rb_define_method(cBinaryIn.klass, "initialize", VALUEFUNC(_wrap_new_BinaryIn), -1);
    rb_define_method(cBinaryIn.klass, "eof", VALUEFUNC(_wrap_BinaryIn_eof), -1);
    rb_define_method(cBinaryIn.klass, "read", VALUEFUNC(_wrap_BinaryIn_read), -1);
    rb_define_method(cBinaryIn.klass, ">>", VALUEFUNC(_wrap_BinaryIn___rshift__), -1);
    cBinaryIn.mark = 0;
    cBinaryIn.destroy = (void (*)(void *)) free_BinaryIn;
    rb_define_module_function(mLibantargis, "disown_BinaryOut", VALUEFUNC(_wrap_disown_BinaryOut), -1);
    
    cBinaryOut.klass = rb_define_class_under(mLibantargis, "BinaryOut", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_BinaryOut, (void *) &cBinaryOut);
    rb_define_alloc_func(cBinaryOut.klass, _wrap_BinaryOut_allocate);
    rb_define_method(cBinaryOut.klass, "initialize", VALUEFUNC(_wrap_new_BinaryOut), -1);
    rb_define_method(cBinaryOut.klass, "write", VALUEFUNC(_wrap_BinaryOut_write), -1);
    rb_define_method(cBinaryOut.klass, "<<", VALUEFUNC(_wrap_BinaryOut___lshift__), -1);
    cBinaryOut.mark = 0;
    cBinaryOut.destroy = (void (*)(void *)) free_BinaryOut;
    rb_define_module_function(mLibantargis, "disown_BinaryFileIn", VALUEFUNC(_wrap_disown_BinaryFileIn), -1);
    
    cBinaryFileIn.klass = rb_define_class_under(mLibantargis, "BinaryFileIn", ((swig_class *) SWIGTYPE_p_BinaryIn->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_BinaryFileIn, (void *) &cBinaryFileIn);
    rb_define_alloc_func(cBinaryFileIn.klass, _wrap_BinaryFileIn_allocate);
    rb_define_method(cBinaryFileIn.klass, "initialize", VALUEFUNC(_wrap_new_BinaryFileIn), -1);
    rb_define_method(cBinaryFileIn.klass, "eof", VALUEFUNC(_wrap_BinaryFileIn_eof), -1);
    rb_define_method(cBinaryFileIn.klass, "read", VALUEFUNC(_wrap_BinaryFileIn_read), -1);
    rb_define_method(cBinaryFileIn.klass, "pos", VALUEFUNC(_wrap_BinaryFileIn_pos), -1);
    cBinaryFileIn.mark = 0;
    cBinaryFileIn.destroy = (void (*)(void *)) free_BinaryFileIn;
    rb_define_module_function(mLibantargis, "disown_BinaryFileOut", VALUEFUNC(_wrap_disown_BinaryFileOut), -1);
    
    cBinaryFileOut.klass = rb_define_class_under(mLibantargis, "BinaryFileOut", ((swig_class *) SWIGTYPE_p_BinaryOut->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_BinaryFileOut, (void *) &cBinaryFileOut);
    rb_define_alloc_func(cBinaryFileOut.klass, _wrap_BinaryFileOut_allocate);
    rb_define_method(cBinaryFileOut.klass, "initialize", VALUEFUNC(_wrap_new_BinaryFileOut), -1);
    rb_define_method(cBinaryFileOut.klass, "write", VALUEFUNC(_wrap_BinaryFileOut_write), -1);
    rb_define_method(cBinaryFileOut.klass, "flush", VALUEFUNC(_wrap_BinaryFileOut_flush), -1);
    rb_define_method(cBinaryFileOut.klass, "pos", VALUEFUNC(_wrap_BinaryFileOut_pos), -1);
    cBinaryFileOut.mark = 0;
    cBinaryFileOut.destroy = (void (*)(void *)) free_BinaryFileOut;
    rb_define_module_function(mLibantargis, "disown_BinaryStringIn", VALUEFUNC(_wrap_disown_BinaryStringIn), -1);
    
    cBinaryStringIn.klass = rb_define_class_under(mLibantargis, "BinaryStringIn", ((swig_class *) SWIGTYPE_p_BinaryIn->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_BinaryStringIn, (void *) &cBinaryStringIn);
    rb_define_alloc_func(cBinaryStringIn.klass, _wrap_BinaryStringIn_allocate);
    rb_define_method(cBinaryStringIn.klass, "initialize", VALUEFUNC(_wrap_new_BinaryStringIn), -1);
    rb_define_method(cBinaryStringIn.klass, "eof", VALUEFUNC(_wrap_BinaryStringIn_eof), -1);
    rb_define_method(cBinaryStringIn.klass, "read", VALUEFUNC(_wrap_BinaryStringIn_read), -1);
    cBinaryStringIn.mark = 0;
    cBinaryStringIn.destroy = (void (*)(void *)) free_BinaryStringIn;
    rb_define_module_function(mLibantargis, "disown_BinaryStringOut", VALUEFUNC(_wrap_disown_BinaryStringOut), -1);
    
    cBinaryStringOut.klass = rb_define_class_under(mLibantargis, "BinaryStringOut", ((swig_class *) SWIGTYPE_p_BinaryOut->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_BinaryStringOut, (void *) &cBinaryStringOut);
    rb_define_alloc_func(cBinaryStringOut.klass, _wrap_BinaryStringOut_allocate);
    rb_define_method(cBinaryStringOut.klass, "initialize", VALUEFUNC(_wrap_new_BinaryStringOut), -1);
    rb_define_method(cBinaryStringOut.klass, "write", VALUEFUNC(_wrap_BinaryStringOut_write), -1);
    rb_define_method(cBinaryStringOut.klass, "getString", VALUEFUNC(_wrap_BinaryStringOut_getString), -1);
    cBinaryStringOut.mark = 0;
    cBinaryStringOut.destroy = (void (*)(void *)) free_BinaryStringOut;
    rb_define_module_function(mLibantargis, "disown_AntEntity", VALUEFUNC(_wrap_disown_AntEntity), -1);
    
    cAntEntity.klass = rb_define_class_under(mLibantargis, "AntEntity", ((swig_class *) SWIGTYPE_p_AGRubyObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AntEntity, (void *) &cAntEntity);
    rb_define_alloc_func(cAntEntity.klass, _wrap_AntEntity_allocate);
    rb_define_method(cAntEntity.klass, "initialize", VALUEFUNC(_wrap_new_AntEntity), -1);
    rb_define_method(cAntEntity.klass, "mDir=", VALUEFUNC(_wrap_AntEntity_mDir_set), -1);
    rb_define_method(cAntEntity.klass, "mDir", VALUEFUNC(_wrap_AntEntity_mDir_get), -1);
    rb_define_method(cAntEntity.klass, "resource=", VALUEFUNC(_wrap_AntEntity_resource_set), -1);
    rb_define_method(cAntEntity.klass, "resource", VALUEFUNC(_wrap_AntEntity_resource_get), -1);
    rb_define_method(cAntEntity.klass, "setMinimapColor", VALUEFUNC(_wrap_AntEntity_setMinimapColor), -1);
    rb_define_method(cAntEntity.klass, "getMinimapColor", VALUEFUNC(_wrap_AntEntity_getMinimapColor), -1);
    rb_define_method(cAntEntity.klass, "showOnMinimap", VALUEFUNC(_wrap_AntEntity_showOnMinimap), -1);
    rb_define_method(cAntEntity.klass, "setStrength", VALUEFUNC(_wrap_AntEntity_setStrength), -1);
    rb_define_method(cAntEntity.klass, "getStrength", VALUEFUNC(_wrap_AntEntity_getStrength), -1);
    rb_define_method(cAntEntity.klass, "setMoraleStrength", VALUEFUNC(_wrap_AntEntity_setMoraleStrength), -1);
    rb_define_method(cAntEntity.klass, "getMoraleStrength", VALUEFUNC(_wrap_AntEntity_getMoraleStrength), -1);
    rb_define_method(cAntEntity.klass, "getPos3D", VALUEFUNC(_wrap_AntEntity_getPos3D), -1);
    rb_define_method(cAntEntity.klass, "getPos2D", VALUEFUNC(_wrap_AntEntity_getPos2D), -1);
    rb_define_method(cAntEntity.klass, "setPos", VALUEFUNC(_wrap_AntEntity_setPos), -1);
    rb_define_method(cAntEntity.klass, "getID", VALUEFUNC(_wrap_AntEntity_getID), -1);
    rb_define_method(cAntEntity.klass, "getName", VALUEFUNC(_wrap_AntEntity_getName), -1);
    rb_define_method(cAntEntity.klass, "setName", VALUEFUNC(_wrap_AntEntity_setName), -1);
    rb_define_method(cAntEntity.klass, "setProvide", VALUEFUNC(_wrap_AntEntity_setProvide), -1);
    rb_define_method(cAntEntity.klass, "provides", VALUEFUNC(_wrap_AntEntity_provides), -1);
    rb_define_method(cAntEntity.klass, "xmlName", VALUEFUNC(_wrap_AntEntity_xmlName), -1);
    rb_define_method(cAntEntity.klass, "saveXML", VALUEFUNC(_wrap_AntEntity_saveXML), -1);
    rb_define_method(cAntEntity.klass, "loadXML", VALUEFUNC(_wrap_AntEntity_loadXML), -1);
    rb_define_method(cAntEntity.klass, "newRestJob", VALUEFUNC(_wrap_AntEntity_newRestJob), -1);
    rb_define_method(cAntEntity.klass, "newFetchJob", VALUEFUNC(_wrap_AntEntity_newFetchJob), -1);
    rb_define_method(cAntEntity.klass, "newMoveJob", VALUEFUNC(_wrap_AntEntity_newMoveJob), -1);
    rb_define_method(cAntEntity.klass, "newFightJob", VALUEFUNC(_wrap_AntEntity_newFightJob), -1);
    rb_define_method(cAntEntity.klass, "delJob", VALUEFUNC(_wrap_AntEntity_delJob), -1);
    rb_define_method(cAntEntity.klass, "resourceChanged", VALUEFUNC(_wrap_AntEntity_resourceChanged), -1);
    rb_define_method(cAntEntity.klass, "hasJob", VALUEFUNC(_wrap_AntEntity_hasJob), -1);
    rb_define_method(cAntEntity.klass, "getRect", VALUEFUNC(_wrap_AntEntity_getRect), -1);
    rb_define_method(cAntEntity.klass, "eventNoJob", VALUEFUNC(_wrap_AntEntity_eventNoJob), -1);
    rb_define_method(cAntEntity.klass, "eventJobFinished", VALUEFUNC(_wrap_AntEntity_eventJobFinished), -1);
    rb_define_method(cAntEntity.klass, "eventGotNewJob", VALUEFUNC(_wrap_AntEntity_eventGotNewJob), -1);
    rb_define_method(cAntEntity.klass, "eventGotFight", VALUEFUNC(_wrap_AntEntity_eventGotFight), -1);
    rb_define_method(cAntEntity.klass, "setSpeed", VALUEFUNC(_wrap_AntEntity_setSpeed), -1);
    rb_define_method(cAntEntity.klass, "getSpeed", VALUEFUNC(_wrap_AntEntity_getSpeed), -1);
    rb_define_method(cAntEntity.klass, "getHealSpeed", VALUEFUNC(_wrap_AntEntity_getHealSpeed), -1);
    rb_define_method(cAntEntity.klass, "setHealSpeed", VALUEFUNC(_wrap_AntEntity_setHealSpeed), -1);
    rb_define_method(cAntEntity.klass, "setAggression", VALUEFUNC(_wrap_AntEntity_setAggression), -1);
    rb_define_method(cAntEntity.klass, "getAggression", VALUEFUNC(_wrap_AntEntity_getAggression), -1);
    rb_define_method(cAntEntity.klass, "eventDie", VALUEFUNC(_wrap_AntEntity_eventDie), -1);
    rb_define_method(cAntEntity.klass, "eventDefeated", VALUEFUNC(_wrap_AntEntity_eventDefeated), -1);
    rb_define_method(cAntEntity.klass, "getEnergy", VALUEFUNC(_wrap_AntEntity_getEnergy), -1);
    rb_define_method(cAntEntity.klass, "getMorale", VALUEFUNC(_wrap_AntEntity_getMorale), -1);
    rb_define_method(cAntEntity.klass, "setMesh", VALUEFUNC(_wrap_AntEntity_setMesh), -1);
    rb_define_method(cAntEntity.klass, "getMesh", VALUEFUNC(_wrap_AntEntity_getMesh), -1);
    rb_define_method(cAntEntity.klass, "getFirstMesh", VALUEFUNC(_wrap_AntEntity_getFirstMesh), -1);
    rb_define_method(cAntEntity.klass, "addMesh", VALUEFUNC(_wrap_AntEntity_addMesh), -1);
    rb_define_method(cAntEntity.klass, "setDirection", VALUEFUNC(_wrap_AntEntity_setDirection), -1);
    rb_define_method(cAntEntity.klass, "getDirection", VALUEFUNC(_wrap_AntEntity_getDirection), -1);
    rb_define_method(cAntEntity.klass, "decEnergy", VALUEFUNC(_wrap_AntEntity_decEnergy), -1);
    rb_define_method(cAntEntity.klass, "decMorale", VALUEFUNC(_wrap_AntEntity_decMorale), -1);
    rb_define_method(cAntEntity.klass, "eventMapChanged", VALUEFUNC(_wrap_AntEntity_eventMapChanged), -1);
    rb_define_method(cAntEntity.klass, "move", VALUEFUNC(_wrap_AntEntity_move), -1);
    rb_define_method(cAntEntity.klass, "mark", VALUEFUNC(_wrap_AntEntity_mark), -1);
    rb_define_method(cAntEntity.klass, "clear", VALUEFUNC(_wrap_AntEntity_clear), -1);
    rb_define_method(cAntEntity.klass, "clearMeshes", VALUEFUNC(_wrap_AntEntity_clearMeshes), -1);
    rb_define_method(cAntEntity.klass, "setVisible", VALUEFUNC(_wrap_AntEntity_setVisible), -1);
    rb_define_method(cAntEntity.klass, "animationEvent", VALUEFUNC(_wrap_AntEntity_animationEvent), -1);
    cAntEntity.mark = (void (*)(void *)) general_markfunc;
    cAntEntity.destroy = (void (*)(void *)) free_AntEntity;
    
    cAntEntityPtr.klass = rb_define_class_under(mLibantargis, "AntEntityPtr", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AntEntityPtr, (void *) &cAntEntityPtr);
    rb_define_alloc_func(cAntEntityPtr.klass, _wrap_AntEntityPtr_allocate);
    rb_define_method(cAntEntityPtr.klass, "initialize", VALUEFUNC(_wrap_new_AntEntityPtr), -1);
    rb_define_method(cAntEntityPtr.klass, "get", VALUEFUNC(_wrap_AntEntityPtr_get), -1);
    cAntEntityPtr.mark = 0;
    cAntEntityPtr.destroy = (void (*)(void *)) free_AntEntityPtr;
    
    cAntVertexProgram.klass = rb_define_class_under(mLibantargis, "AntVertexProgram", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AntVertexProgram, (void *) &cAntVertexProgram);
    rb_define_alloc_func(cAntVertexProgram.klass, _wrap_AntVertexProgram_allocate);
    rb_define_method(cAntVertexProgram.klass, "initialize", VALUEFUNC(_wrap_new_AntVertexProgram), -1);
    cAntVertexProgram.mark = 0;
    cAntVertexProgram.destroy = (void (*)(void *)) free_AntVertexProgram;
    
    cAntFragProgram.klass = rb_define_class_under(mLibantargis, "AntFragProgram", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AntFragProgram, (void *) &cAntFragProgram);
    rb_define_alloc_func(cAntFragProgram.klass, _wrap_AntFragProgram_allocate);
    rb_define_method(cAntFragProgram.klass, "initialize", VALUEFUNC(_wrap_new_AntFragProgram), -1);
    rb_define_method(cAntFragProgram.klass, "valid", VALUEFUNC(_wrap_AntFragProgram_valid), -1);
    cAntFragProgram.mark = 0;
    cAntFragProgram.destroy = (void (*)(void *)) free_AntFragProgram;
    
    cAntShaderParameter.klass = rb_define_class_under(mLibantargis, "AntShaderParameter", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AntShaderParameter, (void *) &cAntShaderParameter);
    rb_define_alloc_func(cAntShaderParameter.klass, _wrap_AntShaderParameter_allocate);
    rb_define_method(cAntShaderParameter.klass, "initialize", VALUEFUNC(_wrap_new_AntShaderParameter), -1);
    cAntShaderParameter.mark = 0;
    cAntShaderParameter.destroy = (void (*)(void *)) free_AntShaderParameter;
    rb_define_module_function(mLibantargis, "disown_AntShaderProgram", VALUEFUNC(_wrap_disown_AntShaderProgram), -1);
    
    cAntShaderProgram.klass = rb_define_class_under(mLibantargis, "AntShaderProgram", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AntShaderProgram, (void *) &cAntShaderProgram);
    rb_define_alloc_func(cAntShaderProgram.klass, _wrap_AntShaderProgram_allocate);
    rb_define_method(cAntShaderProgram.klass, "initialize", VALUEFUNC(_wrap_new_AntShaderProgram), -1);
    rb_define_method(cAntShaderProgram.klass, "enable", VALUEFUNC(_wrap_AntShaderProgram_enable), -1);
    rb_define_method(cAntShaderProgram.klass, "disable", VALUEFUNC(_wrap_AntShaderProgram_disable), -1);
    rb_define_method(cAntShaderProgram.klass, "update", VALUEFUNC(_wrap_AntShaderProgram_update), -1);
    rb_define_method(cAntShaderProgram.klass, "doUpdate", VALUEFUNC(_wrap_AntShaderProgram_doUpdate), -1);
    rb_define_method(cAntShaderProgram.klass, "getLoc", VALUEFUNC(_wrap_AntShaderProgram_getLoc), -1);
    rb_define_method(cAntShaderProgram.klass, "getAttr", VALUEFUNC(_wrap_AntShaderProgram_getAttr), -1);
    rb_define_method(cAntShaderProgram.klass, "sendUniform", VALUEFUNC(_wrap_AntShaderProgram_sendUniform), -1);
    rb_define_method(cAntShaderProgram.klass, "sendAttribute", VALUEFUNC(_wrap_AntShaderProgram_sendAttribute), -1);
    cAntShaderProgram.mark = 0;
    cAntShaderProgram.destroy = (void (*)(void *)) free_AntShaderProgram;
    rb_define_module_function(mLibantargis, "disown_AntShadowShader", VALUEFUNC(_wrap_disown_AntShadowShader), -1);
    
    cAntShadowShader.klass = rb_define_class_under(mLibantargis, "AntShadowShader", ((swig_class *) SWIGTYPE_p_AntShaderProgram->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AntShadowShader, (void *) &cAntShadowShader);
    rb_define_alloc_func(cAntShadowShader.klass, _wrap_AntShadowShader_allocate);
    rb_define_method(cAntShadowShader.klass, "initialize", VALUEFUNC(_wrap_new_AntShadowShader), -1);
    rb_define_method(cAntShadowShader.klass, "doUpdate", VALUEFUNC(_wrap_AntShadowShader_doUpdate), -1);
    rb_define_method(cAntShadowShader.klass, "enable", VALUEFUNC(_wrap_AntShadowShader_enable), -1);
    rb_define_method(cAntShadowShader.klass, "disable", VALUEFUNC(_wrap_AntShadowShader_disable), -1);
    cAntShadowShader.mark = 0;
    cAntShadowShader.destroy = (void (*)(void *)) free_AntShadowShader;
    rb_define_module_function(mLibantargis, "disown_AntWaterShader", VALUEFUNC(_wrap_disown_AntWaterShader), -1);
    
    cAntWaterShader.klass = rb_define_class_under(mLibantargis, "AntWaterShader", ((swig_class *) SWIGTYPE_p_AntShaderProgram->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AntWaterShader, (void *) &cAntWaterShader);
    rb_define_alloc_func(cAntWaterShader.klass, _wrap_AntWaterShader_allocate);
    rb_define_method(cAntWaterShader.klass, "initialize", VALUEFUNC(_wrap_new_AntWaterShader), -1);
    rb_define_method(cAntWaterShader.klass, "doUpdate", VALUEFUNC(_wrap_AntWaterShader_doUpdate), -1);
    cAntWaterShader.mark = 0;
    cAntWaterShader.destroy = (void (*)(void *)) free_AntWaterShader;
    rb_define_module_function(mLibantargis, "glslOk", VALUEFUNC(_wrap_glslOk), -1);
    rb_define_const(mLibantargis,"WATER", INT2NUM(WATER));
    rb_define_const(mLibantargis,"SAND", INT2NUM(SAND));
    rb_define_const(mLibantargis,"EARTH", INT2NUM(EARTH));
    rb_define_const(mLibantargis,"GRASS", INT2NUM(GRASS));
    rb_define_const(mLibantargis,"GRASS2", INT2NUM(GRASS2));
    rb_define_const(mLibantargis,"FOREST", INT2NUM(FOREST));
    rb_define_const(mLibantargis,"ROCK", INT2NUM(ROCK));
    rb_define_const(mLibantargis,"ROCK2", INT2NUM(ROCK2));
    rb_define_const(mLibantargis,"LASTTERRAIN", INT2NUM(LASTTERRAIN));
    rb_define_module_function(mLibantargis, "disown_HeightMap", VALUEFUNC(_wrap_disown_HeightMap), -1);
    
    cHeightMap.klass = rb_define_class_under(mLibantargis, "HeightMap", ((swig_class *) SWIGTYPE_p_AGMessageObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_HeightMap, (void *) &cHeightMap);
    rb_define_alloc_func(cHeightMap.klass, _wrap_HeightMap_allocate);
    rb_define_method(cHeightMap.klass, "initialize", VALUEFUNC(_wrap_new_HeightMap), -1);
    rb_define_method(cHeightMap.klass, "getHeight", VALUEFUNC(_wrap_HeightMap_getHeight), -1);
    rb_define_method(cHeightMap.klass, "getNormal", VALUEFUNC(_wrap_HeightMap_getNormal), -1);
    rb_define_method(cHeightMap.klass, "getNormalF", VALUEFUNC(_wrap_HeightMap_getNormalF), -1);
    rb_define_method(cHeightMap.klass, "getVertex", VALUEFUNC(_wrap_HeightMap_getVertex), -1);
    rb_define_method(cHeightMap.klass, "get", VALUEFUNC(_wrap_HeightMap_get), -1);
    rb_define_method(cHeightMap.klass, "setTerrain", VALUEFUNC(_wrap_HeightMap_setTerrain), -1);
    rb_define_method(cHeightMap.klass, "getMean", VALUEFUNC(_wrap_HeightMap_getMean), -1);
    rb_define_method(cHeightMap.klass, "getW", VALUEFUNC(_wrap_HeightMap_getW), -1);
    rb_define_method(cHeightMap.klass, "getH", VALUEFUNC(_wrap_HeightMap_getH), -1);
    rb_define_method(cHeightMap.klass, "truncPos", VALUEFUNC(_wrap_HeightMap_truncPos), -1);
    rb_define_method(cHeightMap.klass, "saveXML", VALUEFUNC(_wrap_HeightMap_saveXML), -1);
    rb_define_method(cHeightMap.klass, "loadXML", VALUEFUNC(_wrap_HeightMap_loadXML), -1);
    rb_define_method(cHeightMap.klass, "setHeight", VALUEFUNC(_wrap_HeightMap_setHeight), -1);
    rb_define_method(cHeightMap.klass, "set", VALUEFUNC(_wrap_HeightMap_set), -1);
    rb_define_method(cHeightMap.klass, "mapChanged", VALUEFUNC(_wrap_HeightMap_mapChanged), -1);
    rb_define_method(cHeightMap.klass, "setTerrainScale", VALUEFUNC(_wrap_HeightMap_setTerrainScale), -1);
    rb_define_method(cHeightMap.klass, "getTerrainValue", VALUEFUNC(_wrap_HeightMap_getTerrainValue), -1);
    rb_define_method(cHeightMap.klass, "getTerrain", VALUEFUNC(_wrap_HeightMap_getTerrain), -1);
    rb_define_method(cHeightMap.klass, "getTerrainWeight", VALUEFUNC(_wrap_HeightMap_getTerrainWeight), -1);
    rb_define_method(cHeightMap.klass, "getTerrainScale", VALUEFUNC(_wrap_HeightMap_getTerrainScale), -1);
    rb_define_method(cHeightMap.klass, "addChange", VALUEFUNC(_wrap_HeightMap_addChange), -1);
    rb_define_method(cHeightMap.klass, "getChangeRect", VALUEFUNC(_wrap_HeightMap_getChangeRect), -1);
    rb_define_method(cHeightMap.klass, "newMap", VALUEFUNC(_wrap_HeightMap_newMap), -1);
    rb_define_method(cHeightMap.klass, "sigMapChanged=", VALUEFUNC(_wrap_HeightMap_sigMapChanged_set), -1);
    rb_define_method(cHeightMap.klass, "sigMapChanged", VALUEFUNC(_wrap_HeightMap_sigMapChanged_get), -1);
    rb_define_method(cHeightMap.klass, "sigMapChangedComplete=", VALUEFUNC(_wrap_HeightMap_sigMapChangedComplete_set), -1);
    rb_define_method(cHeightMap.klass, "sigMapChangedComplete", VALUEFUNC(_wrap_HeightMap_sigMapChangedComplete_get), -1);
    rb_define_method(cHeightMap.klass, "getScene", VALUEFUNC(_wrap_HeightMap_getScene), -1);
    cHeightMap.mark = (void (*)(void *)) general_markfunc;
    cHeightMap.destroy = (void (*)(void *)) free_HeightMap;
    rb_define_module_function(mLibantargis, "disown_AntMap", VALUEFUNC(_wrap_disown_AntMap), -1);
    
    cAntMap.klass = rb_define_class_under(mLibantargis, "AntMap", ((swig_class *) SWIGTYPE_p_HeightMap->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AntMap, (void *) &cAntMap);
    rb_define_alloc_func(cAntMap.klass, _wrap_AntMap_allocate);
    rb_define_method(cAntMap.klass, "initialize", VALUEFUNC(_wrap_new_AntMap), -1);
    rb_define_method(cAntMap.klass, "insertEntity", VALUEFUNC(_wrap_AntMap_insertEntity), -1);
    rb_define_method(cAntMap.klass, "removeEntity", VALUEFUNC(_wrap_AntMap_removeEntity), -1);
    rb_define_method(cAntMap.klass, "clear", VALUEFUNC(_wrap_AntMap_clear), -1);
    rb_define_method(cAntMap.klass, "getNewID", VALUEFUNC(_wrap_AntMap_getNewID), -1);
    rb_define_method(cAntMap.klass, "newMap", VALUEFUNC(_wrap_AntMap_newMap), -1);
    rb_define_method(cAntMap.klass, "getAllEntities", VALUEFUNC(_wrap_AntMap_getAllEntities), -1);
    rb_define_method(cAntMap.klass, "getAllEntitiesV", VALUEFUNC(_wrap_AntMap_getAllEntitiesV), -1);
    rb_define_method(cAntMap.klass, "getEntities", VALUEFUNC(_wrap_AntMap_getEntities), -1);
    rb_define_method(cAntMap.klass, "getEntity", VALUEFUNC(_wrap_AntMap_getEntity), -1);
    rb_define_method(cAntMap.klass, "getByName", VALUEFUNC(_wrap_AntMap_getByName), -1);
    rb_define_method(cAntMap.klass, "getNext", VALUEFUNC(_wrap_AntMap_getNext), -1);
    rb_define_method(cAntMap.klass, "loadEntity", VALUEFUNC(_wrap_AntMap_loadEntity), -1);
    rb_define_method(cAntMap.klass, "saveXML", VALUEFUNC(_wrap_AntMap_saveXML), -1);
    rb_define_method(cAntMap.klass, "loadXML", VALUEFUNC(_wrap_AntMap_loadXML), -1);
    rb_define_method(cAntMap.klass, "saveMap", VALUEFUNC(_wrap_AntMap_saveMap), -1);
    rb_define_method(cAntMap.klass, "loadMap", VALUEFUNC(_wrap_AntMap_loadMap), -1);
    rb_define_method(cAntMap.klass, "move", VALUEFUNC(_wrap_AntMap_move), -1);
    rb_define_method(cAntMap.klass, "getPos", VALUEFUNC(_wrap_AntMap_getPos), -1);
    rb_define_method(cAntMap.klass, "mark", VALUEFUNC(_wrap_AntMap_mark), -1);
    rb_define_method(cAntMap.klass, "mapChanged", VALUEFUNC(_wrap_AntMap_mapChanged), -1);
    cAntMap.mark = (void (*)(void *)) general_markfunc;
    cAntMap.destroy = (void (*)(void *)) free_AntMap;
    rb_define_module_function(mLibantargis, "getMap", VALUEFUNC(_wrap_getMap), -1);
    rb_define_module_function(mLibantargis, "disown_MeshData", VALUEFUNC(_wrap_disown_MeshData), -1);
    
    cMeshData.klass = rb_define_class_under(mLibantargis, "MeshData", ((swig_class *) SWIGTYPE_p_AGRubyObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_MeshData, (void *) &cMeshData);
    rb_define_alloc_func(cMeshData.klass, _wrap_MeshData_allocate);
    rb_define_method(cMeshData.klass, "initialize", VALUEFUNC(_wrap_new_MeshData), -1);
    rb_define_method(cMeshData.klass, "draw", VALUEFUNC(_wrap_MeshData_draw), -1);
    rb_define_method(cMeshData.klass, "drawShadow", VALUEFUNC(_wrap_MeshData_drawShadow), -1);
    rb_define_method(cMeshData.klass, "drawDepth", VALUEFUNC(_wrap_MeshData_drawDepth), -1);
    rb_define_method(cMeshData.klass, "drawPick", VALUEFUNC(_wrap_MeshData_drawPick), -1);
    rb_define_method(cMeshData.klass, "bbox", VALUEFUNC(_wrap_MeshData_bbox), -1);
    rb_define_method(cMeshData.klass, "save", VALUEFUNC(_wrap_MeshData_save), -1);
    rb_define_method(cMeshData.klass, "getTriangles", VALUEFUNC(_wrap_MeshData_getTriangles), -1);
    rb_define_method(cMeshData.klass, "lineHit", VALUEFUNC(_wrap_MeshData_lineHit), -1);
    rb_define_method(cMeshData.klass, "texCoordFromPos", VALUEFUNC(_wrap_MeshData_texCoordFromPos), -1);
    rb_define_method(cMeshData.klass, "setPickable", VALUEFUNC(_wrap_MeshData_setPickable), -1);
    rb_define_method(cMeshData.klass, "setTransparent", VALUEFUNC(_wrap_MeshData_setTransparent), -1);
    rb_define_method(cMeshData.klass, "transparent", VALUEFUNC(_wrap_MeshData_transparent), -1);
    rb_define_method(cMeshData.klass, "setLighting", VALUEFUNC(_wrap_MeshData_setLighting), -1);
    rb_define_method(cMeshData.klass, "setOverdraw", VALUEFUNC(_wrap_MeshData_setOverdraw), -1);
    rb_define_method(cMeshData.klass, "setCulling", VALUEFUNC(_wrap_MeshData_setCulling), -1);
    rb_define_method(cMeshData.klass, "setColors", VALUEFUNC(_wrap_MeshData_setColors), -1);
    cMeshData.mark = (void (*)(void *)) general_markfunc;
    cMeshData.destroy = (void (*)(void *)) free_MeshData;
    rb_define_module_function(mLibantargis, "disown_Mesh", VALUEFUNC(_wrap_disown_Mesh), -1);
    
    cMesh.klass = rb_define_class_under(mLibantargis, "Mesh", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_Mesh, (void *) &cMesh);
    rb_define_alloc_func(cMesh.klass, _wrap_Mesh_allocate);
    rb_define_method(cMesh.klass, "initialize", VALUEFUNC(_wrap_new_Mesh), -1);
    rb_define_method(cMesh.klass, "draw", VALUEFUNC(_wrap_Mesh_draw), -1);
    rb_define_method(cMesh.klass, "drawDepth", VALUEFUNC(_wrap_Mesh_drawDepth), -1);
    rb_define_method(cMesh.klass, "drawShadow", VALUEFUNC(_wrap_Mesh_drawShadow), -1);
    rb_define_method(cMesh.klass, "drawPick", VALUEFUNC(_wrap_Mesh_drawPick), -1);
    rb_define_method(cMesh.klass, "lineHit", VALUEFUNC(_wrap_Mesh_lineHit), -1);
    rb_define_method(cMesh.klass, "getTriangles", VALUEFUNC(_wrap_Mesh_getTriangles), -1);
    rb_define_method(cMesh.klass, "setRotation", VALUEFUNC(_wrap_Mesh_setRotation), -1);
    rb_define_method(cMesh.klass, "setColor", VALUEFUNC(_wrap_Mesh_setColor), -1);
    rb_define_method(cMesh.klass, "setVisible", VALUEFUNC(_wrap_Mesh_setVisible), -1);
    rb_define_method(cMesh.klass, "getData", VALUEFUNC(_wrap_Mesh_getData), -1);
    rb_define_method(cMesh.klass, "mark", VALUEFUNC(_wrap_Mesh_mark), -1);
    rb_define_method(cMesh.klass, "transparent", VALUEFUNC(_wrap_Mesh_transparent), -1);
    cMesh.mark = (void (*)(void *)) general_markfunc;
    cMesh.destroy = (void (*)(void *)) free_Mesh;
    rb_define_module_function(mLibantargis, "toMesh", VALUEFUNC(_wrap_toMesh), -1);
    
    cMeshVertex.klass = rb_define_class_under(mLibantargis, "MeshVertex", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_MeshVertex, (void *) &cMeshVertex);
    rb_define_alloc_func(cMeshVertex.klass, _wrap_MeshVertex_allocate);
    rb_define_method(cMeshVertex.klass, "initialize", VALUEFUNC(_wrap_new_MeshVertex), -1);
    rb_define_method(cMeshVertex.klass, "v=", VALUEFUNC(_wrap_MeshVertex_v_set), -1);
    rb_define_method(cMeshVertex.klass, "v", VALUEFUNC(_wrap_MeshVertex_v_get), -1);
    rb_define_method(cMeshVertex.klass, "c=", VALUEFUNC(_wrap_MeshVertex_c_set), -1);
    rb_define_method(cMeshVertex.klass, "c", VALUEFUNC(_wrap_MeshVertex_c_get), -1);
    rb_define_method(cMeshVertex.klass, "n=", VALUEFUNC(_wrap_MeshVertex_n_set), -1);
    rb_define_method(cMeshVertex.klass, "n", VALUEFUNC(_wrap_MeshVertex_n_get), -1);
    rb_define_method(cMeshVertex.klass, "t=", VALUEFUNC(_wrap_MeshVertex_t_set), -1);
    rb_define_method(cMeshVertex.klass, "t", VALUEFUNC(_wrap_MeshVertex_t_get), -1);
    rb_define_method(cMeshVertex.klass, "<", VALUEFUNC(_wrap_MeshVertex___lt__), -1);
    cMeshVertex.mark = 0;
    cMeshVertex.destroy = (void (*)(void *)) free_MeshVertex;
    
    cMeshOptimizer.klass = rb_define_class_under(mLibantargis, "MeshOptimizer", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_MeshOptimizer, (void *) &cMeshOptimizer);
    rb_define_alloc_func(cMeshOptimizer.klass, _wrap_MeshOptimizer_allocate);
    rb_define_method(cMeshOptimizer.klass, "initialize", VALUEFUNC(_wrap_new_MeshOptimizer), -1);
    rb_define_method(cMeshOptimizer.klass, "add", VALUEFUNC(_wrap_MeshOptimizer_add), -1);
    rb_define_method(cMeshOptimizer.klass, "getArray", VALUEFUNC(_wrap_MeshOptimizer_getArray), -1);
    rb_define_method(cMeshOptimizer.klass, "getV", VALUEFUNC(_wrap_MeshOptimizer_getV), -1);
    cMeshOptimizer.mark = 0;
    cMeshOptimizer.destroy = (void (*)(void *)) free_MeshOptimizer;
    rb_define_module_function(mLibantargis, "loadFromText", VALUEFUNC(_wrap_loadFromText), -1);
    rb_define_module_function(mLibantargis, "disown_MiniMap", VALUEFUNC(_wrap_disown_MiniMap), -1);
    
    cMiniMap.klass = rb_define_class_under(mLibantargis, "MiniMap", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_MiniMap, (void *) &cMiniMap);
    rb_define_alloc_func(cMiniMap.klass, _wrap_MiniMap_allocate);
    rb_define_method(cMiniMap.klass, "initialize", VALUEFUNC(_wrap_new_MiniMap), -1);
    rb_define_method(cMiniMap.klass, "mapChanged", VALUEFUNC(_wrap_MiniMap_mapChanged), -1);
    rb_define_method(cMiniMap.klass, "mapChangedComplete", VALUEFUNC(_wrap_MiniMap_mapChangedComplete), -1);
    rb_define_method(cMiniMap.klass, "draw", VALUEFUNC(_wrap_MiniMap_draw), -1);
    rb_define_method(cMiniMap.klass, "setMap", VALUEFUNC(_wrap_MiniMap_setMap), -1);
    rb_define_method(cMiniMap.klass, "setScene", VALUEFUNC(_wrap_MiniMap_setScene), -1);
    rb_define_method(cMiniMap.klass, "eventMouseClick", VALUEFUNC(_wrap_MiniMap_eventMouseClick), -1);
    cMiniMap.mark = (void (*)(void *)) general_markfunc;
    cMiniMap.destroy = (void (*)(void *)) free_MiniMap;
    rb_define_module_function(mLibantargis, "toMiniMap", VALUEFUNC(_wrap_toMiniMap), -1);
    rb_define_module_function(mLibantargis, "disown_NewDecal", VALUEFUNC(_wrap_disown_NewDecal), -1);
    
    cNewDecal.klass = rb_define_class_under(mLibantargis, "NewDecal", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_NewDecal, (void *) &cNewDecal);
    rb_define_alloc_func(cNewDecal.klass, _wrap_NewDecal_allocate);
    rb_define_method(cNewDecal.klass, "initialize", VALUEFUNC(_wrap_new_NewDecal), -1);
    rb_define_method(cNewDecal.klass, "setPos", VALUEFUNC(_wrap_NewDecal_setPos), -1);
    rb_define_method(cNewDecal.klass, "draw", VALUEFUNC(_wrap_NewDecal_draw), -1);
    rb_define_method(cNewDecal.klass, "init", VALUEFUNC(_wrap_NewDecal_init), -1);
    rb_define_method(cNewDecal.klass, "mapChanged", VALUEFUNC(_wrap_NewDecal_mapChanged), -1);
    cNewDecal.mark = (void (*)(void *)) general_markfunc;
    cNewDecal.destroy = (void (*)(void *)) free_NewDecal;
    rb_define_module_function(mLibantargis, "getRenderer", VALUEFUNC(_wrap_getRenderer), -1);
    
    cRenderer.klass = rb_define_class_under(mLibantargis, "Renderer", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Renderer, (void *) &cRenderer);
    rb_undef_alloc_func(cRenderer.klass);
    rb_define_method(cRenderer.klass, "canMultitexture", VALUEFUNC(_wrap_Renderer_canMultitexture), -1);
    rb_define_method(cRenderer.klass, "canShadow", VALUEFUNC(_wrap_Renderer_canShadow), -1);
    rb_define_method(cRenderer.klass, "canGLSL", VALUEFUNC(_wrap_Renderer_canGLSL), -1);
    rb_define_method(cRenderer.klass, "getShadowUnit", VALUEFUNC(_wrap_Renderer_getShadowUnit), -1);
    rb_define_method(cRenderer.klass, "getNormalUnit", VALUEFUNC(_wrap_Renderer_getNormalUnit), -1);
    rb_define_method(cRenderer.klass, "setCurrentScene", VALUEFUNC(_wrap_Renderer_setCurrentScene), -1);
    rb_define_method(cRenderer.klass, "getCurrentScene", VALUEFUNC(_wrap_Renderer_getCurrentScene), -1);
    rb_define_method(cRenderer.klass, "initShadowTexture", VALUEFUNC(_wrap_Renderer_initShadowTexture), -1);
    rb_define_method(cRenderer.klass, "beginShadowComputation", VALUEFUNC(_wrap_Renderer_beginShadowComputation), -1);
    rb_define_method(cRenderer.klass, "endShadowComputation", VALUEFUNC(_wrap_Renderer_endShadowComputation), -1);
    rb_define_method(cRenderer.klass, "beginShadowDrawing", VALUEFUNC(_wrap_Renderer_beginShadowDrawing), -1);
    rb_define_method(cRenderer.klass, "endShadowDrawing", VALUEFUNC(_wrap_Renderer_endShadowDrawing), -1);
    rb_define_method(cRenderer.klass, "badShadowMap", VALUEFUNC(_wrap_Renderer_badShadowMap), -1);
    cRenderer.mark = 0;
    cRenderer.destroy = (void (*)(void *)) free_Renderer;
    
    cResource.klass = rb_define_class_under(mLibantargis, "Resource", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Resource, (void *) &cResource);
    rb_define_alloc_func(cResource.klass, _wrap_Resource_allocate);
    rb_define_method(cResource.klass, "initialize", VALUEFUNC(_wrap_new_Resource), -1);
    rb_define_method(cResource.klass, "get", VALUEFUNC(_wrap_Resource_get), -1);
    rb_define_method(cResource.klass, "add", VALUEFUNC(_wrap_Resource_add), -1);
    rb_define_method(cResource.klass, "sub", VALUEFUNC(_wrap_Resource_sub), -1);
    rb_define_method(cResource.klass, "set", VALUEFUNC(_wrap_Resource_set), -1);
    rb_define_method(cResource.klass, "getAll", VALUEFUNC(_wrap_Resource_getAll), -1);
    rb_define_method(cResource.klass, "takeAll", VALUEFUNC(_wrap_Resource_takeAll), -1);
    cResource.mark = 0;
    cResource.destroy = (void (*)(void *)) free_Resource;
    
    cPickNode.klass = rb_define_class_under(mLibantargis, "PickNode", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_PickNode, (void *) &cPickNode);
    rb_define_alloc_func(cPickNode.klass, _wrap_PickNode_allocate);
    rb_define_method(cPickNode.klass, "initialize", VALUEFUNC(_wrap_new_PickNode), -1);
    rb_define_method(cPickNode.klass, "pos=", VALUEFUNC(_wrap_PickNode_pos_set), -1);
    rb_define_method(cPickNode.klass, "pos", VALUEFUNC(_wrap_PickNode_pos_get), -1);
    rb_define_method(cPickNode.klass, "node=", VALUEFUNC(_wrap_PickNode_node_set), -1);
    rb_define_method(cPickNode.klass, "node", VALUEFUNC(_wrap_PickNode_node_get), -1);
    rb_define_method(cPickNode.klass, "camDist=", VALUEFUNC(_wrap_PickNode_camDist_set), -1);
    rb_define_method(cPickNode.klass, "camDist", VALUEFUNC(_wrap_PickNode_camDist_get), -1);
    rb_define_method(cPickNode.klass, "<", VALUEFUNC(_wrap_PickNode___lt__), -1);
    cPickNode.mark = 0;
    cPickNode.destroy = (void (*)(void *)) free_PickNode;
    
    cViewport.klass = rb_define_class_under(mLibantargis, "Viewport", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Viewport, (void *) &cViewport);
    rb_define_alloc_func(cViewport.klass, _wrap_Viewport_allocate);
    rb_define_method(cViewport.klass, "initialize", VALUEFUNC(_wrap_new_Viewport), -1);
    rb_define_method(cViewport.klass, "viewport=", VALUEFUNC(_wrap_Viewport_viewport_set), -1);
    rb_define_method(cViewport.klass, "viewport", VALUEFUNC(_wrap_Viewport_viewport_get), -1);
    cViewport.mark = 0;
    cViewport.destroy = (void (*)(void *)) free_Viewport;
    rb_define_module_function(mLibantargis, "disown_Scene", VALUEFUNC(_wrap_disown_Scene), -1);
    
    cScene.klass = rb_define_class_under(mLibantargis, "Scene", ((swig_class *) SWIGTYPE_p_AGRubyObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_Scene, (void *) &cScene);
    rb_define_alloc_func(cScene.klass, _wrap_Scene_allocate);
    rb_define_method(cScene.klass, "initialize", VALUEFUNC(_wrap_new_Scene), -1);
    rb_define_method(cScene.klass, "draw", VALUEFUNC(_wrap_Scene_draw), -1);
    rb_define_method(cScene.klass, "setShadow", VALUEFUNC(_wrap_Scene_setShadow), -1);
    rb_define_method(cScene.klass, "getShadow", VALUEFUNC(_wrap_Scene_getShadow), -1);
    rb_define_method(cScene.klass, "addNode", VALUEFUNC(_wrap_Scene_addNode), -1);
    rb_define_method(cScene.klass, "removeNode", VALUEFUNC(_wrap_Scene_removeNode), -1);
    rb_define_method(cScene.klass, "prepareUpdate", VALUEFUNC(_wrap_Scene_prepareUpdate), -1);
    rb_define_method(cScene.klass, "updatePos", VALUEFUNC(_wrap_Scene_updatePos), -1);
    rb_define_method(cScene.klass, "clear", VALUEFUNC(_wrap_Scene_clear), -1);
    rb_define_method(cScene.klass, "setCamera", VALUEFUNC(_wrap_Scene_setCamera), -1);
    rb_define_method(cScene.klass, "getCamera", VALUEFUNC(_wrap_Scene_getCamera), -1);
    rb_define_method(cScene.klass, "advance", VALUEFUNC(_wrap_Scene_advance), -1);
    rb_define_method(cScene.klass, "pick", VALUEFUNC(_wrap_Scene_pick), -1);
    rb_define_method(cScene.klass, "getTriangles", VALUEFUNC(_wrap_Scene_getTriangles), -1);
    rb_define_method(cScene.klass, "getCameraDirTo", VALUEFUNC(_wrap_Scene_getCameraDirTo), -1);
    rb_define_method(cScene.klass, "getFrustum", VALUEFUNC(_wrap_Scene_getFrustum), -1);
    rb_define_method(cScene.klass, "width", VALUEFUNC(_wrap_Scene_width), -1);
    rb_define_method(cScene.klass, "height", VALUEFUNC(_wrap_Scene_height), -1);
    rb_define_method(cScene.klass, "mark", VALUEFUNC(_wrap_Scene_mark), -1);
    rb_define_method(cScene.klass, "getLightComplete", VALUEFUNC(_wrap_Scene_getLightComplete), -1);
    rb_define_method(cScene.klass, "getLightView", VALUEFUNC(_wrap_Scene_getLightView), -1);
    rb_define_method(cScene.klass, "getLightProj", VALUEFUNC(_wrap_Scene_getLightProj), -1);
    rb_define_method(cScene.klass, "getInvCameraView", VALUEFUNC(_wrap_Scene_getInvCameraView), -1);
    rb_define_method(cScene.klass, "getPosition", VALUEFUNC(_wrap_Scene_getPosition), -1);
    rb_define_method(cScene.klass, "getCurrentNodes", VALUEFUNC(_wrap_Scene_getCurrentNodes), -1);
    cScene.mark = (void (*)(void *)) general_markfunc;
    cScene.destroy = (void (*)(void *)) free_Scene;
    rb_define_module_function(mLibantargis, "getScenes", VALUEFUNC(_wrap_getScenes), -1);
    rb_define_module_function(mLibantargis, "disown_Smoke", VALUEFUNC(_wrap_disown_Smoke), -1);
    
    cSmoke.klass = rb_define_class_under(mLibantargis, "Smoke", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_Smoke, (void *) &cSmoke);
    rb_define_alloc_func(cSmoke.klass, _wrap_Smoke_allocate);
    rb_define_method(cSmoke.klass, "initialize", VALUEFUNC(_wrap_new_Smoke), -1);
    rb_define_method(cSmoke.klass, "setFire", VALUEFUNC(_wrap_Smoke_setFire), -1);
    rb_define_method(cSmoke.klass, "setMaxTime", VALUEFUNC(_wrap_Smoke_setMaxTime), -1);
    rb_define_method(cSmoke.klass, "advance", VALUEFUNC(_wrap_Smoke_advance), -1);
    rb_define_method(cSmoke.klass, "transparent", VALUEFUNC(_wrap_Smoke_transparent), -1);
    rb_define_method(cSmoke.klass, "draw", VALUEFUNC(_wrap_Smoke_draw), -1);
    cSmoke.mark = (void (*)(void *)) general_markfunc;
    cSmoke.destroy = (void (*)(void *)) free_Smoke;
    rb_define_module_function(mLibantargis, "disown_TerrainPieceVA", VALUEFUNC(_wrap_disown_TerrainPieceVA), -1);
    
    cTerrainPieceVA.klass = rb_define_class_under(mLibantargis, "TerrainPieceVA", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_TerrainPieceVA, (void *) &cTerrainPieceVA);
    rb_define_alloc_func(cTerrainPieceVA.klass, _wrap_TerrainPieceVA_allocate);
    rb_define_method(cTerrainPieceVA.klass, "initialize", VALUEFUNC(_wrap_new_TerrainPieceVA), -1);
    rb_define_method(cTerrainPieceVA.klass, "draw", VALUEFUNC(_wrap_TerrainPieceVA_draw), -1);
    rb_define_method(cTerrainPieceVA.klass, "drawShadow", VALUEFUNC(_wrap_TerrainPieceVA_drawShadow), -1);
    rb_define_method(cTerrainPieceVA.klass, "drawDepth", VALUEFUNC(_wrap_TerrainPieceVA_drawDepth), -1);
    rb_define_method(cTerrainPieceVA.klass, "drawPick", VALUEFUNC(_wrap_TerrainPieceVA_drawPick), -1);
    rb_define_method(cTerrainPieceVA.klass, "lineHit", VALUEFUNC(_wrap_TerrainPieceVA_lineHit), -1);
    rb_define_method(cTerrainPieceVA.klass, "getTriangles", VALUEFUNC(_wrap_TerrainPieceVA_getTriangles), -1);
    rb_define_method(cTerrainPieceVA.klass, "mapChanged", VALUEFUNC(_wrap_TerrainPieceVA_mapChanged), -1);
    cTerrainPieceVA.mark = (void (*)(void *)) general_markfunc;
    cTerrainPieceVA.destroy = (void (*)(void *)) free_TerrainPieceVA;
    rb_define_module_function(mLibantargis, "disown_Terrain", VALUEFUNC(_wrap_disown_Terrain), -1);
    
    cTerrain.klass = rb_define_class_under(mLibantargis, "Terrain", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Terrain, (void *) &cTerrain);
    rb_define_alloc_func(cTerrain.klass, _wrap_Terrain_allocate);
    rb_define_method(cTerrain.klass, "initialize", VALUEFUNC(_wrap_new_Terrain), -1);
    rb_define_method(cTerrain.klass, "mapChanged", VALUEFUNC(_wrap_Terrain_mapChanged), -1);
    rb_define_method(cTerrain.klass, "mapChangedComplete", VALUEFUNC(_wrap_Terrain_mapChangedComplete), -1);
    rb_define_method(cTerrain.klass, "slotMapChanged", VALUEFUNC(_wrap_Terrain_slotMapChanged), -1);
    rb_define_method(cTerrain.klass, "slotMapChangedComplete", VALUEFUNC(_wrap_Terrain_slotMapChangedComplete), -1);
    rb_define_method(cTerrain.klass, "get3dTexture", VALUEFUNC(_wrap_Terrain_get3dTexture), -1);
    rb_define_method(cTerrain.klass, "getGrassTexture", VALUEFUNC(_wrap_Terrain_getGrassTexture), -1);
    rb_define_method(cTerrain.klass, "getScene", VALUEFUNC(_wrap_Terrain_getScene), -1);
    cTerrain.mark = 0;
    cTerrain.destroy = (void (*)(void *)) free_Terrain;
    rb_define_module_function(mLibantargis, "disown_VertexArray", VALUEFUNC(_wrap_disown_VertexArray), -1);
    
    cVertexArray.klass = rb_define_class_under(mLibantargis, "VertexArray", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_VertexArray, (void *) &cVertexArray);
    rb_define_alloc_func(cVertexArray.klass, _wrap_VertexArray_allocate);
    rb_define_method(cVertexArray.klass, "initialize", VALUEFUNC(_wrap_new_VertexArray), -1);
    rb_define_method(cVertexArray.klass, "addVertex", VALUEFUNC(_wrap_VertexArray_addVertex), -1);
    rb_define_method(cVertexArray.klass, "addTriangle", VALUEFUNC(_wrap_VertexArray_addTriangle), -1);
    rb_define_method(cVertexArray.klass, "setColors", VALUEFUNC(_wrap_VertexArray_setColors), -1);
    rb_define_method(cVertexArray.klass, "setBuffers", VALUEFUNC(_wrap_VertexArray_setBuffers), -1);
    rb_define_method(cVertexArray.klass, "draw", VALUEFUNC(_wrap_VertexArray_draw), -1);
    rb_define_method(cVertexArray.klass, "drawPick", VALUEFUNC(_wrap_VertexArray_drawPick), -1);
    rb_define_method(cVertexArray.klass, "init", VALUEFUNC(_wrap_VertexArray_init), -1);
    rb_define_method(cVertexArray.klass, "clear", VALUEFUNC(_wrap_VertexArray_clear), -1);
    rb_define_method(cVertexArray.klass, "update", VALUEFUNC(_wrap_VertexArray_update), -1);
    rb_define_method(cVertexArray.klass, "getTriangles", VALUEFUNC(_wrap_VertexArray_getTriangles), -1);
    rb_define_method(cVertexArray.klass, "getIndex", VALUEFUNC(_wrap_VertexArray_getIndex), -1);
    rb_define_method(cVertexArray.klass, "getVertex", VALUEFUNC(_wrap_VertexArray_getVertex), -1);
    rb_define_method(cVertexArray.klass, "getColor", VALUEFUNC(_wrap_VertexArray_getColor), -1);
    rb_define_method(cVertexArray.klass, "getNormal", VALUEFUNC(_wrap_VertexArray_getNormal), -1);
    rb_define_method(cVertexArray.klass, "getTexCoord", VALUEFUNC(_wrap_VertexArray_getTexCoord), -1);
    rb_define_method(cVertexArray.klass, "setTexCoord", VALUEFUNC(_wrap_VertexArray_setTexCoord), -1);
    rb_define_method(cVertexArray.klass, "lineHit", VALUEFUNC(_wrap_VertexArray_lineHit), -1);
    cVertexArray.mark = 0;
    cVertexArray.destroy = (void (*)(void *)) free_VertexArray;
    rb_define_module_function(mLibantargis, "disown_VertexArrayShader", VALUEFUNC(_wrap_disown_VertexArrayShader), -1);
    
    cVertexArrayShader.klass = rb_define_class_under(mLibantargis, "VertexArrayShader", ((swig_class *) SWIGTYPE_p_VertexArray->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_VertexArrayShader, (void *) &cVertexArrayShader);
    rb_define_alloc_func(cVertexArrayShader.klass, _wrap_VertexArrayShader_allocate);
    rb_define_method(cVertexArrayShader.klass, "initialize", VALUEFUNC(_wrap_new_VertexArrayShader), -1);
    rb_define_method(cVertexArrayShader.klass, "addAttribute", VALUEFUNC(_wrap_VertexArrayShader_addAttribute), -1);
    rb_define_method(cVertexArrayShader.klass, "draw", VALUEFUNC(_wrap_VertexArrayShader_draw), -1);
    cVertexArrayShader.mark = 0;
    cVertexArrayShader.destroy = (void (*)(void *)) free_VertexArrayShader;
    rb_define_module_function(mLibantargis, "disown_WaterPiece", VALUEFUNC(_wrap_disown_WaterPiece), -1);
    
    cWaterPiece.klass = rb_define_class_under(mLibantargis, "WaterPiece", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_WaterPiece, (void *) &cWaterPiece);
    rb_define_alloc_func(cWaterPiece.klass, _wrap_WaterPiece_allocate);
    rb_define_method(cWaterPiece.klass, "initialize", VALUEFUNC(_wrap_new_WaterPiece), -1);
    rb_define_method(cWaterPiece.klass, "draw", VALUEFUNC(_wrap_WaterPiece_draw), -1);
    rb_define_method(cWaterPiece.klass, "drawPick", VALUEFUNC(_wrap_WaterPiece_drawPick), -1);
    rb_define_method(cWaterPiece.klass, "advance", VALUEFUNC(_wrap_WaterPiece_advance), -1);
    rb_define_method(cWaterPiece.klass, "getTriangles", VALUEFUNC(_wrap_WaterPiece_getTriangles), -1);
    rb_define_method(cWaterPiece.klass, "transparent", VALUEFUNC(_wrap_WaterPiece_transparent), -1);
    rb_define_method(cWaterPiece.klass, "mapChanged", VALUEFUNC(_wrap_WaterPiece_mapChanged), -1);
    cWaterPiece.mark = (void (*)(void *)) general_markfunc;
    cWaterPiece.destroy = (void (*)(void *)) free_WaterPiece;
    rb_define_const(mLibantargis,"SDLK_UNKNOWN", INT2NUM(SDLK_UNKNOWN));
    rb_define_const(mLibantargis,"SDLK_FIRST", INT2NUM(SDLK_FIRST));
    rb_define_const(mLibantargis,"SDLK_BACKSPACE", INT2NUM(SDLK_BACKSPACE));
    rb_define_const(mLibantargis,"SDLK_TAB", INT2NUM(SDLK_TAB));
    rb_define_const(mLibantargis,"SDLK_CLEAR", INT2NUM(SDLK_CLEAR));
    rb_define_const(mLibantargis,"SDLK_RETURN", INT2NUM(SDLK_RETURN));
    rb_define_const(mLibantargis,"SDLK_PAUSE", INT2NUM(SDLK_PAUSE));
    rb_define_const(mLibantargis,"SDLK_ESCAPE", INT2NUM(SDLK_ESCAPE));
    rb_define_const(mLibantargis,"SDLK_SPACE", INT2NUM(SDLK_SPACE));
    rb_define_const(mLibantargis,"SDLK_EXCLAIM", INT2NUM(SDLK_EXCLAIM));
    rb_define_const(mLibantargis,"SDLK_QUOTEDBL", INT2NUM(SDLK_QUOTEDBL));
    rb_define_const(mLibantargis,"SDLK_HASH", INT2NUM(SDLK_HASH));
    rb_define_const(mLibantargis,"SDLK_DOLLAR", INT2NUM(SDLK_DOLLAR));
    rb_define_const(mLibantargis,"SDLK_AMPERSAND", INT2NUM(SDLK_AMPERSAND));
    rb_define_const(mLibantargis,"SDLK_QUOTE", INT2NUM(SDLK_QUOTE));
    rb_define_const(mLibantargis,"SDLK_LEFTPAREN", INT2NUM(SDLK_LEFTPAREN));
    rb_define_const(mLibantargis,"SDLK_RIGHTPAREN", INT2NUM(SDLK_RIGHTPAREN));
    rb_define_const(mLibantargis,"SDLK_ASTERISK", INT2NUM(SDLK_ASTERISK));
    rb_define_const(mLibantargis,"SDLK_PLUS", INT2NUM(SDLK_PLUS));
    rb_define_const(mLibantargis,"SDLK_COMMA", INT2NUM(SDLK_COMMA));
    rb_define_const(mLibantargis,"SDLK_MINUS", INT2NUM(SDLK_MINUS));
    rb_define_const(mLibantargis,"SDLK_PERIOD", INT2NUM(SDLK_PERIOD));
    rb_define_const(mLibantargis,"SDLK_SLASH", INT2NUM(SDLK_SLASH));
    rb_define_const(mLibantargis,"SDLK_0", INT2NUM(SDLK_0));
    rb_define_const(mLibantargis,"SDLK_1", INT2NUM(SDLK_1));
    rb_define_const(mLibantargis,"SDLK_2", INT2NUM(SDLK_2));
    rb_define_const(mLibantargis,"SDLK_3", INT2NUM(SDLK_3));
    rb_define_const(mLibantargis,"SDLK_4", INT2NUM(SDLK_4));
    rb_define_const(mLibantargis,"SDLK_5", INT2NUM(SDLK_5));
    rb_define_const(mLibantargis,"SDLK_6", INT2NUM(SDLK_6));
    rb_define_const(mLibantargis,"SDLK_7", INT2NUM(SDLK_7));
    rb_define_const(mLibantargis,"SDLK_8", INT2NUM(SDLK_8));
    rb_define_const(mLibantargis,"SDLK_9", INT2NUM(SDLK_9));
    rb_define_const(mLibantargis,"SDLK_COLON", INT2NUM(SDLK_COLON));
    rb_define_const(mLibantargis,"SDLK_SEMICOLON", INT2NUM(SDLK_SEMICOLON));
    rb_define_const(mLibantargis,"SDLK_LESS", INT2NUM(SDLK_LESS));
    rb_define_const(mLibantargis,"SDLK_EQUALS", INT2NUM(SDLK_EQUALS));
    rb_define_const(mLibantargis,"SDLK_GREATER", INT2NUM(SDLK_GREATER));
    rb_define_const(mLibantargis,"SDLK_QUESTION", INT2NUM(SDLK_QUESTION));
    rb_define_const(mLibantargis,"SDLK_AT", INT2NUM(SDLK_AT));
    rb_define_const(mLibantargis,"SDLK_LEFTBRACKET", INT2NUM(SDLK_LEFTBRACKET));
    rb_define_const(mLibantargis,"SDLK_BACKSLASH", INT2NUM(SDLK_BACKSLASH));
    rb_define_const(mLibantargis,"SDLK_RIGHTBRACKET", INT2NUM(SDLK_RIGHTBRACKET));
    rb_define_const(mLibantargis,"SDLK_CARET", INT2NUM(SDLK_CARET));
    rb_define_const(mLibantargis,"SDLK_UNDERSCORE", INT2NUM(SDLK_UNDERSCORE));
    rb_define_const(mLibantargis,"SDLK_BACKQUOTE", INT2NUM(SDLK_BACKQUOTE));
    rb_define_const(mLibantargis,"SDLK_a", INT2NUM(SDLK_a));
    rb_define_const(mLibantargis,"SDLK_b", INT2NUM(SDLK_b));
    rb_define_const(mLibantargis,"SDLK_c", INT2NUM(SDLK_c));
    rb_define_const(mLibantargis,"SDLK_d", INT2NUM(SDLK_d));
    rb_define_const(mLibantargis,"SDLK_e", INT2NUM(SDLK_e));
    rb_define_const(mLibantargis,"SDLK_f", INT2NUM(SDLK_f));
    rb_define_const(mLibantargis,"SDLK_g", INT2NUM(SDLK_g));
    rb_define_const(mLibantargis,"SDLK_h", INT2NUM(SDLK_h));
    rb_define_const(mLibantargis,"SDLK_i", INT2NUM(SDLK_i));
    rb_define_const(mLibantargis,"SDLK_j", INT2NUM(SDLK_j));
    rb_define_const(mLibantargis,"SDLK_k", INT2NUM(SDLK_k));
    rb_define_const(mLibantargis,"SDLK_l", INT2NUM(SDLK_l));
    rb_define_const(mLibantargis,"SDLK_m", INT2NUM(SDLK_m));
    rb_define_const(mLibantargis,"SDLK_n", INT2NUM(SDLK_n));
    rb_define_const(mLibantargis,"SDLK_o", INT2NUM(SDLK_o));
    rb_define_const(mLibantargis,"SDLK_p", INT2NUM(SDLK_p));
    rb_define_const(mLibantargis,"SDLK_q", INT2NUM(SDLK_q));
    rb_define_const(mLibantargis,"SDLK_r", INT2NUM(SDLK_r));
    rb_define_const(mLibantargis,"SDLK_s", INT2NUM(SDLK_s));
    rb_define_const(mLibantargis,"SDLK_t", INT2NUM(SDLK_t));
    rb_define_const(mLibantargis,"SDLK_u", INT2NUM(SDLK_u));
    rb_define_const(mLibantargis,"SDLK_v", INT2NUM(SDLK_v));
    rb_define_const(mLibantargis,"SDLK_w", INT2NUM(SDLK_w));
    rb_define_const(mLibantargis,"SDLK_x", INT2NUM(SDLK_x));
    rb_define_const(mLibantargis,"SDLK_y", INT2NUM(SDLK_y));
    rb_define_const(mLibantargis,"SDLK_z", INT2NUM(SDLK_z));
    rb_define_const(mLibantargis,"SDLK_DELETE", INT2NUM(SDLK_DELETE));
    rb_define_const(mLibantargis,"SDLK_WORLD_0", INT2NUM(SDLK_WORLD_0));
    rb_define_const(mLibantargis,"SDLK_WORLD_1", INT2NUM(SDLK_WORLD_1));
    rb_define_const(mLibantargis,"SDLK_WORLD_2", INT2NUM(SDLK_WORLD_2));
    rb_define_const(mLibantargis,"SDLK_WORLD_3", INT2NUM(SDLK_WORLD_3));
    rb_define_const(mLibantargis,"SDLK_WORLD_4", INT2NUM(SDLK_WORLD_4));
    rb_define_const(mLibantargis,"SDLK_WORLD_5", INT2NUM(SDLK_WORLD_5));
    rb_define_const(mLibantargis,"SDLK_WORLD_6", INT2NUM(SDLK_WORLD_6));
    rb_define_const(mLibantargis,"SDLK_WORLD_7", INT2NUM(SDLK_WORLD_7));
    rb_define_const(mLibantargis,"SDLK_WORLD_8", INT2NUM(SDLK_WORLD_8));
    rb_define_const(mLibantargis,"SDLK_WORLD_9", INT2NUM(SDLK_WORLD_9));
    rb_define_const(mLibantargis,"SDLK_WORLD_10", INT2NUM(SDLK_WORLD_10));
    rb_define_const(mLibantargis,"SDLK_WORLD_11", INT2NUM(SDLK_WORLD_11));
    rb_define_const(mLibantargis,"SDLK_WORLD_12", INT2NUM(SDLK_WORLD_12));
    rb_define_const(mLibantargis,"SDLK_WORLD_13", INT2NUM(SDLK_WORLD_13));
    rb_define_const(mLibantargis,"SDLK_WORLD_14", INT2NUM(SDLK_WORLD_14));
    rb_define_const(mLibantargis,"SDLK_WORLD_15", INT2NUM(SDLK_WORLD_15));
    rb_define_const(mLibantargis,"SDLK_WORLD_16", INT2NUM(SDLK_WORLD_16));
    rb_define_const(mLibantargis,"SDLK_WORLD_17", INT2NUM(SDLK_WORLD_17));
    rb_define_const(mLibantargis,"SDLK_WORLD_18", INT2NUM(SDLK_WORLD_18));
    rb_define_const(mLibantargis,"SDLK_WORLD_19", INT2NUM(SDLK_WORLD_19));
    rb_define_const(mLibantargis,"SDLK_WORLD_20", INT2NUM(SDLK_WORLD_20));
    rb_define_const(mLibantargis,"SDLK_WORLD_21", INT2NUM(SDLK_WORLD_21));
    rb_define_const(mLibantargis,"SDLK_WORLD_22", INT2NUM(SDLK_WORLD_22));
    rb_define_const(mLibantargis,"SDLK_WORLD_23", INT2NUM(SDLK_WORLD_23));
    rb_define_const(mLibantargis,"SDLK_WORLD_24", INT2NUM(SDLK_WORLD_24));
    rb_define_const(mLibantargis,"SDLK_WORLD_25", INT2NUM(SDLK_WORLD_25));
    rb_define_const(mLibantargis,"SDLK_WORLD_26", INT2NUM(SDLK_WORLD_26));
    rb_define_const(mLibantargis,"SDLK_WORLD_27", INT2NUM(SDLK_WORLD_27));
    rb_define_const(mLibantargis,"SDLK_WORLD_28", INT2NUM(SDLK_WORLD_28));
    rb_define_const(mLibantargis,"SDLK_WORLD_29", INT2NUM(SDLK_WORLD_29));
    rb_define_const(mLibantargis,"SDLK_WORLD_30", INT2NUM(SDLK_WORLD_30));
    rb_define_const(mLibantargis,"SDLK_WORLD_31", INT2NUM(SDLK_WORLD_31));
    rb_define_const(mLibantargis,"SDLK_WORLD_32", INT2NUM(SDLK_WORLD_32));
    rb_define_const(mLibantargis,"SDLK_WORLD_33", INT2NUM(SDLK_WORLD_33));
    rb_define_const(mLibantargis,"SDLK_WORLD_34", INT2NUM(SDLK_WORLD_34));
    rb_define_const(mLibantargis,"SDLK_WORLD_35", INT2NUM(SDLK_WORLD_35));
    rb_define_const(mLibantargis,"SDLK_WORLD_36", INT2NUM(SDLK_WORLD_36));
    rb_define_const(mLibantargis,"SDLK_WORLD_37", INT2NUM(SDLK_WORLD_37));
    rb_define_const(mLibantargis,"SDLK_WORLD_38", INT2NUM(SDLK_WORLD_38));
    rb_define_const(mLibantargis,"SDLK_WORLD_39", INT2NUM(SDLK_WORLD_39));
    rb_define_const(mLibantargis,"SDLK_WORLD_40", INT2NUM(SDLK_WORLD_40));
    rb_define_const(mLibantargis,"SDLK_WORLD_41", INT2NUM(SDLK_WORLD_41));
    rb_define_const(mLibantargis,"SDLK_WORLD_42", INT2NUM(SDLK_WORLD_42));
    rb_define_const(mLibantargis,"SDLK_WORLD_43", INT2NUM(SDLK_WORLD_43));
    rb_define_const(mLibantargis,"SDLK_WORLD_44", INT2NUM(SDLK_WORLD_44));
    rb_define_const(mLibantargis,"SDLK_WORLD_45", INT2NUM(SDLK_WORLD_45));
    rb_define_const(mLibantargis,"SDLK_WORLD_46", INT2NUM(SDLK_WORLD_46));
    rb_define_const(mLibantargis,"SDLK_WORLD_47", INT2NUM(SDLK_WORLD_47));
    rb_define_const(mLibantargis,"SDLK_WORLD_48", INT2NUM(SDLK_WORLD_48));
    rb_define_const(mLibantargis,"SDLK_WORLD_49", INT2NUM(SDLK_WORLD_49));
    rb_define_const(mLibantargis,"SDLK_WORLD_50", INT2NUM(SDLK_WORLD_50));
    rb_define_const(mLibantargis,"SDLK_WORLD_51", INT2NUM(SDLK_WORLD_51));
    rb_define_const(mLibantargis,"SDLK_WORLD_52", INT2NUM(SDLK_WORLD_52));
    rb_define_const(mLibantargis,"SDLK_WORLD_53", INT2NUM(SDLK_WORLD_53));
    rb_define_const(mLibantargis,"SDLK_WORLD_54", INT2NUM(SDLK_WORLD_54));
    rb_define_const(mLibantargis,"SDLK_WORLD_55", INT2NUM(SDLK_WORLD_55));
    rb_define_const(mLibantargis,"SDLK_WORLD_56", INT2NUM(SDLK_WORLD_56));
    rb_define_const(mLibantargis,"SDLK_WORLD_57", INT2NUM(SDLK_WORLD_57));
    rb_define_const(mLibantargis,"SDLK_WORLD_58", INT2NUM(SDLK_WORLD_58));
    rb_define_const(mLibantargis,"SDLK_WORLD_59", INT2NUM(SDLK_WORLD_59));
    rb_define_const(mLibantargis,"SDLK_WORLD_60", INT2NUM(SDLK_WORLD_60));
    rb_define_const(mLibantargis,"SDLK_WORLD_61", INT2NUM(SDLK_WORLD_61));
    rb_define_const(mLibantargis,"SDLK_WORLD_62", INT2NUM(SDLK_WORLD_62));
    rb_define_const(mLibantargis,"SDLK_WORLD_63", INT2NUM(SDLK_WORLD_63));
    rb_define_const(mLibantargis,"SDLK_WORLD_64", INT2NUM(SDLK_WORLD_64));
    rb_define_const(mLibantargis,"SDLK_WORLD_65", INT2NUM(SDLK_WORLD_65));
    rb_define_const(mLibantargis,"SDLK_WORLD_66", INT2NUM(SDLK_WORLD_66));
    rb_define_const(mLibantargis,"SDLK_WORLD_67", INT2NUM(SDLK_WORLD_67));
    rb_define_const(mLibantargis,"SDLK_WORLD_68", INT2NUM(SDLK_WORLD_68));
    rb_define_const(mLibantargis,"SDLK_WORLD_69", INT2NUM(SDLK_WORLD_69));
    rb_define_const(mLibantargis,"SDLK_WORLD_70", INT2NUM(SDLK_WORLD_70));
    rb_define_const(mLibantargis,"SDLK_WORLD_71", INT2NUM(SDLK_WORLD_71));
    rb_define_const(mLibantargis,"SDLK_WORLD_72", INT2NUM(SDLK_WORLD_72));
    rb_define_const(mLibantargis,"SDLK_WORLD_73", INT2NUM(SDLK_WORLD_73));
    rb_define_const(mLibantargis,"SDLK_WORLD_74", INT2NUM(SDLK_WORLD_74));
    rb_define_const(mLibantargis,"SDLK_WORLD_75", INT2NUM(SDLK_WORLD_75));
    rb_define_const(mLibantargis,"SDLK_WORLD_76", INT2NUM(SDLK_WORLD_76));
    rb_define_const(mLibantargis,"SDLK_WORLD_77", INT2NUM(SDLK_WORLD_77));
    rb_define_const(mLibantargis,"SDLK_WORLD_78", INT2NUM(SDLK_WORLD_78));
    rb_define_const(mLibantargis,"SDLK_WORLD_79", INT2NUM(SDLK_WORLD_79));
    rb_define_const(mLibantargis,"SDLK_WORLD_80", INT2NUM(SDLK_WORLD_80));
    rb_define_const(mLibantargis,"SDLK_WORLD_81", INT2NUM(SDLK_WORLD_81));
    rb_define_const(mLibantargis,"SDLK_WORLD_82", INT2NUM(SDLK_WORLD_82));
    rb_define_const(mLibantargis,"SDLK_WORLD_83", INT2NUM(SDLK_WORLD_83));
    rb_define_const(mLibantargis,"SDLK_WORLD_84", INT2NUM(SDLK_WORLD_84));
    rb_define_const(mLibantargis,"SDLK_WORLD_85", INT2NUM(SDLK_WORLD_85));
    rb_define_const(mLibantargis,"SDLK_WORLD_86", INT2NUM(SDLK_WORLD_86));
    rb_define_const(mLibantargis,"SDLK_WORLD_87", INT2NUM(SDLK_WORLD_87));
    rb_define_const(mLibantargis,"SDLK_WORLD_88", INT2NUM(SDLK_WORLD_88));
    rb_define_const(mLibantargis,"SDLK_WORLD_89", INT2NUM(SDLK_WORLD_89));
    rb_define_const(mLibantargis,"SDLK_WORLD_90", INT2NUM(SDLK_WORLD_90));
    rb_define_const(mLibantargis,"SDLK_WORLD_91", INT2NUM(SDLK_WORLD_91));
    rb_define_const(mLibantargis,"SDLK_WORLD_92", INT2NUM(SDLK_WORLD_92));
    rb_define_const(mLibantargis,"SDLK_WORLD_93", INT2NUM(SDLK_WORLD_93));
    rb_define_const(mLibantargis,"SDLK_WORLD_94", INT2NUM(SDLK_WORLD_94));
    rb_define_const(mLibantargis,"SDLK_WORLD_95", INT2NUM(SDLK_WORLD_95));
    rb_define_const(mLibantargis,"SDLK_KP0", INT2NUM(SDLK_KP0));
    rb_define_const(mLibantargis,"SDLK_KP1", INT2NUM(SDLK_KP1));
    rb_define_const(mLibantargis,"SDLK_KP2", INT2NUM(SDLK_KP2));
    rb_define_const(mLibantargis,"SDLK_KP3", INT2NUM(SDLK_KP3));
    rb_define_const(mLibantargis,"SDLK_KP4", INT2NUM(SDLK_KP4));
    rb_define_const(mLibantargis,"SDLK_KP5", INT2NUM(SDLK_KP5));
    rb_define_const(mLibantargis,"SDLK_KP6", INT2NUM(SDLK_KP6));
    rb_define_const(mLibantargis,"SDLK_KP7", INT2NUM(SDLK_KP7));
    rb_define_const(mLibantargis,"SDLK_KP8", INT2NUM(SDLK_KP8));
    rb_define_const(mLibantargis,"SDLK_KP9", INT2NUM(SDLK_KP9));
    rb_define_const(mLibantargis,"SDLK_KP_PERIOD", INT2NUM(SDLK_KP_PERIOD));
    rb_define_const(mLibantargis,"SDLK_KP_DIVIDE", INT2NUM(SDLK_KP_DIVIDE));
    rb_define_const(mLibantargis,"SDLK_KP_MULTIPLY", INT2NUM(SDLK_KP_MULTIPLY));
    rb_define_const(mLibantargis,"SDLK_KP_MINUS", INT2NUM(SDLK_KP_MINUS));
    rb_define_const(mLibantargis,"SDLK_KP_PLUS", INT2NUM(SDLK_KP_PLUS));
    rb_define_const(mLibantargis,"SDLK_KP_ENTER", INT2NUM(SDLK_KP_ENTER));
    rb_define_const(mLibantargis,"SDLK_KP_EQUALS", INT2NUM(SDLK_KP_EQUALS));
    rb_define_const(mLibantargis,"SDLK_UP", INT2NUM(SDLK_UP));
    rb_define_const(mLibantargis,"SDLK_DOWN", INT2NUM(SDLK_DOWN));
    rb_define_const(mLibantargis,"SDLK_RIGHT", INT2NUM(SDLK_RIGHT));
    rb_define_const(mLibantargis,"SDLK_LEFT", INT2NUM(SDLK_LEFT));
    rb_define_const(mLibantargis,"SDLK_INSERT", INT2NUM(SDLK_INSERT));
    rb_define_const(mLibantargis,"SDLK_HOME", INT2NUM(SDLK_HOME));
    rb_define_const(mLibantargis,"SDLK_END", INT2NUM(SDLK_END));
    rb_define_const(mLibantargis,"SDLK_PAGEUP", INT2NUM(SDLK_PAGEUP));
    rb_define_const(mLibantargis,"SDLK_PAGEDOWN", INT2NUM(SDLK_PAGEDOWN));
    rb_define_const(mLibantargis,"SDLK_F1", INT2NUM(SDLK_F1));
    rb_define_const(mLibantargis,"SDLK_F2", INT2NUM(SDLK_F2));
    rb_define_const(mLibantargis,"SDLK_F3", INT2NUM(SDLK_F3));
    rb_define_const(mLibantargis,"SDLK_F4", INT2NUM(SDLK_F4));
    rb_define_const(mLibantargis,"SDLK_F5", INT2NUM(SDLK_F5));
    rb_define_const(mLibantargis,"SDLK_F6", INT2NUM(SDLK_F6));
    rb_define_const(mLibantargis,"SDLK_F7", INT2NUM(SDLK_F7));
    rb_define_const(mLibantargis,"SDLK_F8", INT2NUM(SDLK_F8));
    rb_define_const(mLibantargis,"SDLK_F9", INT2NUM(SDLK_F9));
    rb_define_const(mLibantargis,"SDLK_F10", INT2NUM(SDLK_F10));
    rb_define_const(mLibantargis,"SDLK_F11", INT2NUM(SDLK_F11));
    rb_define_const(mLibantargis,"SDLK_F12", INT2NUM(SDLK_F12));
    rb_define_const(mLibantargis,"SDLK_F13", INT2NUM(SDLK_F13));
    rb_define_const(mLibantargis,"SDLK_F14", INT2NUM(SDLK_F14));
    rb_define_const(mLibantargis,"SDLK_F15", INT2NUM(SDLK_F15));
    rb_define_const(mLibantargis,"SDLK_NUMLOCK", INT2NUM(SDLK_NUMLOCK));
    rb_define_const(mLibantargis,"SDLK_CAPSLOCK", INT2NUM(SDLK_CAPSLOCK));
    rb_define_const(mLibantargis,"SDLK_SCROLLOCK", INT2NUM(SDLK_SCROLLOCK));
    rb_define_const(mLibantargis,"SDLK_RSHIFT", INT2NUM(SDLK_RSHIFT));
    rb_define_const(mLibantargis,"SDLK_LSHIFT", INT2NUM(SDLK_LSHIFT));
    rb_define_const(mLibantargis,"SDLK_RCTRL", INT2NUM(SDLK_RCTRL));
    rb_define_const(mLibantargis,"SDLK_LCTRL", INT2NUM(SDLK_LCTRL));
    rb_define_const(mLibantargis,"SDLK_RALT", INT2NUM(SDLK_RALT));
    rb_define_const(mLibantargis,"SDLK_LALT", INT2NUM(SDLK_LALT));
    rb_define_const(mLibantargis,"SDLK_RMETA", INT2NUM(SDLK_RMETA));
    rb_define_const(mLibantargis,"SDLK_LMETA", INT2NUM(SDLK_LMETA));
    rb_define_const(mLibantargis,"SDLK_LSUPER", INT2NUM(SDLK_LSUPER));
    rb_define_const(mLibantargis,"SDLK_RSUPER", INT2NUM(SDLK_RSUPER));
    rb_define_const(mLibantargis,"SDLK_MODE", INT2NUM(SDLK_MODE));
    rb_define_const(mLibantargis,"SDLK_COMPOSE", INT2NUM(SDLK_COMPOSE));
    rb_define_const(mLibantargis,"SDLK_HELP", INT2NUM(SDLK_HELP));
    rb_define_const(mLibantargis,"SDLK_PRINT", INT2NUM(SDLK_PRINT));
    rb_define_const(mLibantargis,"SDLK_SYSREQ", INT2NUM(SDLK_SYSREQ));
    rb_define_const(mLibantargis,"SDLK_BREAK", INT2NUM(SDLK_BREAK));
    rb_define_const(mLibantargis,"SDLK_MENU", INT2NUM(SDLK_MENU));
    rb_define_const(mLibantargis,"SDLK_POWER", INT2NUM(SDLK_POWER));
    rb_define_const(mLibantargis,"SDLK_EURO", INT2NUM(SDLK_EURO));
    rb_define_const(mLibantargis,"SDLK_UNDO", INT2NUM(SDLK_UNDO));
    rb_define_const(mLibantargis,"SDLK_LAST", INT2NUM(SDLK_LAST));
    rb_define_const(mLibantargis,"KMOD_NONE", INT2NUM(KMOD_NONE));
    rb_define_const(mLibantargis,"KMOD_LSHIFT", INT2NUM(KMOD_LSHIFT));
    rb_define_const(mLibantargis,"KMOD_RSHIFT", INT2NUM(KMOD_RSHIFT));
    rb_define_const(mLibantargis,"KMOD_LCTRL", INT2NUM(KMOD_LCTRL));
    rb_define_const(mLibantargis,"KMOD_RCTRL", INT2NUM(KMOD_RCTRL));
    rb_define_const(mLibantargis,"KMOD_LALT", INT2NUM(KMOD_LALT));
    rb_define_const(mLibantargis,"KMOD_RALT", INT2NUM(KMOD_RALT));
    rb_define_const(mLibantargis,"KMOD_LMETA", INT2NUM(KMOD_LMETA));
    rb_define_const(mLibantargis,"KMOD_RMETA", INT2NUM(KMOD_RMETA));
    rb_define_const(mLibantargis,"KMOD_NUM", INT2NUM(KMOD_NUM));
    rb_define_const(mLibantargis,"KMOD_CAPS", INT2NUM(KMOD_CAPS));
    rb_define_const(mLibantargis,"KMOD_MODE", INT2NUM(KMOD_MODE));
    rb_define_const(mLibantargis,"KMOD_RESERVED", INT2NUM(KMOD_RESERVED));
}


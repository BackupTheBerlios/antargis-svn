/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.24
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIG_DIRECTORS

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif


#ifndef SWIG_TEMPLATE_DISAMBIGUATOR
#  if defined(__SUNPRO_CC) 
#    define SWIG_TEMPLATE_DISAMBIGUATOR template
#  else
#    define SWIG_TEMPLATE_DISAMBIGUATOR 
#  endif
#endif

/* ruby.swg */
/* Implementation : RUBY */
#define SWIGRUBY 1

#include "ruby.h"

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

#define NUM2USHRT(n) (\
    (0 <= NUM2UINT(n) && NUM2UINT(n) <= USHRT_MAX)\
    ? (unsigned short) NUM2UINT(n) \
    : (rb_raise(rb_eArgError, "integer %d out of range of `unsigned short'",\
               NUM2UINT(n)), (short)0)\
)

#define NUM2SHRT(n) (\
    (SHRT_MIN <= NUM2INT(n) && NUM2INT(n) <= SHRT_MAX)\
    ? (short)NUM2INT(n)\
    : (rb_raise(rb_eArgError, "integer %d out of range of `short'",\
               NUM2INT(n)), (short)0)\
)

/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
} swig_class;

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING(RB_STRING_VALUE(s))->ptr
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING(RB_STRING_VALUE(s))->len
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

/* Contract support */

#define SWIG_contract_assert(expr, msg) if (!(expr)) { rb_raise(rb_eRuntimeError, (char *) msg ); } else


/***********************************************************************
 * swigrun.swg
 *
 *     This file contains generic CAPI SWIG runtime support for pointer
 *     type checking.
 *
 ************************************************************************/

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "1"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
#define SWIG_QUOTE_STRING(x) #x
#define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
#define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
#define SWIG_TYPE_TABLE_NAME
#endif

#include <string.h>

#ifndef SWIGINLINE
#if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#  define SWIGINLINE inline
#else
#  define SWIGINLINE
#endif
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/
#ifndef SWIGRUNTIME
#define SWIGRUNTIME static
#endif
#ifndef SWIGRUNTIMEINLINE
#define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return *f1 - *f2;
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te) == 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Register a type mapping with the type-checking
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeRegisterTL(swig_type_info **tl, swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = *tl;
  while (tc) {
    /* check simple type equivalence */
    int typeequiv = (strcmp(tc->name, ti->name) == 0);   
    /* check full type equivalence, resolving typedefs */
    if (!typeequiv) {
      /* only if tc is not a typedef (no '|' on it) */
      if (tc->str && ti->str && !strstr(tc->str,"|")) {
	typeequiv = SWIG_TypeEquiv(ti->str,tc->str);
      }
    }
    if (typeequiv) {
      /* Already exists in the table.  Just add additional types to the list */
      if (ti->clientdata) tc->clientdata = ti->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = *tl;
  *tl = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;

  return ret;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
  Search for a swig_type_info structure
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryTL(swig_type_info *tl, const char *name) {
  swig_type_info *ty = tl;
  while (ty) {
    if (ty->str && (SWIG_TypeEquiv(ty->str,name))) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientDataTL(swig_type_info *tl, swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = tl;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientDataTL(tl,tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static char hex[17] = "0123456789abcdef";
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  register unsigned char uu;
  for (; u != eu; ++u) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register int d = *(c++);
    register unsigned char uu = 0;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
  This function will propagate the clientdata field of type to any new
  swig_type_info structures that have been added into the list of
  equivalent types.  It is like calling SWIG_TypeClientData(type,
  clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientDataTL(swig_type_info *tl, swig_type_info *type) {
  swig_type_info *equiv = type->next;
  swig_type_info *tc;
  if (!type->clientdata) return;
  while (equiv) {
    if (!equiv->converter) {
      tc = tl;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0) && !tc->clientdata)
          SWIG_TypeClientDataTL(tl,tc, type->clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/


#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if !defined(STATIC_LINKED)
#    define SWIGEXPORT(a) __declspec(dllexport) a
#  else
#    define SWIGEXPORT(a) a
#  endif
#else
#  define SWIGEXPORT(a) a
#endif

#ifdef __cplusplus
extern "C" {
#endif


/*************************************************************************/


/* The static type info list */

static swig_type_info *swig_type_list = 0;
static swig_type_info **swig_type_list_handle = &swig_type_list;
  

/* Register a type mapping with the type-checking */
static swig_type_info *
SWIG_TypeRegister(swig_type_info *ti) {
  return SWIG_TypeRegisterTL(swig_type_list_handle, ti);
}

/* Search for a swig_type_info structure */
static swig_type_info *
SWIG_TypeQuery(const char *name) {
  return SWIG_TypeQueryTL(*swig_type_list_handle, name);
}

/* Set the clientdata field for a type */
static void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientDataTL(*swig_type_list_handle, ti, clientdata);
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
static void
SWIG_PropagateClientData(swig_type_info *type) {
  SWIG_PropagateClientDataTL(*swig_type_list_handle, type);
}

#ifdef __cplusplus
}
#endif

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags) \
  SWIG_Ruby_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags) \
  SWIG_Ruby_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags) \
  SWIG_Ruby_MustGetPtr(p, type, argnum, flags)

/* Ruby-specific SWIG API */

#define SWIG_InitRuntime() \
  SWIG_Ruby_InitRuntime()
#define SWIG_define_class(ty) \
  SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty) \
  SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value) \
  SWIG_Ruby_MangleStr(value)
#define SWIG_CheckConvert(value, ty) \
  SWIG_Ruby_CheckConvert(value, ty)
#define SWIG_NewPackedObj(ptr, sz, ty) \
  SWIG_Ruby_NewPackedObj(ptr, sz, ty)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)

/* rubydef.swg */
#ifdef __cplusplus
extern "C" {
#endif

static VALUE _mSWIG = Qnil;
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Initialize Ruby runtime support */
static void
SWIG_Ruby_InitRuntime(void)
{
    VALUE pointer;
    
    if (_mSWIG == Qnil) {
        _mSWIG = rb_define_module("SWIG");
    }
    
    /* first check if pointer already created */
    pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
    if (pointer != Qnil) {
      Data_Get_Struct(pointer, swig_type_info *, swig_type_list_handle);
    } else {
      /* register a new class */
      VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
      /* create and store the structure pointer to a global variable */
      swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, swig_type_list_handle);
      rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
    }
}

/* Define Ruby class for C type */
static void
SWIG_Ruby_define_class(swig_type_info *type)
{
    VALUE klass;
    char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    if (NIL_P(_cSWIG_Pointer)) {
	_cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
	rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
    }
    klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
    free((void *) klass_name);
}

/* Create a new pointer object */
static VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int own)
{
    char *klass_name;
    swig_class *sklass;
    VALUE klass;
    VALUE obj;
    
    if (!ptr)
	return Qnil;
    
    if (type->clientdata) {
      sklass = (swig_class *) type->clientdata;
      obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);
    } else {
      klass_name = (char *) malloc(4 + strlen(type->name) + 1);
      sprintf(klass_name, "TYPE%s", type->name);
      klass = rb_const_get(_mSWIG, rb_intern(klass_name));
      free((void *) klass_name);
      obj = Data_Wrap_Struct(klass, 0, 0, ptr);
    }
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Create a new class instance (always owned) */
static VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
    VALUE obj;
    swig_class *sklass = (swig_class *) type->clientdata;
    obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Get type mangle from class name */
static SWIGINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "__swigtype__");
  return StringValuePtr(stype);
}

/* Convert a pointer value */
static int
SWIG_Ruby_ConvertPtr(VALUE obj, void **ptr, swig_type_info *ty, int flags)
{
  char *c;
  swig_type_info *tc;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return 0;
  } else {
    Data_Get_Struct(obj, void, *ptr);
  }
  
  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
        if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
          if (*ptr == 0)
            rb_raise(rb_eRuntimeError, "This %s already released", ty->str);
          return 0;
        }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      if (flags & SWIG_POINTER_EXCEPTION)
        rb_raise(rb_eTypeError, "Expected %s", ty->str);
      else
        return -1;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      if (flags & SWIG_POINTER_EXCEPTION)
        rb_raise(rb_eTypeError, "Expected %s", ty->str);
      else
        return -1;
    }
    *ptr = SWIG_TypeCast(tc, *ptr);
  }
  return 0;
}

/* Convert a pointer value, signal an exception on a type mismatch */
static SWIGINLINE void *
SWIG_Ruby_MustGetPtr(VALUE obj, swig_type_info *ty, int argnum, int flags)
{
  void *result;
  SWIG_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
  return result;
}

/* Check convert */
static SWIGINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c)
    return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

static VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
static void
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return;

type_error:

  if (flags) {
    if (ty) {
      rb_raise(rb_eTypeError, "Type error. Expected %s", ty->name);
    } else {
      rb_raise(rb_eTypeError, "Expected a pointer");
    }
  }
}

#ifdef __cplusplus
}
#endif



/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_AGBackground swig_types[0] 
#define  SWIGTYPE_p_iterator swig_types[1] 
#define  SWIGTYPE_p_const_iterator swig_types[2] 
#define  SWIGTYPE_p_Node__NodeVector__iterator swig_types[3] 
#define  SWIGTYPE_p_Node__NodeVector__const_iterator swig_types[4] 
#define  SWIGTYPE_p_Document swig_types[5] 
#define  SWIGTYPE_p_std__vectorTAGVector4_t swig_types[6] 
#define  SWIGTYPE_p_MeshOptimizer swig_types[7] 
#define  SWIGTYPE_p_MeshData swig_types[8] 
#define  SWIGTYPE_p_AGAngle swig_types[9] 
#define  SWIGTYPE_p_AGMenu swig_types[10] 
#define  SWIGTYPE_p_std__vectorTAGVector3_t swig_types[11] 
#define  SWIGTYPE_p_AntEntityPtr swig_types[12] 
#define  SWIGTYPE_p_AGHTiler swig_types[13] 
#define  SWIGTYPE_p_AGLayout swig_types[14] 
#define  SWIGTYPE_p_AGMain swig_types[15] 
#define  SWIGTYPE_p_NodeVector swig_types[16] 
#define  SWIGTYPE_p_GLApp swig_types[17] 
#define  SWIGTYPE_p_AGVTiler swig_types[18] 
#define  SWIGTYPE_p_AGCollisionData swig_types[19] 
#define  SWIGTYPE_p_AGCheckBox swig_types[20] 
#define  SWIGTYPE_p_AGLayoutFactory swig_types[21] 
#define  SWIGTYPE_p_AGSound swig_types[22] 
#define  SWIGTYPE_p_AGFont swig_types[23] 
#define  SWIGTYPE_p_AGScreen swig_types[24] 
#define  SWIGTYPE_p_Scene swig_types[25] 
#define  SWIGTYPE_p_AGTable swig_types[26] 
#define  SWIGTYPE_p_AGEditLine swig_types[27] 
#define  SWIGTYPE_p_HeightMap swig_types[28] 
#define  SWIGTYPE_p_AGListBoxItem swig_types[29] 
#define  SWIGTYPE_p_AGSignal swig_types[30] 
#define  SWIGTYPE_p_MeshVertex swig_types[31] 
#define  SWIGTYPE_p_std__vectorTAGRect3_t swig_types[32] 
#define  SWIGTYPE_p_AGColor swig_types[33] 
#define  SWIGTYPE_p_AGBox3 swig_types[34] 
#define  SWIGTYPE_p_std__listTAGRect2_t swig_types[35] 
#define  SWIGTYPE_p_AGLayoutCreator swig_types[36] 
#define  SWIGTYPE_p_AGButton swig_types[37] 
#define  SWIGTYPE_p_std__vectorTNode_t swig_types[38] 
#define  SWIGTYPE_p_AGSurface swig_types[39] 
#define  SWIGTYPE_p_SDL_Surface swig_types[40] 
#define  SWIGTYPE_p_std__vectorTAGLine2_t swig_types[41] 
#define  SWIGTYPE_p_SceneNode swig_types[42] 
#define  SWIGTYPE_p_p_SceneNode swig_types[43] 
#define  SWIGTYPE_p_AntEntity swig_types[44] 
#define  SWIGTYPE_p_std__vectorTSceneNode_p_t swig_types[45] 
#define  SWIGTYPE_p_std__vectorTNode_p_t swig_types[46] 
#define  SWIGTYPE_p_AGImage swig_types[47] 
#define  SWIGTYPE_p_std__listTMesh_p_t swig_types[48] 
#define  SWIGTYPE_p_Uint32 swig_types[49] 
#define  SWIGTYPE_p_AGApplication swig_types[50] 
#define  SWIGTYPE_p_AGSDLEvent swig_types[51] 
#define  SWIGTYPE_p_EntityList swig_types[52] 
#define  SWIGTYPE_p_AGWidget swig_types[53] 
#define  SWIGTYPE_p_Attributes swig_types[54] 
#define  SWIGTYPE_p_AGMessageObject swig_types[55] 
#define  SWIGTYPE_p_AGFontEngine swig_types[56] 
#define  SWIGTYPE_p_AGPoint swig_types[57] 
#define  SWIGTYPE_p_AGTriangle2 swig_types[58] 
#define  SWIGTYPE_p_AGTriangle3 swig_types[59] 
#define  SWIGTYPE_p_AGWindow swig_types[60] 
#define  SWIGTYPE_p_AGRect swig_types[61] 
#define  SWIGTYPE_p_AGSDLScreen swig_types[62] 
#define  SWIGTYPE_p_Parser swig_types[63] 
#define  SWIGTYPE_p_AGPoint3 swig_types[64] 
#define  SWIGTYPE_p_DomParser swig_types[65] 
#define  SWIGTYPE_p_AGDialog swig_types[66] 
#define  SWIGTYPE_p_TerrainPieceVA swig_types[67] 
#define  SWIGTYPE_p_AGPainter swig_types[68] 
#define  SWIGTYPE_p_AGText swig_types[69] 
#define  SWIGTYPE_p_std__vectorTAntEntityPtr_t swig_types[70] 
#define  SWIGTYPE_p_AGListBox swig_types[71] 
#define  SWIGTYPE_p_AGMatrix3 swig_types[72] 
#define  SWIGTYPE_p_std__vectorTstd__string_t swig_types[73] 
#define  SWIGTYPE_p_SDL_PixelFormat swig_types[74] 
#define  SWIGTYPE_p_AGTexture swig_types[75] 
#define  SWIGTYPE_p_AGLine2 swig_types[76] 
#define  SWIGTYPE_p_AGMatrix4 swig_types[77] 
#define  SWIGTYPE_p_std__mapTstd__string_std__string_t swig_types[78] 
#define  SWIGTYPE_p_AGColorButton swig_types[79] 
#define  SWIGTYPE_p_AGLine3 swig_types[80] 
#define  SWIGTYPE_p_Uint8 swig_types[81] 
#define  SWIGTYPE_p_SDLMod swig_types[82] 
#define  SWIGTYPE_p_GLTree swig_types[83] 
#define  SWIGTYPE_p_Mesh swig_types[84] 
#define  SWIGTYPE_p_AGRect2 swig_types[85] 
#define  SWIGTYPE_p_AGRect3 swig_types[86] 
#define  SWIGTYPE_p_SDL_Rect swig_types[87] 
#define  SWIGTYPE_p_AntMap swig_types[88] 
#define  SWIGTYPE_p_SDL_Event swig_types[89] 
#define  SWIGTYPE_p_GLuint swig_types[90] 
#define  SWIGTYPE_p_std__mapTstd__string_float_t swig_types[91] 
#define  SWIGTYPE_p_AGTextureManager swig_types[92] 
#define  SWIGTYPE_p_AGSurfaceManager swig_types[93] 
#define  SWIGTYPE_p_AGEdit swig_types[94] 
#define  SWIGTYPE_p_AGScreenWidget swig_types[95] 
#define  SWIGTYPE_p_AGGLWidget swig_types[96] 
#define  SWIGTYPE_p_std__vectorTAGBox3_t swig_types[97] 
#define  SWIGTYPE_p_AGRadio swig_types[98] 
#define  SWIGTYPE_p_std__ostringstream swig_types[99] 
#define  SWIGTYPE_p_Resource swig_types[100] 
#define  SWIGTYPE_p_AGVector2 swig_types[101] 
#define  SWIGTYPE_p_unsigned_long swig_types[102] 
#define  SWIGTYPE_p_AGVector3 swig_types[103] 
#define  SWIGTYPE_p_AGCaption swig_types[104] 
#define  SWIGTYPE_p_PickResult swig_types[105] 
#define  SWIGTYPE_p_AGVector4 swig_types[106] 
#define  SWIGTYPE_p_std__string swig_types[107] 
#define  SWIGTYPE_p_AGEvent swig_types[108] 
#define  SWIGTYPE_p_AGRadioGroup swig_types[109] 
#define  SWIGTYPE_p_TerrainMesh swig_types[110] 
#define  SWIGTYPE_p_VertexArray swig_types[111] 
#define  SWIGTYPE_p_AGMenuEvent swig_types[112] 
#define  SWIGTYPE_p_AGMouseEvent swig_types[113] 
#define  SWIGTYPE_p_std__pairTstd__string_bool_t swig_types[114] 
#define  SWIGTYPE_p_AGPaintTarget swig_types[115] 
#define  SWIGTYPE_p_PickNode swig_types[116] 
#define  SWIGTYPE_p_SDLKey swig_types[117] 
#define  SWIGTYPE_p_AGCPPListener swig_types[118] 
#define  SWIGTYPE_p_AGListener swig_types[119] 
#define  SWIGTYPE_p_float swig_types[120] 
#define  SWIGTYPE_p_AGCircle2 swig_types[121] 
#define  SWIGTYPE_p_std__vectorTPickNode_t swig_types[122] 
#define  SWIGTYPE_p_Node swig_types[123] 
#define  SWIGTYPE_p_p_Node swig_types[124] 
#define  SWIGTYPE_p_std__listTAntEntity_p_t swig_types[125] 
#define  SWIGTYPE_p_AGTheme swig_types[126] 
static swig_type_info *swig_types[128];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_libantargis
#define SWIG_name    "Libantargis"

static VALUE mLibantargis;

static void SWIG_AsVal(VALUE obj, int *val)
{
    *val = (int) NUM2INT(obj);
}


#ifdef __cplusplus
extern "C" {
#endif
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
struct timeval rb_time_timeval(VALUE);
#endif
#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
#include "rubyio.h"
#ifdef __cplusplus
}
#endif


#include "antargisgui.h"
#include "antargis.h"


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


static void SWIG_exception_(int code, const char *msg) {
    switch (code) {
        case SWIG_MemoryError:
            rb_raise(rb_eNoMemError, msg);
            break;
        case SWIG_IOError:
            rb_raise(rb_eIOError, msg);
            break;
        case SWIG_RuntimeError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        case SWIG_IndexError:
            rb_raise(rb_eIndexError, msg);
            break;
        case SWIG_TypeError:
            rb_raise(rb_eTypeError, msg);
            break;
        case SWIG_DivisionByZero:
            rb_raise(rb_eZeroDivError, msg);
            break;
        case SWIG_OverflowError:
            rb_raise(rb_eRangeError, msg);
            break;
        case SWIG_SyntaxError:
            rb_raise(rb_eSyntaxError, msg);
            break;
        case SWIG_ValueError:
            rb_raise(rb_eArgError, msg);
            break;
        case SWIG_SystemError:
            rb_raise(rb_eFatal, msg);
            break;
        case SWIG_UnknownError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        default:
            break;
    }
}

#define SWIG_exception(a, b) SWIG_exception_((a), (b))


#include <stdexcept>


#include <string>


#include <string>

#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))

bool SWIG_BOOL_P(VALUE) {
    // dummy test, RTEST should take care of everything
    return true;
}
bool SWIG_RB2BOOL(VALUE x) {
    return RTEST(x);
}
VALUE SWIG_BOOL2RB(bool b) {
    return b ? Qtrue : Qfalse;
}
double SWIG_NUM2DBL(VALUE x) {
    return (FIXNUM_P(x) ? FIX2INT(x) : NUM2DBL(x));
}
bool SWIG_STRING_P(VALUE x) {
    return TYPE(x) == T_STRING;
}
std::string SWIG_RB2STR(VALUE x) {
    return std::string(StringValuePtr(x));
}
VALUE SWIG_STR2RB(const std::string& s) {
    return rb_str_new2(s.c_str());
}


#include <vector>
#include <algorithm>
#include <stdexcept>


#include <map>
#include <algorithm>
#include <stdexcept>

static std::string std_vector_Sl_std_string_Sg__pop(std::vector<std::string > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                std::string x = self->back();
                self->pop_back();
                return x;
            }
static std::string std_vector_Sl_std_string_Sg____getitem__(std::vector<std::string > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_std_string_Sg____setitem__(std::vector<std::string > *self,int i,std::string x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_std_string_Sg__each(std::vector<std::string > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(SWIG_STR2RB((*self)[i]));
            }

swig_class cStringVector;
static void free_std_vector_Sl_std_string_Sg_(std::vector<std::string > *);
static SceneNodePtr std_vector_Sl_SceneNodePtr_Sg__pop(std::vector<SceneNodePtr > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                SceneNodePtr x = self->back();
                self->pop_back();
                return x;
            }
static SceneNodePtr &std_vector_Sl_SceneNodePtr_Sg____getitem__(std::vector<SceneNodePtr > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_SceneNodePtr_Sg____setitem__(std::vector<SceneNodePtr > *self,int i,SceneNodePtr const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_SceneNodePtr_Sg__each(std::vector<SceneNodePtr > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    SceneNodePtr* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_p_SceneNode, 0));
                }
            }

swig_class cSceneNodeVector;
static void free_std_vector_Sl_SceneNodePtr_Sg_(std::vector<SceneNodePtr > *);
static PickNode std_vector_Sl_PickNode_Sg__pop(std::vector<PickNode > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                PickNode x = self->back();
                self->pop_back();
                return x;
            }
static PickNode &std_vector_Sl_PickNode_Sg____getitem__(std::vector<PickNode > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_PickNode_Sg____setitem__(std::vector<PickNode > *self,int i,PickNode const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_PickNode_Sg__each(std::vector<PickNode > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    PickNode* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_PickNode, 0));
                }
            }

swig_class cPickResult;
static void free_std_vector_Sl_PickNode_Sg_(std::vector<PickNode > *);
static AntEntityPtr std_vector_Sl_AntEntityPtr_Sg__pop(std::vector<AntEntityPtr > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                AntEntityPtr x = self->back();
                self->pop_back();
                return x;
            }
static AntEntityPtr &std_vector_Sl_AntEntityPtr_Sg____getitem__(std::vector<AntEntityPtr > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AntEntityPtr_Sg____setitem__(std::vector<AntEntityPtr > *self,int i,AntEntityPtr const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AntEntityPtr_Sg__each(std::vector<AntEntityPtr > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    AntEntityPtr* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_AntEntityPtr, 0));
                }
            }

swig_class cEntityVector;
static void free_std_vector_Sl_AntEntityPtr_Sg_(std::vector<AntEntityPtr > *);
static float std_map_Sl_std_string_Sc_float_Sg____getitem__(std::map<std::string,float > *self,std::string key){
                std::map<std::string,float >::iterator i = self->find(key);
                if (i != self->end())
                    return i->second;
                else
                    throw std::out_of_range("key not found");
            }
static void std_map_Sl_std_string_Sc_float_Sg____setitem__(std::map<std::string,float > *self,std::string key,float x){
                (*self)[key] = x;
            }
static float std_map_Sl_std_string_Sc_float_Sg____delitem__(std::map<std::string,float > *self,std::string key){
                std::map<std::string,float >::iterator i = self->find(key);
                if (i != self->end()) {
                    float x = i->second;
                    self->erase(i);
                    return x;
                } else
                    throw std::out_of_range("key not found");
            }
static bool std_map_Sl_std_string_Sc_float_Sg__has_key(std::map<std::string,float > *self,std::string key){
                std::map<std::string,float >::iterator i = self->find(key);
                return i != self->end();
            }
static VALUE std_map_Sl_std_string_Sc_float_Sg__keys(std::map<std::string,float > *self){
                VALUE keyList = rb_ary_new2(self->size());
                std::map<std::string,float >::iterator i;
                unsigned int j;
                for (i=self->begin(), j=0; i!=self->end(); ++i, ++j) {
                    rb_ary_store(keyList,j,
                                 SWIG_STR2RB(i->first));
                }
                return keyList;
            }
static VALUE std_map_Sl_std_string_Sc_float_Sg__values(std::map<std::string,float > *self){
                VALUE valueList = rb_ary_new2(self->size());
                std::map<std::string,float >::iterator i;
                unsigned int j;
                for (i=self->begin(), j=0; i!=self->end(); ++i, ++j) {
                    rb_ary_store(valueList,j,
                                 rb_float_new(i->second));
                }
                return valueList;
            }
static void std_map_Sl_std_string_Sc_float_Sg__each(std::map<std::string,float > *self){
                std::map<std::string,float >::iterator i;
                for (i=self->begin(); i!=self->end(); ++i) {
                    VALUE entry = rb_ary_new2(2);
                    rb_ary_store(entry,0,SWIG_STR2RB(i->first));
                    rb_ary_store(entry,1,rb_float_new(i->second));
                    rb_yield(entry);
                }
            }

swig_class cResourceMap;
static void free_std_map_Sl_std_string_Sc_float_Sg_(std::map<std::string,float > *);

swig_class cAGMain;
static void free_AGMain(AGMain *);

swig_class cAGSurface;
static void free_AGSurface(AGSurface *);

swig_class cAGTexture;
static void free_AGTexture(AGTexture *);

swig_class cAGScreen;
static void free_AGScreen(AGScreen *);

swig_class cAGSurfaceManager;
static void free_AGSurfaceManager(AGSurfaceManager *);

swig_class cAGTextureManager;
static void free_AGTextureManager(AGTextureManager *);

swig_class cAGSDLScreen;
static void free_AGSDLScreen(AGSDLScreen *);

swig_class cAGEvent;
static void free_AGEvent(AGEvent *);

swig_class cAGSDLEvent;
static void free_AGSDLEvent(AGSDLEvent *);

swig_class cAGMouseEvent;
static void free_AGMouseEvent(AGMouseEvent *);

swig_class cAGListener;
static void free_AGListener(AGListener *);

swig_class cAGCPPListener;
static void free_AGCPPListener(AGCPPListener *);

swig_class cAGSignal;
static void free_AGSignal(AGSignal *);

swig_class cAGMessageObject;
static void free_AGMessageObject(AGMessageObject *);

swig_class cAGWidget;
static void free_AGWidget(AGWidget *);
extern AGWidget *agNoParent;

swig_class cAGPoint;
static void free_AGPoint(AGPoint *);

swig_class cAGRect;
static void free_AGRect(AGRect *);

swig_class cAGAngle;
static void free_AGAngle(AGAngle *);

swig_class cAGVector2;
static void free_AGVector2(AGVector2 *);

swig_class cAGVector3;
static void free_AGVector3(AGVector3 *);

swig_class cAGPoint3;
static void free_AGPoint3(AGPoint3 *);

swig_class cAGMatrix3;
static void free_AGMatrix3(AGMatrix3 *);

swig_class cAGLine2;
static void free_AGLine2(AGLine2 *);

swig_class cAGLine3;
static void free_AGLine3(AGLine3 *);

swig_class cAGCollisionData;
static void free_AGCollisionData(AGCollisionData *);

swig_class cAGTriangle2;
static void free_AGTriangle2(AGTriangle2 *);

swig_class cAGCircle2;
static void free_AGCircle2(AGCircle2 *);

swig_class cAGTriangle3;
static void free_AGTriangle3(AGTriangle3 *);

swig_class cAGRect2;
static void free_AGRect2(AGRect2 *);

swig_class cAGVector4;
static void free_AGVector4(AGVector4 *);

swig_class cAGMatrix4;
static void free_AGMatrix4(AGMatrix4 *);

swig_class cAGRect3;
static void free_AGRect3(AGRect3 *);

swig_class cAGBox3;
static void free_AGBox3(AGBox3 *);

swig_class cAGColor;
static void free_AGColor(AGColor *);

swig_class cAGFont;
static void free_AGFont(AGFont *);

swig_class cAGFontEngine;
static void free_AGFontEngine(AGFontEngine *);

swig_class cAGButton;
static void free_AGButton(AGButton *);

swig_class cAGApplication;
static void free_AGApplication(AGApplication *);

swig_class cAGText;
static void free_AGText(AGText *);

swig_class cAGVTiler;
static void free_AGVTiler(AGVTiler *);

swig_class cAGHTiler;
static void free_AGHTiler(AGHTiler *);

swig_class cAGTheme;
static void free_AGTheme(AGTheme *);

swig_class cAGMenuEvent;
static void free_AGMenuEvent(AGMenuEvent *);

swig_class cAGMenu;
static void free_AGMenu(AGMenu *);

swig_class cAGScreenWidget;
static void free_AGScreenWidget(AGScreenWidget *);

swig_class cAGEditLine;
static void free_AGEditLine(AGEditLine *);

swig_class cAGEdit;
static void free_AGEdit(AGEdit *);

swig_class cAGCheckBox;
static void free_AGCheckBox(AGCheckBox *);

swig_class cAGRadioGroup;
static void free_AGRadioGroup(AGRadioGroup *);

swig_class cAGRadio;
static void free_AGRadio(AGRadio *);

swig_class cAGTable;
static void free_AGTable(AGTable *);

swig_class cAGWindow;
static void free_AGWindow(AGWindow *);

swig_class cAGImage;
static void free_AGImage(AGImage *);

swig_class cAGCaption;
static void free_AGCaption(AGCaption *);

swig_class cAGBackground;
static void free_AGBackground(AGBackground *);

swig_class cAGLayout;
static void free_AGLayout(AGLayout *);

swig_class cAGLayoutCreator;
static void free_AGLayoutCreator(AGLayoutCreator *);

swig_class cAGLayoutFactory;
static void free_AGLayoutFactory(AGLayoutFactory *);

swig_class cNode;
static void free_Node(Node *);

swig_class cDocument;
static void free_Document(Document *);

swig_class cParser;
static void free_Parser(Parser *);

swig_class cDomParser;
static void free_DomParser(DomParser *);

swig_class cAGSound;
static void free_AGSound(AGSound *);

swig_class cAGGLWidget;
static void free_AGGLWidget(AGGLWidget *);

swig_class cAGColorButton;
static void free_AGColorButton(AGColorButton *);

swig_class cAGDialog;
static void free_AGDialog(AGDialog *);

swig_class cAGListBoxItem;
static void free_AGListBoxItem(AGListBoxItem *);

swig_class cAGListBox;
static void free_AGListBox(AGListBox *);

swig_class cAGPainter;
static void free_AGPainter(AGPainter *);
static Node std_vector_Sl_Node_Sg__pop(std::vector<Node > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                Node x = self->back();
                self->pop_back();
                return x;
            }
static Node &std_vector_Sl_Node_Sg____getitem__(std::vector<Node > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sg____setitem__(std::vector<Node > *self,int i,Node const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sg__each(std::vector<Node > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    Node* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_Node, 0));
                }
            }

swig_class cAGNodeList;
static void free_std_vector_Sl_Node_Sg_(std::vector<Node > *);
static Node *std_vector_Sl_Node_Sm__Sg__pop(std::vector<Node * > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                Node* x = self->back();
                self->pop_back();
                return x;
            }
static Node *std_vector_Sl_Node_Sm__Sg____getitem__(std::vector<Node * > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sm__Sg____setitem__(std::vector<Node * > *self,int i,Node *x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sm__Sg__each(std::vector<Node * > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    Node* x = (*self)[i];
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_Node, 0));
                }
            }

swig_class cAGNodePList;
static void free_std_vector_Sl_Node_Sm__Sg_(std::vector<Node * > *);
static AGVector3 std_vector_Sl_AGVector3_Sg__pop(std::vector<AGVector3 > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                AGVector3 x = self->back();
                self->pop_back();
                return x;
            }
static AGVector3 &std_vector_Sl_AGVector3_Sg____getitem__(std::vector<AGVector3 > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGVector3_Sg____setitem__(std::vector<AGVector3 > *self,int i,AGVector3 const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGVector3_Sg__each(std::vector<AGVector3 > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    AGVector3* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_AGVector3, 0));
                }
            }

swig_class cAGVector3List;
static void free_std_vector_Sl_AGVector3_Sg_(std::vector<AGVector3 > *);
static AGVector4 std_vector_Sl_AGVector4_Sg__pop(std::vector<AGVector4 > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                AGVector4 x = self->back();
                self->pop_back();
                return x;
            }
static AGVector4 &std_vector_Sl_AGVector4_Sg____getitem__(std::vector<AGVector4 > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGVector4_Sg____setitem__(std::vector<AGVector4 > *self,int i,AGVector4 const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGVector4_Sg__each(std::vector<AGVector4 > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    AGVector4* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_AGVector4, 0));
                }
            }

swig_class cAGVector4List;
static void free_std_vector_Sl_AGVector4_Sg_(std::vector<AGVector4 > *);

swig_class cHeightMap;
static void free_HeightMap(HeightMap *);

swig_class cAntMap;
static void free_AntMap(AntMap *);

swig_class cSceneNode;
static void free_SceneNode(SceneNode *);

swig_class cMeshVertex;
static void free_MeshVertex(MeshVertex *);

swig_class cMeshOptimizer;
static void free_MeshOptimizer(MeshOptimizer *);

swig_class cMeshData;
static void free_MeshData(MeshData *);

swig_class cMesh;
static void free_Mesh(Mesh *);

swig_class cPickNode;
static void free_PickNode(PickNode *);

swig_class cScene;
static void free_Scene(Scene *);

swig_class cGLApp;
static void free_GLApp(GLApp *);

swig_class cResource;
static void free_Resource(Resource *);

swig_class cAntEntity;
static void free_AntEntity(AntEntity *);

swig_class cAntEntityPtr;
static void free_AntEntityPtr(AntEntityPtr *);

swig_class cTerrainPieceVA;
static void free_TerrainPieceVA(TerrainPieceVA *);

swig_class cTerrainMesh;
static void free_TerrainMesh(TerrainMesh *);

swig_class cGLTree;
static void free_GLTree(GLTree *);
/***********************************************************************
 * director.swg
 *
 * This file contains support for director classes that proxy
 * method calls from C++ to Ruby extensions.
 *
 * Author : Lyle Johnson (lyle@users.sourceforge.net)
 *          Based on the original Python implementation by
 *          Mark Rose (mrose@stm.lbl.gov).
 ************************************************************************/

#ifdef __cplusplus

#include <string>

namespace Swig {
  struct body_args {
    VALUE recv;
    ID id;
    int argc;
    VALUE *argv;
  };

  /* Base class for director exceptions */
  class DirectorException {
    protected:
      VALUE swig_error;
    protected:
      DirectorException(VALUE error=Qnil) : swig_error(error) {}
    public:
      VALUE getType() const  { 
        return CLASS_OF(swig_error); 
      }
      VALUE getError() const {
        return swig_error;
      }
      virtual ~DirectorException() {}
  };

  /* Type mismatch in the return value from a Ruby method call */
  class DirectorTypeMismatchException : public Swig::DirectorException {
    public:
      DirectorTypeMismatchException(const char *msg="") {
        VALUE str = rb_str_new2("Swig director type mismatch: ");
        rb_str_concat(str, rb_str_new2(msg));
        swig_error = rb_exc_new3(rb_eTypeError, str);
      }
  };

  /* Any Ruby exception that occurs during a director method call */
  class DirectorMethodException : public Swig::DirectorException {
    public:
      DirectorMethodException(VALUE error) : Swig::DirectorException(error) {}
  };

  /* Attempted to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public Swig::DirectorException {};


  /* Simple thread abstraction for pthreads on win32 */
#ifdef __THREAD__
#define __PTHREAD__
#if defined(_WIN32) || defined(__WIN32__)
#define pthread_mutex_lock EnterCriticalSection
#define pthread_mutex_unlock LeaveCriticalSection
#define pthread_mutex_t CRITICAL_SECTION
#define MUTEX_INIT(var) CRITICAL_SECTION var
#else
#include <pthread.h>
#define MUTEX_INIT(var) pthread_mutex_t var = PTHREAD_MUTEX_INITIALIZER 
#endif
#endif

  /* director base class */
  class Director {
    private:
      /* pointer to the wrapped Ruby object */
      VALUE swig_self;
      /* flag indicating whether the object is owned by Ruby or c++ */
      mutable bool swig_disown_flag;
      /* shared flag for breaking recursive director calls */
      static bool swig_up;

#ifdef __PTHREAD__
      /* locks for sharing the swig_up flag in a threaded environment */
      static pthread_mutex_t swig_mutex_up;
      static bool swig_mutex_active;
      static pthread_t swig_mutex_thread;
#endif

      /* reset the swig_up flag once the routing direction has been determined */
#ifdef __PTHREAD__
      void swig_clear_up() const { 
        Swig::Director::swig_up = false; 
        Swig::Director::swig_mutex_active = false;
        pthread_mutex_unlock(&swig_mutex_up);
      }
#else
      void swig_clear_up() const { 
        Swig::Director::swig_up = false; 
      }
#endif

    public:
      /* wrap a Ruby object, optionally taking ownership */
      Director(VALUE self) : swig_self(self), swig_disown_flag(false) {
      }

      /* discard our reference at destruction */
      virtual ~Director() {
      }

      /* return a pointer to the wrapped Ruby object */
      VALUE swig_get_self() const { 
        return swig_self; 
      }

      /* get the swig_up flag to determine if the method call should be routed
       * to the c++ base class or through the wrapped Ruby object
       */
#ifdef __PTHREAD__
      bool swig_get_up() const { 
        if (Swig::Director::swig_mutex_active) {
          if (pthread_equal(Swig::Director::swig_mutex_thread, pthread_self())) {
            bool up = swig_up;
            swig_clear_up();
            return up;
          }
        }
        return false;
      }
#else 
      bool swig_get_up() const { 
        bool up = swig_up;
        swig_up = false;
        return up;
      }
#endif

      /* set the swig_up flag if the next method call should be directed to
       * the c++ base class rather than the wrapped Ruby object
       */
#ifdef __PTHREAD__
      void swig_set_up() const { 
        pthread_mutex_lock(&Swig::Director::swig_mutex_up);
        Swig::Director::swig_mutex_thread = pthread_self();
        Swig::Director::swig_mutex_active = true;
        Swig::Director::swig_up = true;
      }
#else 
      void swig_set_up() const { 
        Swig::Director::swig_up = true; 
      }
#endif

      /* acquire ownership of the wrapped Ruby object (the sense of "disown"
       * is from Ruby) */
      void swig_disown() const { 
        if (!swig_disown_flag) { 
          swig_disown_flag = true;
        } 
      }
  };

  bool Swig::Director::swig_up = false;

#ifdef __PTHREAD__
  MUTEX_INIT(Swig::Director::swig_mutex_up);
  pthread_t Swig::Director::swig_mutex_thread;
  bool Swig::Director::swig_mutex_active = false;
#endif

}

#endif /* __cplusplus */




/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "antargisruby.h"

SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self): AGSurface(), Swig::Director(self) {
    
}



SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self, int w, int h): AGSurface(w, h), Swig::Director(self) {
    
}



SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self, AGSurface const &p): AGSurface(p), Swig::Director(self) {
    
}



SwigDirector_AGSurface::~SwigDirector_AGSurface() {
}

void SwigDirector_AGSurface::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc, AGColor const &pColor) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_pColor = const_cast<AGColor *>(&pColor) ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_pColor, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


SwigDirector_AGScreen::SwigDirector_AGScreen(VALUE self) : Swig::Director(self) {
    
}



size_t SwigDirector_AGScreen::getWidth() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGScreen::getWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getWidth"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


size_t SwigDirector_AGScreen::getHeight() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGScreen::getHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getHeight"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_AGScreen::flip() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::flip();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("flip"), 0, NULL);
}


void SwigDirector_AGScreen::begin() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::begin();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("begin"), 0, NULL);
}


SwigDirector_AGSDLScreen::SwigDirector_AGSDLScreen(VALUE self, SDL_Surface *s): AGSDLScreen(s), Swig::Director(self) {
    
}



void SwigDirector_AGSDLScreen::tile(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::tile(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSDLScreen::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


AGSurface SwigDirector_AGSDLScreen::loadSurface(std::string const &pFilename) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGSurface c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSDLScreen::loadSurface(pFilename);
    }
    {
        obj0 = rb_str_new2(pFilename.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("loadSurface"), 1,obj0);
    {
        std::cout<<"test1"<<std::endl;
        AGSurface *b;
        Data_Get_Struct(result,AGSurface,b);
        c_result=*b;
    }
    return (AGSurface) c_result;
}


void SwigDirector_AGSDLScreen::tile(AGTexture const &pSource) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::tile(pSource);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 1,obj0);
}


void SwigDirector_AGSDLScreen::drawGradient(AGRect const &rect, AGColor const &ul, AGColor const &ur, AGColor const &dl, AGColor const &dr) {
    AGRect * nc_tmp_rect = const_cast<AGRect *>(&rect) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_ul = const_cast<AGColor *>(&ul) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_ur = const_cast<AGColor *>(&ur) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_dl = const_cast<AGColor *>(&dl) ;
    VALUE obj3 = Qnil ;
    AGColor * nc_tmp_dr = const_cast<AGColor *>(&dr) ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawGradient(rect,ul,ur,dl,dr);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_rect, SWIGTYPE_p_AGRect, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_ul, SWIGTYPE_p_AGColor, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_ur, SWIGTYPE_p_AGColor, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_dl, SWIGTYPE_p_AGColor, 0);
    obj4 = SWIG_NewPointerObj(nc_tmp_dr, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawGradient"), 5,obj0,obj1,obj2,obj3,obj4);
}


void SwigDirector_AGSDLScreen::drawGradientAlpha(AGRect const &rect, AGColor const &ul, AGColor const &ur, AGColor const &dl, AGColor const &dr) {
    AGRect * nc_tmp_rect = const_cast<AGRect *>(&rect) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_ul = const_cast<AGColor *>(&ul) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_ur = const_cast<AGColor *>(&ur) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_dl = const_cast<AGColor *>(&dl) ;
    VALUE obj3 = Qnil ;
    AGColor * nc_tmp_dr = const_cast<AGColor *>(&dr) ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawGradientAlpha(rect,ul,ur,dl,dr);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_rect, SWIGTYPE_p_AGRect, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_ul, SWIGTYPE_p_AGColor, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_ur, SWIGTYPE_p_AGColor, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_dl, SWIGTYPE_p_AGColor, 0);
    obj4 = SWIG_NewPointerObj(nc_tmp_dr, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawGradientAlpha"), 5,obj0,obj1,obj2,obj3,obj4);
}


void SwigDirector_AGSDLScreen::renderText(AGRect const &pClipRect, int BaseLineX, int BaseLineY, std::string const &pText, AGFont const &ParamIn) {
    std::string temp4 ;
    AGRect * nc_tmp_pClipRect = const_cast<AGRect *>(&pClipRect) ;
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    AGFont * nc_tmp_ParamIn = const_cast<AGFont *>(&ParamIn) ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::renderText(pClipRect,BaseLineX,BaseLineY,pText,ParamIn);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pClipRect, SWIGTYPE_p_AGRect, 0);
    obj1 = INT2NUM(BaseLineX);
    obj2 = INT2NUM(BaseLineY);
    {
        obj3 = rb_str_new2(pText.c_str());
    }
    obj4 = SWIG_NewPointerObj(nc_tmp_ParamIn, SWIGTYPE_p_AGFont, 0);
    result = rb_funcall(swig_get_self(), rb_intern("renderText"), 5,obj0,obj1,obj2,obj3,obj4);
}


void SwigDirector_AGSDLScreen::drawLine(AGPoint const &p0, AGPoint const &p1, AGColor const &c) {
    AGPoint * nc_tmp_p0 = const_cast<AGPoint *>(&p0) ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_p1 = const_cast<AGPoint *>(&p1) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_p0, SWIGTYPE_p_AGPoint, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_p1, SWIGTYPE_p_AGPoint, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


size_t SwigDirector_AGSDLScreen::getWidth() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSDLScreen::getWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getWidth"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


size_t SwigDirector_AGSDLScreen::getHeight() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSDLScreen::getHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getHeight"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_AGSDLScreen::tile(AGTexture const &pSource, AGRect const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::tile(pSource,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 2,obj0,obj1);
}


void SwigDirector_AGSDLScreen::blit(AGTexture const &pSource, AGRect const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::blit(pSource,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 2,obj0,obj1);
}


void SwigDirector_AGSDLScreen::begin() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::begin();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("begin"), 0, NULL);
}


void SwigDirector_AGSDLScreen::drawRect(AGRect const &pRect, AGColor const &c) {
    AGRect * nc_tmp_pRect = const_cast<AGRect *>(&pRect) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawRect(pRect,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pRect, SWIGTYPE_p_AGRect, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawRect"), 2,obj0,obj1);
}


void SwigDirector_AGSDLScreen::flip() {
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::flip();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("flip"), 0, NULL);
}


void SwigDirector_AGSDLScreen::drawBorder(AGRect const &rect, int W, AGColor const &c1, AGColor const &c2) {
    AGRect * nc_tmp_rect = const_cast<AGRect *>(&rect) ;
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c1 = const_cast<AGColor *>(&c1) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_c2 = const_cast<AGColor *>(&c2) ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawBorder(rect,W,c1,c2);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_rect, SWIGTYPE_p_AGRect, 0);
    obj1 = INT2NUM(W);
    obj2 = SWIG_NewPointerObj(nc_tmp_c1, SWIGTYPE_p_AGColor, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_c2, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawBorder"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGSDLScreen::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


SDL_Surface *SwigDirector_AGSDLScreen::newSurface(int x, int y) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    SDL_Surface *c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSDLScreen::newSurface(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("newSurface"), 2,obj0,obj1);
    if ((SWIG_ConvertPtr(result,(void **) &c_result, SWIGTYPE_p_SDL_Surface,SWIG_POINTER_EXCEPTION | 0 )) == -1) throw Swig::DirectorTypeMismatchException("Pointer conversion failed.");
    return (SDL_Surface *) c_result;
}


SwigDirector_AGEvent::SwigDirector_AGEvent(VALUE self, AGListener *pCaller): AGEvent(pCaller), Swig::Director(self) {
    
}



SwigDirector_AGEvent::~SwigDirector_AGEvent() {
}

SwigDirector_AGSDLEvent::SwigDirector_AGSDLEvent(VALUE self, AGListener *pCaller, SDL_Event const *pEvent): AGSDLEvent(pCaller, pEvent), Swig::Director(self) {
    
}



SwigDirector_AGSDLEvent::~SwigDirector_AGSDLEvent() {
}

SwigDirector_AGMouseEvent::SwigDirector_AGMouseEvent(VALUE self, AGListener *pCaller, SDL_Event *pEvent): AGMouseEvent(pCaller, pEvent), Swig::Director(self) {
    
}



SwigDirector_AGMouseEvent::~SwigDirector_AGMouseEvent() {
}

SwigDirector_AGListener::SwigDirector_AGListener(VALUE self): AGListener(), Swig::Director(self) {
    
}



SwigDirector_AGListener::~SwigDirector_AGListener() {
}

bool SwigDirector_AGListener::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCPPListener::SwigDirector_AGCPPListener(VALUE self) : Swig::Director(self) {
    
}



SwigDirector_AGCPPListener::~SwigDirector_AGCPPListener() {
}

bool SwigDirector_AGCPPListener::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) const {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        throw Swig::DirectorPureVirtualException();
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self): AGSignal(), Swig::Director(self) {
    
}



SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self, AGMessageObject *pCaller): AGSignal(pCaller), Swig::Director(self) {
    
}



SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self, AGMessageObject *pCaller, std::string const &pName): AGSignal(pCaller, pName), Swig::Director(self) {
    
}



SwigDirector_AGSignal::~SwigDirector_AGSignal() {
}

SwigDirector_AGMessageObject::SwigDirector_AGMessageObject(VALUE self): AGMessageObject(), Swig::Director(self) {
    
}



bool SwigDirector_AGMessageObject::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGMessageObject::~SwigDirector_AGMessageObject() {
}

bool SwigDirector_AGMessageObject::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGWidget::SwigDirector_AGWidget(VALUE self, AGWidget *pParent, AGRect const &r): AGWidget(pParent, r), Swig::Director(self) {
    
}



bool SwigDirector_AGWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGWidget::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGWidget::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGWidget::~SwigDirector_AGWidget() {
}

bool SwigDirector_AGWidget::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGWidget::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGWidget::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGWidget::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGWidget::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGWidget::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGWidget::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGButton::SwigDirector_AGButton(VALUE self, AGWidget *pParent, AGRect const &r, std::string const &pText, int id): AGButton(pParent, r, pText, id), Swig::Director(self) {
    
}



bool SwigDirector_AGButton::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGButton::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGButton::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGButton::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


std::string SwigDirector_AGButton::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        c_result = std::string(StringValuePtr(result));
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGButton::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGButton::~SwigDirector_AGButton() {
}

bool SwigDirector_AGButton::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGButton::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGButton::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGButton::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGButton::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGButton::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGButton::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGButton::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGButton::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGApplication::SwigDirector_AGApplication(VALUE self): AGApplication(), Swig::Director(self) {
    
}



bool SwigDirector_AGApplication::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventKeyDown(AGEvent const *m2) {
    AGEvent * nc_tmp_m2 = const_cast<AGEvent *>(m2) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventKeyDown(m2);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m2);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m2, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventFrame(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrame(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrame"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventFrameEnd(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrameEnd(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrameEnd"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::eventChangedRes() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::eventChangedRes();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventChangedRes"), 0, NULL);
}


SwigDirector_AGApplication::~SwigDirector_AGApplication() {
}

bool SwigDirector_AGApplication::eventIdle() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventIdle();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventIdle"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


SwigDirector_AGText::SwigDirector_AGText(VALUE self, AGWidget *pParent, AGRect const &pRect, std::string const &pText, AGFont const &pFont): AGText(pParent, pRect, pText, pFont), Swig::Director(self) {
    
}



bool SwigDirector_AGText::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGText::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGText::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGText::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGText::~SwigDirector_AGText() {
}

bool SwigDirector_AGText::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGText::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGText::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGText::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGText::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGText::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGText::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGText::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGText::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGText::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGVTiler::SwigDirector_AGVTiler(VALUE self, AGWidget *pParent, AGRect const &pRect, bool pAdaptMyHeight): AGVTiler(pParent, pRect, pAdaptMyHeight), Swig::Director(self) {
    
}



bool SwigDirector_AGVTiler::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


int SwigDirector_AGVTiler::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGVTiler::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGVTiler::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGVTiler::~SwigDirector_AGVTiler() {
}

bool SwigDirector_AGVTiler::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGVTiler::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGVTiler::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGVTiler::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGVTiler::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGVTiler::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGVTiler::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGVTiler::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGVTiler::addChild(AGWidget *pWidget) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(pWidget);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(pWidget, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


SwigDirector_AGHTiler::SwigDirector_AGHTiler(VALUE self, AGWidget *pParent, AGRect const &pRect, bool pAdaptMyHeight): AGHTiler(pParent, pRect, pAdaptMyHeight), Swig::Director(self) {
    
}



bool SwigDirector_AGHTiler::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGHTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


int SwigDirector_AGHTiler::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGHTiler::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGHTiler::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGHTiler::~SwigDirector_AGHTiler() {
}

bool SwigDirector_AGHTiler::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGHTiler::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGHTiler::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGHTiler::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGHTiler::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGHTiler::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGHTiler::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGHTiler::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGHTiler::addChild(AGWidget *pWidget) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(pWidget);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(pWidget, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


SwigDirector_AGTheme::SwigDirector_AGTheme(VALUE self): AGTheme(), Swig::Director(self) {
    
}



SwigDirector_AGTheme::~SwigDirector_AGTheme() {
}

SwigDirector_AGMenuEvent::SwigDirector_AGMenuEvent(VALUE self, AGListener *pListener, std::string const &pName): AGMenuEvent(pListener, pName), Swig::Director(self) {
    
}



SwigDirector_AGMenuEvent::~SwigDirector_AGMenuEvent() {
}

SwigDirector_AGMenu::SwigDirector_AGMenu(VALUE self, AGWidget *pParent, AGPoint pWishPos, std::string const &pName): AGMenu(pParent, pWishPos, pName), Swig::Director(self) {
    
}



bool SwigDirector_AGMenu::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


int SwigDirector_AGMenu::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGMenu::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGMenu::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGMenu::~SwigDirector_AGMenu() {
}

bool SwigDirector_AGMenu::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGMenu::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGMenu::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGMenu::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGMenu::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGMenu::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGMenu::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGMenu::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGMenu::addChild(AGWidget *pWidget) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(pWidget);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(pWidget, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


SwigDirector_AGScreenWidget::SwigDirector_AGScreenWidget(VALUE self): AGScreenWidget(), Swig::Director(self) {
    
}



bool SwigDirector_AGScreenWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGScreenWidget::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGScreenWidget::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGScreenWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGScreenWidget::~SwigDirector_AGScreenWidget() {
}

bool SwigDirector_AGScreenWidget::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGScreenWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGScreenWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGScreenWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGScreenWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGScreenWidget::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGScreenWidget::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGScreenWidget::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGEditLine::SwigDirector_AGEditLine(VALUE self, std::string const &pText, AGFont pFont, bool pHardEnd): AGEditLine(pText, pFont, pHardEnd), Swig::Director(self) {
    
}



SwigDirector_AGEditLine::~SwigDirector_AGEditLine() {
}

void SwigDirector_AGEditLine::drawCursor(AGPainter &p, int cx, AGPoint const &pPoint, AGRect const &pClip, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGPoint * nc_tmp_pPoint = const_cast<AGPoint *>(&pPoint) ;
    VALUE obj2 = Qnil ;
    AGRect * nc_tmp_pClip = const_cast<AGRect *>(&pClip) ;
    VALUE obj3 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEditLine::drawCursor(p,cx,pPoint,pClip,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    obj1 = INT2NUM(cx);
    obj2 = SWIG_NewPointerObj(nc_tmp_pPoint, SWIGTYPE_p_AGPoint, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_pClip, SWIGTYPE_p_AGRect, 0);
    obj4 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawCursor"), 5,obj0,obj1,obj2,obj3,obj4);
}


void SwigDirector_AGEditLine::draw(AGPainter &p, AGPoint const &pPoint, AGRect const &pClip) {
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pPoint = const_cast<AGPoint *>(&pPoint) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pClip = const_cast<AGRect *>(&pClip) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEditLine::draw(p,pPoint,pClip);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pPoint, SWIGTYPE_p_AGPoint, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pClip, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 3,obj0,obj1,obj2);
}


SwigDirector_AGEdit::SwigDirector_AGEdit(VALUE self, AGWidget *pParent, AGRect const &pRect): AGEdit(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGEdit::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGEdit::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGEdit::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGEdit::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGEdit::~SwigDirector_AGEdit() {
}

bool SwigDirector_AGEdit::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGEdit::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGEdit::drawBackground(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::drawBackground(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawBackground"), 1,obj0);
}


void SwigDirector_AGEdit::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGEdit::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGEdit::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGEdit::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGEdit::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGEdit::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGEdit::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGCheckBox::SwigDirector_AGCheckBox(VALUE self, AGWidget *pParent, AGRect pRect): AGCheckBox(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGCheckBox::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGCheckBox::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGCheckBox::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGCheckBox::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


std::string SwigDirector_AGCheckBox::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        c_result = std::string(StringValuePtr(result));
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGCheckBox::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCheckBox::~SwigDirector_AGCheckBox() {
}

bool SwigDirector_AGCheckBox::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGCheckBox::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGCheckBox::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGCheckBox::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGCheckBox::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGCheckBox::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGCheckBox::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGCheckBox::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGCheckBox::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGCheckBox::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGRadioGroup::SwigDirector_AGRadioGroup(VALUE self, AGWidget *pParent, AGRect const &pr): AGRadioGroup(pParent, pr), Swig::Director(self) {
    
}



bool SwigDirector_AGRadioGroup::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGRadioGroup::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGRadioGroup::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGRadioGroup::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::eventChange(std::string const &p) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGRadioGroup::eventChange(p);
        return;
    }
    {
        obj0 = rb_str_new2(p.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventChange"), 1,obj0);
}


bool SwigDirector_AGRadioGroup::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGRadioGroup::~SwigDirector_AGRadioGroup() {
}

bool SwigDirector_AGRadioGroup::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGRadioGroup::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGRadioGroup::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGRadioGroup::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGRadioGroup::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGRadio::SwigDirector_AGRadio(VALUE self, AGWidget *pParent, AGRect pRect): AGRadio(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGRadio::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGRadio::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGRadio::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGRadio::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGRadio::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


std::string SwigDirector_AGRadio::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        c_result = std::string(StringValuePtr(result));
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGRadio::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGRadio::~SwigDirector_AGRadio() {
}

bool SwigDirector_AGRadio::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGCheckBox::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGRadio::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGRadio::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGRadio::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGRadio::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGRadio::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGRadio::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGRadio::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGRadio::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGTable::SwigDirector_AGTable(VALUE self, AGWidget *pWidget, AGRect const &pRect): AGTable(pWidget, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGTable::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGTable::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGTable::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGTable::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGTable::~SwigDirector_AGTable() {
}

bool SwigDirector_AGTable::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGTable::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGTable::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGTable::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGTable::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGTable::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGTable::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGTable::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGTable::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGWindow::SwigDirector_AGWindow(VALUE self, AGWidget *pWidget, AGRect const &pRect, std::string const &pTitle): AGWindow(pWidget, pRect, pTitle), Swig::Director(self) {
    
}



bool SwigDirector_AGWindow::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGWindow::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGWindow::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGWindow::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGWindow::~SwigDirector_AGWindow() {
}

bool SwigDirector_AGWindow::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGWindow::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGWindow::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGWindow::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGWindow::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGWindow::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGWindow::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGWindow::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGWindow::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWindow::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


SwigDirector_AGImage::SwigDirector_AGImage(VALUE self, AGWidget *pParent, AGPoint const &p, AGSurface pSurface, bool pTile, AGRect const &pRect): AGImage(pParent, p, pSurface, pTile, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGImage::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGImage::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGImage::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGImage::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGImage::~SwigDirector_AGImage() {
}

bool SwigDirector_AGImage::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGImage::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGImage::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGImage::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGImage::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGImage::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGImage::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGImage::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGImage::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGImage::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGCaption::SwigDirector_AGCaption(VALUE self, AGWidget *pParent, AGRect const &pRect, std::string const &pText, AGFont const &pFont, AGBackground const &pBG): AGCaption(pParent, pRect, pText, pFont, pBG), Swig::Director(self) {
    
}



bool SwigDirector_AGCaption::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGCaption::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGCaption::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGCaption::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCaption::~SwigDirector_AGCaption() {
}

bool SwigDirector_AGCaption::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGCaption::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGCaption::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGCaption::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGCaption::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGCaption::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGCaption::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGCaption::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGCaption::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGCaption::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGLayout::SwigDirector_AGLayout(VALUE self, AGWidget *pgParent, std::string const &pXMLData): AGLayout(pgParent, pXMLData), Swig::Director(self) {
    
}



bool SwigDirector_AGLayout::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGLayout::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGLayout::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGLayout::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGLayout::~SwigDirector_AGLayout() {
}

bool SwigDirector_AGLayout::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGLayout::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGLayout::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGLayout::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGLayout::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGLayout::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGLayout::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGLayout::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGLayout::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGLayoutCreator::SwigDirector_AGLayoutCreator(VALUE self, std::string const &pName): AGLayoutCreator(pName), Swig::Director(self) {
    
}



SwigDirector_AGLayoutCreator::~SwigDirector_AGLayoutCreator() {
}

AGWidget *SwigDirector_AGLayoutCreator::create(AGWidget *pParent, AGRect const &pRect, xmlpp::Node const &pNode) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pRect = const_cast<AGRect *>(&pRect) ;
    VALUE obj1 = Qnil ;
    xmlpp::Node * nc_tmp_pNode = const_cast<xmlpp::Node *>(&pNode) ;
    VALUE obj2 = Qnil ;
    AGWidget *c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGLayoutCreator::create(pParent,pRect,pNode);
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(pParent);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(pParent, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pRect, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pNode, SWIGTYPE_p_Node, 0);
    result = rb_funcall(swig_get_self(), rb_intern("create"), 3,obj0,obj1,obj2);
    if ((SWIG_ConvertPtr(result,(void **) &c_result, SWIGTYPE_p_AGWidget,SWIG_POINTER_EXCEPTION | 0 )) == -1) throw Swig::DirectorTypeMismatchException("Pointer conversion failed.");
    return (AGWidget *) c_result;
}


SwigDirector_Parser::SwigDirector_Parser(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_Parser::simpleTag(std::string const &pName, Node::Attributes const &pAttributes) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    Node::Attributes * nc_tmp_pAttributes = const_cast<Node::Attributes *>(&pAttributes) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::simpleTag(pName,pAttributes);
        return;
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0);
    result = rb_funcall(swig_get_self(), rb_intern("simpleTag"), 2,obj0,obj1);
}


SwigDirector_Parser::~SwigDirector_Parser() {
}

void SwigDirector_Parser::startTag(std::string const &pName, Node::Attributes const &pAttributes) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    Node::Attributes * nc_tmp_pAttributes = const_cast<Node::Attributes *>(&pAttributes) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::startTag(pName,pAttributes);
        return;
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0);
    result = rb_funcall(swig_get_self(), rb_intern("startTag"), 2,obj0,obj1);
}


void SwigDirector_Parser::endTag(std::string const &pName) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::endTag(pName);
        return;
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("endTag"), 1,obj0);
}


void SwigDirector_Parser::text(std::string const &pText) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::text(pText);
        return;
    }
    {
        obj0 = rb_str_new2(pText.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("text"), 1,obj0);
}


void SwigDirector_Parser::comment(std::string const &pText) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::comment(pText);
        return;
    }
    {
        obj0 = rb_str_new2(pText.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("comment"), 1,obj0);
}


void SwigDirector_Parser::header(std::string const &pText) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::header(pText);
        return;
    }
    {
        obj0 = rb_str_new2(pText.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("header"), 1,obj0);
}


SwigDirector_DomParser::SwigDirector_DomParser(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_DomParser::simpleTag(std::string const &pName, Node::Attributes const &pAttributes) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    Node::Attributes * nc_tmp_pAttributes = const_cast<Node::Attributes *>(&pAttributes) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::simpleTag(pName,pAttributes);
        return;
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0);
    result = rb_funcall(swig_get_self(), rb_intern("simpleTag"), 2,obj0,obj1);
}


SwigDirector_DomParser::~SwigDirector_DomParser() {
}

void SwigDirector_DomParser::startTag(std::string const &pName, Node::Attributes const &pAttributes) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    Node::Attributes * nc_tmp_pAttributes = const_cast<Node::Attributes *>(&pAttributes) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::startTag(pName,pAttributes);
        return;
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0);
    result = rb_funcall(swig_get_self(), rb_intern("startTag"), 2,obj0,obj1);
}


void SwigDirector_DomParser::endTag(std::string const &pName) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::endTag(pName);
        return;
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("endTag"), 1,obj0);
}


void SwigDirector_DomParser::text(std::string const &pText) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::text(pText);
        return;
    }
    {
        obj0 = rb_str_new2(pText.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("text"), 1,obj0);
}


void SwigDirector_DomParser::comment(std::string const &pText) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::comment(pText);
        return;
    }
    {
        obj0 = rb_str_new2(pText.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("comment"), 1,obj0);
}


void SwigDirector_DomParser::header(std::string const &pText) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::header(pText);
        return;
    }
    {
        obj0 = rb_str_new2(pText.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("header"), 1,obj0);
}


SwigDirector_AGSound::SwigDirector_AGSound(VALUE self): AGSound(), Swig::Director(self) {
    
}



bool SwigDirector_AGSound::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGSound::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGSound::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGSound::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSound::~SwigDirector_AGSound() {
}

bool SwigDirector_AGSound::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGSound::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGSound::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGSound::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGSound::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGSound::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGSound::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGSound::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGSound::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGGLWidget::SwigDirector_AGGLWidget(VALUE self, AGWidget *pParent, AGRect const &r): AGGLWidget(pParent, r), Swig::Director(self) {
    
}



bool SwigDirector_AGGLWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGGLWidget::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGGLWidget::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGGLWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGGLWidget::~SwigDirector_AGGLWidget() {
}

bool SwigDirector_AGGLWidget::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::drawGL() {
    VALUE result;
    
    if (swig_get_up()) {
        AGGLWidget::drawGL();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawGL"), 0, NULL);
}


void SwigDirector_AGGLWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGGLWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGGLWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGGLWidget::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGGLWidget::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGGLWidget::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGGLWidget::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGGLWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGGLWidget::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGGLWidget::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGColorButton::SwigDirector_AGColorButton(VALUE self, AGWidget *pParent, AGRect const &r, int x, int y): AGColorButton(pParent, r, x, y), Swig::Director(self) {
    
}



bool SwigDirector_AGColorButton::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGColorButton::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGColorButton::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGColorButton::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGColorButton::~SwigDirector_AGColorButton() {
}

bool SwigDirector_AGColorButton::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGColorButton::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGColorButton::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGColorButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGColorButton::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGColorButton::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGColorButton::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGColorButton::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGColorButton::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGColorButton::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGColorButton::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGDialog::SwigDirector_AGDialog(VALUE self, AGWidget *pgParent, std::string const &pXMLData): AGDialog(pgParent, pXMLData), Swig::Director(self) {
    
}



bool SwigDirector_AGDialog::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventClose(std::string const &pName, AGEvent const *event, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventClose(pName,event,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventClose"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGDialog::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGDialog::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGDialog::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGDialog::~SwigDirector_AGDialog() {
}

bool SwigDirector_AGDialog::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGDialog::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGDialog::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGDialog::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGDialog::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGDialog::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGDialog::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventCancel(std::string const &pName, AGEvent const *event, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventCancel(pName,event,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventCancel"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventOk(std::string const &pName, AGEvent const *event, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventOk(pName,event,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventOk"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGDialog::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGDialog::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGListBox::SwigDirector_AGListBox(VALUE self, AGWidget *pParent, AGRect const &pRect): AGListBox(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGListBox::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGListBox::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGListBox::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGListBox::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGListBox::~SwigDirector_AGListBox() {
}

bool SwigDirector_AGListBox::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListBox::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListBox::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGListBox::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGListBox::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGListBox::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGListBox::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGListBox::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGListBox::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGListBox::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGListBox::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGListBox::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGPainter::SwigDirector_AGPainter(VALUE self): AGPainter(), Swig::Director(self) {
    
}



SwigDirector_AGPainter::SwigDirector_AGPainter(VALUE self, AGPainter const &p): AGPainter(p), Swig::Director(self) {
    
}



SwigDirector_AGPainter::SwigDirector_AGPainter(VALUE self, AGPaintTarget &pTarget): AGPainter(pTarget), Swig::Director(self) {
    
}



void SwigDirector_AGPainter::tile(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc, AGColor const &pColor) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_pColor = const_cast<AGColor *>(&pColor) ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_pColor, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect const &pDest, AGColor const &pColor) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_pColor = const_cast<AGColor *>(&pColor) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pColor, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pSrc);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::tile(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource,pDest,pSrc);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::tile(AGTexture const &pSource) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 1,obj0);
}


void SwigDirector_AGPainter::drawCircle(AGPoint const &p, float rad, AGColor const &c) {
    AGPoint * nc_tmp_p = const_cast<AGPoint *>(&p) ;
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::drawCircle(p,rad,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_p, SWIGTYPE_p_AGPoint, 0);
    obj1 = rb_float_new(rad);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawCircle"), 3,obj0,obj1,obj2);
}


SwigDirector_AGPainter::~SwigDirector_AGPainter() {
}

void SwigDirector_AGPainter::drawLine(AGPoint const &p0, AGPoint const &p1, AGColor const &c) {
    AGPoint * nc_tmp_p0 = const_cast<AGPoint *>(&p0) ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_p1 = const_cast<AGPoint *>(&p1) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_p0, SWIGTYPE_p_AGPoint, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_p1, SWIGTYPE_p_AGPoint, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::blit(AGSurface const &pSource, AGRect const &pDest) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::tile(AGTexture const &pSource, AGRect const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::tile(AGSurface const &pSource, AGRect const &pDest) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource,pDest);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect2 * nc_tmp_pDest = const_cast<AGRect2 *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect2 * nc_tmp_pSrc = const_cast<AGRect2 *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect2, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect2, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::tile(AGSurface const &pSource) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 1,obj0);
}


void SwigDirector_AGPainter::putPixel(AGPoint const &p, AGColor const &c) {
    AGPoint * nc_tmp_p = const_cast<AGPoint *>(&p) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::putPixel(p,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_p, SWIGTYPE_p_AGPoint, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::drawRect(AGRect const &pRect, AGColor const &c) {
    AGRect * nc_tmp_pRect = const_cast<AGRect *>(&pRect) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::drawRect(pRect,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pRect, SWIGTYPE_p_AGRect, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawRect"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGTriangle2 * nc_tmp_pSrc = const_cast<AGTriangle2 *>(&pSrc) ;
    VALUE obj1 = Qnil ;
    AGTriangle2 * nc_tmp_pDest = const_cast<AGTriangle2 *>(&pDest) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGTriangle2, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGTriangle2, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


SwigDirector_HeightMap::SwigDirector_HeightMap(VALUE self, int w, int h): HeightMap(w, h), Swig::Director(self) {
    
}



void SwigDirector_HeightMap::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        HeightMap::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


SwigDirector_HeightMap::~SwigDirector_HeightMap() {
}

void SwigDirector_HeightMap::saveXML(Node &node) const {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        HeightMap::saveXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj(&node, SWIGTYPE_p_Node, 0);
    result = rb_funcall(swig_get_self(), rb_intern("saveXML"), 1,obj0);
}


void SwigDirector_HeightMap::loadXML(Node const &node) {
    Node * nc_tmp_node = const_cast<Node *>(&node) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        HeightMap::loadXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_node, SWIGTYPE_p_Node, 0);
    result = rb_funcall(swig_get_self(), rb_intern("loadXML"), 1,obj0);
}


SwigDirector_AntMap::SwigDirector_AntMap(VALUE self, int w, int h): AntMap(w, h), Swig::Director(self) {
    
}



void SwigDirector_AntMap::insertEntity(AntEntity *e) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::insertEntity(e);
        return;
    }
    obj0 = SWIG_NewPointerObj(e, SWIGTYPE_p_AntEntity, 0);
    result = rb_funcall(swig_get_self(), rb_intern("insertEntity"), 1,obj0);
}


void SwigDirector_AntMap::removeEntity(AntEntity *p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::removeEntity(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(p, SWIGTYPE_p_AntEntity, 0);
    result = rb_funcall(swig_get_self(), rb_intern("removeEntity"), 1,obj0);
}


void SwigDirector_AntMap::entsChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::entsChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("entsChanged"), 0, NULL);
}


void SwigDirector_AntMap::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


SwigDirector_AntMap::~SwigDirector_AntMap() {
}

AntEntity *SwigDirector_AntMap::loadEntity(xmlpp::Node const &node) {
    xmlpp::Node * nc_tmp_node = const_cast<xmlpp::Node *>(&node) ;
    VALUE obj0 = Qnil ;
    AntEntity *c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AntMap::loadEntity(node);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_node, SWIGTYPE_p_Node, 0);
    result = rb_funcall(swig_get_self(), rb_intern("loadEntity"), 1,obj0);
    if ((SWIG_ConvertPtr(result,(void **) &c_result, SWIGTYPE_p_AntEntity,SWIG_POINTER_EXCEPTION | 0 )) == -1) throw Swig::DirectorTypeMismatchException("Pointer conversion failed.");
    return (AntEntity *) c_result;
}


void SwigDirector_AntMap::saveXML(xmlpp::Node &node) const {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::saveXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj(&node, SWIGTYPE_p_Node, 0);
    result = rb_funcall(swig_get_self(), rb_intern("saveXML"), 1,obj0);
}


void SwigDirector_AntMap::loadXML(xmlpp::Node const &node) {
    xmlpp::Node * nc_tmp_node = const_cast<xmlpp::Node *>(&node) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntMap::loadXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_node, SWIGTYPE_p_Node, 0);
    result = rb_funcall(swig_get_self(), rb_intern("loadXML"), 1,obj0);
}


SwigDirector_SceneNode::SwigDirector_SceneNode(VALUE self): SceneNode(), Swig::Director(self) {
    
}



void SwigDirector_SceneNode::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


size_t SwigDirector_SceneNode::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return SceneNode::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_SceneNode::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


SwigDirector_SceneNode::~SwigDirector_SceneNode() {
}

void SwigDirector_SceneNode::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_SceneNode::sort(AGVector4 const &pCamera) {
    AGVector4 * nc_tmp_pCamera = const_cast<AGVector4 *>(&pCamera) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pCamera, SWIGTYPE_p_AGVector4, 0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_SceneNode::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


void SwigDirector_SceneNode::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


SwigDirector_MeshData::SwigDirector_MeshData(VALUE self, std::string const &filename, float zoom, std::string const &pTexture, bool pShadow): MeshData(filename, zoom, pTexture, pShadow), Swig::Director(self) {
    
}



SwigDirector_MeshData::SwigDirector_MeshData(VALUE self, VertexArray const &va, std::string const &pTexture, bool pShadow): MeshData(va, pTexture, pShadow), Swig::Director(self) {
    
}



void SwigDirector_MeshData::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_MeshData::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


size_t SwigDirector_MeshData::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return MeshData::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


SwigDirector_MeshData::~SwigDirector_MeshData() {
}

void SwigDirector_MeshData::sort(AGVector4 const &pCamera) {
    AGVector4 * nc_tmp_pCamera = const_cast<AGVector4 *>(&pCamera) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pCamera, SWIGTYPE_p_AGVector4, 0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_MeshData::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        MeshData::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_MeshData::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        MeshData::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_MeshData::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        MeshData::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


SwigDirector_Mesh::SwigDirector_Mesh(VALUE self): Mesh(), Swig::Director(self) {
    
}



SwigDirector_Mesh::SwigDirector_Mesh(VALUE self, MeshData &data, AGVector4 const &pPos, float pRot): Mesh(data, pPos, pRot), Swig::Director(self) {
    
}



void SwigDirector_Mesh::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_Mesh::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


size_t SwigDirector_Mesh::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return Mesh::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


SwigDirector_Mesh::~SwigDirector_Mesh() {
}

void SwigDirector_Mesh::sort(AGVector4 const &pCamera) {
    AGVector4 * nc_tmp_pCamera = const_cast<AGVector4 *>(&pCamera) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pCamera, SWIGTYPE_p_AGVector4, 0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_Mesh::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        Mesh::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_Mesh::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        Mesh::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_Mesh::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        Mesh::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


SwigDirector_GLApp::SwigDirector_GLApp(VALUE self, int w, int h): GLApp(w, h), Swig::Director(self) {
    
}



bool SwigDirector_GLApp::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventFrameEnd(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrameEnd(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrameEnd"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::eventFrame(float t) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return GLApp::eventFrame(t);
    }
    obj0 = rb_float_new(t);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrame"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_GLApp::eventChangedRes() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::eventChangedRes();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventChangedRes"), 0, NULL);
}


void SwigDirector_GLApp::eventClick(Scene::PickResult const &pNodes, int button) {
    std::vector<PickNode > temp1 ;
    Scene::PickResult * nc_tmp_pNodes = const_cast<Scene::PickResult *>(&pNodes) ;
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        GLApp::eventClick(pNodes,button);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pNodes, SWIGTYPE_p_std__vectorTPickNode_t, 0);
    obj1 = INT2NUM(button);
    result = rb_funcall(swig_get_self(), rb_intern("eventClick"), 2,obj0,obj1);
}


SwigDirector_GLApp::~SwigDirector_GLApp() {
}

bool SwigDirector_GLApp::eventIdle() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventIdle();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventIdle"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_GLApp::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    {
        obj0 = rb_str_new2(pName.c_str());
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_GLApp::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        GLApp::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


SwigDirector_AntEntity::SwigDirector_AntEntity(VALUE self): AntEntity(), Swig::Director(self) {
    
}



SwigDirector_AntEntity::SwigDirector_AntEntity(VALUE self, AGVector3 const &p): AntEntity(p), Swig::Director(self) {
    
}



SwigDirector_AntEntity::SwigDirector_AntEntity(VALUE self, AGVector2 const &p): AntEntity(p), Swig::Director(self) {
    
}



void SwigDirector_AntEntity::move(float pTime) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::move(pTime);
        return;
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("move"), 1,obj0);
}


void SwigDirector_AntEntity::eventNoJob() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventNoJob();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventNoJob"), 0, NULL);
}


void SwigDirector_AntEntity::delJob() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::delJob();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("delJob"), 0, NULL);
}


void SwigDirector_AntEntity::eventGotNewJob() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventGotNewJob();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotNewJob"), 0, NULL);
}


void SwigDirector_AntEntity::newFetchJob(int p, AntEntity *pTarget, std::string const &pWhat) {
    std::string temp3 ;
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newFetchJob(p,pTarget,pWhat);
        return;
    }
    obj0 = INT2NUM(p);
    obj1 = SWIG_NewPointerObj(pTarget, SWIGTYPE_p_AntEntity, 0);
    {
        obj2 = rb_str_new2(pWhat.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("newFetchJob"), 3,obj0,obj1,obj2);
}


void SwigDirector_AntEntity::newFetchJob(int p, AGVector2 &pTarget, std::string const &pWhat) {
    std::string temp3 ;
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newFetchJob(p,pTarget,pWhat);
        return;
    }
    obj0 = INT2NUM(p);
    obj1 = SWIG_NewPointerObj(&pTarget, SWIGTYPE_p_AGVector2, 0);
    {
        obj2 = rb_str_new2(pWhat.c_str());
    }
    result = rb_funcall(swig_get_self(), rb_intern("newFetchJob"), 3,obj0,obj1,obj2);
}


SwigDirector_AntEntity::~SwigDirector_AntEntity() {
}

void SwigDirector_AntEntity::newMoveJob(int p, AGVector2 const &pTarget, int pnear) {
    VALUE obj0 = Qnil ;
    AGVector2 * nc_tmp_pTarget = const_cast<AGVector2 *>(&pTarget) ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newMoveJob(p,pTarget,pnear);
        return;
    }
    obj0 = INT2NUM(p);
    obj1 = SWIG_NewPointerObj(nc_tmp_pTarget, SWIGTYPE_p_AGVector2, 0);
    obj2 = INT2NUM(pnear);
    result = rb_funcall(swig_get_self(), rb_intern("newMoveJob"), 3,obj0,obj1,obj2);
}


std::string SwigDirector_AntEntity::xmlName() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AntEntity::xmlName();
    }
    result = rb_funcall(swig_get_self(), rb_intern("xmlName"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        c_result = std::string(StringValuePtr(result));
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


void SwigDirector_AntEntity::resourceChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::resourceChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("resourceChanged"), 0, NULL);
}


void SwigDirector_AntEntity::eventJobFinished() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventJobFinished();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventJobFinished"), 0, NULL);
}


void SwigDirector_AntEntity::eventDefeated() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventDefeated();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventDefeated"), 0, NULL);
}


void SwigDirector_AntEntity::eventDie() {
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventDie();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventDie"), 0, NULL);
}


void SwigDirector_AntEntity::loadXML(xmlpp::Node const &node) {
    xmlpp::Node * nc_tmp_node = const_cast<xmlpp::Node *>(&node) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::loadXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_node, SWIGTYPE_p_Node, 0);
    result = rb_funcall(swig_get_self(), rb_intern("loadXML"), 1,obj0);
}


void SwigDirector_AntEntity::saveXML(xmlpp::Node &node) const {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::saveXML(node);
        return;
    }
    obj0 = SWIG_NewPointerObj(&node, SWIGTYPE_p_Node, 0);
    result = rb_funcall(swig_get_self(), rb_intern("saveXML"), 1,obj0);
}


void SwigDirector_AntEntity::newFightJob(int p, AntEntity *target) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newFightJob(p,target);
        return;
    }
    obj0 = INT2NUM(p);
    obj1 = SWIG_NewPointerObj(target, SWIGTYPE_p_AntEntity, 0);
    result = rb_funcall(swig_get_self(), rb_intern("newFightJob"), 2,obj0,obj1);
}


void SwigDirector_AntEntity::eventGotFight(AntEntity *pOther) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::eventGotFight(pOther);
        return;
    }
    obj0 = SWIG_NewPointerObj(pOther, SWIGTYPE_p_AntEntity, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFight"), 1,obj0);
}


void SwigDirector_AntEntity::setPos(AGVector2 const &p) {
    AGVector2 * nc_tmp_p = const_cast<AGVector2 *>(&p) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::setPos(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_p, SWIGTYPE_p_AGVector2, 0);
    result = rb_funcall(swig_get_self(), rb_intern("setPos"), 1,obj0);
}


void SwigDirector_AntEntity::newRestJob(int pTime) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AntEntity::newRestJob(pTime);
        return;
    }
    obj0 = INT2NUM(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("newRestJob"), 1,obj0);
}


SwigDirector_TerrainPieceVA::SwigDirector_TerrainPieceVA(VALUE self, HeightMap &map, int x, int y, int w, int h, AGVector4 const &pPos): TerrainPieceVA(map, x, y, w, h, pPos), Swig::Director(self) {
    
}



void SwigDirector_TerrainPieceVA::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


size_t SwigDirector_TerrainPieceVA::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return TerrainPieceVA::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_TerrainPieceVA::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainPieceVA::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


SwigDirector_TerrainPieceVA::~SwigDirector_TerrainPieceVA() {
}

void SwigDirector_TerrainPieceVA::sort(AGVector4 const &pCamera) {
    AGVector4 * nc_tmp_pCamera = const_cast<AGVector4 *>(&pCamera) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pCamera, SWIGTYPE_p_AGVector4, 0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_TerrainPieceVA::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainPieceVA::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_TerrainPieceVA::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainPieceVA::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_TerrainPieceVA::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainPieceVA::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


SwigDirector_TerrainMesh::SwigDirector_TerrainMesh(VALUE self, HeightMap &map): TerrainMesh(map), Swig::Director(self) {
    
}



void SwigDirector_TerrainMesh::advance(float t) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        TerrainMesh::advance(t);
        return;
    }
    obj0 = rb_float_new(t);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


size_t SwigDirector_TerrainMesh::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return TerrainMesh::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_TerrainMesh::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainMesh::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


SwigDirector_TerrainMesh::~SwigDirector_TerrainMesh() {
}

void SwigDirector_TerrainMesh::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainMesh::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_TerrainMesh::sort(AGVector4 const &camera) {
    AGVector4 * nc_tmp_camera = const_cast<AGVector4 *>(&camera) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        TerrainMesh::sort(camera);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_camera, SWIGTYPE_p_AGVector4, 0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_TerrainMesh::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainMesh::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_TerrainMesh::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        TerrainMesh::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


SwigDirector_GLTree::SwigDirector_GLTree(VALUE self, AGVector4 p, float h): GLTree(p, h), Swig::Director(self) {
    
}



void SwigDirector_GLTree::advance(float time) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::advance(time);
        return;
    }
    obj0 = rb_float_new(time);
    result = rb_funcall(swig_get_self(), rb_intern("advance"), 1,obj0);
}


void SwigDirector_GLTree::mapChanged() {
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::mapChanged();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("mapChanged"), 0, NULL);
}


size_t SwigDirector_GLTree::getTriangles() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return Mesh::getTriangles();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getTriangles"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


SwigDirector_GLTree::~SwigDirector_GLTree() {
}

void SwigDirector_GLTree::sort(AGVector4 const &pCamera) {
    AGVector4 * nc_tmp_pCamera = const_cast<AGVector4 *>(&pCamera) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        SceneNode::sort(pCamera);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pCamera, SWIGTYPE_p_AGVector4, 0);
    result = rb_funcall(swig_get_self(), rb_intern("sort"), 1,obj0);
}


void SwigDirector_GLTree::drawDepth() {
    VALUE result;
    
    if (swig_get_up()) {
        GLTree::drawDepth();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawDepth"), 0, NULL);
}


void SwigDirector_GLTree::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        GLTree::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


void SwigDirector_GLTree::drawShadow() {
    VALUE result;
    
    if (swig_get_up()) {
        GLTree::drawShadow();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawShadow"), 0, NULL);
}


static VALUE
_wrap_new_StringVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<std::string > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<std::string > *)new std::vector<std::string >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_StringVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<std::string > *)new std::vector<std::string >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_StringVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::string *arg2 = 0 ;
    std::vector<std::string > *result;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[1]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (std::vector<std::string > *)new std::vector<std::string >(arg1,(std::string const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_StringVector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_StringVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTstd__string_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_StringVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = 0 ;
    std::vector<std::string > *result;
    std::vector<std::string > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (std::vector<std::string > *)new std::vector<std::string >((std::vector<std::string > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_StringVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_StringVector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if (SWIG_STRING_P(o))
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<std::string >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTstd__string_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_StringVector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_StringVector'");
    return Qnil;
}


static VALUE
_wrap_StringVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    unsigned int result;
    std::vector<std::string > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (unsigned int)((std::vector<std::string > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_StringVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    bool result;
    std::vector<std::string > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (bool)((std::vector<std::string > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_StringVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_StringVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->push_back(arg2);
    
    return Qnil;
}


static VALUE
_wrap_StringVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    {
        try {
            result = std_vector_Sl_std_string_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_StringVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    int arg2 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            result = std_vector_Sl_std_string_Sg____getitem__(arg1,arg2);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_StringVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    int arg2 ;
    std::string arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg3 = std::string(StringValuePtr(argv[1]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        try {
            std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_StringVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    std_vector_Sl_std_string_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_std_string_Sg_(std::vector<std::string > *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_SceneNodeVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<SceneNodePtr > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<SceneNodePtr > *)new std::vector<SceneNodePtr >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_SceneNodeVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<SceneNodePtr > *)new std::vector<SceneNodePtr >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_SceneNodeVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    SceneNodePtr *arg2 = 0 ;
    std::vector<SceneNodePtr > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_p_SceneNode, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<SceneNodePtr > *)new std::vector<SceneNodePtr >(arg1,(SceneNode *const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_SceneNodeVector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_SceneNodeVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTSceneNode_p_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_SceneNodeVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = 0 ;
    std::vector<SceneNodePtr > *result;
    std::vector<SceneNodePtr > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<SceneNodePtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                SceneNodePtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_p_SceneNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNode_p_t, 1);
        }
    }
    result = (std::vector<SceneNodePtr > *)new std::vector<SceneNodePtr >((std::vector<SceneNodePtr > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_SceneNodeVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_SceneNodeVector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_SceneNodeVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    SceneNodePtr* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_p_SceneNode,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<SceneNodePtr >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTSceneNode_p_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_SceneNodeVector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_p_SceneNode, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_SceneNodeVector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_SceneNodeVector'");
    return Qnil;
}


static VALUE
_wrap_SceneNodeVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    unsigned int result;
    std::vector<SceneNodePtr > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<SceneNodePtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                SceneNodePtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_p_SceneNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNode_p_t, 1);
        }
    }
    result = (unsigned int)((std::vector<SceneNodePtr > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_SceneNodeVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    bool result;
    std::vector<SceneNodePtr > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<SceneNodePtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                SceneNodePtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_p_SceneNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNode_p_t, 1);
        }
    }
    result = (bool)((std::vector<SceneNodePtr > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_SceneNodeVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNode_p_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_SceneNodeVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    SceneNodePtr *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNode_p_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_p_SceneNode, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((SceneNode *const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNodeVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    SceneNodePtr result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNode_p_t, 1);
    {
        try {
            result = (SceneNodePtr)std_vector_Sl_SceneNodePtr_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        //	std::cout<<"test2"<<std::endl;
        if(result)
        {
            if(result->mRubyObject)
            {
                vresult=result->mRUBY;
                //			std::cout<<"found :"<<vresult<<std::endl;
            }
            else
            {
                if(dynamic_cast<Mesh*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
                else if(dynamic_cast<TerrainMesh*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainMesh,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SceneNode,0);
                
                
                //		        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
                //result->mRubyObject=true;
                //result->mRUBY=vresult;
                //			std::cout<<"not found - but set:"<<vresult<<std::endl;
            }
        }
        else
        {
            vresult = Qnil;
            std::cout<<"nilled"<<std::endl;
        }
    }
    return vresult;
}


static VALUE
_wrap_SceneNodeVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    int arg2 ;
    SceneNodePtr *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNode_p_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                SceneNodePtr &_result_ref = std_vector_Sl_SceneNodePtr_Sg____getitem__(arg1,arg2);
                result = (SceneNodePtr *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_SceneNode,0);
    return vresult;
}


static VALUE
_wrap_SceneNodeVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    int arg2 ;
    SceneNodePtr *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNode_p_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_p_SceneNode, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_SceneNodePtr_Sg____setitem__(arg1,arg2,(SceneNode *const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_SceneNodeVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<SceneNodePtr > *arg1 = (std::vector<SceneNodePtr > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTSceneNode_p_t, 1);
    std_vector_Sl_SceneNodePtr_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_SceneNodePtr_Sg_(std::vector<SceneNodePtr > *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_PickResult__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<PickNode > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<PickNode > *)new std::vector<PickNode >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_PickResult__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<PickNode > *)new std::vector<PickNode >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_PickResult__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    PickNode *arg2 = 0 ;
    std::vector<PickNode > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_PickNode, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<PickNode > *)new std::vector<PickNode >(arg1,(PickNode const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_PickResult_allocate(VALUE self) {
#else
    static VALUE
    _wrap_PickResult_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTPickNode_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_PickResult__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = 0 ;
    std::vector<PickNode > *result;
    std::vector<PickNode > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<PickNode >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                PickNode* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_PickNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
        }
    }
    result = (std::vector<PickNode > *)new std::vector<PickNode >((std::vector<PickNode > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_PickResult(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_PickResult__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_PickResult__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    PickNode* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_PickNode,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<PickNode >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTPickNode_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_PickResult__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_PickNode, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_PickResult__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_PickResult'");
    return Qnil;
}


static VALUE
_wrap_PickResult___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    unsigned int result;
    std::vector<PickNode > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<PickNode >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                PickNode* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_PickNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
        }
    }
    result = (unsigned int)((std::vector<PickNode > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_PickResult_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    bool result;
    std::vector<PickNode > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<PickNode >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                PickNode* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_PickNode, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
        }
    }
    result = (bool)((std::vector<PickNode > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_PickResult_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_PickResult_push(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    PickNode *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_PickNode, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((PickNode const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_PickResult_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    PickNode result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
    {
        try {
            result = std_vector_Sl_PickNode_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        PickNode * resultptr;
        resultptr = new PickNode((PickNode &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PickNode, 1);
    }
    return vresult;
}


static VALUE
_wrap_PickResult___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    int arg2 ;
    PickNode *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                PickNode &_result_ref = std_vector_Sl_PickNode_Sg____getitem__(arg1,arg2);
                result = (PickNode *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PickNode,0);
    return vresult;
}


static VALUE
_wrap_PickResult___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    int arg2 ;
    PickNode *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_PickNode, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_PickNode_Sg____setitem__(arg1,arg2,(PickNode const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_PickResult_each(int argc, VALUE *argv, VALUE self) {
    std::vector<PickNode > *arg1 = (std::vector<PickNode > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTPickNode_t, 1);
    std_vector_Sl_PickNode_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_PickNode_Sg_(std::vector<PickNode > *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_EntityVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<AntEntityPtr > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<AntEntityPtr > *)new std::vector<AntEntityPtr >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_EntityVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<AntEntityPtr > *)new std::vector<AntEntityPtr >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_EntityVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    AntEntityPtr *arg2 = 0 ;
    std::vector<AntEntityPtr > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AntEntityPtr, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<AntEntityPtr > *)new std::vector<AntEntityPtr >(arg1,(AntEntityPtr const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_EntityVector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_EntityVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTAntEntityPtr_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_EntityVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = 0 ;
    std::vector<AntEntityPtr > *result;
    std::vector<AntEntityPtr > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<AntEntityPtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                AntEntityPtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AntEntityPtr, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
        }
    }
    result = (std::vector<AntEntityPtr > *)new std::vector<AntEntityPtr >((std::vector<AntEntityPtr > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_EntityVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_EntityVector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_EntityVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    AntEntityPtr* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_AntEntityPtr,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<AntEntityPtr >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTAntEntityPtr_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_EntityVector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AntEntityPtr, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_EntityVector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_EntityVector'");
    return Qnil;
}


static VALUE
_wrap_EntityVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    unsigned int result;
    std::vector<AntEntityPtr > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AntEntityPtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AntEntityPtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AntEntityPtr, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
        }
    }
    result = (unsigned int)((std::vector<AntEntityPtr > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_EntityVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    bool result;
    std::vector<AntEntityPtr > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AntEntityPtr >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AntEntityPtr* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AntEntityPtr, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
        }
    }
    result = (bool)((std::vector<AntEntityPtr > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_EntityVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_EntityVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    AntEntityPtr *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntityPtr, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((AntEntityPtr const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_EntityVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    AntEntityPtr result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
    {
        try {
            result = std_vector_Sl_AntEntityPtr_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        AntEntityPtr * resultptr;
        resultptr = new AntEntityPtr((AntEntityPtr &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AntEntityPtr, 1);
    }
    return vresult;
}


static VALUE
_wrap_EntityVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    int arg2 ;
    AntEntityPtr *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                AntEntityPtr &_result_ref = std_vector_Sl_AntEntityPtr_Sg____getitem__(arg1,arg2);
                result = (AntEntityPtr *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntityPtr,0);
    return vresult;
}


static VALUE
_wrap_EntityVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    int arg2 ;
    AntEntityPtr *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AntEntityPtr, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_AntEntityPtr_Sg____setitem__(arg1,arg2,(AntEntityPtr const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_EntityVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<AntEntityPtr > *arg1 = (std::vector<AntEntityPtr > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAntEntityPtr_t, 1);
    std_vector_Sl_AntEntityPtr_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_AntEntityPtr_Sg_(std::vector<AntEntityPtr > *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_ResourceMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::map<std::string,float > *)new std::map<std::string,float >();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_ResourceMap_allocate(VALUE self) {
#else
    static VALUE
    _wrap_ResourceMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__mapTstd__string_float_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_ResourceMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = 0 ;
    std::map<std::string,float > *result;
    std::map<std::string,float > temp1 ;
    std::map<std::string,float > *m1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cHash)) {
            temp1 = std::map<std::string,float >();
            arg1 = &temp1;
            VALUE keys = rb_funcall(argv[0],rb_intern("keys"),0);
            unsigned int size = RARRAY(keys)->len;
            for (unsigned int i=0; i<size; i++) {
                VALUE key = RARRAY(keys)->ptr[i];
                VALUE val = rb_hash_aref(argv[0],key);
                if (!(SWIG_STRING_P(key) && SWIG_FLOAT_P(val)))
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected map<""std::string" ",""float" ">)");
                temp1[SWIG_RB2STR(key)] = SWIG_NUM2DBL(val);
            }
        } else {
            SWIG_ConvertPtr(argv[0],(void **) &m1, SWIGTYPE_p_std__mapTstd__string_float_t,1);
            arg1 = m1;
        }
    }
    result = (std::map<std::string,float > *)new std::map<std::string,float >((std::map<std::string,float > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_ResourceMap(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_ResourceMap__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            // native sequence?
            if (rb_obj_is_kind_of(argv[0],rb_cHash)) {
                VALUE keys = rb_funcall(argv[0],rb_intern("keys"),0);
                unsigned int size = RARRAY(keys)->len;
                if (size == 0) {
                    // an empty dictionary can be of any type
                    _v = 1;
                } else {
                    // check the first element only
                    VALUE key = RARRAY(keys)->ptr[0];
                    VALUE val = rb_hash_aref(argv[0],key);
                    if (SWIG_STRING_P(key) && SWIG_FLOAT_P(val))
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                // wrapped map?
                std::map<std::string,float >* m;
                if (SWIG_ConvertPtr(argv[0],(void **) &m,
                SWIGTYPE_p_std__mapTstd__string_float_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_ResourceMap__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_ResourceMap'");
    return Qnil;
}


static VALUE
_wrap_ResourceMap___len__(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    unsigned int result;
    std::map<std::string,float > temp1 ;
    std::map<std::string,float > *m1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cHash)) {
            temp1 = std::map<std::string,float >();
            arg1 = &temp1;
            VALUE keys = rb_funcall(self,rb_intern("keys"),0);
            unsigned int size = RARRAY(keys)->len;
            for (unsigned int i=0; i<size; i++) {
                VALUE key = RARRAY(keys)->ptr[i];
                VALUE val = rb_hash_aref(self,key);
                if (!(SWIG_STRING_P(key) && SWIG_FLOAT_P(val)))
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected map<""std::string" ",""float" ">)");
                temp1[SWIG_RB2STR(key)] = SWIG_NUM2DBL(val);
            }
        } else {
            SWIG_ConvertPtr(self,(void **) &m1, SWIGTYPE_p_std__mapTstd__string_float_t,1);
            arg1 = m1;
        }
    }
    result = (unsigned int)((std::map<std::string,float > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_ResourceMap_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    bool result;
    std::map<std::string,float > temp1 ;
    std::map<std::string,float > *m1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cHash)) {
            temp1 = std::map<std::string,float >();
            arg1 = &temp1;
            VALUE keys = rb_funcall(self,rb_intern("keys"),0);
            unsigned int size = RARRAY(keys)->len;
            for (unsigned int i=0; i<size; i++) {
                VALUE key = RARRAY(keys)->ptr[i];
                VALUE val = rb_hash_aref(self,key);
                if (!(SWIG_STRING_P(key) && SWIG_FLOAT_P(val)))
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected map<""std::string" ",""float" ">)");
                temp1[SWIG_RB2STR(key)] = SWIG_NUM2DBL(val);
            }
        } else {
            SWIG_ConvertPtr(self,(void **) &m1, SWIGTYPE_p_std__mapTstd__string_float_t,1);
            arg1 = m1;
        }
    }
    result = (bool)((std::map<std::string,float > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_ResourceMap_clear(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_ResourceMap___getitem__(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    std::string arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        try {
            result = (float)std_map_Sl_std_string_Sc_float_Sg____getitem__(arg1,arg2);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_ResourceMap___setitem__(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    std::string arg2 ;
    float arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    std_map_Sl_std_string_Sc_float_Sg____setitem__(arg1,arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_ResourceMap_delete(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    std::string arg2 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        try {
            result = (float)std_map_Sl_std_string_Sc_float_Sg____delitem__(arg1,arg2);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_ResourceMap_has_keyq___(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    std::string arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)std_map_Sl_std_string_Sc_float_Sg__has_key(arg1,arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_ResourceMap_keys(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 1);
    result = (VALUE)std_map_Sl_std_string_Sc_float_Sg__keys(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_ResourceMap_values(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 1);
    result = (VALUE)std_map_Sl_std_string_Sc_float_Sg__values(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_ResourceMap_each(int argc, VALUE *argv, VALUE self) {
    std::map<std::string,float > *arg1 = (std::map<std::string,float > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__mapTstd__string_float_t, 1);
    std_map_Sl_std_string_Sc_float_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_map_Sl_std_string_Sc_float_Sg_(std::map<std::string,float > *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMain_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMain_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMain);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMain(int argc, VALUE *argv, VALUE self) {
    AGMain *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMain *)new AGMain();
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGMain(AGMain *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGMain_flip(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGMain_changeRes(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    bool arg5 ;
    bool arg6 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    arg5 = RTEST(argv[3]);
    arg6 = RTEST(argv[4]);
    (arg1)->changeRes(arg2,arg3,arg4,arg5,arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGMain_toggleFull(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    (arg1)->toggleFull();
    
    return Qnil;
}


static VALUE
_wrap_AGMain_width(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    result = (int)((AGMain const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGMain_height(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    result = (int)((AGMain const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_getMain(int argc, VALUE *argv, VALUE self) {
    AGMain *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMain *)getMain();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMain,0);
    return vresult;
}


static VALUE
_wrap_new_AGSurface__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1);
        
    } else {
        result = (AGSurface *)new AGSurface();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGSurface__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    AGSurface *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    char *classname = "Libantargis::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1,arg2,arg3);
        
    } else {
        result = (AGSurface *)new AGSurface(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSurface_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSurface_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSurface);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSurface__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *arg2 = 0 ;
    AGSurface *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargis::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1,(AGSurface const &)*arg2);
        
    } else {
        result = (AGSurface *)new AGSurface((AGSurface const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGSurface(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGSurface__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGSurface__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGSurface__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGSurface'");
    return Qnil;
}


static void
free_AGSurface(AGSurface *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGSurface_width(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (int)((AGSurface const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSurface_height(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (int)((AGSurface const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSurface_surface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    SDL_Surface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (SDL_Surface *)(arg1)->surface();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


static VALUE
_wrap_AGSurface_getRect(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = ((AGSurface const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_getSubSurface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    AGSurface result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGSurface const *)arg1)->getSubSurface((AGRect const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_clone(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (AGSurface *)((AGSurface const *)arg1)->clone();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSurface,0);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_valid(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (bool)((AGSurface const *)arg1)->valid();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSurface_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE _wrap_AGSurface_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGSurface_blit__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGSurface_blit__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSurface_blit'");
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradient((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawGradientAlpha(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradientAlpha((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawBorder((AGRect const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_putPixel(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_getPixel(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSurface const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_disown_AGSurface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_new_AGTexture__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGTexture *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTexture *)new AGTexture();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTexture_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTexture_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTexture);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTexture__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = 0 ;
    AGTexture *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTexture, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTexture *)new AGTexture((AGTexture const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGTexture(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGTexture__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGTexture__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGTexture'");
    return Qnil;
}


static void
free_AGTexture(AGTexture *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGTexture_width(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (int)((AGTexture const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_height(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (int)((AGTexture const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_testSave(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    ((AGTexture const *)arg1)->testSave();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_getRect(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = ((AGTexture const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_getPixel(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = ((AGTexture const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_getTW(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (float)((AGTexture const *)arg1)->getTW();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTH(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (float)((AGTexture const *)arg1)->getTH();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_hasTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (bool)((AGTexture const *)arg1)->hasTexture();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTexture_textureUsed(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (bool)((AGTexture const *)arg1)->textureUsed();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTexture_clearTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    (arg1)->clearTexture();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_clearTextureUsed(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    (arg1)->clearTextureUsed();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_setTextureID(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    GLuint arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_GLuint, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setTextureID(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_getTextureID(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    GLuint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (arg1)->getTextureID();
    
    {
        GLuint * resultptr;
        resultptr = new GLuint((GLuint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_GLuint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_surface(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    SDL_Surface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (SDL_Surface *)(arg1)->surface();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


static VALUE
_wrap_AGScreen_begin(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->begin();
    
    return Qnil;
}


static VALUE
_wrap_AGScreen_flip(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGScreen_getWidth(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGScreen const *)arg1)->getWidth();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGScreen_getHeight(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGScreen const *)arg1)->getHeight();
    
    vresult = UINT2NUM(result);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGScreen_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGScreen_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGScreen);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGScreen(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGScreen *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGScreen";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGScreen *)new SwigDirector_AGScreen(arg1);
        
    } else {
        result = (AGScreen *)new AGScreen();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGScreen(AGScreen *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        AGScreen &_result_ref = getScreen();
        result = (AGScreen *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreen,0);
    return vresult;
}


static VALUE
_wrap_setScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    setScreen(arg1);
    
    return Qnil;
}


static void
free_AGSurfaceManager(AGSurfaceManager *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGSurfaceManager_loadSurface(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->loadSurface((std::string const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurfaceManager_fromSDL(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    SDL_Surface *arg2 = (SDL_Surface *) 0 ;
    AGSurface result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Surface, 1);
    result = (arg1)->fromSDL(arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurfaceManager_registerSurface(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGSurface *arg2 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1);
    (arg1)->registerSurface(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_deregisterSurface(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGSurface *arg2 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1);
    (arg1)->deregisterSurface(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_cleanup(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    (arg1)->cleanup();
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_enableGC(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    (arg1)->enableGC();
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_disableGC(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    (arg1)->disableGC();
    
    return Qnil;
}


static VALUE
_wrap_getSurfaceManager(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGSurfaceManager *)getSurfaceManager();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSurfaceManager,0);
    return vresult;
}


static void
free_AGTextureManager(AGTextureManager *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGTextureManager_registerTexture(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    AGTexture *arg2 = (AGTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1);
    (arg1)->registerTexture(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTextureManager_deregisterTexture(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    AGTexture *arg2 = (AGTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1);
    (arg1)->deregisterTexture(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTextureManager_cleanup(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    (arg1)->cleanup();
    
    return Qnil;
}


static VALUE
_wrap_AGTextureManager_checkUnused(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    (arg1)->checkUnused();
    
    return Qnil;
}


static VALUE
_wrap_AGTextureManager_makeTexture(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    AGSurface *arg2 = 0 ;
    AGTexture result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (arg1)->makeTexture((AGSurface const &)*arg2);
    
    {
        AGTexture * resultptr;
        resultptr = new AGTexture((AGTexture &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTexture, 1);
    }
    return vresult;
}


static VALUE
_wrap_getTextureManager(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTextureManager *)getTextureManager();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTextureManager,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSDLScreen_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSDLScreen_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSDLScreen);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSDLScreen(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    SDL_Surface *arg2 = (SDL_Surface *) 0 ;
    AGSDLScreen *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Surface, 1);
    {
        char *classname = "Libantargis::AGSDLScreen";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGSDLScreen *)new SwigDirector_AGSDLScreen(arg1,arg2);
            
        } else {
            result = (AGSDLScreen *)new AGSDLScreen(arg2);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGSDLScreen\n");
    }
    return self;
}


static VALUE
_wrap_AGSDLScreen_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGSDLScreen_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSDLScreen_blit__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGSDLScreen_blit__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSDLScreen_blit'");
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_tile__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_tile__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_tile__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGSDLScreen_tile(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSDLScreen_tile__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSDLScreen_tile__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGSDLScreen_tile__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSDLScreen_tile'");
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_flip(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_getRect(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSDLScreen const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_drawRect(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawRect((AGRect const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_drawLine(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawLine((AGPoint const &)*arg2,(AGPoint const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_drawGradientAlpha(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGradientAlpha((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGradient((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_renderText(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    int arg4 ;
    std::string *arg5 = 0 ;
    AGFont *arg6 = 0 ;
    std::string temp5 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    {
        if (TYPE(argv[3]) == T_STRING) {
            temp5 = std::string(StringValuePtr(argv[3]));
            arg5 = &temp5;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGFont, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->renderText((AGRect const &)*arg2,arg3,arg4,(std::string const &)*arg5,(AGFont const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawBorder((AGRect const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_putPixel(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_newSurface(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    int arg2 ;
    int arg3 ;
    SDL_Surface *result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (SDL_Surface *)(arg1)->newSurface(arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_loadSurface(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (arg1)->loadSurface((std::string const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_displayFormat(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    SDL_Surface *arg2 = (SDL_Surface *) 0 ;
    AGTexture result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Surface, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (arg1)->displayFormat(arg2);
    
    {
        AGTexture * resultptr;
        resultptr = new AGTexture((AGTexture &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTexture, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_makeTexture(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGSurface *arg2 = 0 ;
    AGTexture result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (arg1)->makeTexture((AGSurface const &)*arg2);
    
    {
        AGTexture * resultptr;
        resultptr = new AGTexture((AGTexture &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTexture, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_getWidth(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSDLScreen const *)arg1)->getWidth();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_getHeight(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSDLScreen const *)arg1)->getHeight();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static void
free_AGSDLScreen(AGSDLScreen *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGSDLScreen(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEvent(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    AGEvent *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1);
    char *classname = "Libantargis::AGEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEvent *)new SwigDirector_AGEvent(arg1,arg2);
        
    } else {
        result = (AGEvent *)new AGEvent(arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGEvent(AGEvent *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGEvent_getCaller(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    AGListener *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 1);
    result = (AGListener *)((AGEvent const *)arg1)->getCaller();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListener,0);
    return vresult;
}


static VALUE
_wrap_disown_AGEvent(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEvent, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSDLEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSDLEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSDLEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSDLEvent(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    SDL_Event *arg3 = (SDL_Event *) 0 ;
    AGSDLEvent *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_SDL_Event, 1);
    char *classname = "Libantargis::AGSDLEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSDLEvent *)new SwigDirector_AGSDLEvent(arg1,arg2,(SDL_Event const *)arg3);
        
    } else {
        result = (AGSDLEvent *)new AGSDLEvent(arg2,(SDL_Event const *)arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGSDLEvent_getMousePosition(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = ((AGSDLEvent const *)arg1)->getMousePosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLEvent_getKey(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    SDLKey result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = (SDLKey)((AGSDLEvent const *)arg1)->getKey();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSDLEvent_getMod(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    SDLMod result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = (SDLMod)((AGSDLEvent const *)arg1)->getMod();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSDLEvent_getButton(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = (int)((AGSDLEvent const *)arg1)->getButton();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSDLEvent_get(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    SDL_Event *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = (SDL_Event *)((AGSDLEvent const *)arg1)->get();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Event,0);
    return vresult;
}


static void
free_AGSDLEvent(AGSDLEvent *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGSDLEvent(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMouseEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMouseEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMouseEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMouseEvent(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    SDL_Event *arg3 = (SDL_Event *) 0 ;
    AGMouseEvent *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_SDL_Event, 1);
    char *classname = "Libantargis::AGMouseEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGMouseEvent *)new SwigDirector_AGMouseEvent(arg1,arg2,arg3);
        
    } else {
        result = (AGMouseEvent *)new AGMouseEvent(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGMouseEvent(AGMouseEvent *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGMouseEvent(int argc, VALUE *argv, VALUE self) {
    AGMouseEvent *arg1 = (AGMouseEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMouseEvent, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListener_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListener_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListener);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListener(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGListener";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGListener *)new SwigDirector_AGListener(arg1);
        
    } else {
        result = (AGListener *)new AGListener();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGListener(AGListener *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGListener_signal(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListener, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->signal((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGListener(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListener, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static void
free_AGCPPListener(AGCPPListener *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGCPPListener_signal(int argc, VALUE *argv, VALUE self) {
    AGCPPListener *arg1 = (AGCPPListener *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCPPListener, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGCPPListener const *)arg1)->signal((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCPPListener_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCPPListener_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCPPListener);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCPPListener(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGCPPListener *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGCPPListener";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGCPPListener *)new SwigDirector_AGCPPListener(arg1);
        
    } else {
        rb_raise(rb_eNameError,"accessing abstract class or protected constructor"); 
        return Qnil;
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_disown_AGCPPListener(int argc, VALUE *argv, VALUE self) {
    AGCPPListener *arg1 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCPPListener, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_new_AGSignal__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSignal *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1);
        
    } else {
        result = (AGSignal *)new AGSignal();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGSignal__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *arg2 = (AGMessageObject *) 0 ;
    AGSignal *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMessageObject, 1);
    char *classname = "Libantargis::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1,arg2);
        
    } else {
        result = (AGSignal *)new AGSignal(arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSignal_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSignal_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSignal);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSignal__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *arg2 = (AGMessageObject *) 0 ;
    std::string *arg3 = 0 ;
    AGSignal *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMessageObject, 1);
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp3 = std::string(StringValuePtr(argv[1]));
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1,arg2,(std::string const &)*arg3);
        
    } else {
        result = (AGSignal *)new AGSignal(arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGSignal(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGSignal__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMessageObject, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGSignal__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMessageObject, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGSignal__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGSignal'");
    return Qnil;
}


static void
free_AGSignal(AGSignal *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGSignal_connect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGListener *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->connect(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSignal_disconnect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGListener *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->disconnect(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSignal_connect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGCPPListener *arg2 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGCPPListener, 1);
    (arg1)->connect(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSignal_connect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_connect__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGCPPListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_connect__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSignal_connect'");
    return Qnil;
}


static VALUE
_wrap_AGSignal_disconnect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGCPPListener *arg2 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGCPPListener, 1);
    (arg1)->disconnect(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSignal_disconnect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_disconnect__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGCPPListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_disconnect__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSignal_disconnect'");
    return Qnil;
}


static VALUE
_wrap_AGSignal_signal(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->signal((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSignal___call__(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->operator ()((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGSignal(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMessageObject_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMessageObject_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMessageObject);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMessageObject(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGMessageObject";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGMessageObject *)new SwigDirector_AGMessageObject(arg1);
        
    } else {
        result = (AGMessageObject *)new AGMessageObject();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGMessageObject(AGMessageObject *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGMessageObject_processEvent(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->processEvent((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_acceptEvent(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    SDL_Event *arg2 = (SDL_Event *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Event, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->acceptEvent((SDL_Event const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventActive(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventActive((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventKeyUp(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventQuit(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuit((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventQuitModal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuitModal((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventSysWM(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventSysWM((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventResize(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventResize((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_getButtonState(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    Uint8 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGMessageObject const *)arg1)->getButtonState();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMessageObject_getMousePosition(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGPoint result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGMessageObject const *)arg1)->getMousePosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigActive_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigActive = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigActive_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigActive);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigKeyDown_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigKeyDown = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigKeyDown_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigKeyDown);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigKeyUp_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigKeyUp = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigKeyUp_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigKeyUp);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseMotion_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseMotion = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseMotion_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigMouseMotion);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonDown_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseButtonDown = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonDown_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigMouseButtonDown);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonUp_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseButtonUp = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonUp_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigMouseButtonUp);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigQuit_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigQuit = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigQuit_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigQuit);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigSysWM_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigSysWM = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigSysWM_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigSysWM);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigVideoResize_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigVideoResize = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigVideoResize_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigVideoResize);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_pushSignal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    (arg1)->pushSignal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_popSignal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    (arg1)->popSignal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGMessageObject(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_newEvent(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    SDL_Event *arg2 = (SDL_Event *) 0 ;
    AGEvent *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListener, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_SDL_Event, 1);
    result = (AGEvent *)newEvent(arg1,(SDL_Event const *)arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEvent,0);
    return vresult;
}


static VALUE
_wrap_toAGSDLEvent(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = 0 ;
    AGSDLEvent *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEvent, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSDLEvent &_result_ref = toAGSDLEvent(*arg1);
        result = (AGSDLEvent *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSDLEvent,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGWidget *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWidget *)new SwigDirector_AGWidget(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGWidget *)new AGWidget(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGWidget\n");
    }
    return self;
}


static void
free_AGWidget(AGWidget *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGWidget_draw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_drawAll(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAll(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = ((AGWidget const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGWidget const *)arg1)->getClientRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setRect((AGRect const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setParent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->setParent(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getParent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (AGWidget *)(arg1)->getParent();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_eventShow(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventShow();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventHide(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventHide();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventGotFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventGotFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventLostFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventLostFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_canFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGWidget const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_processEvent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->processEvent((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_sigMouseEnter_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseEnter = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigMouseEnter_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (AGSignal *)& ((arg1)->sigMouseEnter);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_sigMouseLeave_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseLeave = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigMouseLeave_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (AGSignal *)& ((arg1)->sigMouseLeave);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_sigClick_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigClick = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigClick_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (AGSignal *)& ((arg1)->sigClick);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_minWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (int)((AGWidget const *)arg1)->minWidth();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_minHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (int)((AGWidget const *)arg1)->minHeight();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_width(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (int)((AGWidget const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_height(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (int)((AGWidget const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_top(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (int)((AGWidget const *)arg1)->top();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_left(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (int)((AGWidget const *)arg1)->left();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_setWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setTop(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setTop(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setLeft(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setLeft(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_fixedWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (bool)((AGWidget const *)arg1)->fixedWidth();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_fixedHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (bool)((AGWidget const *)arg1)->fixedHeight();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_show(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->show();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_hide(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->hide();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_addChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_addChildBack(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChildBack(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_removeChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->removeChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_clear(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getScreenRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = ((AGWidget const *)arg1)->getScreenRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_getScreenPosition(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = ((AGWidget const *)arg1)->getScreenPosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_fromScreen(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGWidget const *)arg1)->fromScreen((AGPoint const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_gainFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->gainFocus(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->gainFocus();
    
    return Qnil;
}


static VALUE _wrap_AGWidget_gainFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_gainFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_gainFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_gainFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainCompleteFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->gainCompleteFocus(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainCompleteFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->gainCompleteFocus();
    
    return Qnil;
}


static VALUE _wrap_AGWidget_gainCompleteFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_gainCompleteFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_gainCompleteFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_gainCompleteFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_eventDragBy(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    AGPoint *arg3 = 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventDragBy((AGEvent const *)arg2,(AGPoint const &)*arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_getFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (bool)((AGWidget const *)arg1)->getFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_hasFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    result = (bool)(arg1)->hasFocus((AGWidget const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_hasFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (bool)(arg1)->hasFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGWidget_hasFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_hasFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_hasFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_hasFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_getName(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = ((AGWidget const *)arg1)->getName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setName(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string *arg2 = 0 ;
    AGWidget *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGWidget *)(arg1)->getChild((std::string const &)*arg2);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setModal(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setModal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_erase(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->erase(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_eventChildrenDeleted(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->eventChildrenDeleted(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, 1);
    AGWidget_markfunc(arg1);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGWidget(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGWidget(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGWidget *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGWidget *)toAGWidget(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    return vresult;
}


static VALUE
agNoParent_get(VALUE self) {
    VALUE _val;
    
    _val = SWIG_NewPointerObj((void *) agNoParent, SWIGTYPE_p_AGWidget,0);    return _val;
}


static VALUE
agNoParent_set(VALUE self, VALUE _val) {
    SWIG_ConvertPtr(_val, (void **) &agNoParent, SWIGTYPE_p_AGWidget, 1);
    return _val;
}


static VALUE
_wrap_AGPoint_x_set(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    arg2 = NUM2INT(argv[0]);
    if (arg1) (arg1)->x = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGPoint_x_get(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    result = (int) ((arg1)->x);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGPoint_y_set(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    arg2 = NUM2INT(argv[0]);
    if (arg1) (arg1)->y = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGPoint_y_get(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    result = (int) ((arg1)->y);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_new_AGPoint__SWIG_0(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    AGPoint *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    result = (AGPoint *)new AGPoint(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPoint_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPoint_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPoint);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPoint__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPoint *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGPoint *)new AGPoint();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGPoint(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGPoint__SWIG_1(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGPoint__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGPoint'");
    return Qnil;
}


static VALUE
_wrap_AGPoint___sub__(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGPoint const *)arg1)->operator -((AGPoint const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPoint___add__(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGPoint const *)arg1)->operator +((AGPoint const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static void
free_AGPoint(AGPoint *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGRect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGRect *)new AGRect();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGRect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = 0 ;
    AGRect *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRect, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect *)new AGRect((AGRect const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGRect__SWIG_2(int argc, VALUE *argv, VALUE self) {
    SDL_Rect *arg1 = 0 ;
    AGRect *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SDL_Rect, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect *)new AGRect((SDL_Rect const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGRect__SWIG_3(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    AGRect *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    arg4 = NUM2INT(argv[3]);
    result = (AGRect *)new AGRect(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect__SWIG_4(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGRect *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGRect *)new AGRect((std::string const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGRect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGRect__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGRect__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SDL_Rect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGRect__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGRect__SWIG_4(nargs, args, self);
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGRect__SWIG_3(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGRect'");
    return Qnil;
}


static VALUE
_wrap_AGRect_setX(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect_setY(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect_setW(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setW(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect_setH(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setH(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect_getX(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (int)((AGRect const *)arg1)->getX();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGRect_getY(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (int)((AGRect const *)arg1)->getY();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGRect_width(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (int)((AGRect const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGRect_height(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (int)((AGRect const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGRect_intersect(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect const *)arg1)->intersect((AGRect const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_isNull(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (bool)((AGRect const *)arg1)->isNull();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect_shrink(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    result = ((AGRect const *)arg1)->shrink(arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_shrinkRB(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    result = ((AGRect const *)arg1)->shrinkRB(arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_contains__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect const *)arg1)->contains((AGPoint const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect_contains__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect const *)arg1)->contains((AGRect const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGRect_contains(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGPoint, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect_contains__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect_contains__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGRect_contains'");
    return Qnil;
}


static VALUE
_wrap_AGRect_project__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect const *)arg1)->project((AGRect const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_project__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect const *)arg1)->project((AGPoint const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE _wrap_AGRect_project(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect_project__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGPoint, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect_project__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGRect_project'");
    return Qnil;
}


static VALUE
_wrap_AGRect_getMiddle(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = ((AGRect const *)arg1)->getMiddle();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_origin(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = ((AGRect const *)arg1)->origin();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_getPosition(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = ((AGRect const *)arg1)->getPosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_to_s(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = ((AGRect const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGRect___eq__(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect const *)arg1)->operator ==((AGRect const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect___add__(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect const *)arg1)->operator +((AGPoint const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static void
free_AGRect(AGRect *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGAngle_angle_set(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = (AGAngle *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGAngle, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->angle = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGAngle_angle_get(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = (AGAngle *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGAngle, 1);
    result = (float) ((arg1)->angle);
    
    vresult = rb_float_new(result);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGAngle_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGAngle_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGAngle);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGAngle(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    AGAngle *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    result = (AGAngle *)new AGAngle(arg1);
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGAngle(AGAngle *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGVector2_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 1);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector2_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGVector2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector2 *)new AGVector2(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGVector2 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector2 *)new AGVector2((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector2__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector2 *)new AGVector2((AGVector2 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector2__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector2 *)new AGVector2();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector2__SWIG_3(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector2__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector2__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector2__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector2'");
    return Qnil;
}


static VALUE
_wrap_AGVector2_setX(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_setY(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_x(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float)((AGVector2 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_y(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float)((AGVector2 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_getAngle(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    SwigValueWrapper<AGAngle > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = ((AGVector2 const *)arg1)->getAngle();
    
    {
        AGAngle * resultptr;
        resultptr = new AGAngle((AGAngle &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGAngle, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector2 const *)arg1)->operator -((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___add__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector2 const *)arg1)->operator +((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector2 const *)arg1)->operator *((AGVector2 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector2 const *)arg1)->operator *(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector2___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector2___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector2___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector2___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector2___div__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector2 const *)arg1)->operator /(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector2 const *)arg1)->operator ==((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector2_length(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float)((AGVector2 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_length2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float)((AGVector2 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = ((AGVector2 const *)arg1)->normalized();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_normal(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = ((AGVector2 const *)arg1)->normal();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (bool)((AGVector2 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector2_saveXML(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((AGVector2 const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_loadXML(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = ((AGVector2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGVector2(AGVector2 *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGVector3_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 1);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector3_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGVector3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGVector3 *)new AGVector3(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGVector3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector3 *)new AGVector3(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector3__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGVector3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector3 *)new AGVector3();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector3__SWIG_4(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector3__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVector3__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector3'");
    return Qnil;
}


static VALUE
_wrap_AGVector3_setX(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_setY(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_setZ(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setZ(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_x(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_y(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_z(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->getZ();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_getAngle(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    SwigValueWrapper<AGAngle > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = ((AGVector3 const *)arg1)->getAngle();
    
    {
        AGAngle * resultptr;
        resultptr = new AGAngle((AGAngle &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGAngle, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator -((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___add__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator +((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_add(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector3 &_result_ref = (arg1)->operator +=((AGVector3 const &)*arg2);
        result = (AGVector3 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3_sub(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector3 &_result_ref = (arg1)->operator -=((AGVector3 const &)*arg2);
        result = (AGVector3 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector3 const *)arg1)->operator *((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector3 const *)arg1)->operator *(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector3___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector3___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector3___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector3___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector3___div__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector3 const *)arg1)->operator /(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___mod__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator %((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector3 const *)arg1)->operator ==((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3_length(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_length2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = ((AGVector3 const *)arg1)->normalized();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_normal(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = ((AGVector3 const *)arg1)->normal();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (bool)((AGVector3 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3_saveXML(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((AGVector3 const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_loadXML(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = ((AGVector3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGVector3(AGVector3 *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGPoint3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPoint3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGPoint3 *)new AGPoint3();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGPoint3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGPoint3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGPoint3 *)new AGPoint3(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGPoint3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGPoint3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGPoint3 *)new AGPoint3(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPoint3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPoint3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPoint3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPoint3__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGPoint3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGPoint3 *)new AGPoint3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGPoint3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGPoint3__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGPoint3__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGPoint3__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGPoint3__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGPoint3'");
    return Qnil;
}


static void
free_AGPoint3(AGPoint3 *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGMatrix3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMatrix3 *)new AGMatrix3();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGMatrix3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGMatrix3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix3 *)new AGMatrix3((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMatrix3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMatrix3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMatrix3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMatrix3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGMatrix3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix3 *)new AGMatrix3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGMatrix3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGMatrix3__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix3__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix3__SWIG_2(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGMatrix3'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3_set(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGMatrix3_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix3 const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix3_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->get(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix3_get(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix3_get__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix3_get__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix3_get'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix3 const *)arg1)->operator *((AGMatrix3 const &)*arg2);
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix3 const *)arg1)->operator *((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE _wrap_AGMatrix3___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix3___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix3___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix3___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3___neg__(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    result = ((AGMatrix3 const *)arg1)->operator -();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_inverted(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    result = ((AGMatrix3 const *)arg1)->inverted();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_transposed(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    result = ((AGMatrix3 const *)arg1)->transposed();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_to_s(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    result = ((AGMatrix3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGMatrix3(AGMatrix3 *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGLine2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGLine2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLine2 *)new AGLine2();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLine2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLine2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLine2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLine2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGLine2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGLine2 *)new AGLine2((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGLine2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGLine2__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGLine2__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGLine2'");
    return Qnil;
}


static VALUE
_wrap_AGLine2_getV0(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->getV0();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_getV1(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->getV1();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_has(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->has((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_collide(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->collide((AGLine2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_collisionPoint(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGLine2 const *)arg1)->collisionPoint((AGLine2 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_collisionPointNI(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGLine2 const *)arg1)->collisionPointNI((AGLine2 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_includes(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->includes((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_getBBox(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    SwigValueWrapper<AGRect2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->getBBox();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_normal(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->normal();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_direction(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->direction();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_distance(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGLine2 const *)arg1)->distance((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGLine2_to_s(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGLine2(AGLine2 *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGLine3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGLine3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLine3 *)new AGLine3();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLine3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLine3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLine3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLine3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGLine3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGLine3 *)new AGLine3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGLine3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGLine3__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGLine3__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGLine3'");
    return Qnil;
}


static VALUE
_wrap_AGLine3_getV0(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    result = ((AGLine3 const *)arg1)->getV0();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_getV1(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    result = ((AGLine3 const *)arg1)->getV1();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_has(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine3 const *)arg1)->has((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine3_direction(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    result = ((AGLine3 const *)arg1)->direction();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_distance(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGLine3 const *)arg1)->distance((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGLine3_to_s(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    result = ((AGLine3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGLine3(AGLine3 *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCollisionData_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCollisionData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCollisionData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCollisionData(int argc, VALUE *argv, VALUE self) {
    AGCollisionData *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGCollisionData *)new AGCollisionData();
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGCollisionData(AGCollisionData *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTriangle2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTriangle2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTriangle2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTriangle2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *arg3 = 0 ;
    AGTriangle2 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_AGVector3, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTriangle2 *)new AGTriangle2((AGVector3 const &)*arg1,(AGVector3 const &)*arg2,(AGVector3 const &)*arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGTriangle2_get(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    int arg2 ;
    AGPoint3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    arg2 = NUM2INT(argv[0]);
    result = ((AGTriangle2 const *)arg1)->get(arg2);
    
    {
        AGPoint3 * resultptr;
        resultptr = new AGPoint3((AGPoint3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_collide(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGTriangle2 const *)arg1)->collide((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getNormals(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    std::vector<AGVector3 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    result = ((AGTriangle2 const *)arg1)->getNormals();
    
    {
        std::vector<AGVector3 > * resultptr;
        resultptr = new std::vector<AGVector3 >((std::vector<AGVector3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_apply(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->apply((AGMatrix3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTriangle2_applied(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    SwigValueWrapper<AGTriangle2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->applied((AGMatrix3 const &)*arg2);
    
    {
        AGTriangle2 * resultptr;
        resultptr = new AGTriangle2((AGTriangle2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTriangle2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_touchPoint(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    AGPoint3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->touchPoint((AGTriangle2 const &)*arg2);
    
    {
        AGPoint3 * resultptr;
        resultptr = new AGPoint3((AGPoint3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_touchVector(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->touchVector((AGTriangle2 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_collisionPoints(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    std::vector<AGVector3 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->collisionPoints((AGLine2 const &)*arg2);
    
    {
        std::vector<AGVector3 > * resultptr;
        resultptr = new std::vector<AGVector3 >((std::vector<AGVector3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_contains(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGPoint3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGTriangle2 const *)arg1)->contains((AGPoint3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getBBox(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    SwigValueWrapper<AGRect2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    result = ((AGTriangle2 const *)arg1)->getBBox();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_nearestLine(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGLine2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->nearestLine((AGVector3 const &)*arg2);
    
    {
        AGLine2 * resultptr;
        resultptr = new AGLine2((AGLine2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGLine2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getLines(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    SwigValueWrapper<std::vector<AGLine2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    result = ((AGTriangle2 const *)arg1)->getLines();
    
    {
        std::vector<AGLine2 > * resultptr;
        resultptr = new std::vector<AGLine2 >((std::vector<AGLine2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_to_s(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    result = ((AGTriangle2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGTriangle2(AGTriangle2 *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCircle2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCircle2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCircle2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCircle2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    float arg2 ;
    AGCircle2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGCircle2 *)new AGCircle2((AGVector3 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGCircle2_inCircle__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->inCircle((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGCircle2_outCircle__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->outCircle((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGCircle2_inCircle__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->inCircle((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGCircle2_inCircle(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTriangle2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_inCircle__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_inCircle__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGCircle2_inCircle'");
    return Qnil;
}


static VALUE
_wrap_AGCircle2_outCircle__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->outCircle((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGCircle2_outCircle(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTriangle2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_outCircle__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_outCircle__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGCircle2_outCircle'");
    return Qnil;
}


static VALUE
_wrap_AGCircle2_getPos(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    result = ((AGCircle2 const *)arg1)->getPos();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGCircle2_getRadius(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    result = (float)((AGCircle2 const *)arg1)->getRadius();
    
    vresult = rb_float_new(result);
    return vresult;
}


static void
free_AGCircle2(AGCircle2 *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTriangle3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTriangle3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTriangle3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTriangle3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *arg3 = 0 ;
    AGTriangle3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_AGVector3, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTriangle3 *)new AGTriangle3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2,(AGVector3 const &)*arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGTriangle3_collide(int argc, VALUE *argv, VALUE self) {
    AGTriangle3 *arg1 = (AGTriangle3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle3 const *)arg1)->collide((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle3_toString(int argc, VALUE *argv, VALUE self) {
    AGTriangle3 *arg1 = (AGTriangle3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle3, 1);
    result = ((AGTriangle3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGTriangle3(AGTriangle3 *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGRect2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGRect2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect2 *)new AGRect2((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    AGRect2 *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    arg4 = (float) NUM2DBL(argv[3]);
    result = (AGRect2 *)new AGRect2(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGRect2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGRect2__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FLOAT) || (TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGRect2__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGRect2'");
    return Qnil;
}


static VALUE
_wrap_AGRect2_collide(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->collide((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2___add__(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    SwigValueWrapper<AGRect2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect2 const *)arg1)->operator +((AGVector3 const &)*arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_contains__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->contains((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2_contains__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->contains((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGRect2_contains(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect2_contains__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect2_contains__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGRect2_contains'");
    return Qnil;
}


static VALUE
_wrap_AGRect2_split(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    SwigValueWrapper<std::list<AGRect2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->split();
    
    {
        std::list<AGRect2 > * resultptr;
        resultptr = new std::list<AGRect2 >((std::list<AGRect2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTAGRect2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->getV0();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->getV1();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV01(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->getV01();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV10(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->getV10();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_setX(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setY(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_x(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = (float)((AGRect2 const *)arg1)->x();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_y(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = (float)((AGRect2 const *)arg1)->y();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_w(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = (float)((AGRect2 const *)arg1)->w();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_h(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = (float)((AGRect2 const *)arg1)->h();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_to_s(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGRect2(AGRect2 *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGVector4_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 1);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector4_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector4__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    AGVector4 *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    arg4 = (float) NUM2DBL(argv[3]);
    result = (AGVector4 *)new AGVector4(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGVector4 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGVector4 *)new AGVector4(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = 0 ;
    AGVector4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector4, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector4 *)new AGVector4((AGVector4 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    float arg2 ;
    AGVector4 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector4 *)new AGVector4((AGVector3 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector4_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector4__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGVector4 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector4 *)new AGVector4();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector4(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector4__SWIG_4(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector4__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector4__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVector4__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FLOAT) || (TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGVector4__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector4'");
    return Qnil;
}


static VALUE
_wrap_AGVector4_setX(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setY(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setZ(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setZ(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setW(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setW(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_x(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_y(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_z(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->getZ();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_w(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->getW();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator -((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___add__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator +((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_add(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector4 &_result_ref = (arg1)->operator +=((AGVector4 const &)*arg2);
        result = (AGVector4 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4_sub(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector4 &_result_ref = (arg1)->operator -=((AGVector4 const &)*arg2);
        result = (AGVector4 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector4 const *)arg1)->operator *((AGVector4 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector4 const *)arg1)->operator *(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector4___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector4___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector4___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector4___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector4___div__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector4 const *)arg1)->operator /(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___neg__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->operator -();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector4 const *)arg1)->operator ==((AGVector4 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4_length(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_length2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_length3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->length3();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->normalized();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_normalized3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->normalized3();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_normalize3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    (arg1)->normalize3();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (bool)((AGVector4 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4___mod__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator %((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_cross(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->cross((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_dim3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->dim3();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGVector4(AGVector4 *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGMatrix4__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMatrix4 *)new AGMatrix4();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGMatrix4__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float *arg1 ;
    AGMatrix4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_float, 1);
    result = (AGMatrix4 *)new AGMatrix4(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGMatrix4__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    AGVector3 *arg2 = 0 ;
    AGMatrix4 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix4 *)new AGMatrix4(arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMatrix4_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMatrix4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMatrix4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMatrix4__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = 0 ;
    AGMatrix4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector4, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix4 *)new AGMatrix4((AGVector4 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGMatrix4(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGMatrix4__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_float, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix4__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix4__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGMatrix4__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGMatrix4'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_set(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix4 const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix4_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->get(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix4_get(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4_get__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4_get__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4_get'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 *arg2 = 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix4 const *)arg1)->operator *((AGMatrix4 const &)*arg2);
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_get3x3(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = ((AGMatrix4 const *)arg1)->get3x3(arg2,arg3);
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix4 const *)arg1)->operator *((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE _wrap_AGMatrix4___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix4___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix4___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4___call____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix4 const *)arg1)->operator ()(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix4___call____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->operator ()(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix4___call__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4___call____SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4___call____SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4___call__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_inverted(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    result = ((AGMatrix4 const *)arg1)->inverted();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_transposed(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    result = ((AGMatrix4 const *)arg1)->transposed();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_to_s(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    result = ((AGMatrix4 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_getRow(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = ((AGMatrix4 const *)arg1)->getRow(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static void
free_AGMatrix4(AGMatrix4 *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGRect3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect3 *)new AGRect3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGRect3_collides(int argc, VALUE *argv, VALUE self) {
    AGRect3 *arg1 = (AGRect3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect3 const *)arg1)->collides((AGLine3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect3_toString(int argc, VALUE *argv, VALUE self) {
    AGRect3 *arg1 = (AGRect3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect3, 1);
    result = ((AGRect3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGRect3(AGRect3 *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGBox3_base_set(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1);
    if (arg1) (arg1)->base = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_base_get(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = (AGVector3 *)& ((arg1)->base);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGBox3_dir_set(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1);
    if (arg1) (arg1)->dir = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_dir_get(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = (AGVector3 *)& ((arg1)->dir);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBox3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBox3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBox3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBox3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGBox3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGBox3 *)new AGBox3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGBox3_include(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->include((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_includes(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGBox3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBox3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)(arg1)->includes((AGBox3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGLine3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGBox3_collides(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGLine3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGBox3_collides'");
    return Qnil;
}


static VALUE
_wrap_AGBox3_getSides(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGRect3 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = ((AGBox3 const *)arg1)->getSides();
    
    {
        std::vector<AGRect3 > * resultptr;
        resultptr = new std::vector<AGRect3 >((std::vector<AGRect3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGRect3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_toString(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = ((AGBox3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_split(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGBox3 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = ((AGBox3 const *)arg1)->split();
    
    {
        std::vector<AGBox3 > * resultptr;
        resultptr = new std::vector<AGBox3 >((std::vector<AGBox3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGBox3_t, 1);
    }
    return vresult;
}


static void
free_AGBox3(AGBox3 *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGColor__SWIG_0(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    AGColor *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    arg4 = NUM2INT(argv[3]);
    result = (AGColor *)new AGColor(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_1(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    AGColor *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    result = (AGColor *)new AGColor(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = 0 ;
    AGColor *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColor, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGColor *)new AGColor((AGColor const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_3(int argc, VALUE *argv, VALUE self) {
    Uint32 arg1 ;
    AGSurface *arg2 = 0 ;
    AGColor *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        Uint32 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint32, 1);
        if (ptr) arg1 = *ptr;
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGColor *)new AGColor(arg1,(AGSurface const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_4(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGColor *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGColor *)new AGColor((std::string const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGColor_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGColor_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGColor);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGColor__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGColor *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGColor *)new AGColor();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGColor(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGColor__SWIG_5(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGColor__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGColor__SWIG_4(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Uint32, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGColor__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGColor__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGColor__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGColor'");
    return Qnil;
}


static VALUE
_wrap_AGColor___mul__(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    float arg2 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGColor const *)arg1)->operator *(arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor___add__(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    AGColor *arg2 = 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGColor const *)arg1)->operator +((AGColor const &)*arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_mapRGB(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    SDL_PixelFormat *arg2 = (SDL_PixelFormat *) 0 ;
    Uint32 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_PixelFormat, 1);
    result = ((AGColor const *)arg1)->mapRGB(arg2);
    
    {
        Uint32 * resultptr;
        resultptr = new Uint32((Uint32 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint32, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_toString(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    result = ((AGColor const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGColor_grey(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    result = ((AGColor const *)arg1)->grey();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_brightness(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    result = ((AGColor const *)arg1)->brightness();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_light(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->light(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColor_a_set(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg2 = *ptr;
    }
    if (arg1) (arg1)->a = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGColor_a_get(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    result =  ((arg1)->a);
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static void
free_AGColor(AGColor *arg1) {
    delete arg1;
}
static VALUE
_wrap_toInt(int argc, VALUE *argv, VALUE self) {
    Uint8 arg1 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg1 = *ptr;
    }
    result = (int)toInt(arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_new_AGFont__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGFont *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGFont *)new AGFont();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGFont__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    int arg2 ;
    AGFont *result;
    std::string temp1 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg2 = NUM2INT(argv[1]);
    result = (AGFont *)new AGFont((std::string const &)*arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFont_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFont_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFont);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFont__SWIG_2(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGFont *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGFont *)new AGFont((std::string const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGFont(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGFont__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGFont__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGFont__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGFont'");
    return Qnil;
}


static VALUE
_wrap_AGFont_setColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = ((AGFont const *)arg1)->getColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setAlpha(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setAlpha(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getAlpha(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = ((AGFont const *)arg1)->getAlpha();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setSize(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSize(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getSize(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = ((AGFont const *)arg1)->getSize();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setStyle(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGFont::Style *arg2 = 0 ;
    AGFont::Style temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    temp2 = (AGFont::Style) NUM2INT(argv[0]);
    arg2 = &temp2;
    (arg1)->setStyle((enum AGFont::Style const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getStyle(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGFont::Style result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = (AGFont::Style)((AGFont const *)arg1)->getStyle();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_setName(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getName(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = ((AGFont const *)arg1)->getName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGFont_getWidth(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)((AGFont const *)arg1)->getWidth((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_getHeight(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)((AGFont const *)arg1)->getHeight((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static void
free_AGFont(AGFont *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFontEngine_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFontEngine_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFontEngine);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFontEngine(int argc, VALUE *argv, VALUE self) {
    AGFontEngine *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGFontEngine *)new AGFontEngine();
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGFontEngine(AGFontEngine *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGFontEngine_renderText(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    int arg4 ;
    std::string *arg5 = 0 ;
    AGFont *arg6 = 0 ;
    bool result;
    std::string temp5 ;
    VALUE vresult = Qnil;
    
    if ((argc < 6) || (argc > 6))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[2]);
    arg4 = NUM2INT(argv[3]);
    {
        if (TYPE(argv[4]) == T_STRING) {
            temp5 = std::string(StringValuePtr(argv[4]));
            arg5 = &temp5;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[5], (void **) &arg6, SWIGTYPE_p_AGFont, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)AGFontEngine::renderText(arg1,(AGRect const &)*arg2,arg3,arg4,(std::string const &)*arg5,(AGFont const &)*arg6);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGFontEngine_getWidth(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGFont, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[1]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)AGFontEngine::getWidth((AGFont const &)*arg1,(std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFontEngine_getHeight(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGFont, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[1]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)AGFontEngine::getHeight((AGFont const &)*arg1,(std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_new_AGButton__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    int arg5 ;
    AGButton *result;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg5 = NUM2INT(argv[3]);
    {
        char *classname = "Libantargis::AGButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGButton *)new SwigDirector_AGButton(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4,arg5);
            
        } else {
            result = (AGButton *)new AGButton(arg2,(AGRect const &)*arg3,(std::string const &)*arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGButton\n");
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGButton_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGButton_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGButton);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGButton__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGButton *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGButton *)new SwigDirector_AGButton(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGButton *)new AGButton(arg2,(AGRect const &)*arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGButton\n");
    }
    return self;
}


static VALUE _wrap_new_AGButton(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGButton__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = ((TYPE(argv[4]) == T_FIXNUM) || (TYPE(argv[4]) == T_BIGNUM)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGButton__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGButton'");
    return Qnil;
}


static VALUE
_wrap_AGButton_setSurface__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGSurface arg2 ;
    bool arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg2 = *ptr;
    }
    arg3 = RTEST(argv[1]);
    (arg1)->setSurface(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setSurface__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGSurface arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSurface(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGButton_setSurface(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGButton_setSurface__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGButton_setSurface__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGButton_setSurface'");
    return Qnil;
}


static VALUE
_wrap_AGButton_draw(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_setWidth(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setHeight(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_getCaption(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGButton const *)arg1)->getCaption();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGButton_setEnabled(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setEnabled(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setTheme(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setTheme((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setCaption(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setCaption((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setState(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGButton::State *arg2 = 0 ;
    AGButton::State temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    temp2 = (AGButton::State) NUM2INT(argv[0]);
    arg2 = &temp2;
    (arg1)->setState((enum AGButton::State const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setChecked(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    arg2 = RTEST(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setChecked(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_isChecked(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    result = (bool)((AGButton const *)arg1)->isChecked();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_canFocus(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGButton const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGButton(AGButton *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGButton(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGButton(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGButton *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGButton &_result_ref = toAGButton(*arg1);
        result = (AGButton *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGApplication_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGApplication_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGApplication);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGApplication(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGApplication *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::AGApplication";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGApplication *)new SwigDirector_AGApplication(arg1);
            
        } else {
            result = (AGApplication *)new AGApplication();
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGApplication\n");
    }
    return self;
}


static VALUE
_wrap_AGApplication_run(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    result = (bool)(arg1)->run();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventIdle(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventIdle();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventFrame(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrame(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventFrameEnd(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrameEnd(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventQuit(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuit((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventChangedRes(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventChangedRes();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_setMainWidget(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->setMainWidget(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_draw(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_tryQuit(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    (arg1)->tryQuit();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_getTicks(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    long result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    result = (long)((AGApplication const *)arg1)->getTicks();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGApplication_delay(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->delay(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, 1);
    AGApplication_markfunc(arg1);
    
    return Qnil;
}


static void
free_AGApplication(AGApplication *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGApplication(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_disableKeyrepeat(int argc, VALUE *argv, VALUE self) {
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    disableKeyrepeat();
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGText_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGText_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGText);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGText(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGFont *arg5 = 0 ;
    AGText *result;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGFont, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGText";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGText *)new SwigDirector_AGText(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5);
            
        } else {
            result = (AGText *)new AGText(arg2,(AGRect const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGText\n");
    }
    return self;
}


static VALUE
_wrap_AGText_setDeriveRect(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 1);
    (arg1)->setDeriveRect();
    
    return Qnil;
}


static VALUE
_wrap_AGText_draw(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGText_setText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGText_getText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 1);
    result = ((AGText const *)arg1)->getText();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGText(AGText *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGText, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGText(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGText *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGText &_result_ref = toAGText(*arg1);
        result = (AGText *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
    return vresult;
}


static VALUE
_wrap_new_AGVTiler__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    bool arg4 ;
    AGVTiler *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = RTEST(argv[2]);
    {
        char *classname = "Libantargis::AGVTiler";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGVTiler *)new SwigDirector_AGVTiler(arg1,arg2,(AGRect const &)*arg3,arg4);
            
        } else {
            result = (AGVTiler *)new AGVTiler(arg2,(AGRect const &)*arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGVTiler\n");
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVTiler_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVTiler_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVTiler);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVTiler__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGVTiler *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGVTiler";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGVTiler *)new SwigDirector_AGVTiler(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGVTiler *)new AGVTiler(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGVTiler\n");
    }
    return self;
}


static VALUE _wrap_new_AGVTiler(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVTiler__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (argv[3] == Qtrue || argv[3] == Qfalse) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGVTiler__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVTiler'");
    return Qnil;
}


static VALUE
_wrap_AGVTiler_addChild(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVTiler_rePosition(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->rePosition();
    
    return Qnil;
}


static VALUE
_wrap_AGVTiler_adaptHeightFromChildren(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    (arg1)->adaptHeightFromChildren();
    
    return Qnil;
}


static VALUE
_wrap_AGVTiler_adaptWidthFromChildren(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    (arg1)->adaptWidthFromChildren();
    
    return Qnil;
}


static void
free_AGVTiler(AGVTiler *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGVTiler(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_new_AGHTiler__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    bool arg4 ;
    AGHTiler *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = RTEST(argv[2]);
    {
        char *classname = "Libantargis::AGHTiler";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGHTiler *)new SwigDirector_AGHTiler(arg1,arg2,(AGRect const &)*arg3,arg4);
            
        } else {
            result = (AGHTiler *)new AGHTiler(arg2,(AGRect const &)*arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGHTiler\n");
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGHTiler_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGHTiler_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGHTiler);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGHTiler__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGHTiler *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGHTiler";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGHTiler *)new SwigDirector_AGHTiler(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGHTiler *)new AGHTiler(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGHTiler\n");
    }
    return self;
}


static VALUE _wrap_new_AGHTiler(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGHTiler__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (argv[3] == Qtrue || argv[3] == Qfalse) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGHTiler__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGHTiler'");
    return Qnil;
}


static VALUE
_wrap_AGHTiler_rePosition(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->rePosition();
    
    return Qnil;
}


static VALUE
_wrap_AGHTiler_adaptHeightFromChildren(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    (arg1)->adaptHeightFromChildren();
    
    return Qnil;
}


static VALUE
_wrap_AGHTiler_adaptWidthFromChildren(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    (arg1)->adaptWidthFromChildren();
    
    return Qnil;
}


static VALUE
_wrap_AGHTiler_adaptWidthFromParent(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    (arg1)->adaptWidthFromParent();
    
    return Qnil;
}


static void
free_AGHTiler(AGHTiler *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGHTiler(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTheme_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTheme_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTheme);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTheme(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGTheme *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGTheme";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTheme *)new SwigDirector_AGTheme(arg1);
        
    } else {
        result = (AGTheme *)new AGTheme();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGTheme(AGTheme *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGTheme_getFont(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGFont result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getFont((std::string const &)*arg2);
    
    {
        AGFont * resultptr;
        resultptr = new AGFont((AGFont &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGFont, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_getColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGColor result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getColor((std::string const &)*arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setFont(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGFont arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGFont * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGFont, 1);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setFont((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_setColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGColor arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGColor * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGColor, 1);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setColor((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getInt(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)(arg1)->getInt((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTheme_setInt(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = NUM2INT(argv[1]);
    (arg1)->setInt((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getSurface((std::string const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGSurface, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setSurface((std::string const &)*arg2,(AGSurface const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_hasSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)((AGTheme const *)arg1)->hasSurface((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTheme_hasColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)((AGTheme const *)arg1)->hasColor((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTheme *)getTheme();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTheme,0);
    return vresult;
}


static VALUE
_wrap_setTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTheme, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    setTheme((AGTheme const &)*arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadTheme(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    loadTheme((std::string const &)*arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadThemeFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    bool result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)loadThemeFile((std::string const &)*arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_addPoint(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = addPoint((std::string const &)*arg1);
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMenuEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMenuEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMenuEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMenuEvent(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    std::string *arg3 = 0 ;
    AGMenuEvent *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1);
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp3 = std::string(StringValuePtr(argv[1]));
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::AGMenuEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGMenuEvent *)new SwigDirector_AGMenuEvent(arg1,arg2,(std::string const &)*arg3);
        
    } else {
        result = (AGMenuEvent *)new AGMenuEvent(arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGMenuEvent_getName(int argc, VALUE *argv, VALUE self) {
    AGMenuEvent *arg1 = (AGMenuEvent *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuEvent, 1);
    result = ((AGMenuEvent const *)arg1)->getName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGMenuEvent(AGMenuEvent *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGMenuEvent(int argc, VALUE *argv, VALUE self) {
    AGMenuEvent *arg1 = (AGMenuEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMenuEvent, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMenu_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMenu_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMenu);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMenu(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGPoint arg3 ;
    std::string *arg4 = 0 ;
    AGMenu *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        AGPoint * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGPoint, 1);
        if (ptr) arg3 = *ptr;
    }
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGMenu";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGMenu *)new SwigDirector_AGMenu(arg1,arg2,arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGMenu *)new AGMenu(arg2,arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGMenu\n");
    }
    return self;
}


static VALUE
_wrap_AGMenu_show(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGPoint arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        AGPoint * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGPoint, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->show(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_addItem(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->addItem((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_addMenu(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    AGMenu *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGMenu &_result_ref = (arg1)->addMenu((std::string const &)*arg2);
        result = (AGMenu *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
    }
    return vresult;
}


static VALUE
_wrap_AGMenu_draw(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGRect *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw((AGRect const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_eventItemSelected(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->eventItemSelected((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_eventItemClicked(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->eventItemClicked((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_sigSelected_set(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigSelected = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_sigSelected_get(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    result = (AGSignal *)& ((arg1)->sigSelected);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static void
free_AGMenu(AGMenu *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGMenu(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGScreenWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGScreenWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGScreenWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGScreenWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGScreenWidget *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::AGScreenWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGScreenWidget *)new SwigDirector_AGScreenWidget(arg1);
            
        } else {
            result = (AGScreenWidget *)new AGScreenWidget();
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGScreenWidget\n");
    }
    return self;
}


static void
free_AGScreenWidget(AGScreenWidget *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGScreenWidget_draw(int argc, VALUE *argv, VALUE self) {
    AGScreenWidget *arg1 = (AGScreenWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreenWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGScreenWidget(int argc, VALUE *argv, VALUE self) {
    AGScreenWidget *arg1 = (AGScreenWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreenWidget, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEditLine_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEditLine_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEditLine);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEditLine(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    AGFont arg3 ;
    bool arg4 ;
    AGEditLine *result;
    std::string temp2 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGFont * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGFont, 1);
        if (ptr) arg3 = *ptr;
    }
    arg4 = RTEST(argv[2]);
    char *classname = "Libantargis::AGEditLine";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEditLine *)new SwigDirector_AGEditLine(arg1,(std::string const &)*arg2,arg3,arg4);
        
    } else {
        result = (AGEditLine *)new AGEditLine((std::string const &)*arg2,arg3,arg4);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGEditLine(AGEditLine *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGEditLine_setAlign(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = (AGAlign) NUM2INT(argv[0]);
    (arg1)->setAlign((AGAlign )arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_setVAlign(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGVAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = (AGVAlign) NUM2INT(argv[0]);
    (arg1)->setVAlign((AGVAlign )arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_draw(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGPainter *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2,(AGPoint const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_drawCursor(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGPainter *arg2 = 0 ;
    int arg3 ;
    AGPoint *arg4 = 0 ;
    AGRect *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGPoint, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGRect, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawCursor(*arg2,arg3,(AGPoint const &)*arg4,(AGRect const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_height(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = (int)((AGEditLine const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_width(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = (int)((AGEditLine const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_insert(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    char arg2 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2CHR(argv[0]);
    arg3 = NUM2INT(argv[1]);
    (arg1)->insert(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_doDelete(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->doDelete(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_split(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    SwigValueWrapper<AGEditLine > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2INT(argv[0]);
    result = (arg1)->split(arg2);
    
    {
        AGEditLine * resultptr;
        resultptr = new AGEditLine((AGEditLine &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGEditLine, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_length(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = (int)((AGEditLine const *)arg1)->length();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_append(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->append(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_prepend(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->prepend(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_getText(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = ((AGEditLine const *)arg1)->getText();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_getFont(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGFont result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = ((AGEditLine const *)arg1)->getFont();
    
    {
        AGFont * resultptr;
        resultptr = new AGFont((AGFont &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGFont, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_setText(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_hardEnd(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = (bool)((AGEditLine const *)arg1)->hardEnd();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEditLine_setHardEnd(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setHardEnd(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_checkUnwrap(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    std::string arg3 ;
    std::pair<std::string,bool > result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2INT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg3 = std::string(StringValuePtr(argv[1]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->checkUnwrap(arg2,arg3);
    
    {
        std::pair<std::string,bool > * resultptr;
        resultptr = new std::pair<std::string,bool >((std::pair<std::string,bool > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTstd__string_bool_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_checkWrap(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    std::pair<std::string,bool > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2INT(argv[0]);
    result = (arg1)->checkWrap(arg2);
    
    {
        std::pair<std::string,bool > * resultptr;
        resultptr = new std::pair<std::string,bool >((std::pair<std::string,bool > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTstd__string_bool_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_setFont(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGEditLine(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEdit_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEdit_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEdit);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEdit(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGEdit *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGEdit";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGEdit *)new SwigDirector_AGEdit(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGEdit *)new AGEdit(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGEdit\n");
    }
    return self;
}


static VALUE
_wrap_AGEdit_draw(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_drawBackground(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawBackground(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_eventKeyUp(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_setMulti(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setMulti(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_insert(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    char arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = NUM2CHR(argv[0]);
    (arg1)->insert(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_doDelete(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->doDelete(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setText(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setFont(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_clear(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setMutable(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setMutable(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setAlign(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = (AGAlign) NUM2INT(argv[0]);
    (arg1)->setAlign((AGAlign )arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setVAlign(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGVAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = (AGVAlign) NUM2INT(argv[0]);
    (arg1)->setVAlign((AGVAlign )arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setBackground__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setBackground(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setBackground__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGBackground *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBackground, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setBackground((AGBackground const &)*arg2);
    
    return Qnil;
}


static VALUE _wrap_AGEdit_setBackground(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGEdit, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGBackground, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGEdit_setBackground__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGEdit, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGEdit_setBackground__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGEdit_setBackground'");
    return Qnil;
}


static VALUE
_wrap_AGEdit_setTheme(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setTheme((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_canFocus(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGEdit const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_getText(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    result = ((AGEdit const *)arg1)->getText();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static void
free_AGEdit(AGEdit *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGEdit(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGEdit(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGEdit *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGEdit &_result_ref = toAGEdit(*arg1);
        result = (AGEdit *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCheckBox_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCheckBox_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCheckBox);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCheckBox(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect arg3 ;
    AGCheckBox *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        AGRect * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect, 1);
        if (ptr) arg3 = *ptr;
    }
    {
        char *classname = "Libantargis::AGCheckBox";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGCheckBox *)new SwigDirector_AGCheckBox(arg1,arg2,arg3);
            
        } else {
            result = (AGCheckBox *)new AGCheckBox(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGCheckBox\n");
    }
    return self;
}


static VALUE
_wrap_AGCheckBox_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGCheckBox *arg1 = (AGCheckBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCheckBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGCheckBox(AGCheckBox *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGCheckBox(int argc, VALUE *argv, VALUE self) {
    AGCheckBox *arg1 = (AGCheckBox *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCheckBox, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRadioGroup_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRadioGroup_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRadioGroup);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRadioGroup(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGRadioGroup *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGRadioGroup";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGRadioGroup *)new SwigDirector_AGRadioGroup(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGRadioGroup *)new AGRadioGroup(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGRadioGroup\n");
    }
    return self;
}


static void
free_AGRadioGroup(AGRadioGroup *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGRadioGroup_eventChange(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventChange((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_add(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGRadio *arg2 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadio, 1);
    (arg1)->add(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_erase(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGRadio *arg2 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadio, 1);
    (arg1)->erase(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_sigChanged_set(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigChanged = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_sigChanged_get(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    result = (AGSignal *)& ((arg1)->sigChanged);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_disown_AGRadioGroup(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRadio_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRadio_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRadio);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRadio(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect arg3 ;
    AGRadio *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        AGRect * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect, 1);
        if (ptr) arg3 = *ptr;
    }
    {
        char *classname = "Libantargis::AGRadio";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGRadio *)new SwigDirector_AGRadio(arg1,arg2,arg3);
            
        } else {
            result = (AGRadio *)new AGRadio(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGRadio\n");
    }
    return self;
}


static void
free_AGRadio(AGRadio *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGRadio_setGroup(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    AGRadioGroup *arg2 = (AGRadioGroup *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadioGroup, 1);
    (arg1)->setGroup(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadio_deselect(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 1);
    (arg1)->deselect();
    
    return Qnil;
}


static VALUE
_wrap_AGRadio_setChecked(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    bool arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 1);
    arg2 = RTEST(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setChecked(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGRadio(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRadio, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTable_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTable(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGTable *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGTable";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGTable *)new SwigDirector_AGTable(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGTable *)new AGTable(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGTable\n");
    }
    return self;
}


static void
free_AGTable(AGTable *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGTable_addFixedColumn(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addFixedColumn(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addFixedRow(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addFixedRow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addColumn(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addColumn(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addRow(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addRow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addChild(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    int arg3 ;
    AGWidget *arg4 = (AGWidget *) 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGWidget, 1);
    (arg1)->addChild(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    int arg3 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = ((AGTable const *)arg1)->getClientRect(arg2,arg3);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTable_arrange(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    (arg1)->arrange();
    
    return Qnil;
}


static VALUE
_wrap_AGTable_setWidth(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_setHeight(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGTable(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_new_AGWindow__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGWindow *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect const &)*arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGWindow\n");
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGWindow_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGWindow_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGWindow);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGWindow__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGWindow *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGWindow\n");
    }
    return self;
}


static VALUE _wrap_new_AGWindow(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGWindow__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGWindow__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGWindow'");
    return Qnil;
}


static VALUE
_wrap_AGWindow_addChild(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_getClient(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    result = (AGWidget *)(arg1)->getClient();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_AGWindow_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_eventDragBy(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    AGPoint *arg3 = 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventDragBy((AGEvent const *)arg2,(AGPoint const &)*arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_close(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    (arg1)->close();
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_tryClose(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->tryClose((std::string const &)*arg2,(AGEvent const *)arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGWindow const *)arg1)->getClientRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWindow_sigClose_set(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigClose = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_sigClose_get(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    result = (AGSignal *)& ((arg1)->sigClose);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static void
free_AGWindow(AGWindow *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGWindow(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGWindow(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGWindow *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGWindow &_result_ref = toAGWindow(*arg1);
        result = (AGWindow *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
    return vresult;
}


static VALUE
_wrap_new_AGImage__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGPoint *arg3 = 0 ;
    AGSurface arg4 ;
    bool arg5 ;
    AGRect *arg6 = 0 ;
    AGImage *result;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg4 = *ptr;
    }
    arg5 = RTEST(argv[3]);
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGRect, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGImage";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGImage *)new SwigDirector_AGImage(arg1,arg2,(AGPoint const &)*arg3,arg4,arg5,(AGRect const &)*arg6);
            
        } else {
            result = (AGImage *)new AGImage(arg2,(AGPoint const &)*arg3,arg4,arg5,(AGRect const &)*arg6);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGImage\n");
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGImage_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGImage_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGImage);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGImage__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGPoint *arg3 = 0 ;
    AGSurface arg4 ;
    bool arg5 ;
    AGImage *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg4 = *ptr;
    }
    arg5 = RTEST(argv[3]);
    {
        char *classname = "Libantargis::AGImage";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGImage *)new SwigDirector_AGImage(arg1,arg2,(AGPoint const &)*arg3,arg4,arg5);
            
        } else {
            result = (AGImage *)new AGImage(arg2,(AGPoint const &)*arg3,arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGImage\n");
    }
    return self;
}


static VALUE _wrap_new_AGImage(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[7];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 6); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGPoint, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGImage__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    if (argc == 6) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGPoint, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            {
                                void *ptr;
                                _v = (NIL_P(argv[5]) || (TYPE(argv[5]) == T_DATA && SWIG_ConvertPtr(argv[5], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                            }
                            if (_v) {
                                return _wrap_new_AGImage__SWIG_0(nargs, args, self);
                            }
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGImage'");
    return Qnil;
}


static void
free_AGImage(AGImage *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGImage_draw(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGImage_setSurface(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGSurface arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 1);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSurface(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGImage(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGImage, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCaption_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCaption_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCaption);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCaption(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGFont *arg5 = 0 ;
    AGBackground *arg6 = 0 ;
    AGCaption *result;
    std::string temp4 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGFont, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGBackground, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGCaption";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGCaption *)new SwigDirector_AGCaption(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5,(AGBackground const &)*arg6);
            
        } else {
            result = (AGCaption *)new AGCaption(arg2,(AGRect const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5,(AGBackground const &)*arg6);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGCaption\n");
    }
    return self;
}


static VALUE
_wrap_AGCaption_draw(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCaption, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGCaption_setBackground(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    AGBackground arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCaption, 1);
    {
        AGBackground * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGBackground, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setBackground(arg2);
    
    return Qnil;
}


static void
free_AGCaption(AGCaption *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGCaption(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCaption, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_new_AGBackground__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    AGBackground *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGBackground *)new AGBackground(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGBackground__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBackground *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGBackground *)new AGBackground();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBackground_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBackground_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBackground);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBackground__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = 0 ;
    AGBackground *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColor, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGBackground *)new AGBackground((AGColor const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGBackground(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGBackground__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBackground__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBackground__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGBackground'");
    return Qnil;
}


static VALUE
_wrap_AGBackground_draw(int argc, VALUE *argv, VALUE self) {
    AGBackground *arg1 = (AGBackground *) 0 ;
    AGPainter *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBackground, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static void
free_AGBackground(AGBackground *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLayout_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLayout_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLayout);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLayout(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGLayout *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp3 = std::string(StringValuePtr(argv[1]));
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGLayout";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGLayout *)new SwigDirector_AGLayout(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGLayout *)new AGLayout(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGLayout\n");
    }
    return self;
}


static VALUE
_wrap_AGLayout_addTabIndex(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    int arg2 ;
    AGWidget *arg3 = (AGWidget *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayout, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGWidget, 1);
    (arg1)->addTabIndex(arg2,arg3);
    
    return Qnil;
}


static void
free_AGLayout(AGLayout *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGLayout(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGLayout, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_parseNode(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AGWidget *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGWidget *)parseNode(arg1,(Node const &)*arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    return vresult;
}


static VALUE
_wrap_parseChildren(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    parseChildren(arg1,(Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_getLayoutGeometry(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = getLayoutGeometry(arg1,(Node const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLayoutCreator_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLayoutCreator_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLayoutCreator);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLayoutCreator(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    AGLayoutCreator *result;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::AGLayoutCreator";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGLayoutCreator *)new SwigDirector_AGLayoutCreator(arg1,(std::string const &)*arg2);
        
    } else {
        result = (AGLayoutCreator *)new AGLayoutCreator((std::string const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGLayoutCreator(AGLayoutCreator *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGLayoutCreator_create(int argc, VALUE *argv, VALUE self) {
    AGLayoutCreator *arg1 = (AGLayoutCreator *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    xmlpp::Node *arg4 = 0 ;
    AGWidget *result;
    Swig::Director *director = 0;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutCreator, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_Node, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (AGWidget *)(arg1)->create(arg2,(AGRect const &)*arg3,(Node const &)*arg4);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_disown_AGLayoutCreator(int argc, VALUE *argv, VALUE self) {
    AGLayoutCreator *arg1 = (AGLayoutCreator *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGLayoutCreator, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static void
free_AGLayoutFactory(AGLayoutFactory *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGLayoutFactory_addCreator(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *arg1 = (AGLayoutFactory *) 0 ;
    std::string *arg2 = 0 ;
    AGLayoutCreator *arg3 = (AGLayoutCreator *) 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutFactory, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGLayoutCreator, 1);
    (arg1)->addCreator((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGLayoutFactory_create(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *arg1 = (AGLayoutFactory *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    xmlpp::Node *arg4 = 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutFactory, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_Node, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGWidget *)(arg1)->create(arg2,(AGRect const &)*arg3,(Node const &)*arg4);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_getLayoutFactory(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLayoutFactory *)getLayoutFactory();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayoutFactory,0);
    return vresult;
}


static VALUE
_wrap_new_Node__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Node *)new Node();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_Node__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Node *)new Node(arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Node_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Node_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Node);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Node__SWIG_2(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = 0 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Node, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (Node *)new Node((Node const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_Node(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Node__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Node'");
    return Qnil;
}


static void
free_Node(Node *arg1) {
    delete arg1;
}
static VALUE
_wrap_Node_setName(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_get_children__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::NodeVector result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->get_children();
    
    {
        Node::NodeVector * resultptr;
        resultptr = new Node::NodeVector((Node::NodeVector &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_get_children__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    Node::NodeVector result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->get_children(arg2);
    
    {
        Node::NodeVector * resultptr;
        resultptr = new Node::NodeVector((Node::NodeVector &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_get_children(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_get_children__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_get_children__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_get_children'");
    return Qnil;
}


static VALUE
_wrap_Node_getName(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->getName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_Node_get_name(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->get_name();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_Node_setAttributes(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::Attributes *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setAttributes((std::map<std::string,std::string > const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_newChild(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        Node &_result_ref = (arg1)->newChild(arg2);
        result = (Node *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Node_add_child(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Node *)(arg1)->add_child(arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Node_remove_child(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->remove_child(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_begin__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = (arg1)->begin();
    
    {
        Node::iterator * resultptr;
        resultptr = new Node::iterator((Node::iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__iterator, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_begin__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::const_iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->begin();
    
    {
        Node::const_iterator * resultptr;
        resultptr = new Node::const_iterator((Node::const_iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__const_iterator, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_begin(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_begin__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_begin__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_begin'");
    return Qnil;
}


static VALUE
_wrap_Node_end__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = (arg1)->end();
    
    {
        Node::iterator * resultptr;
        resultptr = new Node::iterator((Node::iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__iterator, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_end__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::const_iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->end();
    
    {
        Node::const_iterator * resultptr;
        resultptr = new Node::const_iterator((Node::const_iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__const_iterator, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_end(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_end__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_end__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_end'");
    return Qnil;
}


static VALUE
_wrap_Node_setContent(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setContent((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_getContent__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->getContent();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_Node_set(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp3 = std::string(StringValuePtr(argv[1]));
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->set((std::string const &)*arg2,(std::string const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_get(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->get((std::string const &)*arg2);
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_Node_clear(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_Node_escape(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->escape((std::string const &)*arg2);
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_Node_unescape(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->unescape((std::string const &)*arg2);
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_Node_getStart__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    bool arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = RTEST(argv[1]);
    ((Node const *)arg1)->getStart(*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_getStart__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((Node const *)arg1)->getStart(*arg2);
    
    return Qnil;
}


static VALUE _wrap_Node_getStart(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_getStart__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Node_getStart__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getStart'");
    return Qnil;
}


static VALUE
_wrap_Node_getEnd(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((Node const *)arg1)->getEnd(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_indent(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    ((Node const *)arg1)->indent(*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_getContent__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    ((Node const *)arg1)->getContent(*arg2,arg3);
    
    return Qnil;
}


static VALUE _wrap_Node_getContent(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_getContent__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Node_getContent__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getContent'");
    return Qnil;
}


static VALUE
_wrap_Node_toString__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool arg2 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    arg2 = RTEST(argv[0]);
    result = ((Node const *)arg1)->toString(arg2);
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_Node_toString__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE _wrap_Node_toString(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_toString__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_toString__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_toString'");
    return Qnil;
}


static VALUE
_wrap_Node_isTextNode(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = (bool)((Node const *)arg1)->isTextNode();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Node_getText(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->getText();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_Node_hasTextNode(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = (bool)((Node const *)arg1)->hasTextNode();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Node_size(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_new_Document__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Document *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Document *)new Document();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Document_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Document_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Document);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Document__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    Document *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Document *)new Document(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_Document(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Document__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Document__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Document'");
    return Qnil;
}


static void
free_Document(Document *arg1) {
    delete arg1;
}
static VALUE
_wrap_Document_parseFile(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)(arg1)->parseFile(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Document_root(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    {
        Node &_result_ref = (arg1)->root();
        result = (Node *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Document_get_root_node(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    result = (Node *)(arg1)->get_root_node();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Document_toString(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    result = ((Document const *)arg1)->toString();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_Document_parse_memory(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parse_memory((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Document_parseMemory(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parseMemory((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Document_get_document(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    Document *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    result = (Document *)(arg1)->get_document();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


static void
free_Parser(Parser *arg1) {
    delete arg1;
}
static VALUE
_wrap_Parser_parse(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parse((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_getLine(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    result = ((Parser const *)arg1)->getLine();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Parser_simpleTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->simpleTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Parser_startTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->startTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Parser_endTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endTag((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_text(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->text((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_comment(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->comment((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_header(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->header((std::string const &)*arg2);
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Parser_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Parser_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Parser);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Parser(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Parser *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::Parser";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (Parser *)new SwigDirector_Parser(arg1);
        
    } else {
        result = (Parser *)new Parser();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_disown_Parser(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_DomParser_simpleTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->simpleTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_startTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->startTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_endTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endTag((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_text(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->text((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_comment(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->comment((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_header(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->header((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_parse__SWIG_0(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Document *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Document *)(arg1)->parse((std::string const &)*arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


static VALUE
_wrap_DomParser_parse__SWIG_1(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Document *arg3 = (Document *) 0 ;
    Document *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Document, 1);
    result = (Document *)(arg1)->parse((std::string const &)*arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


static VALUE _wrap_DomParser_parse(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_DomParser, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_DomParser_parse__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_DomParser, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_Document, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_DomParser_parse__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'DomParser_parse'");
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_DomParser_allocate(VALUE self) {
#else
    static VALUE
    _wrap_DomParser_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_DomParser);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_DomParser(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    DomParser *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::DomParser";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (DomParser *)new SwigDirector_DomParser(arg1);
        
    } else {
        result = (DomParser *)new DomParser();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_DomParser(DomParser *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_DomParser(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSound_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSound_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSound);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSound(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSound *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGSound";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSound *)new SwigDirector_AGSound(arg1);
        
    } else {
        result = (AGSound *)new AGSound();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGSound(AGSound *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGSound_playMp3(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)(arg1)->playMp3((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSound_stopMp3(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    (arg1)->stopMp3();
    
    return Qnil;
}


static VALUE
_wrap_AGSound_checkFinished(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    (arg1)->checkFinished();
    
    return Qnil;
}


static VALUE
_wrap_AGSound_sigMp3Finished_set(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMp3Finished = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGSound_sigMp3Finished_get(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    result = (AGSignal *)& ((arg1)->sigMp3Finished);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_getSoundManager(int argc, VALUE *argv, VALUE self) {
    AGSound *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGSound *)getSoundManager();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
    }
    return vresult;
}


static VALUE
_wrap_disown_AGSound(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGGLWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGGLWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGGLWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGGLWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGGLWidget *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargis::AGGLWidget";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGGLWidget *)new SwigDirector_AGGLWidget(arg1,arg2,(AGRect const &)*arg3);
        
    } else {
        result = (AGGLWidget *)new AGGLWidget(arg2,(AGRect const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGGLWidget_drawGL(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGL();
    
    return Qnil;
}


static VALUE
_wrap_AGGLWidget_drawAll(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAll(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGGLWidget_getRatio(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    result = (float)((AGGLWidget const *)arg1)->getRatio();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGGLWidget_setPerspective(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->setPerspective(arg2,arg3,arg4);
    
    return Qnil;
}


static void
free_AGGLWidget(AGGLWidget *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGGLWidget(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGColorButton_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGColorButton_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGColorButton);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGColorButton(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    int arg4 ;
    int arg5 ;
    AGColorButton *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = NUM2INT(argv[2]);
    arg5 = NUM2INT(argv[3]);
    char *classname = "Libantargis::AGColorButton";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGColorButton *)new SwigDirector_AGColorButton(arg1,arg2,(AGRect const &)*arg3,arg4,arg5);
        
    } else {
        result = (AGColorButton *)new AGColorButton(arg2,(AGRect const &)*arg3,arg4,arg5);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGColorButton_draw(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColorButton_getColor(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    result = ((AGColorButton const *)arg1)->getColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColorButton_setColor__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColorButton_setColor__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGColorButton_setColor(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColorButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGColorButton_setColor__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColorButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGColorButton_setColor__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGColorButton_setColor'");
    return Qnil;
}


static VALUE
_wrap_AGColorButton_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGColorButton(AGColorButton *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGColorButton(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGColorButton(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGColorButton *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGColorButton &_result_ref = toAGColorButton(*arg1);
        result = (AGColorButton *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGDialog_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGDialog_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGDialog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGDialog(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGDialog *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp3 = std::string(StringValuePtr(argv[1]));
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargis::AGDialog";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGDialog *)new SwigDirector_AGDialog(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGDialog *)new AGDialog(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGDialog\n");
    }
    return self;
}


static VALUE
_wrap_AGDialog_eventOk(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventOk((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGDialog_eventCancel(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventCancel((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGDialog_eventClose(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventClose((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGDialog(AGDialog *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGDialog(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGDialog, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_initFS(int argc, VALUE *argv, VALUE self) {
    char *arg1 = (char *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = StringValuePtr(argv[0]);
    initFS((char const *)arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = loadFile((std::string const &)*arg1);
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_saveFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[1]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    saveFile((std::string const &)*arg1,(std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_fileExists(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    bool result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)fileExists((std::string const &)*arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_getDirectory(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::vector<std::string > result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp1 = std::string(StringValuePtr(argv[0]));
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = getDirectory((std::string const &)*arg1);
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++)
        rb_ary_store(vresult,i,SWIG_STR2RB(((std::vector<std::string > &)result)[i]));
    }
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListBoxItem_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListBoxItem_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListBoxItem);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListBoxItem(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    std::string arg2 ;
    AGListBoxItem *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg1 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[1]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGListBoxItem *)new AGListBoxItem(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGListBoxItem_id_set(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->id = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBoxItem_id_get(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 1);
    result = (std::string *)& ((arg1)->id);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_AGListBoxItem_value_set(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->value = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBoxItem_value_get(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 1);
    result = (std::string *)& ((arg1)->value);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static void
free_AGListBoxItem(AGListBoxItem *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListBox_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListBox_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListBox);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListBox(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGListBox *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AGListBox";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGListBox *)new SwigDirector_AGListBox(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGListBox *)new AGListBox(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        printf("register:AGListBox\n");
    }
    return self;
}


static VALUE
_wrap_AGListBox_insertItem(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string arg2 ;
    std::string arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            arg3 = std::string(StringValuePtr(argv[1]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->insertItem(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_selectItem(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            arg2 = std::string(StringValuePtr(argv[0]));
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->selectItem(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_getSelectedID(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    result = ((AGListBox const *)arg1)->getSelectedID();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGListBox_getSelectedValue(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    result = ((AGListBox const *)arg1)->getSelectedValue();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AGListBox_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGListBox_sigSelect_set(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigSelect = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_sigSelect_get(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    result = (AGSignal *)& ((arg1)->sigSelect);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGListBox_sigDoubleClick_set(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigDoubleClick = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_sigDoubleClick_get(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    result = (AGSignal *)& ((arg1)->sigDoubleClick);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGListBox_draw(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGListBox_clearList(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    (arg1)->clearList();
    
    return Qnil;
}


static void
free_AGListBox(AGListBox *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGListBox(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGListBox(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGListBox *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGListBox &_result_ref = toAGListBox(*arg1);
        result = (AGListBox *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
    return vresult;
}


static VALUE
_wrap_new_AGPainter__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGPainter *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargis::AGPainter";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGPainter *)new SwigDirector_AGPainter(arg1);
        
    } else {
        result = (AGPainter *)new AGPainter();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGPainter__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGPainter *arg2 = 0 ;
    AGPainter *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargis::AGPainter";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGPainter *)new SwigDirector_AGPainter(arg1,(AGPainter const &)*arg2);
        
    } else {
        result = (AGPainter *)new AGPainter((AGPainter const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPainter_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPainter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPainter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPainter__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGPaintTarget *arg2 = 0 ;
    AGPainter *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPaintTarget, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargis::AGPainter";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGPainter *)new SwigDirector_AGPainter(arg1,*arg2);
        
    } else {
        result = (AGPainter *)new AGPainter(*arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGPainter(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGPainter__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGPainter__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGPainter__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGPainter'");
    return Qnil;
}


static void
free_AGPainter(AGPainter *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGPainter_putPixel(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel((AGPoint const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_getPixel(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_drawCircle(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    float arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = (float) NUM2DBL(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawCircle((AGPoint const &)*arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blitTri(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGTriangle2 *arg3 = 0 ;
    AGTriangle2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGTriangle2, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGTriangle2, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blitTri((AGTexture const &)*arg2,(AGTriangle2 const &)*arg3,(AGTriangle2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_6(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPainter_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_blit__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_blit__SWIG_5(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_3(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_6(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGPainter_blit__SWIG_4(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPainter_blit'");
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGSurface const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGSurface const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGSurface const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPainter_tile(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGPainter_tile__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGPainter_tile__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_tile__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_tile__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_tile__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_tile__SWIG_5(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPainter_tile'");
    return Qnil;
}


static VALUE
_wrap_AGPainter_transform(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->transform((AGRect const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_setNull(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setNull((AGPoint const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_renderText(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    std::string *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGFont *arg4 = 0 ;
    std::string temp2 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGFont, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->renderText((std::string const &)*arg2,(AGPoint const &)*arg3,(AGFont const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_getRect(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    result = ((AGPainter const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradient((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawBorder((AGRect const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawRect(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawRect((AGRect const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawLine(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawLine((AGPoint const &)*arg2,(AGPoint const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGPainter(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_new_AGNodeList__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<Node > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<Node > *)new std::vector<Node >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGNodeList__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<Node > *)new std::vector<Node >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGNodeList__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    Node *arg2 = 0 ;
    std::vector<Node > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<Node > *)new std::vector<Node >(arg1,(Node const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGNodeList_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGNodeList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTNode_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGNodeList__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = 0 ;
    std::vector<Node > *result;
    std::vector<Node > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<Node >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
        }
    }
    result = (std::vector<Node > *)new std::vector<Node >((std::vector<Node > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGNodeList(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGNodeList__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGNodeList__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    Node* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_Node,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<Node >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTNode_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGNodeList__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGNodeList__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGNodeList'");
    return Qnil;
}


static VALUE
_wrap_AGNodeList___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    unsigned int result;
    std::vector<Node > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
        }
    }
    result = (unsigned int)((std::vector<Node > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGNodeList_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    bool result;
    std::vector<Node > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
        }
    }
    result = (bool)((std::vector<Node > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGNodeList_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGNodeList_push(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGNodeList_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    Node result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    {
        try {
            result = std_vector_Sl_Node_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        Node * resultptr;
        resultptr = new Node((Node &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGNodeList___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    int arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                Node &_result_ref = std_vector_Sl_Node_Sg____getitem__(arg1,arg2);
                result = (Node *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_AGNodeList___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    int arg2 ;
    Node *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Node, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_Node_Sg____setitem__(arg1,arg2,(Node const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_AGNodeList_each(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    std_vector_Sl_Node_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_Node_Sg_(std::vector<Node > *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGNodePList__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<Node * > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<Node * > *)new std::vector<Node * >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGNodePList__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<Node * > *)new std::vector<Node * >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGNodePList__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    Node **arg2 = 0 ;
    std::vector<Node * > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<Node * > *)new std::vector<Node * >(arg1,*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGNodePList_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGNodePList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTNode_p_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGNodePList__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = 0 ;
    std::vector<Node * > *result;
    std::vector<Node * > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (std::vector<Node * > *)new std::vector<Node * >((std::vector<Node * > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGNodePList(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGNodePList__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGNodePList__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    Node* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_Node,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<Node* >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTNode_p_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGNodePList__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_p_Node, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGNodePList__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGNodePList'");
    return Qnil;
}


static VALUE
_wrap_AGNodePList___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    unsigned int result;
    std::vector<Node * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (unsigned int)((std::vector<Node * > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGNodePList_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    bool result;
    std::vector<Node * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (bool)((std::vector<Node * > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGNodePList_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGNodePList_push(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    Node *arg2 = (Node *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1);
    (arg1)->push_back(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGNodePList_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    {
        try {
            result = (Node *)std_vector_Sl_Node_Sm__Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_AGNodePList___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    int arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            result = (Node *)std_vector_Sl_Node_Sm__Sg____getitem__(arg1,arg2);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_AGNodePList___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    int arg2 ;
    Node *arg3 = (Node *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Node, 1);
    {
        try {
            std_vector_Sl_Node_Sm__Sg____setitem__(arg1,arg2,arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_AGNodePList_each(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    std_vector_Sl_Node_Sm__Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_Node_Sm__Sg_(std::vector<Node * > *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGVector3List__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<AGVector3 > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<AGVector3 > *)new std::vector<AGVector3 >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3List__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<AGVector3 > *)new std::vector<AGVector3 >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3List__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    AGVector3 *arg2 = 0 ;
    std::vector<AGVector3 > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<AGVector3 > *)new std::vector<AGVector3 >(arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector3List_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector3List_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTAGVector3_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector3List__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = 0 ;
    std::vector<AGVector3 > *result;
    std::vector<AGVector3 > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<AGVector3 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                AGVector3* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector3, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
        }
    }
    result = (std::vector<AGVector3 > *)new std::vector<AGVector3 >((std::vector<AGVector3 > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector3List(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector3List__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3List__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    AGVector3* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_AGVector3,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<AGVector3 >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTAGVector3_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGVector3List__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector3List__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector3List'");
    return Qnil;
}


static VALUE
_wrap_AGVector3List___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    unsigned int result;
    std::vector<AGVector3 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGVector3 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGVector3* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector3, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
        }
    }
    result = (unsigned int)((std::vector<AGVector3 > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGVector3List_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    bool result;
    std::vector<AGVector3 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGVector3 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGVector3* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector3, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
        }
    }
    result = (bool)((std::vector<AGVector3 > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3List_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGVector3List_push(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    AGVector3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3List_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    {
        try {
            result = std_vector_Sl_AGVector3_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3List___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    int arg2 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                AGVector3 &_result_ref = std_vector_Sl_AGVector3_Sg____getitem__(arg1,arg2);
                result = (AGVector3 *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3List___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    int arg2 ;
    AGVector3 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector3, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_AGVector3_Sg____setitem__(arg1,arg2,(AGVector3 const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_AGVector3List_each(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    std_vector_Sl_AGVector3_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_AGVector3_Sg_(std::vector<AGVector3 > *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_AGVector4List__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<AGVector4 > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<AGVector4 > *)new std::vector<AGVector4 >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4List__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<AGVector4 > *)new std::vector<AGVector4 >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4List__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    AGVector4 *arg2 = 0 ;
    std::vector<AGVector4 > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<AGVector4 > *)new std::vector<AGVector4 >(arg1,(AGVector4 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector4List_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector4List_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTAGVector4_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector4List__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = 0 ;
    std::vector<AGVector4 > *result;
    std::vector<AGVector4 > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<AGVector4 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                AGVector4* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector4, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
        }
    }
    result = (std::vector<AGVector4 > *)new std::vector<AGVector4 >((std::vector<AGVector4 > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector4List(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector4List__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector4List__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    AGVector4* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_AGVector4,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<AGVector4 >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTAGVector4_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGVector4List__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector4List__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector4List'");
    return Qnil;
}


static VALUE
_wrap_AGVector4List___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    unsigned int result;
    std::vector<AGVector4 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGVector4 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGVector4* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector4, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
        }
    }
    result = (unsigned int)((std::vector<AGVector4 > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGVector4List_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    bool result;
    std::vector<AGVector4 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGVector4 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGVector4* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector4, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
        }
    }
    result = (bool)((std::vector<AGVector4 > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4List_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4List_push(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    AGVector4 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((AGVector4 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4List_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    {
        try {
            result = std_vector_Sl_AGVector4_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4List___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    int arg2 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                AGVector4 &_result_ref = std_vector_Sl_AGVector4_Sg____getitem__(arg1,arg2);
                result = (AGVector4 *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4List___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    int arg2 ;
    AGVector4 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector4, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_AGVector4_Sg____setitem__(arg1,arg2,(AGVector4 const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_AGVector4List_each(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    std_vector_Sl_AGVector4_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_AGVector4_Sg_(std::vector<AGVector4 > *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_HeightMap_allocate(VALUE self) {
#else
    static VALUE
    _wrap_HeightMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_HeightMap);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_HeightMap(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    HeightMap *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    char *classname = "Libantargis::HeightMap";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (HeightMap *)new SwigDirector_HeightMap(arg1,arg2,arg3);
        
    } else {
        result = (HeightMap *)new HeightMap(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_HeightMap(HeightMap *arg1) {
    delete arg1;
}
static VALUE
_wrap_HeightMap_setScene(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    Scene *arg2 = (Scene *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Scene, 1);
    (arg1)->setScene(arg2);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_getScene(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    Scene *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    result = (Scene *)(arg1)->getScene();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
    return vresult;
}


static VALUE
_wrap_HeightMap_getHeight(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    float arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    result = (float)((HeightMap const *)arg1)->getHeight(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getNormal(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    int arg2 ;
    int arg3 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = ((HeightMap const *)arg1)->getNormal(arg2,arg3);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_HeightMap_getVertex(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    int arg2 ;
    int arg3 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = (arg1)->getVertex(arg2,arg3);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_HeightMap_get(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((HeightMap const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getGrass(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((HeightMap const *)arg1)->getGrass(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getW(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    result = ((HeightMap const *)arg1)->getW();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_getH(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    result = ((HeightMap const *)arg1)->getH();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_HeightMap_truncPos(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((HeightMap const *)arg1)->truncPos((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_HeightMap_saveXML(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    ((HeightMap const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_loadXML(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_setHeight(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_set(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_HeightMap_getTerrainMesh(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    TerrainMesh *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    result = (TerrainMesh *)(arg1)->getTerrainMesh();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainMesh,0);
    return vresult;
}


static VALUE
_wrap_HeightMap_mapChanged(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_disown_HeightMap(int argc, VALUE *argv, VALUE self) {
    HeightMap *arg1 = (HeightMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_HeightMap, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntMap_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntMap);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntMap(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    AntMap *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    {
        char *classname = "Libantargis::AntMap";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AntMap *)new SwigDirector_AntMap(arg1,arg2,arg3);
            
        } else {
            result = (AntMap *)new AntMap(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY = self;
        result->mRubyObject=true;
        //	rb_gc_register_address(self);
        //printf("setting mruby:widget\n");
    }
    return self;
}


static void
free_AntMap(AntMap *arg1) {
    delete arg1;
}
static VALUE
_wrap_AntMap_insertEntity(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AntEntity *arg2 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->insertEntity(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_removeEntity(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AntEntity *arg2 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->removeEntity(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_clear(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AntMap_getNewID(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    result = (int)(arg1)->getNewID();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AntMap_getEntities(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AGRect2 *arg2 = 0 ;
    SwigValueWrapper<std::list<AntEntity * > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (arg1)->getEntities((AGRect2 const &)*arg2);
    
    {
        AntMap::EntityList * resultptr;
        resultptr = new AntMap::EntityList((AntMap::EntityList &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTAntEntity_p_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getAllEntities(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    SwigValueWrapper<std::list<AntEntity * > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    result = (arg1)->getAllEntities();
    
    {
        AntMap::EntityList * resultptr;
        resultptr = new AntMap::EntityList((AntMap::EntityList &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTAntEntity_p_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getAllEntitiesV(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    std::vector<AntEntityPtr > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    result = (arg1)->getAllEntitiesV();
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            AntEntityPtr* x = new AntEntityPtr(((std::vector<AntEntityPtr > &)result)[i]);
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_AntEntityPtr, 1));
        }
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getEntity__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    Mesh *arg2 = 0 ;
    AntEntity *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Mesh, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AntEntity *)(arg1)->getEntity((Mesh const &)*arg2);
    
    {
        //	std::cout<<"test2"<<std::endl;
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                //			result->mRubyObject=true;
                //			result->mRUBY=vresult;
                throw int();
            }
        }
        else
        vresult = Qnil;
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getEntity__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    int arg2 ;
    AntEntity *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    arg2 = NUM2INT(argv[0]);
    result = (AntEntity *)((AntMap const *)arg1)->getEntity(arg2);
    
    {
        //	std::cout<<"test2"<<std::endl;
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                //			result->mRubyObject=true;
                //			result->mRUBY=vresult;
                throw int();
            }
        }
        else
        vresult = Qnil;
    }
    return vresult;
}


static VALUE _wrap_AntMap_getEntity(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntMap, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Mesh, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntMap_getEntity__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntMap, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntMap_getEntity__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntMap_getEntity'");
    return Qnil;
}


static VALUE
_wrap_AntMap_getByName(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    std::string *arg2 = 0 ;
    AntEntity *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AntEntity *)(arg1)->getByName((std::string const &)*arg2);
    
    {
        //	std::cout<<"test2"<<std::endl;
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                //			result->mRubyObject=true;
                //			result->mRUBY=vresult;
                throw int();
            }
        }
        else
        vresult = Qnil;
    }
    return vresult;
}


static VALUE
_wrap_AntMap_getNext(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AntEntity *arg2 = (AntEntity *) 0 ;
    std::string *arg3 = 0 ;
    AntEntity *result;
    std::string temp3 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntity, 1);
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp3 = std::string(StringValuePtr(argv[1]));
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AntEntity *)(arg1)->getNext(arg2,(std::string const &)*arg3);
    
    {
        //	std::cout<<"test2"<<std::endl;
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                //			result->mRubyObject=true;
                //			result->mRUBY=vresult;
                throw int();
            }
        }
        else
        vresult = Qnil;
    }
    return vresult;
}


static VALUE
_wrap_AntMap_loadEntity(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AntEntity *result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (AntEntity *)(arg1)->loadEntity((Node const &)*arg2);
    
    {
        //	std::cout<<"test2"<<std::endl;
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                //			result->mRubyObject=true;
                //			result->mRUBY=vresult;
                throw int();
            }
        }
        else
        vresult = Qnil;
    }
    return vresult;
}


static VALUE
_wrap_AntMap_saveXML(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    ((AntMap const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_loadXML(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_saveMap(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->saveMap((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_loadMap(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->loadMap((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_move(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->move(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntMap_getPos(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AntMap const *)arg1)->getPos((AGVector2 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntMap_entsChanged(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->entsChanged();
    
    return Qnil;
}


static VALUE
_wrap_AntMap_mapChanged(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_AntMap_mRUBY_set(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    VALUE arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    arg2 = argv[0];
    if (arg1) (arg1)->mRUBY = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AntMap_mRUBY_get(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    result = (VALUE) ((arg1)->mRUBY);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_AntMap_mRubyObject_set(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    arg2 = RTEST(argv[0]);
    if (arg1) (arg1)->mRubyObject = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AntMap_mRubyObject_get(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    result = (bool) ((arg1)->mRubyObject);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AntMap_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, 1);
    AntMap_markfunc(arg1);
    
    return Qnil;
}


static VALUE
_wrap_disown_AntMap(int argc, VALUE *argv, VALUE self) {
    AntMap *arg1 = (AntMap *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntMap, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getMap(int argc, VALUE *argv, VALUE self) {
    AntMap *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AntMap *)getMap();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_SceneNode_allocate(VALUE self) {
#else
    static VALUE
    _wrap_SceneNode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SceneNode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_SceneNode(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    SceneNode *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::SceneNode";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (SceneNode *)new SwigDirector_SceneNode(arg1);
            
        } else {
            result = (SceneNode *)new SceneNode();
            
        }
        DATA_PTR(self) = result;
        result->mRUBY = self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_SceneNode(SceneNode *arg1) {
    delete arg1;
}
static VALUE
_wrap_SceneNode_drawShadow(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_drawDepth(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_draw(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_advance(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->advance(arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_getTriangles(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((SceneNode const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_SceneNode_lineHit(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((SceneNode const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_SceneNode_sort(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    AGVector4 *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->sort((AGVector4 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_SceneNode_mapChanged(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_SceneNode___eq__(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    SceneNode *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((SceneNode const *)arg1)->operator ==((SceneNode const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_SceneNode(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_MeshVertex_v_set(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector4 *arg2 = (AGVector4 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1);
    if (arg1) (arg1)->v = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_MeshVertex_v_get(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 1);
    result = (AGVector4 *)& ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_MeshVertex_c_set(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector4 *arg2 = (AGVector4 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1);
    if (arg1) (arg1)->c = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_MeshVertex_c_get(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 1);
    result = (AGVector4 *)& ((arg1)->c);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_MeshVertex_n_set(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1);
    if (arg1) (arg1)->n = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_MeshVertex_n_get(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 1);
    result = (AGVector3 *)& ((arg1)->n);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_MeshVertex_t_set(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector2 *arg2 = (AGVector2 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1);
    if (arg1) (arg1)->t = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_MeshVertex_t_get(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    AGVector2 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 1);
    result = (AGVector2 *)& ((arg1)->t);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector2,0);
    return vresult;
}


static VALUE
_wrap_MeshVertex___lt__(int argc, VALUE *argv, VALUE self) {
    MeshVertex *arg1 = (MeshVertex *) 0 ;
    MeshVertex *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshVertex, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_MeshVertex, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((MeshVertex const *)arg1)->operator <((MeshVertex const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_MeshVertex_allocate(VALUE self) {
#else
    static VALUE
    _wrap_MeshVertex_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MeshVertex);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_MeshVertex(int argc, VALUE *argv, VALUE self) {
    MeshVertex *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (MeshVertex *)new MeshVertex();
    DATA_PTR(self) = result;
    return self;
}


static void
free_MeshVertex(MeshVertex *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_MeshOptimizer_allocate(VALUE self) {
#else
    static VALUE
    _wrap_MeshOptimizer_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MeshOptimizer);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_MeshOptimizer(int argc, VALUE *argv, VALUE self) {
    MeshOptimizer *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (MeshOptimizer *)new MeshOptimizer();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_MeshOptimizer_add(int argc, VALUE *argv, VALUE self) {
    MeshOptimizer *arg1 = (MeshOptimizer *) 0 ;
    MeshVertex *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshOptimizer, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_MeshVertex, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->add((MeshVertex const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_MeshOptimizer_getArray(int argc, VALUE *argv, VALUE self) {
    MeshOptimizer *arg1 = (MeshOptimizer *) 0 ;
    VertexArray result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshOptimizer, 1);
    result = (arg1)->getArray();
    
    {
        VertexArray * resultptr;
        resultptr = new VertexArray((VertexArray &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_VertexArray, 1);
    }
    return vresult;
}


static void
free_MeshOptimizer(MeshOptimizer *arg1) {
    delete arg1;
}
static VALUE
_wrap_new_MeshData__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string *arg4 = 0 ;
    bool arg5 ;
    MeshData *result;
    std::string temp2 ;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg5 = RTEST(argv[3]);
    char *classname = "Libantargis::MeshData";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (MeshData *)new SwigDirector_MeshData(arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4,arg5);
        
    } else {
        result = (MeshData *)new MeshData((std::string const &)*arg2,arg3,(std::string const &)*arg4,arg5);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_MeshData__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string *arg4 = 0 ;
    MeshData *result;
    std::string temp2 ;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::MeshData";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (MeshData *)new SwigDirector_MeshData(arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4);
        
    } else {
        result = (MeshData *)new MeshData((std::string const &)*arg2,arg3,(std::string const &)*arg4);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_MeshData__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    MeshData *result;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    char *classname = "Libantargis::MeshData";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (MeshData *)new SwigDirector_MeshData(arg1,(std::string const &)*arg2,arg3);
        
    } else {
        result = (MeshData *)new MeshData((std::string const &)*arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_MeshData__SWIG_3(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    VertexArray *arg2 = 0 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    MeshData *result;
    std::string temp3 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_VertexArray, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp3 = std::string(StringValuePtr(argv[1]));
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg4 = RTEST(argv[2]);
    char *classname = "Libantargis::MeshData";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (MeshData *)new SwigDirector_MeshData(arg1,(VertexArray const &)*arg2,(std::string const &)*arg3,arg4);
        
    } else {
        result = (MeshData *)new MeshData((VertexArray const &)*arg2,(std::string const &)*arg3,arg4);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_MeshData_allocate(VALUE self) {
#else
    static VALUE
    _wrap_MeshData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MeshData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_MeshData__SWIG_4(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    VertexArray *arg2 = 0 ;
    std::string *arg3 = 0 ;
    MeshData *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_VertexArray, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            temp3 = std::string(StringValuePtr(argv[1]));
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargis::MeshData";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (MeshData *)new SwigDirector_MeshData(arg1,(VertexArray const &)*arg2,(std::string const &)*arg3);
        
    } else {
        result = (MeshData *)new MeshData((VertexArray const &)*arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_MeshData(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_VertexArray, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_MeshData__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_MeshData__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_VertexArray, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (argv[3] == Qtrue || argv[3] == Qfalse) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_MeshData__SWIG_3(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_MeshData__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_MeshData__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_MeshData'");
    return Qnil;
}


static void
free_MeshData(MeshData *arg1) {
    delete arg1;
}
static VALUE
_wrap_MeshData_draw(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_MeshData_drawShadow(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_MeshData_drawDepth(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_MeshData_getTriangles(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((MeshData const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_MeshData_lineHit(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_MeshData, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((MeshData const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_disown_MeshData(int argc, VALUE *argv, VALUE self) {
    MeshData *arg1 = (MeshData *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_MeshData, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_new_Mesh__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Mesh *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::Mesh";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (Mesh *)new SwigDirector_Mesh(arg1);
            
        } else {
            result = (Mesh *)new Mesh();
            
        }
        DATA_PTR(self) = result;
        result->mRUBY = self;
        result->mRubyObject=true;
        //	printf("%X\n",self);
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Mesh_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Mesh_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Mesh);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Mesh__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    MeshData *arg2 = 0 ;
    AGVector4 *arg3 = 0 ;
    float arg4 ;
    Mesh *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_MeshData, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector4, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = (float) NUM2DBL(argv[2]);
    {
        char *classname = "Libantargis::Mesh";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (Mesh *)new SwigDirector_Mesh(arg1,*arg2,(AGVector4 const &)*arg3,arg4);
            
        } else {
            result = (Mesh *)new Mesh(*arg2,(AGVector4 const &)*arg3,arg4);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY = self;
        result->mRubyObject=true;
        //	printf("%X\n",self);
    }
    return self;
}


static VALUE _wrap_new_Mesh(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_Mesh__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_MeshData, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FLOAT) || (TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_Mesh__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Mesh'");
    return Qnil;
}


static VALUE
_wrap_Mesh_draw(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_Mesh_drawDepth(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_Mesh_drawShadow(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_Mesh_lineHit(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((Mesh const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_Mesh_getTriangles(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((Mesh const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Mesh_setPos(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    AGVector3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setPos((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Mesh_setRotation(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Mesh, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setRotation(arg2);
    
    return Qnil;
}


static void
free_Mesh(Mesh *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_Mesh(int argc, VALUE *argv, VALUE self) {
    Mesh *arg1 = (Mesh *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Mesh, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toMesh(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    Mesh *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    result = (Mesh *)toMesh(arg1);
    
    {
        //	std::cout<<"test2"<<std::endl;
        if(result)
        {
            if(result->mRubyObject)
            vresult=result->mRUBY;
            else
            {
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
                //			result->mRubyObject=true;
                //			result->mRUBY=vresult;
            }
        }
        else
        vresult = Qnil;
    }
    return vresult;
}


static VALUE
_wrap_PickNode_pos_set(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    AGVector4 *arg2 = (AGVector4 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1);
    if (arg1) (arg1)->pos = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_PickNode_pos_get(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 1);
    result = (AGVector4 *)& ((arg1)->pos);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_PickNode_node_set(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 1);
    if (arg1) (arg1)->node = arg2;
    
    return Qnil;
}


static VALUE
_wrap_PickNode_node_get(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    SceneNode *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 1);
    result = (SceneNode *) ((arg1)->node);
    
    {
        //	std::cout<<"test2"<<std::endl;
        if(result)
        {
            if(result->mRubyObject)
            {
                vresult=result->mRUBY;
                //			std::cout<<"found :"<<vresult<<std::endl;
            }
            else
            {
                if(dynamic_cast<Mesh*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
                else if(dynamic_cast<TerrainMesh*>(result))
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainMesh,0);
                else
                vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SceneNode,0);
                
                
                //		        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
                //result->mRubyObject=true;
                //result->mRUBY=vresult;
                //			std::cout<<"not found - but set:"<<vresult<<std::endl;
            }
        }
        else
        {
            vresult = Qnil;
            std::cout<<"nilled"<<std::endl;
        }
    }
    return vresult;
}


static VALUE
_wrap_PickNode_camDist_set(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->camDist = arg2;
    
    return Qnil;
}


static VALUE
_wrap_PickNode_camDist_get(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 1);
    result = (float) ((arg1)->camDist);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_PickNode___lt__(int argc, VALUE *argv, VALUE self) {
    PickNode *arg1 = (PickNode *) 0 ;
    PickNode *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_PickNode, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_PickNode, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((PickNode const *)arg1)->operator <((PickNode const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_PickNode_allocate(VALUE self) {
#else
    static VALUE
    _wrap_PickNode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_PickNode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_PickNode(int argc, VALUE *argv, VALUE self) {
    PickNode *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (PickNode *)new PickNode();
    DATA_PTR(self) = result;
    return self;
}


static void
free_PickNode(PickNode *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Scene_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Scene_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Scene);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Scene(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    Scene *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    result = (Scene *)new Scene(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_Scene_draw(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_Scene_setShadow(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setShadow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_getShadow(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    result = (int)((Scene const *)arg1)->getShadow();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Scene_addNode(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 1);
    (arg1)->addNode(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_removeNode(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    SceneNode *arg2 = (SceneNode *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SceneNode, 1);
    (arg1)->removeNode(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_clear(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_Scene_setCamera(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGVector4 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    {
        AGVector4 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGVector4, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setCamera(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_advance(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->advance(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Scene_lineHit(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    AGLine3 *arg2 = 0 ;
    Scene::PickResult result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            PickNode* x = new PickNode(((Scene::PickResult &)result)[i]);
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_PickNode, 1));
        }
    }
    return vresult;
}


static VALUE
_wrap_Scene_getLine(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    int arg2 ;
    int arg3 ;
    AGLine3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = (arg1)->getLine(arg2,arg3);
    
    {
        AGLine3 * resultptr;
        resultptr = new AGLine3((AGLine3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGLine3, 1);
    }
    return vresult;
}


static VALUE
_wrap_Scene_mapChanged(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_Scene_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, 1);
    Scene_markfunc(arg1);
    
    return Qnil;
}


static VALUE
_wrap_Scene_mRubyObject_set(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    arg2 = RTEST(argv[0]);
    if (arg1) (arg1)->mRubyObject = arg2;
    
    return Qnil;
}


static VALUE
_wrap_Scene_mRubyObject_get(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    result = (bool) ((arg1)->mRubyObject);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Scene_mRUBY_set(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    VALUE arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    arg2 = argv[0];
    if (arg1) (arg1)->mRUBY = arg2;
    
    return Qnil;
}


static VALUE
_wrap_Scene_mRUBY_get(int argc, VALUE *argv, VALUE self) {
    Scene *arg1 = (Scene *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Scene, 1);
    result = (VALUE) ((arg1)->mRUBY);
    
    vresult = result;
    return vresult;
}


static void
free_Scene(Scene *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_GLApp_allocate(VALUE self) {
#else
    static VALUE
    _wrap_GLApp_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_GLApp);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_GLApp(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    GLApp *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    char *classname = "Libantargis::GLApp";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (GLApp *)new SwigDirector_GLApp(arg1,arg2,arg3);
        
    } else {
        result = (GLApp *)new GLApp(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_GLApp_draw(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_GLApp_drawGL(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    (arg1)->drawGL();
    
    return Qnil;
}


static VALUE
_wrap_GLApp_eventFrame(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrame(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_eventClick(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    Scene::PickResult *arg2 = 0 ;
    int arg3 ;
    std::vector<PickNode > temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp2 = std::vector<PickNode >(size);
            arg2 = &temp2;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                PickNode* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_PickNode, 1);
                temp2[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTPickNode_t, 1);
        }
    }
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventClick((std::vector<PickNode > const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_GLApp_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_GLApp_setupLight(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    (arg1)->setupLight();
    
    return Qnil;
}


static VALUE
_wrap_GLApp_getScene(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    Scene *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    {
        Scene &_result_ref = (arg1)->getScene();
        result = (Scene *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
    return vresult;
}


static VALUE
_wrap_GLApp_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, 1);
    GLApp_markfunc(arg1);
    
    return Qnil;
}


static void
free_GLApp(GLApp *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_GLApp(int argc, VALUE *argv, VALUE self) {
    GLApp *arg1 = (GLApp *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_GLApp, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Resource_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Resource_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Resource);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Resource(int argc, VALUE *argv, VALUE self) {
    Resource *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Resource *)new Resource();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_Resource_get(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::string *arg2 = 0 ;
    float result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (float)(arg1)->get((std::string const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_Resource_add(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->add((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Resource_sub(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->sub((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Resource_set(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = (float) NUM2DBL(argv[1]);
    (arg1)->set((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Resource_getAll(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    std::map<std::string,float > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 1);
    result = ((Resource const *)arg1)->getAll();
    
    {
        vresult = rb_hash_new();
        for (std::map<std::string,float >::iterator i=(&result)->begin(); i!=(&result)->end(); ++i) {
            rb_hash_aset(vresult,
            SWIG_STR2RB(i->first),
            rb_float_new(i->second));
        }
    }
    return vresult;
}


static VALUE
_wrap_Resource_takeAll(int argc, VALUE *argv, VALUE self) {
    Resource *arg1 = (Resource *) 0 ;
    Resource *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Resource, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Resource, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->takeAll(*arg2);
    
    return Qnil;
}


static void
free_Resource(Resource *arg1) {
    delete arg1;
}
static VALUE
_wrap_AntEntity_mDir_set(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->mDir = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_mDir_get(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (float) ((arg1)->mDir);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_resource_set(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Resource *arg2 = (Resource *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Resource, 1);
    if (arg1) (arg1)->resource = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_resource_get(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Resource *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (Resource *)& ((arg1)->resource);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Resource,0);
    return vresult;
}


static VALUE
_wrap_new_AntEntity__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AntEntity *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargis::AntEntity";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AntEntity *)new SwigDirector_AntEntity(arg1);
            
        } else {
            result = (AntEntity *)new AntEntity();
            
        }
        DATA_PTR(self) = result;
        result->mRUBY = self;
        result->mRubyObject=true;
        //printf("setting mruby:widget\n");
    }
    return self;
}


static VALUE
_wrap_new_AntEntity__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGVector3 *arg2 = 0 ;
    AntEntity *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AntEntity";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AntEntity *)new SwigDirector_AntEntity(arg1,(AGVector3 const &)*arg2);
            
        } else {
            result = (AntEntity *)new AntEntity((AGVector3 const &)*arg2);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY = self;
        result->mRubyObject=true;
        //printf("setting mruby:widget\n");
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntEntity_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntEntity_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntEntity);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntEntity__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGVector2 *arg2 = 0 ;
    AntEntity *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::AntEntity";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AntEntity *)new SwigDirector_AntEntity(arg1,(AGVector2 const &)*arg2);
            
        } else {
            result = (AntEntity *)new AntEntity((AGVector2 const &)*arg2);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY = self;
        result->mRubyObject=true;
        //printf("setting mruby:widget\n");
    }
    return self;
}


static VALUE _wrap_new_AntEntity(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AntEntity__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AntEntity__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AntEntity__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AntEntity'");
    return Qnil;
}


static void
free_AntEntity(AntEntity *arg1) {
    delete arg1;
}
static VALUE
_wrap_AntEntity_getPos3D(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = ((AntEntity const *)arg1)->getPos3D();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_getPos2D(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = ((AntEntity const *)arg1)->getPos2D();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_setPos__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGVector2 *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setPos((AGVector2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setPos__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AGVector3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setPos((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE _wrap_AntEntity_setPos(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntEntity_setPos__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AntEntity_setPos__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntEntity_setPos'");
    return Qnil;
}


static VALUE
_wrap_AntEntity_getID(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (int)((AntEntity const *)arg1)->getID();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_getName(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = ((AntEntity const *)arg1)->getName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_setName(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setType(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            temp2 = std::string(StringValuePtr(argv[0]));
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setType((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getType(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = ((AntEntity const *)arg1)->getType();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_xmlName(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    std::string result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AntEntity const *)arg1)->xmlName();
    
    {
        vresult = rb_str_new2((&result)->c_str());
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_saveXML(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    ((AntEntity const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_loadXML(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_newRestJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newRestJob(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_newFetchJob__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AGVector2 *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp4 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newFetchJob(arg2,*arg3,(std::string const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_newFetchJob__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AntEntity *arg3 = (AntEntity *) 0 ;
    std::string *arg4 = 0 ;
    std::string temp4 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AntEntity, 1);
    {
        if (TYPE(argv[2]) == T_STRING) {
            temp4 = std::string(StringValuePtr(argv[2]));
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newFetchJob(arg2,arg3,(std::string const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AntEntity_newFetchJob(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AntEntity_newFetchJob__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AntEntity_newFetchJob__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntEntity_newFetchJob'");
    return Qnil;
}


static VALUE
_wrap_AntEntity_newMoveJob__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AGVector2 *arg3 = 0 ;
    int arg4 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = NUM2INT(argv[2]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newMoveJob(arg2,(AGVector2 const &)*arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_newMoveJob__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AGVector2 *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector2, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newMoveJob(arg2,(AGVector2 const &)*arg3);
    
    return Qnil;
}


static VALUE _wrap_AntEntity_newMoveJob(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AntEntity_newMoveJob__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AntEntity_newMoveJob__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AntEntity_newMoveJob'");
    return Qnil;
}


static VALUE
_wrap_AntEntity_newFightJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    int arg2 ;
    AntEntity *arg3 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->newFightJob(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_delJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->delJob();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_resourceChanged(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->resourceChanged();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_hasJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (bool)((AntEntity const *)arg1)->hasJob();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AntEntity_getRect(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    SwigValueWrapper<AGRect2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = ((AntEntity const *)arg1)->getRect();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_eventNoJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventNoJob();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventJobFinished(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventJobFinished();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventGotNewJob(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventGotNewJob();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventGotFight(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AntEntity *arg2 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventGotFight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setSpeed(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setSpeed(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getSpeed(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (float)((AntEntity const *)arg1)->getSpeed();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_getHealSpeed(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (float)((AntEntity const *)arg1)->getHealSpeed();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_setHealSpeed(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setHealSpeed(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setAggression(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setAggression(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getAggression(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (float)((AntEntity const *)arg1)->getAggression();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_eventDie(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventDie();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventDefeated(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventDefeated();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getEnergy(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (float)((AntEntity const *)arg1)->getEnergy();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_getMorale(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (float)((AntEntity const *)arg1)->getMorale();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AntEntity_setMesh(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Mesh *arg2 = (Mesh *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Mesh, 1);
    (arg1)->setMesh(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_getMesh(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    SwigValueWrapper<std::list<Mesh * > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (arg1)->getMesh();
    
    {
        std::list<Mesh * > * resultptr;
        resultptr = new std::list<Mesh * >((std::list<Mesh * > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTMesh_p_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AntEntity_addMesh(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    Mesh *arg2 = (Mesh *) 0 ;
    AGVector3 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Mesh, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector3, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->addMesh(arg2,(AGVector3 const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_setDirection(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setDirection(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_decEnergy(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->decEnergy(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_decMorale(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->decMorale(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_eventMapChanged(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    (arg1)->eventMapChanged();
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_move(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->move(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_mRubyObject_set(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = RTEST(argv[0]);
    if (arg1) (arg1)->mRubyObject = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_mRubyObject_get(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (bool) ((arg1)->mRubyObject);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AntEntity_mRUBY_set(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    VALUE arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    arg2 = argv[0];
    if (arg1) (arg1)->mRUBY = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AntEntity_mRUBY_get(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (VALUE) ((arg1)->mRUBY);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_AntEntity_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, 1);
    AntEntity_markfunc(arg1);
    
    return Qnil;
}


static VALUE
_wrap_disown_AntEntity(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_new_AntEntityPtr__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AntEntityPtr *arg1 = 0 ;
    AntEntityPtr *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntEntityPtr, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AntEntityPtr *)new AntEntityPtr((AntEntityPtr const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AntEntityPtr__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AntEntity *arg1 = (AntEntity *) 0 ;
    AntEntityPtr *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AntEntity, 1);
    result = (AntEntityPtr *)new AntEntityPtr(arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AntEntityPtr_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AntEntityPtr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AntEntityPtr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AntEntityPtr__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AntEntityPtr *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AntEntityPtr *)new AntEntityPtr();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AntEntityPtr(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AntEntityPtr__SWIG_2(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntity, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AntEntityPtr__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AntEntityPtr, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AntEntityPtr__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AntEntityPtr'");
    return Qnil;
}


static VALUE
_wrap_AntEntityPtr_get(int argc, VALUE *argv, VALUE self) {
    AntEntityPtr *arg1 = (AntEntityPtr *) 0 ;
    AntEntity *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AntEntityPtr, 1);
    result = (AntEntity *)(arg1)->get();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        {
            //	std::cout<<"test2"<<std::endl;
            if(result)
            {
                if(result->mRubyObject)
                vresult=result->mRUBY;
                else
                {
                    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
                    //			result->mRubyObject=true;
                    //			result->mRUBY=vresult;
                    throw int();
                }
            }
            else
            vresult = Qnil;
        }
    }
    return vresult;
}


static void
free_AntEntityPtr(AntEntityPtr *arg1) {
    delete arg1;
}
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_TerrainPieceVA_allocate(VALUE self) {
#else
    static VALUE
    _wrap_TerrainPieceVA_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_TerrainPieceVA);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_TerrainPieceVA(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    HeightMap *arg2 = 0 ;
    int arg3 ;
    int arg4 ;
    int arg5 ;
    int arg6 ;
    AGVector4 *arg7 = 0 ;
    TerrainPieceVA *result;
    
    if ((argc < 6) || (argc > 6))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_HeightMap, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    arg5 = NUM2INT(argv[3]);
    arg6 = NUM2INT(argv[4]);
    SWIG_ConvertPtr(argv[5], (void **) &arg7, SWIGTYPE_p_AGVector4, 1); if (arg7 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargis::TerrainPieceVA";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (TerrainPieceVA *)new SwigDirector_TerrainPieceVA(arg1,*arg2,arg3,arg4,arg5,arg6,(AGVector4 const &)*arg7);
        
    } else {
        result = (TerrainPieceVA *)new TerrainPieceVA(*arg2,arg3,arg4,arg5,arg6,(AGVector4 const &)*arg7);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_TerrainPieceVA(TerrainPieceVA *arg1) {
    delete arg1;
}
static VALUE
_wrap_TerrainPieceVA_draw(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_TerrainPieceVA_drawShadow(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_TerrainPieceVA_drawDepth(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_TerrainPieceVA_lineHit(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((TerrainPieceVA const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_TerrainPieceVA_getTriangles(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((TerrainPieceVA const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_TerrainPieceVA_mapChanged(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_disown_TerrainPieceVA(int argc, VALUE *argv, VALUE self) {
    TerrainPieceVA *arg1 = (TerrainPieceVA *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_TerrainPieceVA, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_TerrainMesh_allocate(VALUE self) {
#else
    static VALUE
    _wrap_TerrainMesh_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_TerrainMesh);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_TerrainMesh(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    HeightMap *arg2 = 0 ;
    TerrainMesh *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_HeightMap, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargis::TerrainMesh";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (TerrainMesh *)new SwigDirector_TerrainMesh(arg1,*arg2);
            
        } else {
            result = (TerrainMesh *)new TerrainMesh(*arg2);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY = self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_TerrainMesh(TerrainMesh *arg1) {
    delete arg1;
}
static VALUE
_wrap_TerrainMesh_advance(int argc, VALUE *argv, VALUE self) {
    TerrainMesh *arg1 = (TerrainMesh *) 0 ;
    float arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainMesh, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->advance(arg2);
    
    return Qnil;
}


static VALUE
_wrap_TerrainMesh_draw(int argc, VALUE *argv, VALUE self) {
    TerrainMesh *arg1 = (TerrainMesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainMesh, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_TerrainMesh_drawShadow(int argc, VALUE *argv, VALUE self) {
    TerrainMesh *arg1 = (TerrainMesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainMesh, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_TerrainMesh_drawDepth(int argc, VALUE *argv, VALUE self) {
    TerrainMesh *arg1 = (TerrainMesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainMesh, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_TerrainMesh_sort(int argc, VALUE *argv, VALUE self) {
    TerrainMesh *arg1 = (TerrainMesh *) 0 ;
    AGVector4 *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainMesh, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->sort((AGVector4 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_TerrainMesh_lineHit(int argc, VALUE *argv, VALUE self) {
    TerrainMesh *arg1 = (TerrainMesh *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainMesh, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((TerrainMesh const *)arg1)->lineHit((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_TerrainMesh_getTriangles(int argc, VALUE *argv, VALUE self) {
    TerrainMesh *arg1 = (TerrainMesh *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainMesh, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((TerrainMesh const *)arg1)->getTriangles();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_TerrainMesh_mapChanged(int argc, VALUE *argv, VALUE self) {
    TerrainMesh *arg1 = (TerrainMesh *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_TerrainMesh, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->mapChanged();
    
    return Qnil;
}


static VALUE
_wrap_disown_TerrainMesh(int argc, VALUE *argv, VALUE self) {
    TerrainMesh *arg1 = (TerrainMesh *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_TerrainMesh, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toTerrainMesh(int argc, VALUE *argv, VALUE self) {
    SceneNode *arg1 = (SceneNode *) 0 ;
    TerrainMesh *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SceneNode, 1);
    result = (TerrainMesh *)toTerrainMesh(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainMesh,0);
    return vresult;
}


static VALUE
_wrap_new_GLTree__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGVector4 arg2 ;
    float arg3 ;
    GLTree *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    {
        AGVector4 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGVector4, 1);
        if (ptr) arg2 = *ptr;
    }
    arg3 = (float) NUM2DBL(argv[1]);
    char *classname = "Libantargis::GLTree";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (GLTree *)new SwigDirector_GLTree(arg1,arg2,arg3);
        
    } else {
        result = (GLTree *)new GLTree(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_GLTree_allocate(VALUE self) {
#else
    static VALUE
    _wrap_GLTree_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_GLTree);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_GLTree__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGVector4 arg2 ;
    GLTree *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    {
        AGVector4 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGVector4, 1);
        if (ptr) arg2 = *ptr;
    }
    char *classname = "Libantargis::GLTree";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (GLTree *)new SwigDirector_GLTree(arg1,arg2);
        
    } else {
        result = (GLTree *)new GLTree(arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_GLTree(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_GLTree__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_GLTree__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_GLTree'");
    return Qnil;
}


static void
free_GLTree(GLTree *arg1) {
    delete arg1;
}
static VALUE
_wrap_GLTree_draw(int argc, VALUE *argv, VALUE self) {
    GLTree *arg1 = (GLTree *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLTree, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_GLTree_drawDepth(int argc, VALUE *argv, VALUE self) {
    GLTree *arg1 = (GLTree *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLTree, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawDepth();
    
    return Qnil;
}


static VALUE
_wrap_GLTree_drawShadow(int argc, VALUE *argv, VALUE self) {
    GLTree *arg1 = (GLTree *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLTree, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawShadow();
    
    return Qnil;
}


static VALUE
_wrap_GLTree_mydraw__SWIG_0(int argc, VALUE *argv, VALUE self) {
    GLTree *arg1 = (GLTree *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLTree, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->mydraw(arg2);
    
    return Qnil;
}


static VALUE
_wrap_GLTree_mydraw__SWIG_1(int argc, VALUE *argv, VALUE self) {
    GLTree *arg1 = (GLTree *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLTree, 1);
    (arg1)->mydraw();
    
    return Qnil;
}


static VALUE _wrap_GLTree_mydraw(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_GLTree, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_GLTree_mydraw__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_GLTree, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_GLTree_mydraw__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'GLTree_mydraw'");
    return Qnil;
}


static VALUE
_wrap_GLTree_drawVertex(int argc, VALUE *argv, VALUE self) {
    GLTree *arg1 = (GLTree *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 arg3 ;
    float arg4 ;
    float arg5 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_GLTree, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector4 * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGVector4, 1);
        if (ptr) arg3 = *ptr;
    }
    arg4 = (float) NUM2DBL(argv[2]);
    arg5 = (float) NUM2DBL(argv[3]);
    (arg1)->drawVertex((AGVector4 const &)*arg2,arg3,arg4,arg5);
    
    return Qnil;
}


static VALUE
_wrap_disown_GLTree(int argc, VALUE *argv, VALUE self) {
    GLTree *arg1 = (GLTree *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_GLTree, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_AGDialogTo_p_AGLayout(void *x) {
    return (void *)((AGLayout *)  ((AGDialog *) x));
}
static void *_p_GLAppTo_p_AGApplication(void *x) {
    return (void *)((AGApplication *)  ((GLApp *) x));
}
static void *_p_AGSDLEventTo_p_AGEvent(void *x) {
    return (void *)((AGEvent *)  ((AGSDLEvent *) x));
}
static void *_p_AGMouseEventTo_p_AGEvent(void *x) {
    return (void *)((AGEvent *)  ((AGMouseEvent *) x));
}
static void *_p_AGMenuEventTo_p_AGEvent(void *x) {
    return (void *)((AGEvent *)  ((AGMenuEvent *) x));
}
static void *_p_DomParserTo_p_Parser(void *x) {
    return (void *)((Parser *)  ((DomParser *) x));
}
static void *_p_AGWindowTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_AGListBoxTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGListBox *) x));
}
static void *_p_AGCaptionTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGApplicationTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *) ((AGApplication *) x));
}
static void *_p_AGButtonTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGVTiler *) x));
}
static void *_p_AGTableTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGTable *) x));
}
static void *_p_AGWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *) ((AGWidget *) x));
}
static void *_p_AGMenuTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGColorButton *) x));
}
static void *_p_AGHTilerTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGScreenWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGScreenWidget *) x));
}
static void *_p_AGImageTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGImage *) x));
}
static void *_p_AGGLWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGGLWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGLayout *) x));
}
static void *_p_GLAppTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGApplication *) ((GLApp *) x));
}
static void *_p_AGMessageObjectTo_p_AGListener(void *x) {
    return (void *)((AGListener *)  ((AGMessageObject *) x));
}
static void *_p_AGRadioTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGDialogTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGTextTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGSound *) x));
}
static void *_p_AGRectTo_p_SDL_Rect(void *x) {
    return (void *)((SDL_Rect *)  ((AGRect *) x));
}
static void *_p_AGWindowTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGTable *) ((AGWindow *) x));
}
static void *_p_AGListBoxTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGListBox *) x));
}
static void *_p_AGCaptionTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGText *) ((AGCaption *) x));
}
static void *_p_AGButtonTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGVTiler *) x));
}
static void *_p_AGTableTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGTable *) x));
}
static void *_p_AGMenuTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGColorButton *) x));
}
static void *_p_AGHTilerTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGScreenWidgetTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGScreenWidget *) x));
}
static void *_p_AGImageTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGImage *) x));
}
static void *_p_AGGLWidgetTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGGLWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGLayout *) x));
}
static void *_p_AGRadioTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGDialogTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGLayout *) ((AGDialog *) x));
}
static void *_p_AGTextTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGSound *) x));
}
static void *_p_AGWindowTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_AGListBoxTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGListBox *) x));
}
static void *_p_AGCaptionTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGApplicationTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *)  ((AGApplication *) x));
}
static void *_p_AGButtonTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGVTiler *) x));
}
static void *_p_AGTableTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGTable *) x));
}
static void *_p_AGWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *)  ((AGWidget *) x));
}
static void *_p_AGMenuTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGColorButton *) x));
}
static void *_p_AGHTilerTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGScreenWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGScreenWidget *) x));
}
static void *_p_AGImageTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGImage *) x));
}
static void *_p_AGGLWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGGLWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGLayout *) x));
}
static void *_p_GLAppTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGApplication *) ((GLApp *) x));
}
static void *_p_AGRadioTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGDialogTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGTextTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGSound *) x));
}
static void *_p_AGCaptionTo_p_AGText(void *x) {
    return (void *)((AGText *)  ((AGCaption *) x));
}
static void *_p_AGSurfaceTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGSurface *) x));
}
static void *_p_AGSDLScreenTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *) (AGScreen *) ((AGSDLScreen *) x));
}
static void *_p_AGScreenTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGScreen *) x));
}
static void *_p_AGRadioTo_p_AGButton(void *x) {
    return (void *)((AGButton *) (AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGCheckBoxTo_p_AGButton(void *x) {
    return (void *)((AGButton *)  ((AGCheckBox *) x));
}
static void *_p_AGSDLScreenTo_p_AGScreen(void *x) {
    return (void *)((AGScreen *)  ((AGSDLScreen *) x));
}
static void *_p_GLTreeTo_p_Mesh(void *x) {
    return (void *)((Mesh *)  ((GLTree *) x));
}
static void *_p_AGRadioTo_p_AGCheckBox(void *x) {
    return (void *)((AGCheckBox *)  ((AGRadio *) x));
}
static void *_p_p_GLTreeTo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **) (Mesh *) ((GLTree **) x));
}
static void *_p_p_MeshDataTo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((MeshData **) x));
}
static void *_p_p_MeshTo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((Mesh **) x));
}
static void *_p_p_TerrainPieceVATo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((TerrainPieceVA **) x));
}
static void *_p_p_TerrainMeshTo_p_p_SceneNode(void *x) {
    return (void *)((SceneNode **)  ((TerrainMesh **) x));
}
static void *_p_GLTreeTo_p_SceneNode(void *x) {
    return (void *)((SceneNode *) (Mesh *) ((GLTree *) x));
}
static void *_p_MeshDataTo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((MeshData *) x));
}
static void *_p_MeshTo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((Mesh *) x));
}
static void *_p_TerrainPieceVATo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((TerrainPieceVA *) x));
}
static void *_p_TerrainMeshTo_p_SceneNode(void *x) {
    return (void *)((SceneNode *)  ((TerrainMesh *) x));
}
static void *_p_AGHTilerTo_p_AGVTiler(void *x) {
    return (void *)((AGVTiler *)  ((AGHTiler *) x));
}
static void *_p_AGMenuTo_p_AGVTiler(void *x) {
    return (void *)((AGVTiler *)  ((AGMenu *) x));
}
static void *_p_AGWindowTo_p_AGTable(void *x) {
    return (void *)((AGTable *)  ((AGWindow *) x));
}
static void *_p_AGPoint3To_p_AGVector3(void *x) {
    return (void *)((AGVector3 *)  ((AGPoint3 *) x));
}
static void *_p_AntMapTo_p_HeightMap(void *x) {
    return (void *)((HeightMap *)  ((AntMap *) x));
}
static swig_type_info _swigt__p_AGBackground[] = {{"_p_AGBackground", 0, "AGBackground *", 0, 0, 0, 0},{"_p_AGBackground", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_iterator[] = {{"_p_iterator", 0, "iterator *", 0, 0, 0, 0},{"_p_iterator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_const_iterator[] = {{"_p_const_iterator", 0, "const_iterator *", 0, 0, 0, 0},{"_p_const_iterator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Node__NodeVector__iterator[] = {{"_p_Node__NodeVector__iterator", 0, "Node::NodeVector::iterator *|Node::iterator *", 0, 0, 0, 0},{"_p_Node__NodeVector__iterator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Node__NodeVector__const_iterator[] = {{"_p_Node__NodeVector__const_iterator", 0, "Node::NodeVector::const_iterator *|Node::const_iterator *", 0, 0, 0, 0},{"_p_Node__NodeVector__const_iterator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Document[] = {{"_p_Document", 0, "Document *|xmlpp::Document *", 0, 0, 0, 0},{"_p_Document", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTAGVector4_t[] = {{"_p_std__vectorTAGVector4_t", 0, "std::vector<AGVector4 > *", 0, 0, 0, 0},{"_p_std__vectorTAGVector4_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_MeshOptimizer[] = {{"_p_MeshOptimizer", 0, "MeshOptimizer *", 0, 0, 0, 0},{"_p_MeshOptimizer", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_MeshData[] = {{"_p_MeshData", 0, "MeshData *", 0, 0, 0, 0},{"_p_MeshData", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGAngle[] = {{"_p_AGAngle", 0, "AGAngle *", 0, 0, 0, 0},{"_p_AGAngle", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGMenu[] = {{"_p_AGMenu", 0, "AGMenu *", 0, 0, 0, 0},{"_p_AGMenu", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTAGVector3_t[] = {{"_p_std__vectorTAGVector3_t", 0, "std::vector<AGVector3 > *", 0, 0, 0, 0},{"_p_std__vectorTAGVector3_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AntEntityPtr[] = {{"_p_AntEntityPtr", 0, "AntEntityPtr *", 0, 0, 0, 0},{"_p_AntEntityPtr", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGHTiler[] = {{"_p_AGHTiler", 0, "AGHTiler *", 0, 0, 0, 0},{"_p_AGHTiler", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGLayout[] = {{"_p_AGLayout", 0, "AGLayout *", 0, 0, 0, 0},{"_p_AGDialog", _p_AGDialogTo_p_AGLayout, 0, 0, 0, 0, 0},{"_p_AGLayout", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGMain[] = {{"_p_AGMain", 0, "AGMain *", 0, 0, 0, 0},{"_p_AGMain", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_NodeVector[] = {{"_p_NodeVector", 0, "NodeVector *", 0, 0, 0, 0},{"_p_NodeVector", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLApp[] = {{"_p_GLApp", 0, "GLApp *", 0, 0, 0, 0},{"_p_GLApp", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGVTiler[] = {{"_p_AGVTiler", 0, "AGVTiler *", 0, 0, 0, 0},{"_p_AGVTiler", 0, 0, 0, 0, 0, 0},{"_p_AGHTiler", _p_AGHTilerTo_p_AGVTiler, 0, 0, 0, 0, 0},{"_p_AGMenu", _p_AGMenuTo_p_AGVTiler, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGCollisionData[] = {{"_p_AGCollisionData", 0, "AGCollisionData *", 0, 0, 0, 0},{"_p_AGCollisionData", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGCheckBox[] = {{"_p_AGCheckBox", 0, "AGCheckBox *", 0, 0, 0, 0},{"_p_AGRadio", _p_AGRadioTo_p_AGCheckBox, 0, 0, 0, 0, 0},{"_p_AGCheckBox", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGLayoutFactory[] = {{"_p_AGLayoutFactory", 0, "AGLayoutFactory *", 0, 0, 0, 0},{"_p_AGLayoutFactory", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGSound[] = {{"_p_AGSound", 0, "AGSound *", 0, 0, 0, 0},{"_p_AGSound", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGFont[] = {{"_p_AGFont", 0, "AGFont *", 0, 0, 0, 0},{"_p_AGFont", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGScreen[] = {{"_p_AGScreen", 0, "AGScreen *", 0, 0, 0, 0},{"_p_AGSDLScreen", _p_AGSDLScreenTo_p_AGScreen, 0, 0, 0, 0, 0},{"_p_AGScreen", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Scene[] = {{"_p_Scene", 0, "Scene *", 0, 0, 0, 0},{"_p_Scene", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGTable[] = {{"_p_AGTable", 0, "AGTable *", 0, 0, 0, 0},{"_p_AGTable", 0, 0, 0, 0, 0, 0},{"_p_AGWindow", _p_AGWindowTo_p_AGTable, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGEditLine[] = {{"_p_AGEditLine", 0, "AGEditLine *", 0, 0, 0, 0},{"_p_AGEditLine", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_HeightMap[] = {{"_p_HeightMap", 0, "HeightMap *", 0, 0, 0, 0},{"_p_AntMap", _p_AntMapTo_p_HeightMap, 0, 0, 0, 0, 0},{"_p_HeightMap", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGListBoxItem[] = {{"_p_AGListBoxItem", 0, "AGListBoxItem *", 0, 0, 0, 0},{"_p_AGListBoxItem", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGSignal[] = {{"_p_AGSignal", 0, "AGSignal *", 0, 0, 0, 0},{"_p_AGSignal", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_MeshVertex[] = {{"_p_MeshVertex", 0, "MeshVertex *", 0, 0, 0, 0},{"_p_MeshVertex", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTAGRect3_t[] = {{"_p_std__vectorTAGRect3_t", 0, "std::vector<AGRect3 > *", 0, 0, 0, 0},{"_p_std__vectorTAGRect3_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGColor[] = {{"_p_AGColor", 0, "AGColor *", 0, 0, 0, 0},{"_p_AGColor", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGBox3[] = {{"_p_AGBox3", 0, "AGBox3 *", 0, 0, 0, 0},{"_p_AGBox3", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__listTAGRect2_t[] = {{"_p_std__listTAGRect2_t", 0, "std::list<AGRect2 > *", 0, 0, 0, 0},{"_p_std__listTAGRect2_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGLayoutCreator[] = {{"_p_AGLayoutCreator", 0, "AGLayoutCreator *", 0, 0, 0, 0},{"_p_AGLayoutCreator", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGButton[] = {{"_p_AGButton", 0, "AGButton *", 0, 0, 0, 0},{"_p_AGRadio", _p_AGRadioTo_p_AGButton, 0, 0, 0, 0, 0},{"_p_AGButton", 0, 0, 0, 0, 0, 0},{"_p_AGCheckBox", _p_AGCheckBoxTo_p_AGButton, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTNode_t[] = {{"_p_std__vectorTNode_t", 0, "std::vector<Node > *", 0, 0, 0, 0},{"_p_std__vectorTNode_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGSurface[] = {{"_p_AGSurface", 0, "AGSurface *", 0, 0, 0, 0},{"_p_AGSurface", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_SDL_Surface[] = {{"_p_SDL_Surface", 0, "SDL_Surface *", 0, 0, 0, 0},{"_p_SDL_Surface", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTAGLine2_t[] = {{"_p_std__vectorTAGLine2_t", 0, "std::vector<AGLine2 > *", 0, 0, 0, 0},{"_p_std__vectorTAGLine2_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_SceneNode[] = {{"_p_SceneNode", 0, "SceneNode *", 0, 0, 0, 0},{"_p_SceneNode", 0, 0, 0, 0, 0, 0},{"_p_GLTree", _p_GLTreeTo_p_SceneNode, 0, 0, 0, 0, 0},{"_p_Mesh", _p_MeshTo_p_SceneNode, 0, 0, 0, 0, 0},{"_p_MeshData", _p_MeshDataTo_p_SceneNode, 0, 0, 0, 0, 0},{"_p_TerrainPieceVA", _p_TerrainPieceVATo_p_SceneNode, 0, 0, 0, 0, 0},{"_p_TerrainMesh", _p_TerrainMeshTo_p_SceneNode, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_p_SceneNode[] = {{"_p_p_SceneNode", 0, "SceneNode **|SceneNodePtr *", 0, 0, 0, 0},{"_p_p_SceneNode", 0, 0, 0, 0, 0, 0},{"_p_p_GLTree", _p_p_GLTreeTo_p_p_SceneNode, 0, 0, 0, 0, 0},{"_p_p_Mesh", _p_p_MeshTo_p_p_SceneNode, 0, 0, 0, 0, 0},{"_p_p_MeshData", _p_p_MeshDataTo_p_p_SceneNode, 0, 0, 0, 0, 0},{"_p_p_TerrainPieceVA", _p_p_TerrainPieceVATo_p_p_SceneNode, 0, 0, 0, 0, 0},{"_p_p_TerrainMesh", _p_p_TerrainMeshTo_p_p_SceneNode, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AntEntity[] = {{"_p_AntEntity", 0, "AntEntity *", 0, 0, 0, 0},{"_p_AntEntity", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTSceneNode_p_t[] = {{"_p_std__vectorTSceneNode_p_t", 0, "std::vector<SceneNodePtr > *", 0, 0, 0, 0},{"_p_std__vectorTSceneNode_p_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTNode_p_t[] = {{"_p_std__vectorTNode_p_t", 0, "std::vector<Node * > *", 0, 0, 0, 0},{"_p_std__vectorTNode_p_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGImage[] = {{"_p_AGImage", 0, "AGImage *", 0, 0, 0, 0},{"_p_AGImage", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__listTMesh_p_t[] = {{"_p_std__listTMesh_p_t", 0, "std::list<Mesh * > *", 0, 0, 0, 0},{"_p_std__listTMesh_p_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Uint32[] = {{"_p_Uint32", 0, "Uint32 *", 0, 0, 0, 0},{"_p_Uint32", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGApplication[] = {{"_p_AGApplication", 0, "AGApplication *", 0, 0, 0, 0},{"_p_AGApplication", 0, 0, 0, 0, 0, 0},{"_p_GLApp", _p_GLAppTo_p_AGApplication, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGSDLEvent[] = {{"_p_AGSDLEvent", 0, "AGSDLEvent *", 0, 0, 0, 0},{"_p_AGSDLEvent", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_EntityList[] = {{"_p_EntityList", 0, "EntityList *", 0, 0, 0, 0},{"_p_EntityList", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGWidget[] = {{"_p_AGWidget", 0, "AGWidget *", 0, 0, 0, 0},{"_p_AGWindow", _p_AGWindowTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGListBox", _p_AGListBoxTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGCaption", _p_AGCaptionTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGMenu", _p_AGMenuTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGButton", _p_AGButtonTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGVTiler", _p_AGVTilerTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGEdit", _p_AGEditTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGTable", _p_AGTableTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGWidget", 0, 0, 0, 0, 0, 0},{"_p_AGColorButton", _p_AGColorButtonTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGHTiler", _p_AGHTilerTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGGLWidget", _p_AGGLWidgetTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGScreenWidget", _p_AGScreenWidgetTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGImage", _p_AGImageTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGText", _p_AGTextTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGCheckBox", _p_AGCheckBoxTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGLayout", _p_AGLayoutTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGRadio", _p_AGRadioTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGDialog", _p_AGDialogTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGRadioGroup", _p_AGRadioGroupTo_p_AGWidget, 0, 0, 0, 0, 0},{"_p_AGSound", _p_AGSoundTo_p_AGWidget, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Attributes[] = {{"_p_Attributes", 0, "Attributes *", 0, 0, 0, 0},{"_p_Attributes", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGMessageObject[] = {{"_p_AGMessageObject", 0, "AGMessageObject *", 0, 0, 0, 0},{"_p_AGWindow", _p_AGWindowTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGListBox", _p_AGListBoxTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGCaption", _p_AGCaptionTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGMenu", _p_AGMenuTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGApplication", _p_AGApplicationTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGButton", _p_AGButtonTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGVTiler", _p_AGVTilerTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGEdit", _p_AGEditTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGTable", _p_AGTableTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_GLApp", _p_GLAppTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGWidget", _p_AGWidgetTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGColorButton", _p_AGColorButtonTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGHTiler", _p_AGHTilerTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGGLWidget", _p_AGGLWidgetTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGScreenWidget", _p_AGScreenWidgetTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGImage", _p_AGImageTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGText", _p_AGTextTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGCheckBox", _p_AGCheckBoxTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGLayout", _p_AGLayoutTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGMessageObject", 0, 0, 0, 0, 0, 0},{"_p_AGRadio", _p_AGRadioTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGDialog", _p_AGDialogTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGRadioGroup", _p_AGRadioGroupTo_p_AGMessageObject, 0, 0, 0, 0, 0},{"_p_AGSound", _p_AGSoundTo_p_AGMessageObject, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGFontEngine[] = {{"_p_AGFontEngine", 0, "AGFontEngine *", 0, 0, 0, 0},{"_p_AGFontEngine", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGPoint[] = {{"_p_AGPoint", 0, "AGPoint *", 0, 0, 0, 0},{"_p_AGPoint", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGTriangle2[] = {{"_p_AGTriangle2", 0, "AGTriangle2 *", 0, 0, 0, 0},{"_p_AGTriangle2", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGTriangle3[] = {{"_p_AGTriangle3", 0, "AGTriangle3 *", 0, 0, 0, 0},{"_p_AGTriangle3", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGWindow[] = {{"_p_AGWindow", 0, "AGWindow *", 0, 0, 0, 0},{"_p_AGWindow", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGRect[] = {{"_p_AGRect", 0, "AGRect *", 0, 0, 0, 0},{"_p_AGRect", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGSDLScreen[] = {{"_p_AGSDLScreen", 0, "AGSDLScreen *", 0, 0, 0, 0},{"_p_AGSDLScreen", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Parser[] = {{"_p_Parser", 0, "Parser *", 0, 0, 0, 0},{"_p_Parser", 0, 0, 0, 0, 0, 0},{"_p_DomParser", _p_DomParserTo_p_Parser, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGPoint3[] = {{"_p_AGPoint3", 0, "AGPoint3 *", 0, 0, 0, 0},{"_p_AGPoint3", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_DomParser[] = {{"_p_DomParser", 0, "DomParser *", 0, 0, 0, 0},{"_p_DomParser", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGDialog[] = {{"_p_AGDialog", 0, "AGDialog *", 0, 0, 0, 0},{"_p_AGDialog", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_TerrainPieceVA[] = {{"_p_TerrainPieceVA", 0, "TerrainPieceVA *", 0, 0, 0, 0},{"_p_TerrainPieceVA", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGPainter[] = {{"_p_AGPainter", 0, "AGPainter *", 0, 0, 0, 0},{"_p_AGPainter", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGText[] = {{"_p_AGText", 0, "AGText *", 0, 0, 0, 0},{"_p_AGText", 0, 0, 0, 0, 0, 0},{"_p_AGCaption", _p_AGCaptionTo_p_AGText, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTAntEntityPtr_t[] = {{"_p_std__vectorTAntEntityPtr_t", 0, "std::vector<AntEntityPtr > *", 0, 0, 0, 0},{"_p_std__vectorTAntEntityPtr_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGListBox[] = {{"_p_AGListBox", 0, "AGListBox *", 0, 0, 0, 0},{"_p_AGListBox", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGMatrix3[] = {{"_p_AGMatrix3", 0, "AGMatrix3 *", 0, 0, 0, 0},{"_p_AGMatrix3", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTstd__string_t[] = {{"_p_std__vectorTstd__string_t", 0, "std::vector<std::string > *", 0, 0, 0, 0},{"_p_std__vectorTstd__string_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_SDL_PixelFormat[] = {{"_p_SDL_PixelFormat", 0, "SDL_PixelFormat *", 0, 0, 0, 0},{"_p_SDL_PixelFormat", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGTexture[] = {{"_p_AGTexture", 0, "AGTexture *", 0, 0, 0, 0},{"_p_AGTexture", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGLine2[] = {{"_p_AGLine2", 0, "AGLine2 *", 0, 0, 0, 0},{"_p_AGLine2", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGMatrix4[] = {{"_p_AGMatrix4", 0, "AGMatrix4 *", 0, 0, 0, 0},{"_p_AGMatrix4", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__mapTstd__string_std__string_t[] = {{"_p_std__mapTstd__string_std__string_t", 0, "std::map<std::string,std::string > *|Node::Attributes *", 0, 0, 0, 0},{"_p_std__mapTstd__string_std__string_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGColorButton[] = {{"_p_AGColorButton", 0, "AGColorButton *", 0, 0, 0, 0},{"_p_AGColorButton", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGLine3[] = {{"_p_AGLine3", 0, "AGLine3 *", 0, 0, 0, 0},{"_p_AGLine3", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Uint8[] = {{"_p_Uint8", 0, "Uint8 *", 0, 0, 0, 0},{"_p_Uint8", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_SDLMod[] = {{"_p_SDLMod", 0, "enum SDLMod *|SDLMod *", 0, 0, 0, 0},{"_p_SDLMod", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLTree[] = {{"_p_GLTree", 0, "GLTree *", 0, 0, 0, 0},{"_p_GLTree", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Mesh[] = {{"_p_Mesh", 0, "Mesh *", 0, 0, 0, 0},{"_p_Mesh", 0, 0, 0, 0, 0, 0},{"_p_GLTree", _p_GLTreeTo_p_Mesh, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGRect2[] = {{"_p_AGRect2", 0, "AGRect2 *", 0, 0, 0, 0},{"_p_AGRect2", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGRect3[] = {{"_p_AGRect3", 0, "AGRect3 *", 0, 0, 0, 0},{"_p_AGRect3", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_SDL_Rect[] = {{"_p_SDL_Rect", 0, "SDL_Rect *", 0, 0, 0, 0},{"_p_SDL_Rect", 0, 0, 0, 0, 0, 0},{"_p_AGRect", _p_AGRectTo_p_SDL_Rect, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AntMap[] = {{"_p_AntMap", 0, "AntMap *", 0, 0, 0, 0},{"_p_AntMap", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_SDL_Event[] = {{"_p_SDL_Event", 0, "SDL_Event *", 0, 0, 0, 0},{"_p_SDL_Event", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_GLuint[] = {{"_p_GLuint", 0, "GLuint *", 0, 0, 0, 0},{"_p_GLuint", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__mapTstd__string_float_t[] = {{"_p_std__mapTstd__string_float_t", 0, "std::map<std::string,float > *", 0, 0, 0, 0},{"_p_std__mapTstd__string_float_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGTextureManager[] = {{"_p_AGTextureManager", 0, "AGTextureManager *", 0, 0, 0, 0},{"_p_AGTextureManager", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGSurfaceManager[] = {{"_p_AGSurfaceManager", 0, "AGSurfaceManager *", 0, 0, 0, 0},{"_p_AGSurfaceManager", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGEdit[] = {{"_p_AGEdit", 0, "AGEdit *", 0, 0, 0, 0},{"_p_AGEdit", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGScreenWidget[] = {{"_p_AGScreenWidget", 0, "AGScreenWidget *", 0, 0, 0, 0},{"_p_AGScreenWidget", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGGLWidget[] = {{"_p_AGGLWidget", 0, "AGGLWidget *", 0, 0, 0, 0},{"_p_AGGLWidget", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTAGBox3_t[] = {{"_p_std__vectorTAGBox3_t", 0, "std::vector<AGBox3 > *", 0, 0, 0, 0},{"_p_std__vectorTAGBox3_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGRadio[] = {{"_p_AGRadio", 0, "AGRadio *", 0, 0, 0, 0},{"_p_AGRadio", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__ostringstream[] = {{"_p_std__ostringstream", 0, "std::ostringstream *", 0, 0, 0, 0},{"_p_std__ostringstream", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Resource[] = {{"_p_Resource", 0, "Resource *", 0, 0, 0, 0},{"_p_Resource", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGVector2[] = {{"_p_AGVector2", 0, "AGVector2 *", 0, 0, 0, 0},{"_p_AGVector2", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_unsigned_long[] = {{"_p_unsigned_long", 0, "unsigned long *|VALUE *", 0, 0, 0, 0},{"_p_unsigned_long", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGVector3[] = {{"_p_AGVector3", 0, "AGVector3 *", 0, 0, 0, 0},{"_p_AGPoint3", _p_AGPoint3To_p_AGVector3, 0, 0, 0, 0, 0},{"_p_AGVector3", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGCaption[] = {{"_p_AGCaption", 0, "AGCaption *", 0, 0, 0, 0},{"_p_AGCaption", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_PickResult[] = {{"_p_PickResult", 0, "PickResult *", 0, 0, 0, 0},{"_p_PickResult", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGVector4[] = {{"_p_AGVector4", 0, "AGVector4 *", 0, 0, 0, 0},{"_p_AGVector4", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__string[] = {{"_p_std__string", 0, "std::string *", 0, 0, 0, 0},{"_p_std__string", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGEvent[] = {{"_p_AGEvent", 0, "AGEvent *", 0, 0, 0, 0},{"_p_AGSDLEvent", _p_AGSDLEventTo_p_AGEvent, 0, 0, 0, 0, 0},{"_p_AGMouseEvent", _p_AGMouseEventTo_p_AGEvent, 0, 0, 0, 0, 0},{"_p_AGEvent", 0, 0, 0, 0, 0, 0},{"_p_AGMenuEvent", _p_AGMenuEventTo_p_AGEvent, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGRadioGroup[] = {{"_p_AGRadioGroup", 0, "AGRadioGroup *", 0, 0, 0, 0},{"_p_AGRadioGroup", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_TerrainMesh[] = {{"_p_TerrainMesh", 0, "TerrainMesh *", 0, 0, 0, 0},{"_p_TerrainMesh", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_VertexArray[] = {{"_p_VertexArray", 0, "VertexArray *", 0, 0, 0, 0},{"_p_VertexArray", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGMenuEvent[] = {{"_p_AGMenuEvent", 0, "AGMenuEvent *", 0, 0, 0, 0},{"_p_AGMenuEvent", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGMouseEvent[] = {{"_p_AGMouseEvent", 0, "AGMouseEvent *", 0, 0, 0, 0},{"_p_AGMouseEvent", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__pairTstd__string_bool_t[] = {{"_p_std__pairTstd__string_bool_t", 0, "std::pair<std::string,bool > *", 0, 0, 0, 0},{"_p_std__pairTstd__string_bool_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGPaintTarget[] = {{"_p_AGPaintTarget", 0, "AGPaintTarget *", 0, 0, 0, 0},{"_p_AGPaintTarget", 0, 0, 0, 0, 0, 0},{"_p_AGSurface", _p_AGSurfaceTo_p_AGPaintTarget, 0, 0, 0, 0, 0},{"_p_AGSDLScreen", _p_AGSDLScreenTo_p_AGPaintTarget, 0, 0, 0, 0, 0},{"_p_AGScreen", _p_AGScreenTo_p_AGPaintTarget, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_PickNode[] = {{"_p_PickNode", 0, "PickNode *", 0, 0, 0, 0},{"_p_PickNode", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_SDLKey[] = {{"_p_SDLKey", 0, "enum SDLKey *|SDLKey *", 0, 0, 0, 0},{"_p_SDLKey", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGCPPListener[] = {{"_p_AGCPPListener", 0, "AGCPPListener *", 0, 0, 0, 0},{"_p_AGCPPListener", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGListener[] = {{"_p_AGListener", 0, "AGListener *", 0, 0, 0, 0},{"_p_AGWindow", _p_AGWindowTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGListBox", _p_AGListBoxTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGCaption", _p_AGCaptionTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGMenu", _p_AGMenuTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGApplication", _p_AGApplicationTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGButton", _p_AGButtonTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGVTiler", _p_AGVTilerTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGEdit", _p_AGEditTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGTable", _p_AGTableTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_GLApp", _p_GLAppTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGWidget", _p_AGWidgetTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGColorButton", _p_AGColorButtonTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGListener", 0, 0, 0, 0, 0, 0},{"_p_AGHTiler", _p_AGHTilerTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGGLWidget", _p_AGGLWidgetTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGScreenWidget", _p_AGScreenWidgetTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGImage", _p_AGImageTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGText", _p_AGTextTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGCheckBox", _p_AGCheckBoxTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGLayout", _p_AGLayoutTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGRadio", _p_AGRadioTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGDialog", _p_AGDialogTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGMessageObject", _p_AGMessageObjectTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGRadioGroup", _p_AGRadioGroupTo_p_AGListener, 0, 0, 0, 0, 0},{"_p_AGSound", _p_AGSoundTo_p_AGListener, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_float[] = {{"_p_float", 0, "float *", 0, 0, 0, 0},{"_p_float", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGCircle2[] = {{"_p_AGCircle2", 0, "AGCircle2 *", 0, 0, 0, 0},{"_p_AGCircle2", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__vectorTPickNode_t[] = {{"_p_std__vectorTPickNode_t", 0, "std::vector<PickNode > *|Scene::PickResult *", 0, 0, 0, 0},{"_p_std__vectorTPickNode_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_Node[] = {{"_p_Node", 0, "Node *|xmlpp::Node *", 0, 0, 0, 0},{"_p_Node", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_p_Node[] = {{"_p_p_Node", 0, "Node **", 0, 0, 0, 0},{"_p_p_Node", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_std__listTAntEntity_p_t[] = {{"_p_std__listTAntEntity_p_t", 0, "std::list<AntEntity * > *|AntMap::EntityList *", 0, 0, 0, 0},{"_p_std__listTAntEntity_p_t", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
static swig_type_info _swigt__p_AGTheme[] = {{"_p_AGTheme", 0, "AGTheme *", 0, 0, 0, 0},{"_p_AGTheme", 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_AGBackground, 
_swigt__p_iterator, 
_swigt__p_const_iterator, 
_swigt__p_Node__NodeVector__iterator, 
_swigt__p_Node__NodeVector__const_iterator, 
_swigt__p_Document, 
_swigt__p_std__vectorTAGVector4_t, 
_swigt__p_MeshOptimizer, 
_swigt__p_MeshData, 
_swigt__p_AGAngle, 
_swigt__p_AGMenu, 
_swigt__p_std__vectorTAGVector3_t, 
_swigt__p_AntEntityPtr, 
_swigt__p_AGHTiler, 
_swigt__p_AGLayout, 
_swigt__p_AGMain, 
_swigt__p_NodeVector, 
_swigt__p_GLApp, 
_swigt__p_AGVTiler, 
_swigt__p_AGCollisionData, 
_swigt__p_AGCheckBox, 
_swigt__p_AGLayoutFactory, 
_swigt__p_AGSound, 
_swigt__p_AGFont, 
_swigt__p_AGScreen, 
_swigt__p_Scene, 
_swigt__p_AGTable, 
_swigt__p_AGEditLine, 
_swigt__p_HeightMap, 
_swigt__p_AGListBoxItem, 
_swigt__p_AGSignal, 
_swigt__p_MeshVertex, 
_swigt__p_std__vectorTAGRect3_t, 
_swigt__p_AGColor, 
_swigt__p_AGBox3, 
_swigt__p_std__listTAGRect2_t, 
_swigt__p_AGLayoutCreator, 
_swigt__p_AGButton, 
_swigt__p_std__vectorTNode_t, 
_swigt__p_AGSurface, 
_swigt__p_SDL_Surface, 
_swigt__p_std__vectorTAGLine2_t, 
_swigt__p_SceneNode, 
_swigt__p_p_SceneNode, 
_swigt__p_AntEntity, 
_swigt__p_std__vectorTSceneNode_p_t, 
_swigt__p_std__vectorTNode_p_t, 
_swigt__p_AGImage, 
_swigt__p_std__listTMesh_p_t, 
_swigt__p_Uint32, 
_swigt__p_AGApplication, 
_swigt__p_AGSDLEvent, 
_swigt__p_EntityList, 
_swigt__p_AGWidget, 
_swigt__p_Attributes, 
_swigt__p_AGMessageObject, 
_swigt__p_AGFontEngine, 
_swigt__p_AGPoint, 
_swigt__p_AGTriangle2, 
_swigt__p_AGTriangle3, 
_swigt__p_AGWindow, 
_swigt__p_AGRect, 
_swigt__p_AGSDLScreen, 
_swigt__p_Parser, 
_swigt__p_AGPoint3, 
_swigt__p_DomParser, 
_swigt__p_AGDialog, 
_swigt__p_TerrainPieceVA, 
_swigt__p_AGPainter, 
_swigt__p_AGText, 
_swigt__p_std__vectorTAntEntityPtr_t, 
_swigt__p_AGListBox, 
_swigt__p_AGMatrix3, 
_swigt__p_std__vectorTstd__string_t, 
_swigt__p_SDL_PixelFormat, 
_swigt__p_AGTexture, 
_swigt__p_AGLine2, 
_swigt__p_AGMatrix4, 
_swigt__p_std__mapTstd__string_std__string_t, 
_swigt__p_AGColorButton, 
_swigt__p_AGLine3, 
_swigt__p_Uint8, 
_swigt__p_SDLMod, 
_swigt__p_GLTree, 
_swigt__p_Mesh, 
_swigt__p_AGRect2, 
_swigt__p_AGRect3, 
_swigt__p_SDL_Rect, 
_swigt__p_AntMap, 
_swigt__p_SDL_Event, 
_swigt__p_GLuint, 
_swigt__p_std__mapTstd__string_float_t, 
_swigt__p_AGTextureManager, 
_swigt__p_AGSurfaceManager, 
_swigt__p_AGEdit, 
_swigt__p_AGScreenWidget, 
_swigt__p_AGGLWidget, 
_swigt__p_std__vectorTAGBox3_t, 
_swigt__p_AGRadio, 
_swigt__p_std__ostringstream, 
_swigt__p_Resource, 
_swigt__p_AGVector2, 
_swigt__p_unsigned_long, 
_swigt__p_AGVector3, 
_swigt__p_AGCaption, 
_swigt__p_PickResult, 
_swigt__p_AGVector4, 
_swigt__p_std__string, 
_swigt__p_AGEvent, 
_swigt__p_AGRadioGroup, 
_swigt__p_TerrainMesh, 
_swigt__p_VertexArray, 
_swigt__p_AGMenuEvent, 
_swigt__p_AGMouseEvent, 
_swigt__p_std__pairTstd__string_bool_t, 
_swigt__p_AGPaintTarget, 
_swigt__p_PickNode, 
_swigt__p_SDLKey, 
_swigt__p_AGCPPListener, 
_swigt__p_AGListener, 
_swigt__p_float, 
_swigt__p_AGCircle2, 
_swigt__p_std__vectorTPickNode_t, 
_swigt__p_Node, 
_swigt__p_p_Node, 
_swigt__p_std__listTAntEntity_p_t, 
_swigt__p_AGTheme, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) Init_libantargis(void) {
    int i;
    
    SWIG_InitRuntime();
    mLibantargis = rb_define_module("Libantargis");
    
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        SWIG_define_class(swig_types[i]);
    }
    
    
    cStringVector.klass = rb_define_class_under(mLibantargis, "StringVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__string_t, (void *) &cStringVector);
    rb_include_module(cStringVector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cStringVector.klass, _wrap_StringVector_allocate);
    rb_define_method(cStringVector.klass, "initialize", VALUEFUNC(_wrap_new_StringVector), -1);
    rb_define_method(cStringVector.klass, "length", VALUEFUNC(_wrap_StringVector___len__), -1);
    rb_define_method(cStringVector.klass, "empty?", VALUEFUNC(_wrap_StringVector_emptyq___), -1);
    rb_define_method(cStringVector.klass, "clear", VALUEFUNC(_wrap_StringVector_clear), -1);
    rb_define_method(cStringVector.klass, "push", VALUEFUNC(_wrap_StringVector_push), -1);
    rb_define_method(cStringVector.klass, "pop", VALUEFUNC(_wrap_StringVector_pop), -1);
    rb_define_method(cStringVector.klass, "[]", VALUEFUNC(_wrap_StringVector___getitem__), -1);
    rb_define_method(cStringVector.klass, "[]=", VALUEFUNC(_wrap_StringVector___setitem__), -1);
    rb_define_method(cStringVector.klass, "each", VALUEFUNC(_wrap_StringVector_each), -1);
    cStringVector.mark = 0;
    cStringVector.destroy = (void (*)(void *)) free_std_vector_Sl_std_string_Sg_;
    
    cSceneNodeVector.klass = rb_define_class_under(mLibantargis, "SceneNodeVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTSceneNode_p_t, (void *) &cSceneNodeVector);
    rb_include_module(cSceneNodeVector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cSceneNodeVector.klass, _wrap_SceneNodeVector_allocate);
    rb_define_method(cSceneNodeVector.klass, "initialize", VALUEFUNC(_wrap_new_SceneNodeVector), -1);
    rb_define_method(cSceneNodeVector.klass, "length", VALUEFUNC(_wrap_SceneNodeVector___len__), -1);
    rb_define_method(cSceneNodeVector.klass, "empty?", VALUEFUNC(_wrap_SceneNodeVector_emptyq___), -1);
    rb_define_method(cSceneNodeVector.klass, "clear", VALUEFUNC(_wrap_SceneNodeVector_clear), -1);
    rb_define_method(cSceneNodeVector.klass, "push", VALUEFUNC(_wrap_SceneNodeVector_push), -1);
    rb_define_method(cSceneNodeVector.klass, "pop", VALUEFUNC(_wrap_SceneNodeVector_pop), -1);
    rb_define_method(cSceneNodeVector.klass, "[]", VALUEFUNC(_wrap_SceneNodeVector___getitem__), -1);
    rb_define_method(cSceneNodeVector.klass, "[]=", VALUEFUNC(_wrap_SceneNodeVector___setitem__), -1);
    rb_define_method(cSceneNodeVector.klass, "each", VALUEFUNC(_wrap_SceneNodeVector_each), -1);
    cSceneNodeVector.mark = 0;
    cSceneNodeVector.destroy = (void (*)(void *)) free_std_vector_Sl_SceneNodePtr_Sg_;
    
    cPickResult.klass = rb_define_class_under(mLibantargis, "PickResult", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTPickNode_t, (void *) &cPickResult);
    rb_include_module(cPickResult.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cPickResult.klass, _wrap_PickResult_allocate);
    rb_define_method(cPickResult.klass, "initialize", VALUEFUNC(_wrap_new_PickResult), -1);
    rb_define_method(cPickResult.klass, "length", VALUEFUNC(_wrap_PickResult___len__), -1);
    rb_define_method(cPickResult.klass, "empty?", VALUEFUNC(_wrap_PickResult_emptyq___), -1);
    rb_define_method(cPickResult.klass, "clear", VALUEFUNC(_wrap_PickResult_clear), -1);
    rb_define_method(cPickResult.klass, "push", VALUEFUNC(_wrap_PickResult_push), -1);
    rb_define_method(cPickResult.klass, "pop", VALUEFUNC(_wrap_PickResult_pop), -1);
    rb_define_method(cPickResult.klass, "[]", VALUEFUNC(_wrap_PickResult___getitem__), -1);
    rb_define_method(cPickResult.klass, "[]=", VALUEFUNC(_wrap_PickResult___setitem__), -1);
    rb_define_method(cPickResult.klass, "each", VALUEFUNC(_wrap_PickResult_each), -1);
    cPickResult.mark = 0;
    cPickResult.destroy = (void (*)(void *)) free_std_vector_Sl_PickNode_Sg_;
    
    cEntityVector.klass = rb_define_class_under(mLibantargis, "EntityVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTAntEntityPtr_t, (void *) &cEntityVector);
    rb_include_module(cEntityVector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cEntityVector.klass, _wrap_EntityVector_allocate);
    rb_define_method(cEntityVector.klass, "initialize", VALUEFUNC(_wrap_new_EntityVector), -1);
    rb_define_method(cEntityVector.klass, "length", VALUEFUNC(_wrap_EntityVector___len__), -1);
    rb_define_method(cEntityVector.klass, "empty?", VALUEFUNC(_wrap_EntityVector_emptyq___), -1);
    rb_define_method(cEntityVector.klass, "clear", VALUEFUNC(_wrap_EntityVector_clear), -1);
    rb_define_method(cEntityVector.klass, "push", VALUEFUNC(_wrap_EntityVector_push), -1);
    rb_define_method(cEntityVector.klass, "pop", VALUEFUNC(_wrap_EntityVector_pop), -1);
    rb_define_method(cEntityVector.klass, "[]", VALUEFUNC(_wrap_EntityVector___getitem__), -1);
    rb_define_method(cEntityVector.klass, "[]=", VALUEFUNC(_wrap_EntityVector___setitem__), -1);
    rb_define_method(cEntityVector.klass, "each", VALUEFUNC(_wrap_EntityVector_each), -1);
    cEntityVector.mark = 0;
    cEntityVector.destroy = (void (*)(void *)) free_std_vector_Sl_AntEntityPtr_Sg_;
    
    cResourceMap.klass = rb_define_class_under(mLibantargis, "ResourceMap", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__mapTstd__string_float_t, (void *) &cResourceMap);
    rb_include_module(cResourceMap.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cResourceMap.klass, _wrap_ResourceMap_allocate);
    rb_define_method(cResourceMap.klass, "initialize", VALUEFUNC(_wrap_new_ResourceMap), -1);
    rb_define_method(cResourceMap.klass, "length", VALUEFUNC(_wrap_ResourceMap___len__), -1);
    rb_define_method(cResourceMap.klass, "empty?", VALUEFUNC(_wrap_ResourceMap_emptyq___), -1);
    rb_define_method(cResourceMap.klass, "clear", VALUEFUNC(_wrap_ResourceMap_clear), -1);
    rb_define_method(cResourceMap.klass, "[]", VALUEFUNC(_wrap_ResourceMap___getitem__), -1);
    rb_define_method(cResourceMap.klass, "[]=", VALUEFUNC(_wrap_ResourceMap___setitem__), -1);
    rb_define_method(cResourceMap.klass, "delete", VALUEFUNC(_wrap_ResourceMap_delete), -1);
    rb_define_method(cResourceMap.klass, "has_key?", VALUEFUNC(_wrap_ResourceMap_has_keyq___), -1);
    rb_define_method(cResourceMap.klass, "keys", VALUEFUNC(_wrap_ResourceMap_keys), -1);
    rb_define_method(cResourceMap.klass, "values", VALUEFUNC(_wrap_ResourceMap_values), -1);
    rb_define_method(cResourceMap.klass, "each", VALUEFUNC(_wrap_ResourceMap_each), -1);
    cResourceMap.mark = 0;
    cResourceMap.destroy = (void (*)(void *)) free_std_map_Sl_std_string_Sc_float_Sg_;
    
    cAGMain.klass = rb_define_class_under(mLibantargis, "AGMain", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMain, (void *) &cAGMain);
    rb_define_alloc_func(cAGMain.klass, _wrap_AGMain_allocate);
    rb_define_method(cAGMain.klass, "initialize", VALUEFUNC(_wrap_new_AGMain), -1);
    rb_define_method(cAGMain.klass, "flip", VALUEFUNC(_wrap_AGMain_flip), -1);
    rb_define_method(cAGMain.klass, "changeRes", VALUEFUNC(_wrap_AGMain_changeRes), -1);
    rb_define_method(cAGMain.klass, "toggleFull", VALUEFUNC(_wrap_AGMain_toggleFull), -1);
    rb_define_method(cAGMain.klass, "width", VALUEFUNC(_wrap_AGMain_width), -1);
    rb_define_method(cAGMain.klass, "height", VALUEFUNC(_wrap_AGMain_height), -1);
    cAGMain.mark = 0;
    cAGMain.destroy = (void (*)(void *)) free_AGMain;
    rb_define_module_function(mLibantargis, "getMain", VALUEFUNC(_wrap_getMain), -1);
    rb_define_module_function(mLibantargis, "disown_AGSurface", VALUEFUNC(_wrap_disown_AGSurface), -1);
    
    cAGSurface.klass = rb_define_class_under(mLibantargis, "AGSurface", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGSurface, (void *) &cAGSurface);
    rb_define_alloc_func(cAGSurface.klass, _wrap_AGSurface_allocate);
    rb_define_method(cAGSurface.klass, "initialize", VALUEFUNC(_wrap_new_AGSurface), -1);
    rb_define_method(cAGSurface.klass, "width", VALUEFUNC(_wrap_AGSurface_width), -1);
    rb_define_method(cAGSurface.klass, "height", VALUEFUNC(_wrap_AGSurface_height), -1);
    rb_define_method(cAGSurface.klass, "surface", VALUEFUNC(_wrap_AGSurface_surface), -1);
    rb_define_method(cAGSurface.klass, "getRect", VALUEFUNC(_wrap_AGSurface_getRect), -1);
    rb_define_method(cAGSurface.klass, "getSubSurface", VALUEFUNC(_wrap_AGSurface_getSubSurface), -1);
    rb_define_method(cAGSurface.klass, "clone", VALUEFUNC(_wrap_AGSurface_clone), -1);
    rb_define_method(cAGSurface.klass, "valid", VALUEFUNC(_wrap_AGSurface_valid), -1);
    rb_define_method(cAGSurface.klass, "blit", VALUEFUNC(_wrap_AGSurface_blit), -1);
    rb_define_method(cAGSurface.klass, "drawGradient", VALUEFUNC(_wrap_AGSurface_drawGradient), -1);
    rb_define_method(cAGSurface.klass, "drawGradientAlpha", VALUEFUNC(_wrap_AGSurface_drawGradientAlpha), -1);
    rb_define_method(cAGSurface.klass, "drawBorder", VALUEFUNC(_wrap_AGSurface_drawBorder), -1);
    rb_define_method(cAGSurface.klass, "putPixel", VALUEFUNC(_wrap_AGSurface_putPixel), -1);
    rb_define_method(cAGSurface.klass, "getPixel", VALUEFUNC(_wrap_AGSurface_getPixel), -1);
    cAGSurface.mark = 0;
    cAGSurface.destroy = (void (*)(void *)) free_AGSurface;
    
    cAGTexture.klass = rb_define_class_under(mLibantargis, "AGTexture", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTexture, (void *) &cAGTexture);
    rb_define_alloc_func(cAGTexture.klass, _wrap_AGTexture_allocate);
    rb_define_method(cAGTexture.klass, "initialize", VALUEFUNC(_wrap_new_AGTexture), -1);
    rb_define_method(cAGTexture.klass, "width", VALUEFUNC(_wrap_AGTexture_width), -1);
    rb_define_method(cAGTexture.klass, "height", VALUEFUNC(_wrap_AGTexture_height), -1);
    rb_define_method(cAGTexture.klass, "testSave", VALUEFUNC(_wrap_AGTexture_testSave), -1);
    rb_define_method(cAGTexture.klass, "getRect", VALUEFUNC(_wrap_AGTexture_getRect), -1);
    rb_define_method(cAGTexture.klass, "getPixel", VALUEFUNC(_wrap_AGTexture_getPixel), -1);
    rb_define_method(cAGTexture.klass, "getTW", VALUEFUNC(_wrap_AGTexture_getTW), -1);
    rb_define_method(cAGTexture.klass, "getTH", VALUEFUNC(_wrap_AGTexture_getTH), -1);
    rb_define_method(cAGTexture.klass, "hasTexture", VALUEFUNC(_wrap_AGTexture_hasTexture), -1);
    rb_define_method(cAGTexture.klass, "textureUsed", VALUEFUNC(_wrap_AGTexture_textureUsed), -1);
    rb_define_method(cAGTexture.klass, "clearTexture", VALUEFUNC(_wrap_AGTexture_clearTexture), -1);
    rb_define_method(cAGTexture.klass, "clearTextureUsed", VALUEFUNC(_wrap_AGTexture_clearTextureUsed), -1);
    rb_define_method(cAGTexture.klass, "setTextureID", VALUEFUNC(_wrap_AGTexture_setTextureID), -1);
    rb_define_method(cAGTexture.klass, "getTextureID", VALUEFUNC(_wrap_AGTexture_getTextureID), -1);
    rb_define_method(cAGTexture.klass, "surface", VALUEFUNC(_wrap_AGTexture_surface), -1);
    cAGTexture.mark = 0;
    cAGTexture.destroy = (void (*)(void *)) free_AGTexture;
    rb_define_module_function(mLibantargis, "disown_AGScreen", VALUEFUNC(_wrap_disown_AGScreen), -1);
    
    cAGScreen.klass = rb_define_class_under(mLibantargis, "AGScreen", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGScreen, (void *) &cAGScreen);
    rb_define_alloc_func(cAGScreen.klass, _wrap_AGScreen_allocate);
    rb_define_method(cAGScreen.klass, "initialize", VALUEFUNC(_wrap_new_AGScreen), -1);
    rb_define_method(cAGScreen.klass, "begin", VALUEFUNC(_wrap_AGScreen_begin), -1);
    rb_define_method(cAGScreen.klass, "flip", VALUEFUNC(_wrap_AGScreen_flip), -1);
    rb_define_method(cAGScreen.klass, "getWidth", VALUEFUNC(_wrap_AGScreen_getWidth), -1);
    rb_define_method(cAGScreen.klass, "getHeight", VALUEFUNC(_wrap_AGScreen_getHeight), -1);
    cAGScreen.mark = 0;
    cAGScreen.destroy = (void (*)(void *)) free_AGScreen;
    rb_define_module_function(mLibantargis, "getScreen", VALUEFUNC(_wrap_getScreen), -1);
    rb_define_module_function(mLibantargis, "setScreen", VALUEFUNC(_wrap_setScreen), -1);
    rb_define_module_function(mLibantargis, "getSurfaceManager", VALUEFUNC(_wrap_getSurfaceManager), -1);
    
    cAGSurfaceManager.klass = rb_define_class_under(mLibantargis, "AGSurfaceManager", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGSurfaceManager, (void *) &cAGSurfaceManager);
    rb_undef_alloc_func(cAGSurfaceManager.klass);
    rb_define_method(cAGSurfaceManager.klass, "loadSurface", VALUEFUNC(_wrap_AGSurfaceManager_loadSurface), -1);
    rb_define_method(cAGSurfaceManager.klass, "fromSDL", VALUEFUNC(_wrap_AGSurfaceManager_fromSDL), -1);
    rb_define_method(cAGSurfaceManager.klass, "registerSurface", VALUEFUNC(_wrap_AGSurfaceManager_registerSurface), -1);
    rb_define_method(cAGSurfaceManager.klass, "deregisterSurface", VALUEFUNC(_wrap_AGSurfaceManager_deregisterSurface), -1);
    rb_define_method(cAGSurfaceManager.klass, "cleanup", VALUEFUNC(_wrap_AGSurfaceManager_cleanup), -1);
    rb_define_method(cAGSurfaceManager.klass, "enableGC", VALUEFUNC(_wrap_AGSurfaceManager_enableGC), -1);
    rb_define_method(cAGSurfaceManager.klass, "disableGC", VALUEFUNC(_wrap_AGSurfaceManager_disableGC), -1);
    cAGSurfaceManager.mark = 0;
    cAGSurfaceManager.destroy = (void (*)(void *)) free_AGSurfaceManager;
    rb_define_module_function(mLibantargis, "getTextureManager", VALUEFUNC(_wrap_getTextureManager), -1);
    
    cAGTextureManager.klass = rb_define_class_under(mLibantargis, "AGTextureManager", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTextureManager, (void *) &cAGTextureManager);
    rb_undef_alloc_func(cAGTextureManager.klass);
    rb_define_method(cAGTextureManager.klass, "registerTexture", VALUEFUNC(_wrap_AGTextureManager_registerTexture), -1);
    rb_define_method(cAGTextureManager.klass, "deregisterTexture", VALUEFUNC(_wrap_AGTextureManager_deregisterTexture), -1);
    rb_define_method(cAGTextureManager.klass, "cleanup", VALUEFUNC(_wrap_AGTextureManager_cleanup), -1);
    rb_define_method(cAGTextureManager.klass, "checkUnused", VALUEFUNC(_wrap_AGTextureManager_checkUnused), -1);
    rb_define_method(cAGTextureManager.klass, "makeTexture", VALUEFUNC(_wrap_AGTextureManager_makeTexture), -1);
    cAGTextureManager.mark = 0;
    cAGTextureManager.destroy = (void (*)(void *)) free_AGTextureManager;
    rb_define_module_function(mLibantargis, "disown_AGSDLScreen", VALUEFUNC(_wrap_disown_AGSDLScreen), -1);
    
    cAGSDLScreen.klass = rb_define_class_under(mLibantargis, "AGSDLScreen", ((swig_class *) SWIGTYPE_p_AGScreen->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSDLScreen, (void *) &cAGSDLScreen);
    rb_define_alloc_func(cAGSDLScreen.klass, _wrap_AGSDLScreen_allocate);
    rb_define_method(cAGSDLScreen.klass, "initialize", VALUEFUNC(_wrap_new_AGSDLScreen), -1);
    rb_define_method(cAGSDLScreen.klass, "blit", VALUEFUNC(_wrap_AGSDLScreen_blit), -1);
    rb_define_method(cAGSDLScreen.klass, "tile", VALUEFUNC(_wrap_AGSDLScreen_tile), -1);
    rb_define_method(cAGSDLScreen.klass, "flip", VALUEFUNC(_wrap_AGSDLScreen_flip), -1);
    rb_define_method(cAGSDLScreen.klass, "getRect", VALUEFUNC(_wrap_AGSDLScreen_getRect), -1);
    rb_define_method(cAGSDLScreen.klass, "drawRect", VALUEFUNC(_wrap_AGSDLScreen_drawRect), -1);
    rb_define_method(cAGSDLScreen.klass, "drawLine", VALUEFUNC(_wrap_AGSDLScreen_drawLine), -1);
    rb_define_method(cAGSDLScreen.klass, "drawGradientAlpha", VALUEFUNC(_wrap_AGSDLScreen_drawGradientAlpha), -1);
    rb_define_method(cAGSDLScreen.klass, "drawGradient", VALUEFUNC(_wrap_AGSDLScreen_drawGradient), -1);
    rb_define_method(cAGSDLScreen.klass, "renderText", VALUEFUNC(_wrap_AGSDLScreen_renderText), -1);
    rb_define_method(cAGSDLScreen.klass, "drawBorder", VALUEFUNC(_wrap_AGSDLScreen_drawBorder), -1);
    rb_define_method(cAGSDLScreen.klass, "putPixel", VALUEFUNC(_wrap_AGSDLScreen_putPixel), -1);
    rb_define_method(cAGSDLScreen.klass, "newSurface", VALUEFUNC(_wrap_AGSDLScreen_newSurface), -1);
    rb_define_method(cAGSDLScreen.klass, "loadSurface", VALUEFUNC(_wrap_AGSDLScreen_loadSurface), -1);
    rb_define_method(cAGSDLScreen.klass, "displayFormat", VALUEFUNC(_wrap_AGSDLScreen_displayFormat), -1);
    rb_define_method(cAGSDLScreen.klass, "makeTexture", VALUEFUNC(_wrap_AGSDLScreen_makeTexture), -1);
    rb_define_method(cAGSDLScreen.klass, "getWidth", VALUEFUNC(_wrap_AGSDLScreen_getWidth), -1);
    rb_define_method(cAGSDLScreen.klass, "getHeight", VALUEFUNC(_wrap_AGSDLScreen_getHeight), -1);
    cAGSDLScreen.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGSDLScreen.destroy = (void (*)(void *)) free_AGSDLScreen;
    rb_define_module_function(mLibantargis, "disown_AGEvent", VALUEFUNC(_wrap_disown_AGEvent), -1);
    
    cAGEvent.klass = rb_define_class_under(mLibantargis, "AGEvent", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGEvent, (void *) &cAGEvent);
    rb_define_alloc_func(cAGEvent.klass, _wrap_AGEvent_allocate);
    rb_define_method(cAGEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGEvent), -1);
    rb_define_method(cAGEvent.klass, "getCaller", VALUEFUNC(_wrap_AGEvent_getCaller), -1);
    cAGEvent.mark = 0;
    cAGEvent.destroy = (void (*)(void *)) free_AGEvent;
    rb_define_module_function(mLibantargis, "disown_AGSDLEvent", VALUEFUNC(_wrap_disown_AGSDLEvent), -1);
    
    cAGSDLEvent.klass = rb_define_class_under(mLibantargis, "AGSDLEvent", ((swig_class *) SWIGTYPE_p_AGEvent->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSDLEvent, (void *) &cAGSDLEvent);
    rb_define_alloc_func(cAGSDLEvent.klass, _wrap_AGSDLEvent_allocate);
    rb_define_method(cAGSDLEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGSDLEvent), -1);
    rb_define_method(cAGSDLEvent.klass, "getMousePosition", VALUEFUNC(_wrap_AGSDLEvent_getMousePosition), -1);
    rb_define_method(cAGSDLEvent.klass, "getKey", VALUEFUNC(_wrap_AGSDLEvent_getKey), -1);
    rb_define_method(cAGSDLEvent.klass, "getMod", VALUEFUNC(_wrap_AGSDLEvent_getMod), -1);
    rb_define_method(cAGSDLEvent.klass, "getButton", VALUEFUNC(_wrap_AGSDLEvent_getButton), -1);
    rb_define_method(cAGSDLEvent.klass, "get", VALUEFUNC(_wrap_AGSDLEvent_get), -1);
    cAGSDLEvent.mark = 0;
    cAGSDLEvent.destroy = (void (*)(void *)) free_AGSDLEvent;
    rb_define_module_function(mLibantargis, "disown_AGMouseEvent", VALUEFUNC(_wrap_disown_AGMouseEvent), -1);
    
    cAGMouseEvent.klass = rb_define_class_under(mLibantargis, "AGMouseEvent", ((swig_class *) SWIGTYPE_p_AGEvent->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMouseEvent, (void *) &cAGMouseEvent);
    rb_define_alloc_func(cAGMouseEvent.klass, _wrap_AGMouseEvent_allocate);
    rb_define_method(cAGMouseEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGMouseEvent), -1);
    cAGMouseEvent.mark = 0;
    cAGMouseEvent.destroy = (void (*)(void *)) free_AGMouseEvent;
    rb_define_module_function(mLibantargis, "disown_AGListener", VALUEFUNC(_wrap_disown_AGListener), -1);
    
    cAGListener.klass = rb_define_class_under(mLibantargis, "AGListener", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGListener, (void *) &cAGListener);
    rb_define_alloc_func(cAGListener.klass, _wrap_AGListener_allocate);
    rb_define_method(cAGListener.klass, "initialize", VALUEFUNC(_wrap_new_AGListener), -1);
    rb_define_method(cAGListener.klass, "signal", VALUEFUNC(_wrap_AGListener_signal), -1);
    cAGListener.mark = 0;
    cAGListener.destroy = (void (*)(void *)) free_AGListener;
    rb_define_module_function(mLibantargis, "disown_AGCPPListener", VALUEFUNC(_wrap_disown_AGCPPListener), -1);
    
    cAGCPPListener.klass = rb_define_class_under(mLibantargis, "AGCPPListener", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCPPListener, (void *) &cAGCPPListener);
    rb_define_alloc_func(cAGCPPListener.klass, _wrap_AGCPPListener_allocate);
    rb_define_method(cAGCPPListener.klass, "initialize", VALUEFUNC(_wrap_new_AGCPPListener), -1);
    rb_define_method(cAGCPPListener.klass, "signal", VALUEFUNC(_wrap_AGCPPListener_signal), -1);
    cAGCPPListener.mark = 0;
    cAGCPPListener.destroy = (void (*)(void *)) free_AGCPPListener;
    rb_define_module_function(mLibantargis, "disown_AGSignal", VALUEFUNC(_wrap_disown_AGSignal), -1);
    
    cAGSignal.klass = rb_define_class_under(mLibantargis, "AGSignal", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGSignal, (void *) &cAGSignal);
    rb_define_alloc_func(cAGSignal.klass, _wrap_AGSignal_allocate);
    rb_define_method(cAGSignal.klass, "initialize", VALUEFUNC(_wrap_new_AGSignal), -1);
    rb_define_method(cAGSignal.klass, "connect", VALUEFUNC(_wrap_AGSignal_connect), -1);
    rb_define_method(cAGSignal.klass, "disconnect", VALUEFUNC(_wrap_AGSignal_disconnect), -1);
    rb_define_method(cAGSignal.klass, "signal", VALUEFUNC(_wrap_AGSignal_signal), -1);
    rb_define_method(cAGSignal.klass, "call", VALUEFUNC(_wrap_AGSignal___call__), -1);
    cAGSignal.mark = 0;
    cAGSignal.destroy = (void (*)(void *)) free_AGSignal;
    rb_define_module_function(mLibantargis, "disown_AGMessageObject", VALUEFUNC(_wrap_disown_AGMessageObject), -1);
    
    cAGMessageObject.klass = rb_define_class_under(mLibantargis, "AGMessageObject", ((swig_class *) SWIGTYPE_p_AGListener->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMessageObject, (void *) &cAGMessageObject);
    rb_define_alloc_func(cAGMessageObject.klass, _wrap_AGMessageObject_allocate);
    rb_define_method(cAGMessageObject.klass, "initialize", VALUEFUNC(_wrap_new_AGMessageObject), -1);
    rb_define_method(cAGMessageObject.klass, "processEvent", VALUEFUNC(_wrap_AGMessageObject_processEvent), -1);
    rb_define_method(cAGMessageObject.klass, "acceptEvent", VALUEFUNC(_wrap_AGMessageObject_acceptEvent), -1);
    rb_define_method(cAGMessageObject.klass, "eventActive", VALUEFUNC(_wrap_AGMessageObject_eventActive), -1);
    rb_define_method(cAGMessageObject.klass, "eventKeyDown", VALUEFUNC(_wrap_AGMessageObject_eventKeyDown), -1);
    rb_define_method(cAGMessageObject.klass, "eventKeyUp", VALUEFUNC(_wrap_AGMessageObject_eventKeyUp), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseMotion", VALUEFUNC(_wrap_AGMessageObject_eventMouseMotion), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGMessageObject_eventMouseButtonDown), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGMessageObject_eventMouseButtonUp), -1);
    rb_define_method(cAGMessageObject.klass, "eventQuit", VALUEFUNC(_wrap_AGMessageObject_eventQuit), -1);
    rb_define_method(cAGMessageObject.klass, "eventQuitModal", VALUEFUNC(_wrap_AGMessageObject_eventQuitModal), -1);
    rb_define_method(cAGMessageObject.klass, "eventSysWM", VALUEFUNC(_wrap_AGMessageObject_eventSysWM), -1);
    rb_define_method(cAGMessageObject.klass, "eventResize", VALUEFUNC(_wrap_AGMessageObject_eventResize), -1);
    rb_define_method(cAGMessageObject.klass, "getButtonState", VALUEFUNC(_wrap_AGMessageObject_getButtonState), -1);
    rb_define_method(cAGMessageObject.klass, "getMousePosition", VALUEFUNC(_wrap_AGMessageObject_getMousePosition), -1);
    rb_define_method(cAGMessageObject.klass, "sigActive=", VALUEFUNC(_wrap_AGMessageObject_sigActive_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigActive", VALUEFUNC(_wrap_AGMessageObject_sigActive_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyDown=", VALUEFUNC(_wrap_AGMessageObject_sigKeyDown_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyDown", VALUEFUNC(_wrap_AGMessageObject_sigKeyDown_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyUp=", VALUEFUNC(_wrap_AGMessageObject_sigKeyUp_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyUp", VALUEFUNC(_wrap_AGMessageObject_sigKeyUp_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseMotion=", VALUEFUNC(_wrap_AGMessageObject_sigMouseMotion_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseMotion", VALUEFUNC(_wrap_AGMessageObject_sigMouseMotion_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonDown=", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonDown_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonDown", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonDown_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonUp=", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonUp_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonUp", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonUp_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigQuit=", VALUEFUNC(_wrap_AGMessageObject_sigQuit_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigQuit", VALUEFUNC(_wrap_AGMessageObject_sigQuit_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigSysWM=", VALUEFUNC(_wrap_AGMessageObject_sigSysWM_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigSysWM", VALUEFUNC(_wrap_AGMessageObject_sigSysWM_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigVideoResize=", VALUEFUNC(_wrap_AGMessageObject_sigVideoResize_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigVideoResize", VALUEFUNC(_wrap_AGMessageObject_sigVideoResize_get), -1);
    rb_define_method(cAGMessageObject.klass, "pushSignal", VALUEFUNC(_wrap_AGMessageObject_pushSignal), -1);
    rb_define_method(cAGMessageObject.klass, "popSignal", VALUEFUNC(_wrap_AGMessageObject_popSignal), -1);
    cAGMessageObject.mark = 0;
    cAGMessageObject.destroy = (void (*)(void *)) free_AGMessageObject;
    rb_define_module_function(mLibantargis, "newEvent", VALUEFUNC(_wrap_newEvent), -1);
    rb_define_module_function(mLibantargis, "toAGSDLEvent", VALUEFUNC(_wrap_toAGSDLEvent), -1);
    rb_define_module_function(mLibantargis, "AGWidget_markfunc", VALUEFUNC(_wrap_AGWidget_markfunc), -1);
    rb_define_module_function(mLibantargis, "disown_AGWidget", VALUEFUNC(_wrap_disown_AGWidget), -1);
    
    cAGWidget.klass = rb_define_class_under(mLibantargis, "AGWidget", ((swig_class *) SWIGTYPE_p_AGMessageObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGWidget, (void *) &cAGWidget);
    rb_define_alloc_func(cAGWidget.klass, _wrap_AGWidget_allocate);
    rb_define_method(cAGWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGWidget), -1);
    rb_define_method(cAGWidget.klass, "draw", VALUEFUNC(_wrap_AGWidget_draw), -1);
    rb_define_method(cAGWidget.klass, "drawAll", VALUEFUNC(_wrap_AGWidget_drawAll), -1);
    rb_define_method(cAGWidget.klass, "getRect", VALUEFUNC(_wrap_AGWidget_getRect), -1);
    rb_define_method(cAGWidget.klass, "getClientRect", VALUEFUNC(_wrap_AGWidget_getClientRect), -1);
    rb_define_method(cAGWidget.klass, "setRect", VALUEFUNC(_wrap_AGWidget_setRect), -1);
    rb_define_method(cAGWidget.klass, "setParent", VALUEFUNC(_wrap_AGWidget_setParent), -1);
    rb_define_method(cAGWidget.klass, "getParent", VALUEFUNC(_wrap_AGWidget_getParent), -1);
    rb_define_method(cAGWidget.klass, "eventShow", VALUEFUNC(_wrap_AGWidget_eventShow), -1);
    rb_define_method(cAGWidget.klass, "eventHide", VALUEFUNC(_wrap_AGWidget_eventHide), -1);
    rb_define_method(cAGWidget.klass, "eventMouseMotion", VALUEFUNC(_wrap_AGWidget_eventMouseMotion), -1);
    rb_define_method(cAGWidget.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGWidget_eventMouseEnter), -1);
    rb_define_method(cAGWidget.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGWidget_eventMouseLeave), -1);
    rb_define_method(cAGWidget.klass, "eventMouseClick", VALUEFUNC(_wrap_AGWidget_eventMouseClick), -1);
    rb_define_method(cAGWidget.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGWidget_eventMouseButtonDown), -1);
    rb_define_method(cAGWidget.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGWidget_eventMouseButtonUp), -1);
    rb_define_method(cAGWidget.klass, "eventGotFocus", VALUEFUNC(_wrap_AGWidget_eventGotFocus), -1);
    rb_define_method(cAGWidget.klass, "eventLostFocus", VALUEFUNC(_wrap_AGWidget_eventLostFocus), -1);
    rb_define_method(cAGWidget.klass, "canFocus", VALUEFUNC(_wrap_AGWidget_canFocus), -1);
    rb_define_method(cAGWidget.klass, "processEvent", VALUEFUNC(_wrap_AGWidget_processEvent), -1);
    rb_define_method(cAGWidget.klass, "sigMouseEnter=", VALUEFUNC(_wrap_AGWidget_sigMouseEnter_set), -1);
    rb_define_method(cAGWidget.klass, "sigMouseEnter", VALUEFUNC(_wrap_AGWidget_sigMouseEnter_get), -1);
    rb_define_method(cAGWidget.klass, "sigMouseLeave=", VALUEFUNC(_wrap_AGWidget_sigMouseLeave_set), -1);
    rb_define_method(cAGWidget.klass, "sigMouseLeave", VALUEFUNC(_wrap_AGWidget_sigMouseLeave_get), -1);
    rb_define_method(cAGWidget.klass, "sigClick=", VALUEFUNC(_wrap_AGWidget_sigClick_set), -1);
    rb_define_method(cAGWidget.klass, "sigClick", VALUEFUNC(_wrap_AGWidget_sigClick_get), -1);
    rb_define_method(cAGWidget.klass, "minWidth", VALUEFUNC(_wrap_AGWidget_minWidth), -1);
    rb_define_method(cAGWidget.klass, "minHeight", VALUEFUNC(_wrap_AGWidget_minHeight), -1);
    rb_define_method(cAGWidget.klass, "width", VALUEFUNC(_wrap_AGWidget_width), -1);
    rb_define_method(cAGWidget.klass, "height", VALUEFUNC(_wrap_AGWidget_height), -1);
    rb_define_method(cAGWidget.klass, "top", VALUEFUNC(_wrap_AGWidget_top), -1);
    rb_define_method(cAGWidget.klass, "left", VALUEFUNC(_wrap_AGWidget_left), -1);
    rb_define_method(cAGWidget.klass, "setWidth", VALUEFUNC(_wrap_AGWidget_setWidth), -1);
    rb_define_method(cAGWidget.klass, "setHeight", VALUEFUNC(_wrap_AGWidget_setHeight), -1);
    rb_define_method(cAGWidget.klass, "setTop", VALUEFUNC(_wrap_AGWidget_setTop), -1);
    rb_define_method(cAGWidget.klass, "setLeft", VALUEFUNC(_wrap_AGWidget_setLeft), -1);
    rb_define_method(cAGWidget.klass, "fixedWidth", VALUEFUNC(_wrap_AGWidget_fixedWidth), -1);
    rb_define_method(cAGWidget.klass, "fixedHeight", VALUEFUNC(_wrap_AGWidget_fixedHeight), -1);
    rb_define_method(cAGWidget.klass, "show", VALUEFUNC(_wrap_AGWidget_show), -1);
    rb_define_method(cAGWidget.klass, "hide", VALUEFUNC(_wrap_AGWidget_hide), -1);
    rb_define_method(cAGWidget.klass, "addChild", VALUEFUNC(_wrap_AGWidget_addChild), -1);
    rb_define_method(cAGWidget.klass, "addChildBack", VALUEFUNC(_wrap_AGWidget_addChildBack), -1);
    rb_define_method(cAGWidget.klass, "removeChild", VALUEFUNC(_wrap_AGWidget_removeChild), -1);
    rb_define_method(cAGWidget.klass, "clear", VALUEFUNC(_wrap_AGWidget_clear), -1);
    rb_define_method(cAGWidget.klass, "getScreenRect", VALUEFUNC(_wrap_AGWidget_getScreenRect), -1);
    rb_define_method(cAGWidget.klass, "getScreenPosition", VALUEFUNC(_wrap_AGWidget_getScreenPosition), -1);
    rb_define_method(cAGWidget.klass, "fromScreen", VALUEFUNC(_wrap_AGWidget_fromScreen), -1);
    rb_define_method(cAGWidget.klass, "gainFocus", VALUEFUNC(_wrap_AGWidget_gainFocus), -1);
    rb_define_method(cAGWidget.klass, "gainCompleteFocus", VALUEFUNC(_wrap_AGWidget_gainCompleteFocus), -1);
    rb_define_method(cAGWidget.klass, "eventDragBy", VALUEFUNC(_wrap_AGWidget_eventDragBy), -1);
    rb_define_method(cAGWidget.klass, "getFocus", VALUEFUNC(_wrap_AGWidget_getFocus), -1);
    rb_define_method(cAGWidget.klass, "hasFocus", VALUEFUNC(_wrap_AGWidget_hasFocus), -1);
    rb_define_method(cAGWidget.klass, "getName", VALUEFUNC(_wrap_AGWidget_getName), -1);
    rb_define_method(cAGWidget.klass, "setName", VALUEFUNC(_wrap_AGWidget_setName), -1);
    rb_define_method(cAGWidget.klass, "getChild", VALUEFUNC(_wrap_AGWidget_getChild), -1);
    rb_define_method(cAGWidget.klass, "setModal", VALUEFUNC(_wrap_AGWidget_setModal), -1);
    rb_define_method(cAGWidget.klass, "erase", VALUEFUNC(_wrap_AGWidget_erase), -1);
    rb_define_method(cAGWidget.klass, "eventChildrenDeleted", VALUEFUNC(_wrap_AGWidget_eventChildrenDeleted), -1);
    cAGWidget.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGWidget.destroy = (void (*)(void *)) free_AGWidget;
    rb_define_module_function(mLibantargis, "toAGWidget", VALUEFUNC(_wrap_toAGWidget), -1);
    rb_define_singleton_method(mLibantargis, "agNoParent", VALUEFUNC(agNoParent_get), 0);
    rb_define_singleton_method(mLibantargis, "agNoParent=", VALUEFUNC(agNoParent_set), 1);
    
    cAGPoint.klass = rb_define_class_under(mLibantargis, "AGPoint", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGPoint, (void *) &cAGPoint);
    rb_define_alloc_func(cAGPoint.klass, _wrap_AGPoint_allocate);
    rb_define_method(cAGPoint.klass, "initialize", VALUEFUNC(_wrap_new_AGPoint), -1);
    rb_define_method(cAGPoint.klass, "x=", VALUEFUNC(_wrap_AGPoint_x_set), -1);
    rb_define_method(cAGPoint.klass, "x", VALUEFUNC(_wrap_AGPoint_x_get), -1);
    rb_define_method(cAGPoint.klass, "y=", VALUEFUNC(_wrap_AGPoint_y_set), -1);
    rb_define_method(cAGPoint.klass, "y", VALUEFUNC(_wrap_AGPoint_y_get), -1);
    rb_define_method(cAGPoint.klass, "-", VALUEFUNC(_wrap_AGPoint___sub__), -1);
    rb_define_method(cAGPoint.klass, "+", VALUEFUNC(_wrap_AGPoint___add__), -1);
    cAGPoint.mark = 0;
    cAGPoint.destroy = (void (*)(void *)) free_AGPoint;
    
    cAGRect.klass = rb_define_class_under(mLibantargis, "AGRect", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect, (void *) &cAGRect);
    rb_define_alloc_func(cAGRect.klass, _wrap_AGRect_allocate);
    rb_define_method(cAGRect.klass, "initialize", VALUEFUNC(_wrap_new_AGRect), -1);
    rb_define_method(cAGRect.klass, "setX", VALUEFUNC(_wrap_AGRect_setX), -1);
    rb_define_method(cAGRect.klass, "setY", VALUEFUNC(_wrap_AGRect_setY), -1);
    rb_define_method(cAGRect.klass, "setW", VALUEFUNC(_wrap_AGRect_setW), -1);
    rb_define_method(cAGRect.klass, "setH", VALUEFUNC(_wrap_AGRect_setH), -1);
    rb_define_method(cAGRect.klass, "getX", VALUEFUNC(_wrap_AGRect_getX), -1);
    rb_define_method(cAGRect.klass, "getY", VALUEFUNC(_wrap_AGRect_getY), -1);
    rb_define_method(cAGRect.klass, "width", VALUEFUNC(_wrap_AGRect_width), -1);
    rb_define_method(cAGRect.klass, "height", VALUEFUNC(_wrap_AGRect_height), -1);
    rb_define_method(cAGRect.klass, "intersect", VALUEFUNC(_wrap_AGRect_intersect), -1);
    rb_define_method(cAGRect.klass, "isNull", VALUEFUNC(_wrap_AGRect_isNull), -1);
    rb_define_method(cAGRect.klass, "shrink", VALUEFUNC(_wrap_AGRect_shrink), -1);
    rb_define_method(cAGRect.klass, "shrinkRB", VALUEFUNC(_wrap_AGRect_shrinkRB), -1);
    rb_define_method(cAGRect.klass, "contains", VALUEFUNC(_wrap_AGRect_contains), -1);
    rb_define_method(cAGRect.klass, "project", VALUEFUNC(_wrap_AGRect_project), -1);
    rb_define_method(cAGRect.klass, "getMiddle", VALUEFUNC(_wrap_AGRect_getMiddle), -1);
    rb_define_method(cAGRect.klass, "origin", VALUEFUNC(_wrap_AGRect_origin), -1);
    rb_define_method(cAGRect.klass, "getPosition", VALUEFUNC(_wrap_AGRect_getPosition), -1);
    rb_define_method(cAGRect.klass, "to_s", VALUEFUNC(_wrap_AGRect_to_s), -1);
    rb_define_method(cAGRect.klass, "==", VALUEFUNC(_wrap_AGRect___eq__), -1);
    rb_define_method(cAGRect.klass, "+", VALUEFUNC(_wrap_AGRect___add__), -1);
    cAGRect.mark = 0;
    cAGRect.destroy = (void (*)(void *)) free_AGRect;
    
    cAGAngle.klass = rb_define_class_under(mLibantargis, "AGAngle", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGAngle, (void *) &cAGAngle);
    rb_define_alloc_func(cAGAngle.klass, _wrap_AGAngle_allocate);
    rb_define_method(cAGAngle.klass, "initialize", VALUEFUNC(_wrap_new_AGAngle), -1);
    rb_define_method(cAGAngle.klass, "angle=", VALUEFUNC(_wrap_AGAngle_angle_set), -1);
    rb_define_method(cAGAngle.klass, "angle", VALUEFUNC(_wrap_AGAngle_angle_get), -1);
    cAGAngle.mark = 0;
    cAGAngle.destroy = (void (*)(void *)) free_AGAngle;
    
    cAGVector2.klass = rb_define_class_under(mLibantargis, "AGVector2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector2, (void *) &cAGVector2);
    rb_define_alloc_func(cAGVector2.klass, _wrap_AGVector2_allocate);
    rb_define_method(cAGVector2.klass, "initialize", VALUEFUNC(_wrap_new_AGVector2), -1);
    rb_define_method(cAGVector2.klass, "v=", VALUEFUNC(_wrap_AGVector2_v_set), -1);
    rb_define_method(cAGVector2.klass, "v", VALUEFUNC(_wrap_AGVector2_v_get), -1);
    rb_define_method(cAGVector2.klass, "setX", VALUEFUNC(_wrap_AGVector2_setX), -1);
    rb_define_method(cAGVector2.klass, "setY", VALUEFUNC(_wrap_AGVector2_setY), -1);
    rb_define_method(cAGVector2.klass, "x", VALUEFUNC(_wrap_AGVector2_x), -1);
    rb_define_method(cAGVector2.klass, "y", VALUEFUNC(_wrap_AGVector2_y), -1);
    rb_define_method(cAGVector2.klass, "getAngle", VALUEFUNC(_wrap_AGVector2_getAngle), -1);
    rb_define_method(cAGVector2.klass, "-", VALUEFUNC(_wrap_AGVector2___sub__), -1);
    rb_define_method(cAGVector2.klass, "+", VALUEFUNC(_wrap_AGVector2___add__), -1);
    rb_define_method(cAGVector2.klass, "*", VALUEFUNC(_wrap_AGVector2___mul__), -1);
    rb_define_method(cAGVector2.klass, "/", VALUEFUNC(_wrap_AGVector2___div__), -1);
    rb_define_method(cAGVector2.klass, "==", VALUEFUNC(_wrap_AGVector2___eq__), -1);
    rb_define_method(cAGVector2.klass, "length", VALUEFUNC(_wrap_AGVector2_length), -1);
    rb_define_method(cAGVector2.klass, "length2", VALUEFUNC(_wrap_AGVector2_length2), -1);
    rb_define_method(cAGVector2.klass, "normalized", VALUEFUNC(_wrap_AGVector2_normalized), -1);
    rb_define_method(cAGVector2.klass, "normalize", VALUEFUNC(_wrap_AGVector2_normalize), -1);
    rb_define_method(cAGVector2.klass, "normal", VALUEFUNC(_wrap_AGVector2_normal), -1);
    rb_define_method(cAGVector2.klass, "nonZero", VALUEFUNC(_wrap_AGVector2_nonZero), -1);
    rb_define_method(cAGVector2.klass, "saveXML", VALUEFUNC(_wrap_AGVector2_saveXML), -1);
    rb_define_method(cAGVector2.klass, "loadXML", VALUEFUNC(_wrap_AGVector2_loadXML), -1);
    rb_define_method(cAGVector2.klass, "to_s", VALUEFUNC(_wrap_AGVector2_to_s), -1);
    cAGVector2.mark = 0;
    cAGVector2.destroy = (void (*)(void *)) free_AGVector2;
    
    cAGVector3.klass = rb_define_class_under(mLibantargis, "AGVector3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector3, (void *) &cAGVector3);
    rb_define_alloc_func(cAGVector3.klass, _wrap_AGVector3_allocate);
    rb_define_method(cAGVector3.klass, "initialize", VALUEFUNC(_wrap_new_AGVector3), -1);
    rb_define_method(cAGVector3.klass, "v=", VALUEFUNC(_wrap_AGVector3_v_set), -1);
    rb_define_method(cAGVector3.klass, "v", VALUEFUNC(_wrap_AGVector3_v_get), -1);
    rb_define_method(cAGVector3.klass, "setX", VALUEFUNC(_wrap_AGVector3_setX), -1);
    rb_define_method(cAGVector3.klass, "setY", VALUEFUNC(_wrap_AGVector3_setY), -1);
    rb_define_method(cAGVector3.klass, "setZ", VALUEFUNC(_wrap_AGVector3_setZ), -1);
    rb_define_method(cAGVector3.klass, "x", VALUEFUNC(_wrap_AGVector3_x), -1);
    rb_define_method(cAGVector3.klass, "y", VALUEFUNC(_wrap_AGVector3_y), -1);
    rb_define_method(cAGVector3.klass, "z", VALUEFUNC(_wrap_AGVector3_z), -1);
    rb_define_method(cAGVector3.klass, "getAngle", VALUEFUNC(_wrap_AGVector3_getAngle), -1);
    rb_define_method(cAGVector3.klass, "-", VALUEFUNC(_wrap_AGVector3___sub__), -1);
    rb_define_method(cAGVector3.klass, "+", VALUEFUNC(_wrap_AGVector3___add__), -1);
    rb_define_method(cAGVector3.klass, "add", VALUEFUNC(_wrap_AGVector3_add), -1);
    rb_define_method(cAGVector3.klass, "sub", VALUEFUNC(_wrap_AGVector3_sub), -1);
    rb_define_method(cAGVector3.klass, "*", VALUEFUNC(_wrap_AGVector3___mul__), -1);
    rb_define_method(cAGVector3.klass, "/", VALUEFUNC(_wrap_AGVector3___div__), -1);
    rb_define_method(cAGVector3.klass, "%", VALUEFUNC(_wrap_AGVector3___mod__), -1);
    rb_define_method(cAGVector3.klass, "==", VALUEFUNC(_wrap_AGVector3___eq__), -1);
    rb_define_method(cAGVector3.klass, "length", VALUEFUNC(_wrap_AGVector3_length), -1);
    rb_define_method(cAGVector3.klass, "length2", VALUEFUNC(_wrap_AGVector3_length2), -1);
    rb_define_method(cAGVector3.klass, "normalized", VALUEFUNC(_wrap_AGVector3_normalized), -1);
    rb_define_method(cAGVector3.klass, "normalize", VALUEFUNC(_wrap_AGVector3_normalize), -1);
    rb_define_method(cAGVector3.klass, "normal", VALUEFUNC(_wrap_AGVector3_normal), -1);
    rb_define_method(cAGVector3.klass, "nonZero", VALUEFUNC(_wrap_AGVector3_nonZero), -1);
    rb_define_method(cAGVector3.klass, "saveXML", VALUEFUNC(_wrap_AGVector3_saveXML), -1);
    rb_define_method(cAGVector3.klass, "loadXML", VALUEFUNC(_wrap_AGVector3_loadXML), -1);
    rb_define_method(cAGVector3.klass, "to_s", VALUEFUNC(_wrap_AGVector3_to_s), -1);
    cAGVector3.mark = 0;
    cAGVector3.destroy = (void (*)(void *)) free_AGVector3;
    
    cAGPoint3.klass = rb_define_class_under(mLibantargis, "AGPoint3", ((swig_class *) SWIGTYPE_p_AGVector3->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGPoint3, (void *) &cAGPoint3);
    rb_define_alloc_func(cAGPoint3.klass, _wrap_AGPoint3_allocate);
    rb_define_method(cAGPoint3.klass, "initialize", VALUEFUNC(_wrap_new_AGPoint3), -1);
    cAGPoint3.mark = 0;
    cAGPoint3.destroy = (void (*)(void *)) free_AGPoint3;
    
    cAGMatrix3.klass = rb_define_class_under(mLibantargis, "AGMatrix3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMatrix3, (void *) &cAGMatrix3);
    rb_define_alloc_func(cAGMatrix3.klass, _wrap_AGMatrix3_allocate);
    rb_define_method(cAGMatrix3.klass, "initialize", VALUEFUNC(_wrap_new_AGMatrix3), -1);
    rb_define_method(cAGMatrix3.klass, "set", VALUEFUNC(_wrap_AGMatrix3_set), -1);
    rb_define_method(cAGMatrix3.klass, "get", VALUEFUNC(_wrap_AGMatrix3_get), -1);
    rb_define_method(cAGMatrix3.klass, "*", VALUEFUNC(_wrap_AGMatrix3___mul__), -1);
    rb_define_method(cAGMatrix3.klass, "-@", VALUEFUNC(_wrap_AGMatrix3___neg__), -1);
    rb_define_method(cAGMatrix3.klass, "inverted", VALUEFUNC(_wrap_AGMatrix3_inverted), -1);
    rb_define_method(cAGMatrix3.klass, "transposed", VALUEFUNC(_wrap_AGMatrix3_transposed), -1);
    rb_define_method(cAGMatrix3.klass, "to_s", VALUEFUNC(_wrap_AGMatrix3_to_s), -1);
    cAGMatrix3.mark = 0;
    cAGMatrix3.destroy = (void (*)(void *)) free_AGMatrix3;
    
    cAGLine2.klass = rb_define_class_under(mLibantargis, "AGLine2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLine2, (void *) &cAGLine2);
    rb_define_alloc_func(cAGLine2.klass, _wrap_AGLine2_allocate);
    rb_define_method(cAGLine2.klass, "initialize", VALUEFUNC(_wrap_new_AGLine2), -1);
    rb_define_method(cAGLine2.klass, "getV0", VALUEFUNC(_wrap_AGLine2_getV0), -1);
    rb_define_method(cAGLine2.klass, "getV1", VALUEFUNC(_wrap_AGLine2_getV1), -1);
    rb_define_method(cAGLine2.klass, "has", VALUEFUNC(_wrap_AGLine2_has), -1);
    rb_define_method(cAGLine2.klass, "collide", VALUEFUNC(_wrap_AGLine2_collide), -1);
    rb_define_method(cAGLine2.klass, "collisionPoint", VALUEFUNC(_wrap_AGLine2_collisionPoint), -1);
    rb_define_method(cAGLine2.klass, "collisionPointNI", VALUEFUNC(_wrap_AGLine2_collisionPointNI), -1);
    rb_define_method(cAGLine2.klass, "includes", VALUEFUNC(_wrap_AGLine2_includes), -1);
    rb_define_method(cAGLine2.klass, "getBBox", VALUEFUNC(_wrap_AGLine2_getBBox), -1);
    rb_define_method(cAGLine2.klass, "normal", VALUEFUNC(_wrap_AGLine2_normal), -1);
    rb_define_method(cAGLine2.klass, "direction", VALUEFUNC(_wrap_AGLine2_direction), -1);
    rb_define_method(cAGLine2.klass, "distance", VALUEFUNC(_wrap_AGLine2_distance), -1);
    rb_define_method(cAGLine2.klass, "to_s", VALUEFUNC(_wrap_AGLine2_to_s), -1);
    cAGLine2.mark = 0;
    cAGLine2.destroy = (void (*)(void *)) free_AGLine2;
    
    cAGLine3.klass = rb_define_class_under(mLibantargis, "AGLine3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLine3, (void *) &cAGLine3);
    rb_define_alloc_func(cAGLine3.klass, _wrap_AGLine3_allocate);
    rb_define_method(cAGLine3.klass, "initialize", VALUEFUNC(_wrap_new_AGLine3), -1);
    rb_define_method(cAGLine3.klass, "getV0", VALUEFUNC(_wrap_AGLine3_getV0), -1);
    rb_define_method(cAGLine3.klass, "getV1", VALUEFUNC(_wrap_AGLine3_getV1), -1);
    rb_define_method(cAGLine3.klass, "has", VALUEFUNC(_wrap_AGLine3_has), -1);
    rb_define_method(cAGLine3.klass, "direction", VALUEFUNC(_wrap_AGLine3_direction), -1);
    rb_define_method(cAGLine3.klass, "distance", VALUEFUNC(_wrap_AGLine3_distance), -1);
    rb_define_method(cAGLine3.klass, "to_s", VALUEFUNC(_wrap_AGLine3_to_s), -1);
    cAGLine3.mark = 0;
    cAGLine3.destroy = (void (*)(void *)) free_AGLine3;
    
    cAGCollisionData.klass = rb_define_class_under(mLibantargis, "AGCollisionData", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCollisionData, (void *) &cAGCollisionData);
    rb_define_alloc_func(cAGCollisionData.klass, _wrap_AGCollisionData_allocate);
    rb_define_method(cAGCollisionData.klass, "initialize", VALUEFUNC(_wrap_new_AGCollisionData), -1);
    cAGCollisionData.mark = 0;
    cAGCollisionData.destroy = (void (*)(void *)) free_AGCollisionData;
    
    cAGTriangle2.klass = rb_define_class_under(mLibantargis, "AGTriangle2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTriangle2, (void *) &cAGTriangle2);
    rb_define_alloc_func(cAGTriangle2.klass, _wrap_AGTriangle2_allocate);
    rb_define_method(cAGTriangle2.klass, "initialize", VALUEFUNC(_wrap_new_AGTriangle2), -1);
    rb_define_method(cAGTriangle2.klass, "get", VALUEFUNC(_wrap_AGTriangle2_get), -1);
    rb_define_method(cAGTriangle2.klass, "collide", VALUEFUNC(_wrap_AGTriangle2_collide), -1);
    rb_define_method(cAGTriangle2.klass, "getNormals", VALUEFUNC(_wrap_AGTriangle2_getNormals), -1);
    rb_define_method(cAGTriangle2.klass, "apply", VALUEFUNC(_wrap_AGTriangle2_apply), -1);
    rb_define_method(cAGTriangle2.klass, "applied", VALUEFUNC(_wrap_AGTriangle2_applied), -1);
    rb_define_method(cAGTriangle2.klass, "touchPoint", VALUEFUNC(_wrap_AGTriangle2_touchPoint), -1);
    rb_define_method(cAGTriangle2.klass, "touchVector", VALUEFUNC(_wrap_AGTriangle2_touchVector), -1);
    rb_define_method(cAGTriangle2.klass, "collisionPoints", VALUEFUNC(_wrap_AGTriangle2_collisionPoints), -1);
    rb_define_method(cAGTriangle2.klass, "contains", VALUEFUNC(_wrap_AGTriangle2_contains), -1);
    rb_define_method(cAGTriangle2.klass, "getBBox", VALUEFUNC(_wrap_AGTriangle2_getBBox), -1);
    rb_define_method(cAGTriangle2.klass, "nearestLine", VALUEFUNC(_wrap_AGTriangle2_nearestLine), -1);
    rb_define_method(cAGTriangle2.klass, "getLines", VALUEFUNC(_wrap_AGTriangle2_getLines), -1);
    rb_define_method(cAGTriangle2.klass, "to_s", VALUEFUNC(_wrap_AGTriangle2_to_s), -1);
    cAGTriangle2.mark = 0;
    cAGTriangle2.destroy = (void (*)(void *)) free_AGTriangle2;
    
    cAGCircle2.klass = rb_define_class_under(mLibantargis, "AGCircle2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCircle2, (void *) &cAGCircle2);
    rb_define_alloc_func(cAGCircle2.klass, _wrap_AGCircle2_allocate);
    rb_define_method(cAGCircle2.klass, "initialize", VALUEFUNC(_wrap_new_AGCircle2), -1);
    rb_define_method(cAGCircle2.klass, "inCircle", VALUEFUNC(_wrap_AGCircle2_inCircle), -1);
    rb_define_method(cAGCircle2.klass, "outCircle", VALUEFUNC(_wrap_AGCircle2_outCircle), -1);
    rb_define_method(cAGCircle2.klass, "getPos", VALUEFUNC(_wrap_AGCircle2_getPos), -1);
    rb_define_method(cAGCircle2.klass, "getRadius", VALUEFUNC(_wrap_AGCircle2_getRadius), -1);
    cAGCircle2.mark = 0;
    cAGCircle2.destroy = (void (*)(void *)) free_AGCircle2;
    
    cAGTriangle3.klass = rb_define_class_under(mLibantargis, "AGTriangle3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTriangle3, (void *) &cAGTriangle3);
    rb_define_alloc_func(cAGTriangle3.klass, _wrap_AGTriangle3_allocate);
    rb_define_method(cAGTriangle3.klass, "initialize", VALUEFUNC(_wrap_new_AGTriangle3), -1);
    rb_define_method(cAGTriangle3.klass, "collide", VALUEFUNC(_wrap_AGTriangle3_collide), -1);
    rb_define_method(cAGTriangle3.klass, "toString", VALUEFUNC(_wrap_AGTriangle3_toString), -1);
    cAGTriangle3.mark = 0;
    cAGTriangle3.destroy = (void (*)(void *)) free_AGTriangle3;
    
    cAGRect2.klass = rb_define_class_under(mLibantargis, "AGRect2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect2, (void *) &cAGRect2);
    rb_define_alloc_func(cAGRect2.klass, _wrap_AGRect2_allocate);
    rb_define_method(cAGRect2.klass, "initialize", VALUEFUNC(_wrap_new_AGRect2), -1);
    rb_define_method(cAGRect2.klass, "collide", VALUEFUNC(_wrap_AGRect2_collide), -1);
    rb_define_method(cAGRect2.klass, "+", VALUEFUNC(_wrap_AGRect2___add__), -1);
    rb_define_method(cAGRect2.klass, "contains", VALUEFUNC(_wrap_AGRect2_contains), -1);
    rb_define_method(cAGRect2.klass, "split", VALUEFUNC(_wrap_AGRect2_split), -1);
    rb_define_method(cAGRect2.klass, "getV0", VALUEFUNC(_wrap_AGRect2_getV0), -1);
    rb_define_method(cAGRect2.klass, "getV1", VALUEFUNC(_wrap_AGRect2_getV1), -1);
    rb_define_method(cAGRect2.klass, "getV01", VALUEFUNC(_wrap_AGRect2_getV01), -1);
    rb_define_method(cAGRect2.klass, "getV10", VALUEFUNC(_wrap_AGRect2_getV10), -1);
    rb_define_method(cAGRect2.klass, "setX", VALUEFUNC(_wrap_AGRect2_setX), -1);
    rb_define_method(cAGRect2.klass, "setY", VALUEFUNC(_wrap_AGRect2_setY), -1);
    rb_define_method(cAGRect2.klass, "x", VALUEFUNC(_wrap_AGRect2_x), -1);
    rb_define_method(cAGRect2.klass, "y", VALUEFUNC(_wrap_AGRect2_y), -1);
    rb_define_method(cAGRect2.klass, "w", VALUEFUNC(_wrap_AGRect2_w), -1);
    rb_define_method(cAGRect2.klass, "h", VALUEFUNC(_wrap_AGRect2_h), -1);
    rb_define_method(cAGRect2.klass, "to_s", VALUEFUNC(_wrap_AGRect2_to_s), -1);
    cAGRect2.mark = 0;
    cAGRect2.destroy = (void (*)(void *)) free_AGRect2;
    
    cAGVector4.klass = rb_define_class_under(mLibantargis, "AGVector4", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector4, (void *) &cAGVector4);
    rb_define_alloc_func(cAGVector4.klass, _wrap_AGVector4_allocate);
    rb_define_method(cAGVector4.klass, "initialize", VALUEFUNC(_wrap_new_AGVector4), -1);
    rb_define_method(cAGVector4.klass, "v=", VALUEFUNC(_wrap_AGVector4_v_set), -1);
    rb_define_method(cAGVector4.klass, "v", VALUEFUNC(_wrap_AGVector4_v_get), -1);
    rb_define_method(cAGVector4.klass, "setX", VALUEFUNC(_wrap_AGVector4_setX), -1);
    rb_define_method(cAGVector4.klass, "setY", VALUEFUNC(_wrap_AGVector4_setY), -1);
    rb_define_method(cAGVector4.klass, "setZ", VALUEFUNC(_wrap_AGVector4_setZ), -1);
    rb_define_method(cAGVector4.klass, "setW", VALUEFUNC(_wrap_AGVector4_setW), -1);
    rb_define_method(cAGVector4.klass, "x", VALUEFUNC(_wrap_AGVector4_x), -1);
    rb_define_method(cAGVector4.klass, "y", VALUEFUNC(_wrap_AGVector4_y), -1);
    rb_define_method(cAGVector4.klass, "z", VALUEFUNC(_wrap_AGVector4_z), -1);
    rb_define_method(cAGVector4.klass, "w", VALUEFUNC(_wrap_AGVector4_w), -1);
    rb_define_method(cAGVector4.klass, "-", VALUEFUNC(_wrap_AGVector4___sub__), -1);
    rb_define_method(cAGVector4.klass, "+", VALUEFUNC(_wrap_AGVector4___add__), -1);
    rb_define_method(cAGVector4.klass, "add", VALUEFUNC(_wrap_AGVector4_add), -1);
    rb_define_method(cAGVector4.klass, "sub", VALUEFUNC(_wrap_AGVector4_sub), -1);
    rb_define_method(cAGVector4.klass, "*", VALUEFUNC(_wrap_AGVector4___mul__), -1);
    rb_define_method(cAGVector4.klass, "/", VALUEFUNC(_wrap_AGVector4___div__), -1);
    rb_define_method(cAGVector4.klass, "-@", VALUEFUNC(_wrap_AGVector4___neg__), -1);
    rb_define_method(cAGVector4.klass, "==", VALUEFUNC(_wrap_AGVector4___eq__), -1);
    rb_define_method(cAGVector4.klass, "length", VALUEFUNC(_wrap_AGVector4_length), -1);
    rb_define_method(cAGVector4.klass, "length2", VALUEFUNC(_wrap_AGVector4_length2), -1);
    rb_define_method(cAGVector4.klass, "length3", VALUEFUNC(_wrap_AGVector4_length3), -1);
    rb_define_method(cAGVector4.klass, "normalized", VALUEFUNC(_wrap_AGVector4_normalized), -1);
    rb_define_method(cAGVector4.klass, "normalize", VALUEFUNC(_wrap_AGVector4_normalize), -1);
    rb_define_method(cAGVector4.klass, "normalized3", VALUEFUNC(_wrap_AGVector4_normalized3), -1);
    rb_define_method(cAGVector4.klass, "normalize3", VALUEFUNC(_wrap_AGVector4_normalize3), -1);
    rb_define_method(cAGVector4.klass, "nonZero", VALUEFUNC(_wrap_AGVector4_nonZero), -1);
    rb_define_method(cAGVector4.klass, "%", VALUEFUNC(_wrap_AGVector4___mod__), -1);
    rb_define_method(cAGVector4.klass, "cross", VALUEFUNC(_wrap_AGVector4_cross), -1);
    rb_define_method(cAGVector4.klass, "dim3", VALUEFUNC(_wrap_AGVector4_dim3), -1);
    rb_define_method(cAGVector4.klass, "to_s", VALUEFUNC(_wrap_AGVector4_to_s), -1);
    cAGVector4.mark = 0;
    cAGVector4.destroy = (void (*)(void *)) free_AGVector4;
    
    cAGMatrix4.klass = rb_define_class_under(mLibantargis, "AGMatrix4", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMatrix4, (void *) &cAGMatrix4);
    rb_define_alloc_func(cAGMatrix4.klass, _wrap_AGMatrix4_allocate);
    rb_define_method(cAGMatrix4.klass, "initialize", VALUEFUNC(_wrap_new_AGMatrix4), -1);
    rb_define_method(cAGMatrix4.klass, "set", VALUEFUNC(_wrap_AGMatrix4_set), -1);
    rb_define_method(cAGMatrix4.klass, "get", VALUEFUNC(_wrap_AGMatrix4_get), -1);
    rb_define_method(cAGMatrix4.klass, "get3x3", VALUEFUNC(_wrap_AGMatrix4_get3x3), -1);
    rb_define_method(cAGMatrix4.klass, "*", VALUEFUNC(_wrap_AGMatrix4___mul__), -1);
    rb_define_method(cAGMatrix4.klass, "call", VALUEFUNC(_wrap_AGMatrix4___call__), -1);
    rb_define_method(cAGMatrix4.klass, "inverted", VALUEFUNC(_wrap_AGMatrix4_inverted), -1);
    rb_define_method(cAGMatrix4.klass, "transposed", VALUEFUNC(_wrap_AGMatrix4_transposed), -1);
    rb_define_method(cAGMatrix4.klass, "to_s", VALUEFUNC(_wrap_AGMatrix4_to_s), -1);
    rb_define_method(cAGMatrix4.klass, "getRow", VALUEFUNC(_wrap_AGMatrix4_getRow), -1);
    cAGMatrix4.mark = 0;
    cAGMatrix4.destroy = (void (*)(void *)) free_AGMatrix4;
    
    cAGRect3.klass = rb_define_class_under(mLibantargis, "AGRect3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect3, (void *) &cAGRect3);
    rb_define_alloc_func(cAGRect3.klass, _wrap_AGRect3_allocate);
    rb_define_method(cAGRect3.klass, "initialize", VALUEFUNC(_wrap_new_AGRect3), -1);
    rb_define_method(cAGRect3.klass, "collides", VALUEFUNC(_wrap_AGRect3_collides), -1);
    rb_define_method(cAGRect3.klass, "toString", VALUEFUNC(_wrap_AGRect3_toString), -1);
    cAGRect3.mark = 0;
    cAGRect3.destroy = (void (*)(void *)) free_AGRect3;
    
    cAGBox3.klass = rb_define_class_under(mLibantargis, "AGBox3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBox3, (void *) &cAGBox3);
    rb_define_alloc_func(cAGBox3.klass, _wrap_AGBox3_allocate);
    rb_define_method(cAGBox3.klass, "initialize", VALUEFUNC(_wrap_new_AGBox3), -1);
    rb_define_method(cAGBox3.klass, "base=", VALUEFUNC(_wrap_AGBox3_base_set), -1);
    rb_define_method(cAGBox3.klass, "base", VALUEFUNC(_wrap_AGBox3_base_get), -1);
    rb_define_method(cAGBox3.klass, "dir=", VALUEFUNC(_wrap_AGBox3_dir_set), -1);
    rb_define_method(cAGBox3.klass, "dir", VALUEFUNC(_wrap_AGBox3_dir_get), -1);
    rb_define_method(cAGBox3.klass, "include", VALUEFUNC(_wrap_AGBox3_include), -1);
    rb_define_method(cAGBox3.klass, "includes", VALUEFUNC(_wrap_AGBox3_includes), -1);
    rb_define_method(cAGBox3.klass, "collides", VALUEFUNC(_wrap_AGBox3_collides), -1);
    rb_define_method(cAGBox3.klass, "getSides", VALUEFUNC(_wrap_AGBox3_getSides), -1);
    rb_define_method(cAGBox3.klass, "toString", VALUEFUNC(_wrap_AGBox3_toString), -1);
    rb_define_method(cAGBox3.klass, "split", VALUEFUNC(_wrap_AGBox3_split), -1);
    cAGBox3.mark = 0;
    cAGBox3.destroy = (void (*)(void *)) free_AGBox3;
    
    cAGColor.klass = rb_define_class_under(mLibantargis, "AGColor", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGColor, (void *) &cAGColor);
    rb_define_alloc_func(cAGColor.klass, _wrap_AGColor_allocate);
    rb_define_method(cAGColor.klass, "initialize", VALUEFUNC(_wrap_new_AGColor), -1);
    rb_define_method(cAGColor.klass, "*", VALUEFUNC(_wrap_AGColor___mul__), -1);
    rb_define_method(cAGColor.klass, "+", VALUEFUNC(_wrap_AGColor___add__), -1);
    rb_define_method(cAGColor.klass, "mapRGB", VALUEFUNC(_wrap_AGColor_mapRGB), -1);
    rb_define_method(cAGColor.klass, "toString", VALUEFUNC(_wrap_AGColor_toString), -1);
    rb_define_method(cAGColor.klass, "grey", VALUEFUNC(_wrap_AGColor_grey), -1);
    rb_define_method(cAGColor.klass, "brightness", VALUEFUNC(_wrap_AGColor_brightness), -1);
    rb_define_method(cAGColor.klass, "light", VALUEFUNC(_wrap_AGColor_light), -1);
    rb_define_method(cAGColor.klass, "a=", VALUEFUNC(_wrap_AGColor_a_set), -1);
    rb_define_method(cAGColor.klass, "a", VALUEFUNC(_wrap_AGColor_a_get), -1);
    cAGColor.mark = 0;
    cAGColor.destroy = (void (*)(void *)) free_AGColor;
    rb_define_module_function(mLibantargis, "toInt", VALUEFUNC(_wrap_toInt), -1);
    
    cAGFont.klass = rb_define_class_under(mLibantargis, "AGFont", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGFont, (void *) &cAGFont);
    rb_define_alloc_func(cAGFont.klass, _wrap_AGFont_allocate);
    rb_define_method(cAGFont.klass, "initialize", VALUEFUNC(_wrap_new_AGFont), -1);
    rb_define_const(cAGFont.klass,"NORMAL", INT2NUM(AGFont::NORMAL));
    rb_define_const(cAGFont.klass,"BOLD", INT2NUM(AGFont::BOLD));
    rb_define_const(cAGFont.klass,"UNDERLINE", INT2NUM(AGFont::UNDERLINE));
    rb_define_const(cAGFont.klass,"ITALIC", INT2NUM(AGFont::ITALIC));
    rb_define_method(cAGFont.klass, "setColor", VALUEFUNC(_wrap_AGFont_setColor), -1);
    rb_define_method(cAGFont.klass, "getColor", VALUEFUNC(_wrap_AGFont_getColor), -1);
    rb_define_method(cAGFont.klass, "setAlpha", VALUEFUNC(_wrap_AGFont_setAlpha), -1);
    rb_define_method(cAGFont.klass, "getAlpha", VALUEFUNC(_wrap_AGFont_getAlpha), -1);
    rb_define_method(cAGFont.klass, "setSize", VALUEFUNC(_wrap_AGFont_setSize), -1);
    rb_define_method(cAGFont.klass, "getSize", VALUEFUNC(_wrap_AGFont_getSize), -1);
    rb_define_method(cAGFont.klass, "setStyle", VALUEFUNC(_wrap_AGFont_setStyle), -1);
    rb_define_method(cAGFont.klass, "getStyle", VALUEFUNC(_wrap_AGFont_getStyle), -1);
    rb_define_method(cAGFont.klass, "setName", VALUEFUNC(_wrap_AGFont_setName), -1);
    rb_define_method(cAGFont.klass, "getName", VALUEFUNC(_wrap_AGFont_getName), -1);
    rb_define_method(cAGFont.klass, "getWidth", VALUEFUNC(_wrap_AGFont_getWidth), -1);
    rb_define_method(cAGFont.klass, "getHeight", VALUEFUNC(_wrap_AGFont_getHeight), -1);
    cAGFont.mark = 0;
    cAGFont.destroy = (void (*)(void *)) free_AGFont;
    
    cAGFontEngine.klass = rb_define_class_under(mLibantargis, "AGFontEngine", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGFontEngine, (void *) &cAGFontEngine);
    rb_define_alloc_func(cAGFontEngine.klass, _wrap_AGFontEngine_allocate);
    rb_define_method(cAGFontEngine.klass, "initialize", VALUEFUNC(_wrap_new_AGFontEngine), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "renderText", VALUEFUNC(_wrap_AGFontEngine_renderText), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "getWidth", VALUEFUNC(_wrap_AGFontEngine_getWidth), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "getHeight", VALUEFUNC(_wrap_AGFontEngine_getHeight), -1);
    cAGFontEngine.mark = 0;
    cAGFontEngine.destroy = (void (*)(void *)) free_AGFontEngine;
    rb_define_module_function(mLibantargis, "disown_AGButton", VALUEFUNC(_wrap_disown_AGButton), -1);
    
    cAGButton.klass = rb_define_class_under(mLibantargis, "AGButton", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGButton, (void *) &cAGButton);
    rb_define_alloc_func(cAGButton.klass, _wrap_AGButton_allocate);
    rb_define_method(cAGButton.klass, "initialize", VALUEFUNC(_wrap_new_AGButton), -1);
    rb_define_const(cAGButton.klass,"NORMAL", INT2NUM(AGButton::NORMAL));
    rb_define_const(cAGButton.klass,"LIGHTED", INT2NUM(AGButton::LIGHTED));
    rb_define_const(cAGButton.klass,"PRESSED", INT2NUM(AGButton::PRESSED));
    rb_define_const(cAGButton.klass,"CHECKED", INT2NUM(AGButton::CHECKED));
    rb_define_const(cAGButton.klass,"CHECKEDLIGHTED", INT2NUM(AGButton::CHECKEDLIGHTED));
    rb_define_method(cAGButton.klass, "setSurface", VALUEFUNC(_wrap_AGButton_setSurface), -1);
    rb_define_method(cAGButton.klass, "draw", VALUEFUNC(_wrap_AGButton_draw), -1);
    rb_define_method(cAGButton.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGButton_eventMouseEnter), -1);
    rb_define_method(cAGButton.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGButton_eventMouseLeave), -1);
    rb_define_method(cAGButton.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGButton_eventMouseButtonDown), -1);
    rb_define_method(cAGButton.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGButton_eventMouseButtonUp), -1);
    rb_define_method(cAGButton.klass, "setWidth", VALUEFUNC(_wrap_AGButton_setWidth), -1);
    rb_define_method(cAGButton.klass, "setHeight", VALUEFUNC(_wrap_AGButton_setHeight), -1);
    rb_define_method(cAGButton.klass, "getCaption", VALUEFUNC(_wrap_AGButton_getCaption), -1);
    rb_define_method(cAGButton.klass, "setEnabled", VALUEFUNC(_wrap_AGButton_setEnabled), -1);
    rb_define_method(cAGButton.klass, "setTheme", VALUEFUNC(_wrap_AGButton_setTheme), -1);
    rb_define_method(cAGButton.klass, "setCaption", VALUEFUNC(_wrap_AGButton_setCaption), -1);
    rb_define_method(cAGButton.klass, "setState", VALUEFUNC(_wrap_AGButton_setState), -1);
    rb_define_method(cAGButton.klass, "setChecked", VALUEFUNC(_wrap_AGButton_setChecked), -1);
    rb_define_method(cAGButton.klass, "isChecked", VALUEFUNC(_wrap_AGButton_isChecked), -1);
    rb_define_method(cAGButton.klass, "canFocus", VALUEFUNC(_wrap_AGButton_canFocus), -1);
    cAGButton.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGButton.destroy = (void (*)(void *)) free_AGButton;
    rb_define_module_function(mLibantargis, "toAGButton", VALUEFUNC(_wrap_toAGButton), -1);
    rb_define_module_function(mLibantargis, "AGApplication_markfunc", VALUEFUNC(_wrap_AGApplication_markfunc), -1);
    rb_define_module_function(mLibantargis, "disown_AGApplication", VALUEFUNC(_wrap_disown_AGApplication), -1);
    
    cAGApplication.klass = rb_define_class_under(mLibantargis, "AGApplication", ((swig_class *) SWIGTYPE_p_AGMessageObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGApplication, (void *) &cAGApplication);
    rb_define_alloc_func(cAGApplication.klass, _wrap_AGApplication_allocate);
    rb_define_method(cAGApplication.klass, "initialize", VALUEFUNC(_wrap_new_AGApplication), -1);
    rb_define_method(cAGApplication.klass, "run", VALUEFUNC(_wrap_AGApplication_run), -1);
    rb_define_method(cAGApplication.klass, "eventIdle", VALUEFUNC(_wrap_AGApplication_eventIdle), -1);
    rb_define_method(cAGApplication.klass, "eventFrame", VALUEFUNC(_wrap_AGApplication_eventFrame), -1);
    rb_define_method(cAGApplication.klass, "eventFrameEnd", VALUEFUNC(_wrap_AGApplication_eventFrameEnd), -1);
    rb_define_method(cAGApplication.klass, "eventQuit", VALUEFUNC(_wrap_AGApplication_eventQuit), -1);
    rb_define_method(cAGApplication.klass, "eventKeyDown", VALUEFUNC(_wrap_AGApplication_eventKeyDown), -1);
    rb_define_method(cAGApplication.klass, "eventChangedRes", VALUEFUNC(_wrap_AGApplication_eventChangedRes), -1);
    rb_define_method(cAGApplication.klass, "setMainWidget", VALUEFUNC(_wrap_AGApplication_setMainWidget), -1);
    rb_define_method(cAGApplication.klass, "draw", VALUEFUNC(_wrap_AGApplication_draw), -1);
    rb_define_method(cAGApplication.klass, "tryQuit", VALUEFUNC(_wrap_AGApplication_tryQuit), -1);
    rb_define_method(cAGApplication.klass, "getTicks", VALUEFUNC(_wrap_AGApplication_getTicks), -1);
    rb_define_method(cAGApplication.klass, "delay", VALUEFUNC(_wrap_AGApplication_delay), -1);
    cAGApplication.mark = (void (*)(void *)) AGApplication_markfunc;
    cAGApplication.destroy = (void (*)(void *)) free_AGApplication;
    rb_define_module_function(mLibantargis, "disableKeyrepeat", VALUEFUNC(_wrap_disableKeyrepeat), -1);
    rb_define_module_function(mLibantargis, "disown_AGText", VALUEFUNC(_wrap_disown_AGText), -1);
    
    cAGText.klass = rb_define_class_under(mLibantargis, "AGText", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGText, (void *) &cAGText);
    rb_define_alloc_func(cAGText.klass, _wrap_AGText_allocate);
    rb_define_method(cAGText.klass, "initialize", VALUEFUNC(_wrap_new_AGText), -1);
    rb_define_method(cAGText.klass, "setDeriveRect", VALUEFUNC(_wrap_AGText_setDeriveRect), -1);
    rb_define_method(cAGText.klass, "draw", VALUEFUNC(_wrap_AGText_draw), -1);
    rb_define_method(cAGText.klass, "setText", VALUEFUNC(_wrap_AGText_setText), -1);
    rb_define_method(cAGText.klass, "getText", VALUEFUNC(_wrap_AGText_getText), -1);
    cAGText.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGText.destroy = (void (*)(void *)) free_AGText;
    rb_define_module_function(mLibantargis, "toAGText", VALUEFUNC(_wrap_toAGText), -1);
    rb_define_module_function(mLibantargis, "disown_AGVTiler", VALUEFUNC(_wrap_disown_AGVTiler), -1);
    
    cAGVTiler.klass = rb_define_class_under(mLibantargis, "AGVTiler", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGVTiler, (void *) &cAGVTiler);
    rb_define_alloc_func(cAGVTiler.klass, _wrap_AGVTiler_allocate);
    rb_define_method(cAGVTiler.klass, "initialize", VALUEFUNC(_wrap_new_AGVTiler), -1);
    rb_define_method(cAGVTiler.klass, "addChild", VALUEFUNC(_wrap_AGVTiler_addChild), -1);
    rb_define_method(cAGVTiler.klass, "rePosition", VALUEFUNC(_wrap_AGVTiler_rePosition), -1);
    rb_define_method(cAGVTiler.klass, "adaptHeightFromChildren", VALUEFUNC(_wrap_AGVTiler_adaptHeightFromChildren), -1);
    rb_define_method(cAGVTiler.klass, "adaptWidthFromChildren", VALUEFUNC(_wrap_AGVTiler_adaptWidthFromChildren), -1);
    cAGVTiler.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGVTiler.destroy = (void (*)(void *)) free_AGVTiler;
    rb_define_module_function(mLibantargis, "disown_AGHTiler", VALUEFUNC(_wrap_disown_AGHTiler), -1);
    
    cAGHTiler.klass = rb_define_class_under(mLibantargis, "AGHTiler", ((swig_class *) SWIGTYPE_p_AGVTiler->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGHTiler, (void *) &cAGHTiler);
    rb_define_alloc_func(cAGHTiler.klass, _wrap_AGHTiler_allocate);
    rb_define_method(cAGHTiler.klass, "initialize", VALUEFUNC(_wrap_new_AGHTiler), -1);
    rb_define_method(cAGHTiler.klass, "rePosition", VALUEFUNC(_wrap_AGHTiler_rePosition), -1);
    rb_define_method(cAGHTiler.klass, "adaptHeightFromChildren", VALUEFUNC(_wrap_AGHTiler_adaptHeightFromChildren), -1);
    rb_define_method(cAGHTiler.klass, "adaptWidthFromChildren", VALUEFUNC(_wrap_AGHTiler_adaptWidthFromChildren), -1);
    rb_define_method(cAGHTiler.klass, "adaptWidthFromParent", VALUEFUNC(_wrap_AGHTiler_adaptWidthFromParent), -1);
    cAGHTiler.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGHTiler.destroy = (void (*)(void *)) free_AGHTiler;
    rb_define_module_function(mLibantargis, "disown_AGTheme", VALUEFUNC(_wrap_disown_AGTheme), -1);
    
    cAGTheme.klass = rb_define_class_under(mLibantargis, "AGTheme", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTheme, (void *) &cAGTheme);
    rb_define_alloc_func(cAGTheme.klass, _wrap_AGTheme_allocate);
    rb_define_method(cAGTheme.klass, "initialize", VALUEFUNC(_wrap_new_AGTheme), -1);
    rb_define_method(cAGTheme.klass, "getFont", VALUEFUNC(_wrap_AGTheme_getFont), -1);
    rb_define_method(cAGTheme.klass, "getColor", VALUEFUNC(_wrap_AGTheme_getColor), -1);
    rb_define_method(cAGTheme.klass, "setFont", VALUEFUNC(_wrap_AGTheme_setFont), -1);
    rb_define_method(cAGTheme.klass, "setColor", VALUEFUNC(_wrap_AGTheme_setColor), -1);
    rb_define_method(cAGTheme.klass, "getInt", VALUEFUNC(_wrap_AGTheme_getInt), -1);
    rb_define_method(cAGTheme.klass, "setInt", VALUEFUNC(_wrap_AGTheme_setInt), -1);
    rb_define_method(cAGTheme.klass, "getSurface", VALUEFUNC(_wrap_AGTheme_getSurface), -1);
    rb_define_method(cAGTheme.klass, "setSurface", VALUEFUNC(_wrap_AGTheme_setSurface), -1);
    rb_define_method(cAGTheme.klass, "hasSurface", VALUEFUNC(_wrap_AGTheme_hasSurface), -1);
    rb_define_method(cAGTheme.klass, "hasColor", VALUEFUNC(_wrap_AGTheme_hasColor), -1);
    cAGTheme.mark = 0;
    cAGTheme.destroy = (void (*)(void *)) free_AGTheme;
    rb_define_module_function(mLibantargis, "getTheme", VALUEFUNC(_wrap_getTheme), -1);
    rb_define_module_function(mLibantargis, "setTheme", VALUEFUNC(_wrap_setTheme), -1);
    rb_define_module_function(mLibantargis, "loadTheme", VALUEFUNC(_wrap_loadTheme), -1);
    rb_define_module_function(mLibantargis, "loadThemeFile", VALUEFUNC(_wrap_loadThemeFile), -1);
    rb_define_module_function(mLibantargis, "addPoint", VALUEFUNC(_wrap_addPoint), -1);
    rb_define_module_function(mLibantargis, "disown_AGMenuEvent", VALUEFUNC(_wrap_disown_AGMenuEvent), -1);
    
    cAGMenuEvent.klass = rb_define_class_under(mLibantargis, "AGMenuEvent", ((swig_class *) SWIGTYPE_p_AGEvent->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMenuEvent, (void *) &cAGMenuEvent);
    rb_define_alloc_func(cAGMenuEvent.klass, _wrap_AGMenuEvent_allocate);
    rb_define_method(cAGMenuEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGMenuEvent), -1);
    rb_define_method(cAGMenuEvent.klass, "getName", VALUEFUNC(_wrap_AGMenuEvent_getName), -1);
    cAGMenuEvent.mark = 0;
    cAGMenuEvent.destroy = (void (*)(void *)) free_AGMenuEvent;
    rb_define_module_function(mLibantargis, "disown_AGMenu", VALUEFUNC(_wrap_disown_AGMenu), -1);
    
    cAGMenu.klass = rb_define_class_under(mLibantargis, "AGMenu", ((swig_class *) SWIGTYPE_p_AGVTiler->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMenu, (void *) &cAGMenu);
    rb_define_alloc_func(cAGMenu.klass, _wrap_AGMenu_allocate);
    rb_define_method(cAGMenu.klass, "initialize", VALUEFUNC(_wrap_new_AGMenu), -1);
    rb_define_method(cAGMenu.klass, "show", VALUEFUNC(_wrap_AGMenu_show), -1);
    rb_define_method(cAGMenu.klass, "addItem", VALUEFUNC(_wrap_AGMenu_addItem), -1);
    rb_define_method(cAGMenu.klass, "addMenu", VALUEFUNC(_wrap_AGMenu_addMenu), -1);
    rb_define_method(cAGMenu.klass, "draw", VALUEFUNC(_wrap_AGMenu_draw), -1);
    rb_define_method(cAGMenu.klass, "eventItemSelected", VALUEFUNC(_wrap_AGMenu_eventItemSelected), -1);
    rb_define_method(cAGMenu.klass, "eventItemClicked", VALUEFUNC(_wrap_AGMenu_eventItemClicked), -1);
    rb_define_method(cAGMenu.klass, "sigSelected=", VALUEFUNC(_wrap_AGMenu_sigSelected_set), -1);
    rb_define_method(cAGMenu.klass, "sigSelected", VALUEFUNC(_wrap_AGMenu_sigSelected_get), -1);
    cAGMenu.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGMenu.destroy = (void (*)(void *)) free_AGMenu;
    rb_define_module_function(mLibantargis, "disown_AGScreenWidget", VALUEFUNC(_wrap_disown_AGScreenWidget), -1);
    
    cAGScreenWidget.klass = rb_define_class_under(mLibantargis, "AGScreenWidget", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGScreenWidget, (void *) &cAGScreenWidget);
    rb_define_alloc_func(cAGScreenWidget.klass, _wrap_AGScreenWidget_allocate);
    rb_define_method(cAGScreenWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGScreenWidget), -1);
    rb_define_method(cAGScreenWidget.klass, "draw", VALUEFUNC(_wrap_AGScreenWidget_draw), -1);
    cAGScreenWidget.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGScreenWidget.destroy = (void (*)(void *)) free_AGScreenWidget;
    rb_define_const(mLibantargis,"EDIT_LEFT", INT2NUM(EDIT_LEFT));
    rb_define_const(mLibantargis,"EDIT_RIGHT", INT2NUM(EDIT_RIGHT));
    rb_define_const(mLibantargis,"EDIT_JUSTIFY", INT2NUM(EDIT_JUSTIFY));
    rb_define_const(mLibantargis,"EDIT_CENTER", INT2NUM(EDIT_CENTER));
    rb_define_const(mLibantargis,"EDIT_TOP", INT2NUM(EDIT_TOP));
    rb_define_const(mLibantargis,"EDIT_BOTTOM", INT2NUM(EDIT_BOTTOM));
    rb_define_const(mLibantargis,"EDIT_VCENTER", INT2NUM(EDIT_VCENTER));
    rb_define_module_function(mLibantargis, "disown_AGEditLine", VALUEFUNC(_wrap_disown_AGEditLine), -1);
    
    cAGEditLine.klass = rb_define_class_under(mLibantargis, "AGEditLine", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGEditLine, (void *) &cAGEditLine);
    rb_define_alloc_func(cAGEditLine.klass, _wrap_AGEditLine_allocate);
    rb_define_method(cAGEditLine.klass, "initialize", VALUEFUNC(_wrap_new_AGEditLine), -1);
    rb_define_method(cAGEditLine.klass, "setAlign", VALUEFUNC(_wrap_AGEditLine_setAlign), -1);
    rb_define_method(cAGEditLine.klass, "setVAlign", VALUEFUNC(_wrap_AGEditLine_setVAlign), -1);
    rb_define_method(cAGEditLine.klass, "draw", VALUEFUNC(_wrap_AGEditLine_draw), -1);
    rb_define_method(cAGEditLine.klass, "drawCursor", VALUEFUNC(_wrap_AGEditLine_drawCursor), -1);
    rb_define_method(cAGEditLine.klass, "height", VALUEFUNC(_wrap_AGEditLine_height), -1);
    rb_define_method(cAGEditLine.klass, "width", VALUEFUNC(_wrap_AGEditLine_width), -1);
    rb_define_method(cAGEditLine.klass, "insert", VALUEFUNC(_wrap_AGEditLine_insert), -1);
    rb_define_method(cAGEditLine.klass, "doDelete", VALUEFUNC(_wrap_AGEditLine_doDelete), -1);
    rb_define_method(cAGEditLine.klass, "split", VALUEFUNC(_wrap_AGEditLine_split), -1);
    rb_define_method(cAGEditLine.klass, "length", VALUEFUNC(_wrap_AGEditLine_length), -1);
    rb_define_method(cAGEditLine.klass, "append", VALUEFUNC(_wrap_AGEditLine_append), -1);
    rb_define_method(cAGEditLine.klass, "prepend", VALUEFUNC(_wrap_AGEditLine_prepend), -1);
    rb_define_method(cAGEditLine.klass, "getText", VALUEFUNC(_wrap_AGEditLine_getText), -1);
    rb_define_method(cAGEditLine.klass, "getFont", VALUEFUNC(_wrap_AGEditLine_getFont), -1);
    rb_define_method(cAGEditLine.klass, "setText", VALUEFUNC(_wrap_AGEditLine_setText), -1);
    rb_define_method(cAGEditLine.klass, "hardEnd", VALUEFUNC(_wrap_AGEditLine_hardEnd), -1);
    rb_define_method(cAGEditLine.klass, "setHardEnd", VALUEFUNC(_wrap_AGEditLine_setHardEnd), -1);
    rb_define_method(cAGEditLine.klass, "checkUnwrap", VALUEFUNC(_wrap_AGEditLine_checkUnwrap), -1);
    rb_define_method(cAGEditLine.klass, "checkWrap", VALUEFUNC(_wrap_AGEditLine_checkWrap), -1);
    rb_define_method(cAGEditLine.klass, "setFont", VALUEFUNC(_wrap_AGEditLine_setFont), -1);
    cAGEditLine.mark = 0;
    cAGEditLine.destroy = (void (*)(void *)) free_AGEditLine;
    rb_define_module_function(mLibantargis, "disown_AGEdit", VALUEFUNC(_wrap_disown_AGEdit), -1);
    
    cAGEdit.klass = rb_define_class_under(mLibantargis, "AGEdit", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGEdit, (void *) &cAGEdit);
    rb_define_alloc_func(cAGEdit.klass, _wrap_AGEdit_allocate);
    rb_define_method(cAGEdit.klass, "initialize", VALUEFUNC(_wrap_new_AGEdit), -1);
    rb_define_method(cAGEdit.klass, "draw", VALUEFUNC(_wrap_AGEdit_draw), -1);
    rb_define_method(cAGEdit.klass, "drawBackground", VALUEFUNC(_wrap_AGEdit_drawBackground), -1);
    rb_define_method(cAGEdit.klass, "eventKeyDown", VALUEFUNC(_wrap_AGEdit_eventKeyDown), -1);
    rb_define_method(cAGEdit.klass, "eventKeyUp", VALUEFUNC(_wrap_AGEdit_eventKeyUp), -1);
    rb_define_method(cAGEdit.klass, "setMulti", VALUEFUNC(_wrap_AGEdit_setMulti), -1);
    rb_define_method(cAGEdit.klass, "insert", VALUEFUNC(_wrap_AGEdit_insert), -1);
    rb_define_method(cAGEdit.klass, "doDelete", VALUEFUNC(_wrap_AGEdit_doDelete), -1);
    rb_define_method(cAGEdit.klass, "setText", VALUEFUNC(_wrap_AGEdit_setText), -1);
    rb_define_method(cAGEdit.klass, "setFont", VALUEFUNC(_wrap_AGEdit_setFont), -1);
    rb_define_method(cAGEdit.klass, "clear", VALUEFUNC(_wrap_AGEdit_clear), -1);
    rb_define_method(cAGEdit.klass, "setMutable", VALUEFUNC(_wrap_AGEdit_setMutable), -1);
    rb_define_method(cAGEdit.klass, "setAlign", VALUEFUNC(_wrap_AGEdit_setAlign), -1);
    rb_define_method(cAGEdit.klass, "setVAlign", VALUEFUNC(_wrap_AGEdit_setVAlign), -1);
    rb_define_method(cAGEdit.klass, "setBackground", VALUEFUNC(_wrap_AGEdit_setBackground), -1);
    rb_define_method(cAGEdit.klass, "setTheme", VALUEFUNC(_wrap_AGEdit_setTheme), -1);
    rb_define_method(cAGEdit.klass, "canFocus", VALUEFUNC(_wrap_AGEdit_canFocus), -1);
    rb_define_method(cAGEdit.klass, "getText", VALUEFUNC(_wrap_AGEdit_getText), -1);
    cAGEdit.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGEdit.destroy = (void (*)(void *)) free_AGEdit;
    rb_define_module_function(mLibantargis, "toAGEdit", VALUEFUNC(_wrap_toAGEdit), -1);
    rb_define_module_function(mLibantargis, "disown_AGCheckBox", VALUEFUNC(_wrap_disown_AGCheckBox), -1);
    
    cAGCheckBox.klass = rb_define_class_under(mLibantargis, "AGCheckBox", ((swig_class *) SWIGTYPE_p_AGButton->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGCheckBox, (void *) &cAGCheckBox);
    rb_define_alloc_func(cAGCheckBox.klass, _wrap_AGCheckBox_allocate);
    rb_define_method(cAGCheckBox.klass, "initialize", VALUEFUNC(_wrap_new_AGCheckBox), -1);
    rb_define_method(cAGCheckBox.klass, "eventMouseClick", VALUEFUNC(_wrap_AGCheckBox_eventMouseClick), -1);
    cAGCheckBox.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGCheckBox.destroy = (void (*)(void *)) free_AGCheckBox;
    rb_define_module_function(mLibantargis, "disown_AGRadioGroup", VALUEFUNC(_wrap_disown_AGRadioGroup), -1);
    
    cAGRadioGroup.klass = rb_define_class_under(mLibantargis, "AGRadioGroup", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGRadioGroup, (void *) &cAGRadioGroup);
    rb_define_alloc_func(cAGRadioGroup.klass, _wrap_AGRadioGroup_allocate);
    rb_define_method(cAGRadioGroup.klass, "initialize", VALUEFUNC(_wrap_new_AGRadioGroup), -1);
    rb_define_method(cAGRadioGroup.klass, "eventChange", VALUEFUNC(_wrap_AGRadioGroup_eventChange), -1);
    rb_define_method(cAGRadioGroup.klass, "add", VALUEFUNC(_wrap_AGRadioGroup_add), -1);
    rb_define_method(cAGRadioGroup.klass, "erase", VALUEFUNC(_wrap_AGRadioGroup_erase), -1);
    rb_define_method(cAGRadioGroup.klass, "sigChanged=", VALUEFUNC(_wrap_AGRadioGroup_sigChanged_set), -1);
    rb_define_method(cAGRadioGroup.klass, "sigChanged", VALUEFUNC(_wrap_AGRadioGroup_sigChanged_get), -1);
    cAGRadioGroup.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGRadioGroup.destroy = (void (*)(void *)) free_AGRadioGroup;
    rb_define_module_function(mLibantargis, "disown_AGRadio", VALUEFUNC(_wrap_disown_AGRadio), -1);
    
    cAGRadio.klass = rb_define_class_under(mLibantargis, "AGRadio", ((swig_class *) SWIGTYPE_p_AGCheckBox->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGRadio, (void *) &cAGRadio);
    rb_define_alloc_func(cAGRadio.klass, _wrap_AGRadio_allocate);
    rb_define_method(cAGRadio.klass, "initialize", VALUEFUNC(_wrap_new_AGRadio), -1);
    rb_define_method(cAGRadio.klass, "setGroup", VALUEFUNC(_wrap_AGRadio_setGroup), -1);
    rb_define_method(cAGRadio.klass, "deselect", VALUEFUNC(_wrap_AGRadio_deselect), -1);
    rb_define_method(cAGRadio.klass, "setChecked", VALUEFUNC(_wrap_AGRadio_setChecked), -1);
    cAGRadio.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGRadio.destroy = (void (*)(void *)) free_AGRadio;
    rb_define_module_function(mLibantargis, "disown_AGTable", VALUEFUNC(_wrap_disown_AGTable), -1);
    
    cAGTable.klass = rb_define_class_under(mLibantargis, "AGTable", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGTable, (void *) &cAGTable);
    rb_define_alloc_func(cAGTable.klass, _wrap_AGTable_allocate);
    rb_define_method(cAGTable.klass, "initialize", VALUEFUNC(_wrap_new_AGTable), -1);
    rb_define_method(cAGTable.klass, "addFixedColumn", VALUEFUNC(_wrap_AGTable_addFixedColumn), -1);
    rb_define_method(cAGTable.klass, "addFixedRow", VALUEFUNC(_wrap_AGTable_addFixedRow), -1);
    rb_define_method(cAGTable.klass, "addColumn", VALUEFUNC(_wrap_AGTable_addColumn), -1);
    rb_define_method(cAGTable.klass, "addRow", VALUEFUNC(_wrap_AGTable_addRow), -1);
    rb_define_method(cAGTable.klass, "addChild", VALUEFUNC(_wrap_AGTable_addChild), -1);
    rb_define_method(cAGTable.klass, "getClientRect", VALUEFUNC(_wrap_AGTable_getClientRect), -1);
    rb_define_method(cAGTable.klass, "arrange", VALUEFUNC(_wrap_AGTable_arrange), -1);
    rb_define_method(cAGTable.klass, "setWidth", VALUEFUNC(_wrap_AGTable_setWidth), -1);
    rb_define_method(cAGTable.klass, "setHeight", VALUEFUNC(_wrap_AGTable_setHeight), -1);
    cAGTable.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGTable.destroy = (void (*)(void *)) free_AGTable;
    rb_define_module_function(mLibantargis, "disown_AGWindow", VALUEFUNC(_wrap_disown_AGWindow), -1);
    
    cAGWindow.klass = rb_define_class_under(mLibantargis, "AGWindow", ((swig_class *) SWIGTYPE_p_AGTable->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGWindow, (void *) &cAGWindow);
    rb_define_alloc_func(cAGWindow.klass, _wrap_AGWindow_allocate);
    rb_define_method(cAGWindow.klass, "initialize", VALUEFUNC(_wrap_new_AGWindow), -1);
    rb_define_method(cAGWindow.klass, "addChild", VALUEFUNC(_wrap_AGWindow_addChild), -1);
    rb_define_method(cAGWindow.klass, "getClient", VALUEFUNC(_wrap_AGWindow_getClient), -1);
    rb_define_method(cAGWindow.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGWindow_eventMouseButtonDown), -1);
    rb_define_method(cAGWindow.klass, "eventDragBy", VALUEFUNC(_wrap_AGWindow_eventDragBy), -1);
    rb_define_method(cAGWindow.klass, "close", VALUEFUNC(_wrap_AGWindow_close), -1);
    rb_define_method(cAGWindow.klass, "tryClose", VALUEFUNC(_wrap_AGWindow_tryClose), -1);
    rb_define_method(cAGWindow.klass, "getClientRect", VALUEFUNC(_wrap_AGWindow_getClientRect), -1);
    rb_define_method(cAGWindow.klass, "sigClose=", VALUEFUNC(_wrap_AGWindow_sigClose_set), -1);
    rb_define_method(cAGWindow.klass, "sigClose", VALUEFUNC(_wrap_AGWindow_sigClose_get), -1);
    cAGWindow.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGWindow.destroy = (void (*)(void *)) free_AGWindow;
    rb_define_module_function(mLibantargis, "toAGWindow", VALUEFUNC(_wrap_toAGWindow), -1);
    rb_define_module_function(mLibantargis, "disown_AGImage", VALUEFUNC(_wrap_disown_AGImage), -1);
    
    cAGImage.klass = rb_define_class_under(mLibantargis, "AGImage", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGImage, (void *) &cAGImage);
    rb_define_alloc_func(cAGImage.klass, _wrap_AGImage_allocate);
    rb_define_method(cAGImage.klass, "initialize", VALUEFUNC(_wrap_new_AGImage), -1);
    rb_define_method(cAGImage.klass, "draw", VALUEFUNC(_wrap_AGImage_draw), -1);
    rb_define_method(cAGImage.klass, "setSurface", VALUEFUNC(_wrap_AGImage_setSurface), -1);
    cAGImage.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGImage.destroy = (void (*)(void *)) free_AGImage;
    rb_define_module_function(mLibantargis, "disown_AGCaption", VALUEFUNC(_wrap_disown_AGCaption), -1);
    
    cAGCaption.klass = rb_define_class_under(mLibantargis, "AGCaption", ((swig_class *) SWIGTYPE_p_AGText->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGCaption, (void *) &cAGCaption);
    rb_define_alloc_func(cAGCaption.klass, _wrap_AGCaption_allocate);
    rb_define_method(cAGCaption.klass, "initialize", VALUEFUNC(_wrap_new_AGCaption), -1);
    rb_define_method(cAGCaption.klass, "draw", VALUEFUNC(_wrap_AGCaption_draw), -1);
    rb_define_method(cAGCaption.klass, "setBackground", VALUEFUNC(_wrap_AGCaption_setBackground), -1);
    cAGCaption.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGCaption.destroy = (void (*)(void *)) free_AGCaption;
    
    cAGBackground.klass = rb_define_class_under(mLibantargis, "AGBackground", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBackground, (void *) &cAGBackground);
    rb_define_alloc_func(cAGBackground.klass, _wrap_AGBackground_allocate);
    rb_define_method(cAGBackground.klass, "initialize", VALUEFUNC(_wrap_new_AGBackground), -1);
    rb_define_method(cAGBackground.klass, "draw", VALUEFUNC(_wrap_AGBackground_draw), -1);
    cAGBackground.mark = 0;
    cAGBackground.destroy = (void (*)(void *)) free_AGBackground;
    rb_define_module_function(mLibantargis, "disown_AGLayout", VALUEFUNC(_wrap_disown_AGLayout), -1);
    
    cAGLayout.klass = rb_define_class_under(mLibantargis, "AGLayout", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayout, (void *) &cAGLayout);
    rb_define_alloc_func(cAGLayout.klass, _wrap_AGLayout_allocate);
    rb_define_method(cAGLayout.klass, "initialize", VALUEFUNC(_wrap_new_AGLayout), -1);
    rb_define_method(cAGLayout.klass, "addTabIndex", VALUEFUNC(_wrap_AGLayout_addTabIndex), -1);
    cAGLayout.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGLayout.destroy = (void (*)(void *)) free_AGLayout;
    rb_define_module_function(mLibantargis, "parseNode", VALUEFUNC(_wrap_parseNode), -1);
    rb_define_module_function(mLibantargis, "parseChildren", VALUEFUNC(_wrap_parseChildren), -1);
    rb_define_module_function(mLibantargis, "getLayoutGeometry", VALUEFUNC(_wrap_getLayoutGeometry), -1);
    rb_define_module_function(mLibantargis, "disown_AGLayoutCreator", VALUEFUNC(_wrap_disown_AGLayoutCreator), -1);
    
    cAGLayoutCreator.klass = rb_define_class_under(mLibantargis, "AGLayoutCreator", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayoutCreator, (void *) &cAGLayoutCreator);
    rb_define_alloc_func(cAGLayoutCreator.klass, _wrap_AGLayoutCreator_allocate);
    rb_define_method(cAGLayoutCreator.klass, "initialize", VALUEFUNC(_wrap_new_AGLayoutCreator), -1);
    rb_define_method(cAGLayoutCreator.klass, "create", VALUEFUNC(_wrap_AGLayoutCreator_create), -1);
    cAGLayoutCreator.mark = 0;
    cAGLayoutCreator.destroy = (void (*)(void *)) free_AGLayoutCreator;
    rb_define_module_function(mLibantargis, "getLayoutFactory", VALUEFUNC(_wrap_getLayoutFactory), -1);
    
    cAGLayoutFactory.klass = rb_define_class_under(mLibantargis, "AGLayoutFactory", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayoutFactory, (void *) &cAGLayoutFactory);
    rb_undef_alloc_func(cAGLayoutFactory.klass);
    rb_define_method(cAGLayoutFactory.klass, "addCreator", VALUEFUNC(_wrap_AGLayoutFactory_addCreator), -1);
    rb_define_method(cAGLayoutFactory.klass, "create", VALUEFUNC(_wrap_AGLayoutFactory_create), -1);
    cAGLayoutFactory.mark = 0;
    cAGLayoutFactory.destroy = (void (*)(void *)) free_AGLayoutFactory;
    
    cNode.klass = rb_define_class_under(mLibantargis, "Node", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Node, (void *) &cNode);
    rb_define_alloc_func(cNode.klass, _wrap_Node_allocate);
    rb_define_method(cNode.klass, "initialize", VALUEFUNC(_wrap_new_Node), -1);
    rb_define_method(cNode.klass, "setName", VALUEFUNC(_wrap_Node_setName), -1);
    rb_define_method(cNode.klass, "get_children", VALUEFUNC(_wrap_Node_get_children), -1);
    rb_define_method(cNode.klass, "getName", VALUEFUNC(_wrap_Node_getName), -1);
    rb_define_method(cNode.klass, "get_name", VALUEFUNC(_wrap_Node_get_name), -1);
    rb_define_method(cNode.klass, "setAttributes", VALUEFUNC(_wrap_Node_setAttributes), -1);
    rb_define_method(cNode.klass, "newChild", VALUEFUNC(_wrap_Node_newChild), -1);
    rb_define_method(cNode.klass, "add_child", VALUEFUNC(_wrap_Node_add_child), -1);
    rb_define_method(cNode.klass, "remove_child", VALUEFUNC(_wrap_Node_remove_child), -1);
    rb_define_method(cNode.klass, "begin", VALUEFUNC(_wrap_Node_begin), -1);
    rb_define_method(cNode.klass, "end", VALUEFUNC(_wrap_Node_end), -1);
    rb_define_method(cNode.klass, "setContent", VALUEFUNC(_wrap_Node_setContent), -1);
    rb_define_method(cNode.klass, "set", VALUEFUNC(_wrap_Node_set), -1);
    rb_define_method(cNode.klass, "get", VALUEFUNC(_wrap_Node_get), -1);
    rb_define_method(cNode.klass, "clear", VALUEFUNC(_wrap_Node_clear), -1);
    rb_define_method(cNode.klass, "escape", VALUEFUNC(_wrap_Node_escape), -1);
    rb_define_method(cNode.klass, "unescape", VALUEFUNC(_wrap_Node_unescape), -1);
    rb_define_method(cNode.klass, "getStart", VALUEFUNC(_wrap_Node_getStart), -1);
    rb_define_method(cNode.klass, "getEnd", VALUEFUNC(_wrap_Node_getEnd), -1);
    rb_define_method(cNode.klass, "indent", VALUEFUNC(_wrap_Node_indent), -1);
    rb_define_method(cNode.klass, "getContent", VALUEFUNC(_wrap_Node_getContent), -1);
    rb_define_method(cNode.klass, "toString", VALUEFUNC(_wrap_Node_toString), -1);
    rb_define_method(cNode.klass, "isTextNode", VALUEFUNC(_wrap_Node_isTextNode), -1);
    rb_define_method(cNode.klass, "getText", VALUEFUNC(_wrap_Node_getText), -1);
    rb_define_method(cNode.klass, "hasTextNode", VALUEFUNC(_wrap_Node_hasTextNode), -1);
    rb_define_method(cNode.klass, "size", VALUEFUNC(_wrap_Node_size), -1);
    cNode.mark = 0;
    cNode.destroy = (void (*)(void *)) free_Node;
    
    cDocument.klass = rb_define_class_under(mLibantargis, "Document", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Document, (void *) &cDocument);
    rb_define_alloc_func(cDocument.klass, _wrap_Document_allocate);
    rb_define_method(cDocument.klass, "initialize", VALUEFUNC(_wrap_new_Document), -1);
    rb_define_method(cDocument.klass, "parseFile", VALUEFUNC(_wrap_Document_parseFile), -1);
    rb_define_method(cDocument.klass, "root", VALUEFUNC(_wrap_Document_root), -1);
    rb_define_method(cDocument.klass, "get_root_node", VALUEFUNC(_wrap_Document_get_root_node), -1);
    rb_define_method(cDocument.klass, "toString", VALUEFUNC(_wrap_Document_toString), -1);
    rb_define_method(cDocument.klass, "parse_memory", VALUEFUNC(_wrap_Document_parse_memory), -1);
    rb_define_method(cDocument.klass, "parseMemory", VALUEFUNC(_wrap_Document_parseMemory), -1);
    rb_define_method(cDocument.klass, "get_document", VALUEFUNC(_wrap_Document_get_document), -1);
    cDocument.mark = 0;
    cDocument.destroy = (void (*)(void *)) free_Document;
    rb_define_module_function(mLibantargis, "disown_Parser", VALUEFUNC(_wrap_disown_Parser), -1);
    
    cParser.klass = rb_define_class_under(mLibantargis, "Parser", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Parser, (void *) &cParser);
    rb_define_alloc_func(cParser.klass, _wrap_Parser_allocate);
    rb_define_method(cParser.klass, "initialize", VALUEFUNC(_wrap_new_Parser), -1);
    rb_define_method(cParser.klass, "parse", VALUEFUNC(_wrap_Parser_parse), -1);
    rb_define_method(cParser.klass, "getLine", VALUEFUNC(_wrap_Parser_getLine), -1);
    rb_define_method(cParser.klass, "simpleTag", VALUEFUNC(_wrap_Parser_simpleTag), -1);
    rb_define_method(cParser.klass, "startTag", VALUEFUNC(_wrap_Parser_startTag), -1);
    rb_define_method(cParser.klass, "endTag", VALUEFUNC(_wrap_Parser_endTag), -1);
    rb_define_method(cParser.klass, "text", VALUEFUNC(_wrap_Parser_text), -1);
    rb_define_method(cParser.klass, "comment", VALUEFUNC(_wrap_Parser_comment), -1);
    rb_define_method(cParser.klass, "header", VALUEFUNC(_wrap_Parser_header), -1);
    cParser.mark = 0;
    cParser.destroy = (void (*)(void *)) free_Parser;
    rb_define_module_function(mLibantargis, "disown_DomParser", VALUEFUNC(_wrap_disown_DomParser), -1);
    
    cDomParser.klass = rb_define_class_under(mLibantargis, "DomParser", ((swig_class *) SWIGTYPE_p_Parser->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_DomParser, (void *) &cDomParser);
    rb_define_alloc_func(cDomParser.klass, _wrap_DomParser_allocate);
    rb_define_method(cDomParser.klass, "initialize", VALUEFUNC(_wrap_new_DomParser), -1);
    rb_define_method(cDomParser.klass, "simpleTag", VALUEFUNC(_wrap_DomParser_simpleTag), -1);
    rb_define_method(cDomParser.klass, "startTag", VALUEFUNC(_wrap_DomParser_startTag), -1);
    rb_define_method(cDomParser.klass, "endTag", VALUEFUNC(_wrap_DomParser_endTag), -1);
    rb_define_method(cDomParser.klass, "text", VALUEFUNC(_wrap_DomParser_text), -1);
    rb_define_method(cDomParser.klass, "comment", VALUEFUNC(_wrap_DomParser_comment), -1);
    rb_define_method(cDomParser.klass, "header", VALUEFUNC(_wrap_DomParser_header), -1);
    rb_define_method(cDomParser.klass, "parse", VALUEFUNC(_wrap_DomParser_parse), -1);
    cDomParser.mark = 0;
    cDomParser.destroy = (void (*)(void *)) free_DomParser;
    rb_define_module_function(mLibantargis, "getSoundManager", VALUEFUNC(_wrap_getSoundManager), -1);
    rb_define_module_function(mLibantargis, "disown_AGSound", VALUEFUNC(_wrap_disown_AGSound), -1);
    
    cAGSound.klass = rb_define_class_under(mLibantargis, "AGSound", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSound, (void *) &cAGSound);
    rb_define_alloc_func(cAGSound.klass, _wrap_AGSound_allocate);
    rb_define_method(cAGSound.klass, "initialize", VALUEFUNC(_wrap_new_AGSound), -1);
    rb_define_method(cAGSound.klass, "playMp3", VALUEFUNC(_wrap_AGSound_playMp3), -1);
    rb_define_method(cAGSound.klass, "stopMp3", VALUEFUNC(_wrap_AGSound_stopMp3), -1);
    rb_define_method(cAGSound.klass, "checkFinished", VALUEFUNC(_wrap_AGSound_checkFinished), -1);
    rb_define_method(cAGSound.klass, "sigMp3Finished=", VALUEFUNC(_wrap_AGSound_sigMp3Finished_set), -1);
    rb_define_method(cAGSound.klass, "sigMp3Finished", VALUEFUNC(_wrap_AGSound_sigMp3Finished_get), -1);
    cAGSound.mark = 0;
    cAGSound.destroy = (void (*)(void *)) free_AGSound;
    rb_define_module_function(mLibantargis, "disown_AGGLWidget", VALUEFUNC(_wrap_disown_AGGLWidget), -1);
    
    cAGGLWidget.klass = rb_define_class_under(mLibantargis, "AGGLWidget", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGGLWidget, (void *) &cAGGLWidget);
    rb_define_alloc_func(cAGGLWidget.klass, _wrap_AGGLWidget_allocate);
    rb_define_method(cAGGLWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGGLWidget), -1);
    rb_define_method(cAGGLWidget.klass, "drawGL", VALUEFUNC(_wrap_AGGLWidget_drawGL), -1);
    rb_define_method(cAGGLWidget.klass, "drawAll", VALUEFUNC(_wrap_AGGLWidget_drawAll), -1);
    rb_define_method(cAGGLWidget.klass, "getRatio", VALUEFUNC(_wrap_AGGLWidget_getRatio), -1);
    rb_define_method(cAGGLWidget.klass, "setPerspective", VALUEFUNC(_wrap_AGGLWidget_setPerspective), -1);
    cAGGLWidget.mark = 0;
    cAGGLWidget.destroy = (void (*)(void *)) free_AGGLWidget;
    rb_define_module_function(mLibantargis, "disown_AGColorButton", VALUEFUNC(_wrap_disown_AGColorButton), -1);
    
    cAGColorButton.klass = rb_define_class_under(mLibantargis, "AGColorButton", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGColorButton, (void *) &cAGColorButton);
    rb_define_alloc_func(cAGColorButton.klass, _wrap_AGColorButton_allocate);
    rb_define_method(cAGColorButton.klass, "initialize", VALUEFUNC(_wrap_new_AGColorButton), -1);
    rb_define_method(cAGColorButton.klass, "draw", VALUEFUNC(_wrap_AGColorButton_draw), -1);
    rb_define_method(cAGColorButton.klass, "getColor", VALUEFUNC(_wrap_AGColorButton_getColor), -1);
    rb_define_method(cAGColorButton.klass, "setColor", VALUEFUNC(_wrap_AGColorButton_setColor), -1);
    rb_define_method(cAGColorButton.klass, "eventMouseClick", VALUEFUNC(_wrap_AGColorButton_eventMouseClick), -1);
    cAGColorButton.mark = 0;
    cAGColorButton.destroy = (void (*)(void *)) free_AGColorButton;
    rb_define_module_function(mLibantargis, "toAGColorButton", VALUEFUNC(_wrap_toAGColorButton), -1);
    rb_define_module_function(mLibantargis, "disown_AGDialog", VALUEFUNC(_wrap_disown_AGDialog), -1);
    
    cAGDialog.klass = rb_define_class_under(mLibantargis, "AGDialog", ((swig_class *) SWIGTYPE_p_AGLayout->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGDialog, (void *) &cAGDialog);
    rb_define_alloc_func(cAGDialog.klass, _wrap_AGDialog_allocate);
    rb_define_method(cAGDialog.klass, "initialize", VALUEFUNC(_wrap_new_AGDialog), -1);
    rb_define_method(cAGDialog.klass, "eventOk", VALUEFUNC(_wrap_AGDialog_eventOk), -1);
    rb_define_method(cAGDialog.klass, "eventCancel", VALUEFUNC(_wrap_AGDialog_eventCancel), -1);
    rb_define_method(cAGDialog.klass, "eventClose", VALUEFUNC(_wrap_AGDialog_eventClose), -1);
    cAGDialog.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGDialog.destroy = (void (*)(void *)) free_AGDialog;
    rb_define_module_function(mLibantargis, "initFS", VALUEFUNC(_wrap_initFS), -1);
    rb_define_module_function(mLibantargis, "loadFile", VALUEFUNC(_wrap_loadFile), -1);
    rb_define_module_function(mLibantargis, "saveFile", VALUEFUNC(_wrap_saveFile), -1);
    rb_define_module_function(mLibantargis, "fileExists", VALUEFUNC(_wrap_fileExists), -1);
    rb_define_module_function(mLibantargis, "getDirectory", VALUEFUNC(_wrap_getDirectory), -1);
    
    cAGListBoxItem.klass = rb_define_class_under(mLibantargis, "AGListBoxItem", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGListBoxItem, (void *) &cAGListBoxItem);
    rb_define_alloc_func(cAGListBoxItem.klass, _wrap_AGListBoxItem_allocate);
    rb_define_method(cAGListBoxItem.klass, "initialize", VALUEFUNC(_wrap_new_AGListBoxItem), -1);
    rb_define_method(cAGListBoxItem.klass, "id=", VALUEFUNC(_wrap_AGListBoxItem_id_set), -1);
    rb_define_method(cAGListBoxItem.klass, "id", VALUEFUNC(_wrap_AGListBoxItem_id_get), -1);
    rb_define_method(cAGListBoxItem.klass, "value=", VALUEFUNC(_wrap_AGListBoxItem_value_set), -1);
    rb_define_method(cAGListBoxItem.klass, "value", VALUEFUNC(_wrap_AGListBoxItem_value_get), -1);
    cAGListBoxItem.mark = 0;
    cAGListBoxItem.destroy = (void (*)(void *)) free_AGListBoxItem;
    rb_define_module_function(mLibantargis, "disown_AGListBox", VALUEFUNC(_wrap_disown_AGListBox), -1);
    
    cAGListBox.klass = rb_define_class_under(mLibantargis, "AGListBox", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGListBox, (void *) &cAGListBox);
    rb_define_alloc_func(cAGListBox.klass, _wrap_AGListBox_allocate);
    rb_define_method(cAGListBox.klass, "initialize", VALUEFUNC(_wrap_new_AGListBox), -1);
    rb_define_method(cAGListBox.klass, "insertItem", VALUEFUNC(_wrap_AGListBox_insertItem), -1);
    rb_define_method(cAGListBox.klass, "selectItem", VALUEFUNC(_wrap_AGListBox_selectItem), -1);
    rb_define_method(cAGListBox.klass, "getSelectedID", VALUEFUNC(_wrap_AGListBox_getSelectedID), -1);
    rb_define_method(cAGListBox.klass, "getSelectedValue", VALUEFUNC(_wrap_AGListBox_getSelectedValue), -1);
    rb_define_method(cAGListBox.klass, "eventKeyDown", VALUEFUNC(_wrap_AGListBox_eventKeyDown), -1);
    rb_define_method(cAGListBox.klass, "sigSelect=", VALUEFUNC(_wrap_AGListBox_sigSelect_set), -1);
    rb_define_method(cAGListBox.klass, "sigSelect", VALUEFUNC(_wrap_AGListBox_sigSelect_get), -1);
    rb_define_method(cAGListBox.klass, "sigDoubleClick=", VALUEFUNC(_wrap_AGListBox_sigDoubleClick_set), -1);
    rb_define_method(cAGListBox.klass, "sigDoubleClick", VALUEFUNC(_wrap_AGListBox_sigDoubleClick_get), -1);
    rb_define_method(cAGListBox.klass, "draw", VALUEFUNC(_wrap_AGListBox_draw), -1);
    rb_define_method(cAGListBox.klass, "eventMouseClick", VALUEFUNC(_wrap_AGListBox_eventMouseClick), -1);
    rb_define_method(cAGListBox.klass, "clearList", VALUEFUNC(_wrap_AGListBox_clearList), -1);
    cAGListBox.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGListBox.destroy = (void (*)(void *)) free_AGListBox;
    rb_define_module_function(mLibantargis, "toAGListBox", VALUEFUNC(_wrap_toAGListBox), -1);
    rb_define_const(mLibantargis,"SDLK_UNKNOWN", INT2NUM(SDLK_UNKNOWN));
    rb_define_const(mLibantargis,"SDLK_FIRST", INT2NUM(SDLK_FIRST));
    rb_define_const(mLibantargis,"SDLK_BACKSPACE", INT2NUM(SDLK_BACKSPACE));
    rb_define_const(mLibantargis,"SDLK_TAB", INT2NUM(SDLK_TAB));
    rb_define_const(mLibantargis,"SDLK_CLEAR", INT2NUM(SDLK_CLEAR));
    rb_define_const(mLibantargis,"SDLK_RETURN", INT2NUM(SDLK_RETURN));
    rb_define_const(mLibantargis,"SDLK_PAUSE", INT2NUM(SDLK_PAUSE));
    rb_define_const(mLibantargis,"SDLK_ESCAPE", INT2NUM(SDLK_ESCAPE));
    rb_define_const(mLibantargis,"SDLK_SPACE", INT2NUM(SDLK_SPACE));
    rb_define_const(mLibantargis,"SDLK_EXCLAIM", INT2NUM(SDLK_EXCLAIM));
    rb_define_const(mLibantargis,"SDLK_QUOTEDBL", INT2NUM(SDLK_QUOTEDBL));
    rb_define_const(mLibantargis,"SDLK_HASH", INT2NUM(SDLK_HASH));
    rb_define_const(mLibantargis,"SDLK_DOLLAR", INT2NUM(SDLK_DOLLAR));
    rb_define_const(mLibantargis,"SDLK_AMPERSAND", INT2NUM(SDLK_AMPERSAND));
    rb_define_const(mLibantargis,"SDLK_QUOTE", INT2NUM(SDLK_QUOTE));
    rb_define_const(mLibantargis,"SDLK_LEFTPAREN", INT2NUM(SDLK_LEFTPAREN));
    rb_define_const(mLibantargis,"SDLK_RIGHTPAREN", INT2NUM(SDLK_RIGHTPAREN));
    rb_define_const(mLibantargis,"SDLK_ASTERISK", INT2NUM(SDLK_ASTERISK));
    rb_define_const(mLibantargis,"SDLK_PLUS", INT2NUM(SDLK_PLUS));
    rb_define_const(mLibantargis,"SDLK_COMMA", INT2NUM(SDLK_COMMA));
    rb_define_const(mLibantargis,"SDLK_MINUS", INT2NUM(SDLK_MINUS));
    rb_define_const(mLibantargis,"SDLK_PERIOD", INT2NUM(SDLK_PERIOD));
    rb_define_const(mLibantargis,"SDLK_SLASH", INT2NUM(SDLK_SLASH));
    rb_define_const(mLibantargis,"SDLK_0", INT2NUM(SDLK_0));
    rb_define_const(mLibantargis,"SDLK_1", INT2NUM(SDLK_1));
    rb_define_const(mLibantargis,"SDLK_2", INT2NUM(SDLK_2));
    rb_define_const(mLibantargis,"SDLK_3", INT2NUM(SDLK_3));
    rb_define_const(mLibantargis,"SDLK_4", INT2NUM(SDLK_4));
    rb_define_const(mLibantargis,"SDLK_5", INT2NUM(SDLK_5));
    rb_define_const(mLibantargis,"SDLK_6", INT2NUM(SDLK_6));
    rb_define_const(mLibantargis,"SDLK_7", INT2NUM(SDLK_7));
    rb_define_const(mLibantargis,"SDLK_8", INT2NUM(SDLK_8));
    rb_define_const(mLibantargis,"SDLK_9", INT2NUM(SDLK_9));
    rb_define_const(mLibantargis,"SDLK_COLON", INT2NUM(SDLK_COLON));
    rb_define_const(mLibantargis,"SDLK_SEMICOLON", INT2NUM(SDLK_SEMICOLON));
    rb_define_const(mLibantargis,"SDLK_LESS", INT2NUM(SDLK_LESS));
    rb_define_const(mLibantargis,"SDLK_EQUALS", INT2NUM(SDLK_EQUALS));
    rb_define_const(mLibantargis,"SDLK_GREATER", INT2NUM(SDLK_GREATER));
    rb_define_const(mLibantargis,"SDLK_QUESTION", INT2NUM(SDLK_QUESTION));
    rb_define_const(mLibantargis,"SDLK_AT", INT2NUM(SDLK_AT));
    rb_define_const(mLibantargis,"SDLK_LEFTBRACKET", INT2NUM(SDLK_LEFTBRACKET));
    rb_define_const(mLibantargis,"SDLK_BACKSLASH", INT2NUM(SDLK_BACKSLASH));
    rb_define_const(mLibantargis,"SDLK_RIGHTBRACKET", INT2NUM(SDLK_RIGHTBRACKET));
    rb_define_const(mLibantargis,"SDLK_CARET", INT2NUM(SDLK_CARET));
    rb_define_const(mLibantargis,"SDLK_UNDERSCORE", INT2NUM(SDLK_UNDERSCORE));
    rb_define_const(mLibantargis,"SDLK_BACKQUOTE", INT2NUM(SDLK_BACKQUOTE));
    rb_define_const(mLibantargis,"SDLK_a", INT2NUM(SDLK_a));
    rb_define_const(mLibantargis,"SDLK_b", INT2NUM(SDLK_b));
    rb_define_const(mLibantargis,"SDLK_c", INT2NUM(SDLK_c));
    rb_define_const(mLibantargis,"SDLK_d", INT2NUM(SDLK_d));
    rb_define_const(mLibantargis,"SDLK_e", INT2NUM(SDLK_e));
    rb_define_const(mLibantargis,"SDLK_f", INT2NUM(SDLK_f));
    rb_define_const(mLibantargis,"SDLK_g", INT2NUM(SDLK_g));
    rb_define_const(mLibantargis,"SDLK_h", INT2NUM(SDLK_h));
    rb_define_const(mLibantargis,"SDLK_i", INT2NUM(SDLK_i));
    rb_define_const(mLibantargis,"SDLK_j", INT2NUM(SDLK_j));
    rb_define_const(mLibantargis,"SDLK_k", INT2NUM(SDLK_k));
    rb_define_const(mLibantargis,"SDLK_l", INT2NUM(SDLK_l));
    rb_define_const(mLibantargis,"SDLK_m", INT2NUM(SDLK_m));
    rb_define_const(mLibantargis,"SDLK_n", INT2NUM(SDLK_n));
    rb_define_const(mLibantargis,"SDLK_o", INT2NUM(SDLK_o));
    rb_define_const(mLibantargis,"SDLK_p", INT2NUM(SDLK_p));
    rb_define_const(mLibantargis,"SDLK_q", INT2NUM(SDLK_q));
    rb_define_const(mLibantargis,"SDLK_r", INT2NUM(SDLK_r));
    rb_define_const(mLibantargis,"SDLK_s", INT2NUM(SDLK_s));
    rb_define_const(mLibantargis,"SDLK_t", INT2NUM(SDLK_t));
    rb_define_const(mLibantargis,"SDLK_u", INT2NUM(SDLK_u));
    rb_define_const(mLibantargis,"SDLK_v", INT2NUM(SDLK_v));
    rb_define_const(mLibantargis,"SDLK_w", INT2NUM(SDLK_w));
    rb_define_const(mLibantargis,"SDLK_x", INT2NUM(SDLK_x));
    rb_define_const(mLibantargis,"SDLK_y", INT2NUM(SDLK_y));
    rb_define_const(mLibantargis,"SDLK_z", INT2NUM(SDLK_z));
    rb_define_const(mLibantargis,"SDLK_DELETE", INT2NUM(SDLK_DELETE));
    rb_define_const(mLibantargis,"SDLK_WORLD_0", INT2NUM(SDLK_WORLD_0));
    rb_define_const(mLibantargis,"SDLK_WORLD_1", INT2NUM(SDLK_WORLD_1));
    rb_define_const(mLibantargis,"SDLK_WORLD_2", INT2NUM(SDLK_WORLD_2));
    rb_define_const(mLibantargis,"SDLK_WORLD_3", INT2NUM(SDLK_WORLD_3));
    rb_define_const(mLibantargis,"SDLK_WORLD_4", INT2NUM(SDLK_WORLD_4));
    rb_define_const(mLibantargis,"SDLK_WORLD_5", INT2NUM(SDLK_WORLD_5));
    rb_define_const(mLibantargis,"SDLK_WORLD_6", INT2NUM(SDLK_WORLD_6));
    rb_define_const(mLibantargis,"SDLK_WORLD_7", INT2NUM(SDLK_WORLD_7));
    rb_define_const(mLibantargis,"SDLK_WORLD_8", INT2NUM(SDLK_WORLD_8));
    rb_define_const(mLibantargis,"SDLK_WORLD_9", INT2NUM(SDLK_WORLD_9));
    rb_define_const(mLibantargis,"SDLK_WORLD_10", INT2NUM(SDLK_WORLD_10));
    rb_define_const(mLibantargis,"SDLK_WORLD_11", INT2NUM(SDLK_WORLD_11));
    rb_define_const(mLibantargis,"SDLK_WORLD_12", INT2NUM(SDLK_WORLD_12));
    rb_define_const(mLibantargis,"SDLK_WORLD_13", INT2NUM(SDLK_WORLD_13));
    rb_define_const(mLibantargis,"SDLK_WORLD_14", INT2NUM(SDLK_WORLD_14));
    rb_define_const(mLibantargis,"SDLK_WORLD_15", INT2NUM(SDLK_WORLD_15));
    rb_define_const(mLibantargis,"SDLK_WORLD_16", INT2NUM(SDLK_WORLD_16));
    rb_define_const(mLibantargis,"SDLK_WORLD_17", INT2NUM(SDLK_WORLD_17));
    rb_define_const(mLibantargis,"SDLK_WORLD_18", INT2NUM(SDLK_WORLD_18));
    rb_define_const(mLibantargis,"SDLK_WORLD_19", INT2NUM(SDLK_WORLD_19));
    rb_define_const(mLibantargis,"SDLK_WORLD_20", INT2NUM(SDLK_WORLD_20));
    rb_define_const(mLibantargis,"SDLK_WORLD_21", INT2NUM(SDLK_WORLD_21));
    rb_define_const(mLibantargis,"SDLK_WORLD_22", INT2NUM(SDLK_WORLD_22));
    rb_define_const(mLibantargis,"SDLK_WORLD_23", INT2NUM(SDLK_WORLD_23));
    rb_define_const(mLibantargis,"SDLK_WORLD_24", INT2NUM(SDLK_WORLD_24));
    rb_define_const(mLibantargis,"SDLK_WORLD_25", INT2NUM(SDLK_WORLD_25));
    rb_define_const(mLibantargis,"SDLK_WORLD_26", INT2NUM(SDLK_WORLD_26));
    rb_define_const(mLibantargis,"SDLK_WORLD_27", INT2NUM(SDLK_WORLD_27));
    rb_define_const(mLibantargis,"SDLK_WORLD_28", INT2NUM(SDLK_WORLD_28));
    rb_define_const(mLibantargis,"SDLK_WORLD_29", INT2NUM(SDLK_WORLD_29));
    rb_define_const(mLibantargis,"SDLK_WORLD_30", INT2NUM(SDLK_WORLD_30));
    rb_define_const(mLibantargis,"SDLK_WORLD_31", INT2NUM(SDLK_WORLD_31));
    rb_define_const(mLibantargis,"SDLK_WORLD_32", INT2NUM(SDLK_WORLD_32));
    rb_define_const(mLibantargis,"SDLK_WORLD_33", INT2NUM(SDLK_WORLD_33));
    rb_define_const(mLibantargis,"SDLK_WORLD_34", INT2NUM(SDLK_WORLD_34));
    rb_define_const(mLibantargis,"SDLK_WORLD_35", INT2NUM(SDLK_WORLD_35));
    rb_define_const(mLibantargis,"SDLK_WORLD_36", INT2NUM(SDLK_WORLD_36));
    rb_define_const(mLibantargis,"SDLK_WORLD_37", INT2NUM(SDLK_WORLD_37));
    rb_define_const(mLibantargis,"SDLK_WORLD_38", INT2NUM(SDLK_WORLD_38));
    rb_define_const(mLibantargis,"SDLK_WORLD_39", INT2NUM(SDLK_WORLD_39));
    rb_define_const(mLibantargis,"SDLK_WORLD_40", INT2NUM(SDLK_WORLD_40));
    rb_define_const(mLibantargis,"SDLK_WORLD_41", INT2NUM(SDLK_WORLD_41));
    rb_define_const(mLibantargis,"SDLK_WORLD_42", INT2NUM(SDLK_WORLD_42));
    rb_define_const(mLibantargis,"SDLK_WORLD_43", INT2NUM(SDLK_WORLD_43));
    rb_define_const(mLibantargis,"SDLK_WORLD_44", INT2NUM(SDLK_WORLD_44));
    rb_define_const(mLibantargis,"SDLK_WORLD_45", INT2NUM(SDLK_WORLD_45));
    rb_define_const(mLibantargis,"SDLK_WORLD_46", INT2NUM(SDLK_WORLD_46));
    rb_define_const(mLibantargis,"SDLK_WORLD_47", INT2NUM(SDLK_WORLD_47));
    rb_define_const(mLibantargis,"SDLK_WORLD_48", INT2NUM(SDLK_WORLD_48));
    rb_define_const(mLibantargis,"SDLK_WORLD_49", INT2NUM(SDLK_WORLD_49));
    rb_define_const(mLibantargis,"SDLK_WORLD_50", INT2NUM(SDLK_WORLD_50));
    rb_define_const(mLibantargis,"SDLK_WORLD_51", INT2NUM(SDLK_WORLD_51));
    rb_define_const(mLibantargis,"SDLK_WORLD_52", INT2NUM(SDLK_WORLD_52));
    rb_define_const(mLibantargis,"SDLK_WORLD_53", INT2NUM(SDLK_WORLD_53));
    rb_define_const(mLibantargis,"SDLK_WORLD_54", INT2NUM(SDLK_WORLD_54));
    rb_define_const(mLibantargis,"SDLK_WORLD_55", INT2NUM(SDLK_WORLD_55));
    rb_define_const(mLibantargis,"SDLK_WORLD_56", INT2NUM(SDLK_WORLD_56));
    rb_define_const(mLibantargis,"SDLK_WORLD_57", INT2NUM(SDLK_WORLD_57));
    rb_define_const(mLibantargis,"SDLK_WORLD_58", INT2NUM(SDLK_WORLD_58));
    rb_define_const(mLibantargis,"SDLK_WORLD_59", INT2NUM(SDLK_WORLD_59));
    rb_define_const(mLibantargis,"SDLK_WORLD_60", INT2NUM(SDLK_WORLD_60));
    rb_define_const(mLibantargis,"SDLK_WORLD_61", INT2NUM(SDLK_WORLD_61));
    rb_define_const(mLibantargis,"SDLK_WORLD_62", INT2NUM(SDLK_WORLD_62));
    rb_define_const(mLibantargis,"SDLK_WORLD_63", INT2NUM(SDLK_WORLD_63));
    rb_define_const(mLibantargis,"SDLK_WORLD_64", INT2NUM(SDLK_WORLD_64));
    rb_define_const(mLibantargis,"SDLK_WORLD_65", INT2NUM(SDLK_WORLD_65));
    rb_define_const(mLibantargis,"SDLK_WORLD_66", INT2NUM(SDLK_WORLD_66));
    rb_define_const(mLibantargis,"SDLK_WORLD_67", INT2NUM(SDLK_WORLD_67));
    rb_define_const(mLibantargis,"SDLK_WORLD_68", INT2NUM(SDLK_WORLD_68));
    rb_define_const(mLibantargis,"SDLK_WORLD_69", INT2NUM(SDLK_WORLD_69));
    rb_define_const(mLibantargis,"SDLK_WORLD_70", INT2NUM(SDLK_WORLD_70));
    rb_define_const(mLibantargis,"SDLK_WORLD_71", INT2NUM(SDLK_WORLD_71));
    rb_define_const(mLibantargis,"SDLK_WORLD_72", INT2NUM(SDLK_WORLD_72));
    rb_define_const(mLibantargis,"SDLK_WORLD_73", INT2NUM(SDLK_WORLD_73));
    rb_define_const(mLibantargis,"SDLK_WORLD_74", INT2NUM(SDLK_WORLD_74));
    rb_define_const(mLibantargis,"SDLK_WORLD_75", INT2NUM(SDLK_WORLD_75));
    rb_define_const(mLibantargis,"SDLK_WORLD_76", INT2NUM(SDLK_WORLD_76));
    rb_define_const(mLibantargis,"SDLK_WORLD_77", INT2NUM(SDLK_WORLD_77));
    rb_define_const(mLibantargis,"SDLK_WORLD_78", INT2NUM(SDLK_WORLD_78));
    rb_define_const(mLibantargis,"SDLK_WORLD_79", INT2NUM(SDLK_WORLD_79));
    rb_define_const(mLibantargis,"SDLK_WORLD_80", INT2NUM(SDLK_WORLD_80));
    rb_define_const(mLibantargis,"SDLK_WORLD_81", INT2NUM(SDLK_WORLD_81));
    rb_define_const(mLibantargis,"SDLK_WORLD_82", INT2NUM(SDLK_WORLD_82));
    rb_define_const(mLibantargis,"SDLK_WORLD_83", INT2NUM(SDLK_WORLD_83));
    rb_define_const(mLibantargis,"SDLK_WORLD_84", INT2NUM(SDLK_WORLD_84));
    rb_define_const(mLibantargis,"SDLK_WORLD_85", INT2NUM(SDLK_WORLD_85));
    rb_define_const(mLibantargis,"SDLK_WORLD_86", INT2NUM(SDLK_WORLD_86));
    rb_define_const(mLibantargis,"SDLK_WORLD_87", INT2NUM(SDLK_WORLD_87));
    rb_define_const(mLibantargis,"SDLK_WORLD_88", INT2NUM(SDLK_WORLD_88));
    rb_define_const(mLibantargis,"SDLK_WORLD_89", INT2NUM(SDLK_WORLD_89));
    rb_define_const(mLibantargis,"SDLK_WORLD_90", INT2NUM(SDLK_WORLD_90));
    rb_define_const(mLibantargis,"SDLK_WORLD_91", INT2NUM(SDLK_WORLD_91));
    rb_define_const(mLibantargis,"SDLK_WORLD_92", INT2NUM(SDLK_WORLD_92));
    rb_define_const(mLibantargis,"SDLK_WORLD_93", INT2NUM(SDLK_WORLD_93));
    rb_define_const(mLibantargis,"SDLK_WORLD_94", INT2NUM(SDLK_WORLD_94));
    rb_define_const(mLibantargis,"SDLK_WORLD_95", INT2NUM(SDLK_WORLD_95));
    rb_define_const(mLibantargis,"SDLK_KP0", INT2NUM(SDLK_KP0));
    rb_define_const(mLibantargis,"SDLK_KP1", INT2NUM(SDLK_KP1));
    rb_define_const(mLibantargis,"SDLK_KP2", INT2NUM(SDLK_KP2));
    rb_define_const(mLibantargis,"SDLK_KP3", INT2NUM(SDLK_KP3));
    rb_define_const(mLibantargis,"SDLK_KP4", INT2NUM(SDLK_KP4));
    rb_define_const(mLibantargis,"SDLK_KP5", INT2NUM(SDLK_KP5));
    rb_define_const(mLibantargis,"SDLK_KP6", INT2NUM(SDLK_KP6));
    rb_define_const(mLibantargis,"SDLK_KP7", INT2NUM(SDLK_KP7));
    rb_define_const(mLibantargis,"SDLK_KP8", INT2NUM(SDLK_KP8));
    rb_define_const(mLibantargis,"SDLK_KP9", INT2NUM(SDLK_KP9));
    rb_define_const(mLibantargis,"SDLK_KP_PERIOD", INT2NUM(SDLK_KP_PERIOD));
    rb_define_const(mLibantargis,"SDLK_KP_DIVIDE", INT2NUM(SDLK_KP_DIVIDE));
    rb_define_const(mLibantargis,"SDLK_KP_MULTIPLY", INT2NUM(SDLK_KP_MULTIPLY));
    rb_define_const(mLibantargis,"SDLK_KP_MINUS", INT2NUM(SDLK_KP_MINUS));
    rb_define_const(mLibantargis,"SDLK_KP_PLUS", INT2NUM(SDLK_KP_PLUS));
    rb_define_const(mLibantargis,"SDLK_KP_ENTER", INT2NUM(SDLK_KP_ENTER));
    rb_define_const(mLibantargis,"SDLK_KP_EQUALS", INT2NUM(SDLK_KP_EQUALS));
    rb_define_const(mLibantargis,"SDLK_UP", INT2NUM(SDLK_UP));
    rb_define_const(mLibantargis,"SDLK_DOWN", INT2NUM(SDLK_DOWN));
    rb_define_const(mLibantargis,"SDLK_RIGHT", INT2NUM(SDLK_RIGHT));
    rb_define_const(mLibantargis,"SDLK_LEFT", INT2NUM(SDLK_LEFT));
    rb_define_const(mLibantargis,"SDLK_INSERT", INT2NUM(SDLK_INSERT));
    rb_define_const(mLibantargis,"SDLK_HOME", INT2NUM(SDLK_HOME));
    rb_define_const(mLibantargis,"SDLK_END", INT2NUM(SDLK_END));
    rb_define_const(mLibantargis,"SDLK_PAGEUP", INT2NUM(SDLK_PAGEUP));
    rb_define_const(mLibantargis,"SDLK_PAGEDOWN", INT2NUM(SDLK_PAGEDOWN));
    rb_define_const(mLibantargis,"SDLK_F1", INT2NUM(SDLK_F1));
    rb_define_const(mLibantargis,"SDLK_F2", INT2NUM(SDLK_F2));
    rb_define_const(mLibantargis,"SDLK_F3", INT2NUM(SDLK_F3));
    rb_define_const(mLibantargis,"SDLK_F4", INT2NUM(SDLK_F4));
    rb_define_const(mLibantargis,"SDLK_F5", INT2NUM(SDLK_F5));
    rb_define_const(mLibantargis,"SDLK_F6", INT2NUM(SDLK_F6));
    rb_define_const(mLibantargis,"SDLK_F7", INT2NUM(SDLK_F7));
    rb_define_const(mLibantargis,"SDLK_F8", INT2NUM(SDLK_F8));
    rb_define_const(mLibantargis,"SDLK_F9", INT2NUM(SDLK_F9));
    rb_define_const(mLibantargis,"SDLK_F10", INT2NUM(SDLK_F10));
    rb_define_const(mLibantargis,"SDLK_F11", INT2NUM(SDLK_F11));
    rb_define_const(mLibantargis,"SDLK_F12", INT2NUM(SDLK_F12));
    rb_define_const(mLibantargis,"SDLK_F13", INT2NUM(SDLK_F13));
    rb_define_const(mLibantargis,"SDLK_F14", INT2NUM(SDLK_F14));
    rb_define_const(mLibantargis,"SDLK_F15", INT2NUM(SDLK_F15));
    rb_define_const(mLibantargis,"SDLK_NUMLOCK", INT2NUM(SDLK_NUMLOCK));
    rb_define_const(mLibantargis,"SDLK_CAPSLOCK", INT2NUM(SDLK_CAPSLOCK));
    rb_define_const(mLibantargis,"SDLK_SCROLLOCK", INT2NUM(SDLK_SCROLLOCK));
    rb_define_const(mLibantargis,"SDLK_RSHIFT", INT2NUM(SDLK_RSHIFT));
    rb_define_const(mLibantargis,"SDLK_LSHIFT", INT2NUM(SDLK_LSHIFT));
    rb_define_const(mLibantargis,"SDLK_RCTRL", INT2NUM(SDLK_RCTRL));
    rb_define_const(mLibantargis,"SDLK_LCTRL", INT2NUM(SDLK_LCTRL));
    rb_define_const(mLibantargis,"SDLK_RALT", INT2NUM(SDLK_RALT));
    rb_define_const(mLibantargis,"SDLK_LALT", INT2NUM(SDLK_LALT));
    rb_define_const(mLibantargis,"SDLK_RMETA", INT2NUM(SDLK_RMETA));
    rb_define_const(mLibantargis,"SDLK_LMETA", INT2NUM(SDLK_LMETA));
    rb_define_const(mLibantargis,"SDLK_LSUPER", INT2NUM(SDLK_LSUPER));
    rb_define_const(mLibantargis,"SDLK_RSUPER", INT2NUM(SDLK_RSUPER));
    rb_define_const(mLibantargis,"SDLK_MODE", INT2NUM(SDLK_MODE));
    rb_define_const(mLibantargis,"SDLK_COMPOSE", INT2NUM(SDLK_COMPOSE));
    rb_define_const(mLibantargis,"SDLK_HELP", INT2NUM(SDLK_HELP));
    rb_define_const(mLibantargis,"SDLK_PRINT", INT2NUM(SDLK_PRINT));
    rb_define_const(mLibantargis,"SDLK_SYSREQ", INT2NUM(SDLK_SYSREQ));
    rb_define_const(mLibantargis,"SDLK_BREAK", INT2NUM(SDLK_BREAK));
    rb_define_const(mLibantargis,"SDLK_MENU", INT2NUM(SDLK_MENU));
    rb_define_const(mLibantargis,"SDLK_POWER", INT2NUM(SDLK_POWER));
    rb_define_const(mLibantargis,"SDLK_EURO", INT2NUM(SDLK_EURO));
    rb_define_const(mLibantargis,"SDLK_UNDO", INT2NUM(SDLK_UNDO));
    rb_define_const(mLibantargis,"SDLK_LAST", INT2NUM(SDLK_LAST));
    rb_define_const(mLibantargis,"KMOD_NONE", INT2NUM(KMOD_NONE));
    rb_define_const(mLibantargis,"KMOD_LSHIFT", INT2NUM(KMOD_LSHIFT));
    rb_define_const(mLibantargis,"KMOD_RSHIFT", INT2NUM(KMOD_RSHIFT));
    rb_define_const(mLibantargis,"KMOD_LCTRL", INT2NUM(KMOD_LCTRL));
    rb_define_const(mLibantargis,"KMOD_RCTRL", INT2NUM(KMOD_RCTRL));
    rb_define_const(mLibantargis,"KMOD_LALT", INT2NUM(KMOD_LALT));
    rb_define_const(mLibantargis,"KMOD_RALT", INT2NUM(KMOD_RALT));
    rb_define_const(mLibantargis,"KMOD_LMETA", INT2NUM(KMOD_LMETA));
    rb_define_const(mLibantargis,"KMOD_RMETA", INT2NUM(KMOD_RMETA));
    rb_define_const(mLibantargis,"KMOD_NUM", INT2NUM(KMOD_NUM));
    rb_define_const(mLibantargis,"KMOD_CAPS", INT2NUM(KMOD_CAPS));
    rb_define_const(mLibantargis,"KMOD_MODE", INT2NUM(KMOD_MODE));
    rb_define_const(mLibantargis,"KMOD_RESERVED", INT2NUM(KMOD_RESERVED));
    rb_define_module_function(mLibantargis, "disown_AGPainter", VALUEFUNC(_wrap_disown_AGPainter), -1);
    
    cAGPainter.klass = rb_define_class_under(mLibantargis, "AGPainter", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGPainter, (void *) &cAGPainter);
    rb_define_alloc_func(cAGPainter.klass, _wrap_AGPainter_allocate);
    rb_define_method(cAGPainter.klass, "initialize", VALUEFUNC(_wrap_new_AGPainter), -1);
    rb_define_method(cAGPainter.klass, "putPixel", VALUEFUNC(_wrap_AGPainter_putPixel), -1);
    rb_define_method(cAGPainter.klass, "getPixel", VALUEFUNC(_wrap_AGPainter_getPixel), -1);
    rb_define_method(cAGPainter.klass, "drawCircle", VALUEFUNC(_wrap_AGPainter_drawCircle), -1);
    rb_define_method(cAGPainter.klass, "blitTri", VALUEFUNC(_wrap_AGPainter_blitTri), -1);
    rb_define_method(cAGPainter.klass, "blit", VALUEFUNC(_wrap_AGPainter_blit), -1);
    rb_define_method(cAGPainter.klass, "tile", VALUEFUNC(_wrap_AGPainter_tile), -1);
    rb_define_method(cAGPainter.klass, "transform", VALUEFUNC(_wrap_AGPainter_transform), -1);
    rb_define_method(cAGPainter.klass, "setNull", VALUEFUNC(_wrap_AGPainter_setNull), -1);
    rb_define_method(cAGPainter.klass, "renderText", VALUEFUNC(_wrap_AGPainter_renderText), -1);
    rb_define_method(cAGPainter.klass, "getRect", VALUEFUNC(_wrap_AGPainter_getRect), -1);
    rb_define_method(cAGPainter.klass, "drawGradient", VALUEFUNC(_wrap_AGPainter_drawGradient), -1);
    rb_define_method(cAGPainter.klass, "drawBorder", VALUEFUNC(_wrap_AGPainter_drawBorder), -1);
    rb_define_method(cAGPainter.klass, "drawRect", VALUEFUNC(_wrap_AGPainter_drawRect), -1);
    rb_define_method(cAGPainter.klass, "drawLine", VALUEFUNC(_wrap_AGPainter_drawLine), -1);
    cAGPainter.mark = 0;
    cAGPainter.destroy = (void (*)(void *)) free_AGPainter;
    
    cAGNodeList.klass = rb_define_class_under(mLibantargis, "AGNodeList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTNode_t, (void *) &cAGNodeList);
    rb_include_module(cAGNodeList.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGNodeList.klass, _wrap_AGNodeList_allocate);
    rb_define_method(cAGNodeList.klass, "initialize", VALUEFUNC(_wrap_new_AGNodeList), -1);
    rb_define_method(cAGNodeList.klass, "length", VALUEFUNC(_wrap_AGNodeList___len__), -1);
    rb_define_method(cAGNodeList.klass, "empty?", VALUEFUNC(_wrap_AGNodeList_emptyq___), -1);
    rb_define_method(cAGNodeList.klass, "clear", VALUEFUNC(_wrap_AGNodeList_clear), -1);
    rb_define_method(cAGNodeList.klass, "push", VALUEFUNC(_wrap_AGNodeList_push), -1);
    rb_define_method(cAGNodeList.klass, "pop", VALUEFUNC(_wrap_AGNodeList_pop), -1);
    rb_define_method(cAGNodeList.klass, "[]", VALUEFUNC(_wrap_AGNodeList___getitem__), -1);
    rb_define_method(cAGNodeList.klass, "[]=", VALUEFUNC(_wrap_AGNodeList___setitem__), -1);
    rb_define_method(cAGNodeList.klass, "each", VALUEFUNC(_wrap_AGNodeList_each), -1);
    cAGNodeList.mark = 0;
    cAGNodeList.destroy = (void (*)(void *)) free_std_vector_Sl_Node_Sg_;
    
    cAGNodePList.klass = rb_define_class_under(mLibantargis, "AGNodePList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTNode_p_t, (void *) &cAGNodePList);
    rb_include_module(cAGNodePList.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGNodePList.klass, _wrap_AGNodePList_allocate);
    rb_define_method(cAGNodePList.klass, "initialize", VALUEFUNC(_wrap_new_AGNodePList), -1);
    rb_define_method(cAGNodePList.klass, "length", VALUEFUNC(_wrap_AGNodePList___len__), -1);
    rb_define_method(cAGNodePList.klass, "empty?", VALUEFUNC(_wrap_AGNodePList_emptyq___), -1);
    rb_define_method(cAGNodePList.klass, "clear", VALUEFUNC(_wrap_AGNodePList_clear), -1);
    rb_define_method(cAGNodePList.klass, "push", VALUEFUNC(_wrap_AGNodePList_push), -1);
    rb_define_method(cAGNodePList.klass, "pop", VALUEFUNC(_wrap_AGNodePList_pop), -1);
    rb_define_method(cAGNodePList.klass, "[]", VALUEFUNC(_wrap_AGNodePList___getitem__), -1);
    rb_define_method(cAGNodePList.klass, "[]=", VALUEFUNC(_wrap_AGNodePList___setitem__), -1);
    rb_define_method(cAGNodePList.klass, "each", VALUEFUNC(_wrap_AGNodePList_each), -1);
    cAGNodePList.mark = 0;
    cAGNodePList.destroy = (void (*)(void *)) free_std_vector_Sl_Node_Sm__Sg_;
    
    cAGVector3List.klass = rb_define_class_under(mLibantargis, "AGVector3List", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTAGVector3_t, (void *) &cAGVector3List);
    rb_include_module(cAGVector3List.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGVector3List.klass, _wrap_AGVector3List_allocate);
    rb_define_method(cAGVector3List.klass, "initialize", VALUEFUNC(_wrap_new_AGVector3List), -1);
    rb_define_method(cAGVector3List.klass, "length", VALUEFUNC(_wrap_AGVector3List___len__), -1);
    rb_define_method(cAGVector3List.klass, "empty?", VALUEFUNC(_wrap_AGVector3List_emptyq___), -1);
    rb_define_method(cAGVector3List.klass, "clear", VALUEFUNC(_wrap_AGVector3List_clear), -1);
    rb_define_method(cAGVector3List.klass, "push", VALUEFUNC(_wrap_AGVector3List_push), -1);
    rb_define_method(cAGVector3List.klass, "pop", VALUEFUNC(_wrap_AGVector3List_pop), -1);
    rb_define_method(cAGVector3List.klass, "[]", VALUEFUNC(_wrap_AGVector3List___getitem__), -1);
    rb_define_method(cAGVector3List.klass, "[]=", VALUEFUNC(_wrap_AGVector3List___setitem__), -1);
    rb_define_method(cAGVector3List.klass, "each", VALUEFUNC(_wrap_AGVector3List_each), -1);
    cAGVector3List.mark = 0;
    cAGVector3List.destroy = (void (*)(void *)) free_std_vector_Sl_AGVector3_Sg_;
    
    cAGVector4List.klass = rb_define_class_under(mLibantargis, "AGVector4List", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTAGVector4_t, (void *) &cAGVector4List);
    rb_include_module(cAGVector4List.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGVector4List.klass, _wrap_AGVector4List_allocate);
    rb_define_method(cAGVector4List.klass, "initialize", VALUEFUNC(_wrap_new_AGVector4List), -1);
    rb_define_method(cAGVector4List.klass, "length", VALUEFUNC(_wrap_AGVector4List___len__), -1);
    rb_define_method(cAGVector4List.klass, "empty?", VALUEFUNC(_wrap_AGVector4List_emptyq___), -1);
    rb_define_method(cAGVector4List.klass, "clear", VALUEFUNC(_wrap_AGVector4List_clear), -1);
    rb_define_method(cAGVector4List.klass, "push", VALUEFUNC(_wrap_AGVector4List_push), -1);
    rb_define_method(cAGVector4List.klass, "pop", VALUEFUNC(_wrap_AGVector4List_pop), -1);
    rb_define_method(cAGVector4List.klass, "[]", VALUEFUNC(_wrap_AGVector4List___getitem__), -1);
    rb_define_method(cAGVector4List.klass, "[]=", VALUEFUNC(_wrap_AGVector4List___setitem__), -1);
    rb_define_method(cAGVector4List.klass, "each", VALUEFUNC(_wrap_AGVector4List_each), -1);
    cAGVector4List.mark = 0;
    cAGVector4List.destroy = (void (*)(void *)) free_std_vector_Sl_AGVector4_Sg_;
    rb_define_module_function(mLibantargis, "disown_HeightMap", VALUEFUNC(_wrap_disown_HeightMap), -1);
    
    cHeightMap.klass = rb_define_class_under(mLibantargis, "HeightMap", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_HeightMap, (void *) &cHeightMap);
    rb_define_alloc_func(cHeightMap.klass, _wrap_HeightMap_allocate);
    rb_define_method(cHeightMap.klass, "initialize", VALUEFUNC(_wrap_new_HeightMap), -1);
    rb_define_method(cHeightMap.klass, "setScene", VALUEFUNC(_wrap_HeightMap_setScene), -1);
    rb_define_method(cHeightMap.klass, "getScene", VALUEFUNC(_wrap_HeightMap_getScene), -1);
    rb_define_method(cHeightMap.klass, "getHeight", VALUEFUNC(_wrap_HeightMap_getHeight), -1);
    rb_define_method(cHeightMap.klass, "getNormal", VALUEFUNC(_wrap_HeightMap_getNormal), -1);
    rb_define_method(cHeightMap.klass, "getVertex", VALUEFUNC(_wrap_HeightMap_getVertex), -1);
    rb_define_method(cHeightMap.klass, "get", VALUEFUNC(_wrap_HeightMap_get), -1);
    rb_define_method(cHeightMap.klass, "getGrass", VALUEFUNC(_wrap_HeightMap_getGrass), -1);
    rb_define_method(cHeightMap.klass, "getW", VALUEFUNC(_wrap_HeightMap_getW), -1);
    rb_define_method(cHeightMap.klass, "getH", VALUEFUNC(_wrap_HeightMap_getH), -1);
    rb_define_method(cHeightMap.klass, "truncPos", VALUEFUNC(_wrap_HeightMap_truncPos), -1);
    rb_define_method(cHeightMap.klass, "saveXML", VALUEFUNC(_wrap_HeightMap_saveXML), -1);
    rb_define_method(cHeightMap.klass, "loadXML", VALUEFUNC(_wrap_HeightMap_loadXML), -1);
    rb_define_method(cHeightMap.klass, "setHeight", VALUEFUNC(_wrap_HeightMap_setHeight), -1);
    rb_define_method(cHeightMap.klass, "set", VALUEFUNC(_wrap_HeightMap_set), -1);
    rb_define_method(cHeightMap.klass, "getTerrainMesh", VALUEFUNC(_wrap_HeightMap_getTerrainMesh), -1);
    rb_define_method(cHeightMap.klass, "mapChanged", VALUEFUNC(_wrap_HeightMap_mapChanged), -1);
    cHeightMap.mark = 0;
    cHeightMap.destroy = (void (*)(void *)) free_HeightMap;
    rb_define_module_function(mLibantargis, "AntMap_markfunc", VALUEFUNC(_wrap_AntMap_markfunc), -1);
    rb_define_module_function(mLibantargis, "disown_AntMap", VALUEFUNC(_wrap_disown_AntMap), -1);
    
    cAntMap.klass = rb_define_class_under(mLibantargis, "AntMap", ((swig_class *) SWIGTYPE_p_HeightMap->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AntMap, (void *) &cAntMap);
    rb_define_alloc_func(cAntMap.klass, _wrap_AntMap_allocate);
    rb_define_method(cAntMap.klass, "initialize", VALUEFUNC(_wrap_new_AntMap), -1);
    rb_define_method(cAntMap.klass, "insertEntity", VALUEFUNC(_wrap_AntMap_insertEntity), -1);
    rb_define_method(cAntMap.klass, "removeEntity", VALUEFUNC(_wrap_AntMap_removeEntity), -1);
    rb_define_method(cAntMap.klass, "clear", VALUEFUNC(_wrap_AntMap_clear), -1);
    rb_define_method(cAntMap.klass, "getNewID", VALUEFUNC(_wrap_AntMap_getNewID), -1);
    rb_define_method(cAntMap.klass, "getEntities", VALUEFUNC(_wrap_AntMap_getEntities), -1);
    rb_define_method(cAntMap.klass, "getAllEntities", VALUEFUNC(_wrap_AntMap_getAllEntities), -1);
    rb_define_method(cAntMap.klass, "getAllEntitiesV", VALUEFUNC(_wrap_AntMap_getAllEntitiesV), -1);
    rb_define_method(cAntMap.klass, "getEntity", VALUEFUNC(_wrap_AntMap_getEntity), -1);
    rb_define_method(cAntMap.klass, "getByName", VALUEFUNC(_wrap_AntMap_getByName), -1);
    rb_define_method(cAntMap.klass, "getNext", VALUEFUNC(_wrap_AntMap_getNext), -1);
    rb_define_method(cAntMap.klass, "loadEntity", VALUEFUNC(_wrap_AntMap_loadEntity), -1);
    rb_define_method(cAntMap.klass, "saveXML", VALUEFUNC(_wrap_AntMap_saveXML), -1);
    rb_define_method(cAntMap.klass, "loadXML", VALUEFUNC(_wrap_AntMap_loadXML), -1);
    rb_define_method(cAntMap.klass, "saveMap", VALUEFUNC(_wrap_AntMap_saveMap), -1);
    rb_define_method(cAntMap.klass, "loadMap", VALUEFUNC(_wrap_AntMap_loadMap), -1);
    rb_define_method(cAntMap.klass, "move", VALUEFUNC(_wrap_AntMap_move), -1);
    rb_define_method(cAntMap.klass, "getPos", VALUEFUNC(_wrap_AntMap_getPos), -1);
    rb_define_method(cAntMap.klass, "entsChanged", VALUEFUNC(_wrap_AntMap_entsChanged), -1);
    rb_define_method(cAntMap.klass, "mapChanged", VALUEFUNC(_wrap_AntMap_mapChanged), -1);
    rb_define_method(cAntMap.klass, "mRUBY=", VALUEFUNC(_wrap_AntMap_mRUBY_set), -1);
    rb_define_method(cAntMap.klass, "mRUBY", VALUEFUNC(_wrap_AntMap_mRUBY_get), -1);
    rb_define_method(cAntMap.klass, "mRubyObject=", VALUEFUNC(_wrap_AntMap_mRubyObject_set), -1);
    rb_define_method(cAntMap.klass, "mRubyObject", VALUEFUNC(_wrap_AntMap_mRubyObject_get), -1);
    cAntMap.mark = (void (*)(void *)) AntMap_markfunc;
    cAntMap.destroy = (void (*)(void *)) free_AntMap;
    rb_define_module_function(mLibantargis, "getMap", VALUEFUNC(_wrap_getMap), -1);
    rb_define_module_function(mLibantargis, "disown_SceneNode", VALUEFUNC(_wrap_disown_SceneNode), -1);
    
    cSceneNode.klass = rb_define_class_under(mLibantargis, "SceneNode", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_SceneNode, (void *) &cSceneNode);
    rb_define_alloc_func(cSceneNode.klass, _wrap_SceneNode_allocate);
    rb_define_method(cSceneNode.klass, "initialize", VALUEFUNC(_wrap_new_SceneNode), -1);
    rb_define_method(cSceneNode.klass, "drawShadow", VALUEFUNC(_wrap_SceneNode_drawShadow), -1);
    rb_define_method(cSceneNode.klass, "drawDepth", VALUEFUNC(_wrap_SceneNode_drawDepth), -1);
    rb_define_method(cSceneNode.klass, "draw", VALUEFUNC(_wrap_SceneNode_draw), -1);
    rb_define_method(cSceneNode.klass, "advance", VALUEFUNC(_wrap_SceneNode_advance), -1);
    rb_define_method(cSceneNode.klass, "getTriangles", VALUEFUNC(_wrap_SceneNode_getTriangles), -1);
    rb_define_method(cSceneNode.klass, "lineHit", VALUEFUNC(_wrap_SceneNode_lineHit), -1);
    rb_define_method(cSceneNode.klass, "sort", VALUEFUNC(_wrap_SceneNode_sort), -1);
    rb_define_method(cSceneNode.klass, "mapChanged", VALUEFUNC(_wrap_SceneNode_mapChanged), -1);
    rb_define_method(cSceneNode.klass, "==", VALUEFUNC(_wrap_SceneNode___eq__), -1);
    cSceneNode.mark = 0;
    cSceneNode.destroy = (void (*)(void *)) free_SceneNode;
    
    cMeshVertex.klass = rb_define_class_under(mLibantargis, "MeshVertex", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_MeshVertex, (void *) &cMeshVertex);
    rb_define_alloc_func(cMeshVertex.klass, _wrap_MeshVertex_allocate);
    rb_define_method(cMeshVertex.klass, "initialize", VALUEFUNC(_wrap_new_MeshVertex), -1);
    rb_define_method(cMeshVertex.klass, "v=", VALUEFUNC(_wrap_MeshVertex_v_set), -1);
    rb_define_method(cMeshVertex.klass, "v", VALUEFUNC(_wrap_MeshVertex_v_get), -1);
    rb_define_method(cMeshVertex.klass, "c=", VALUEFUNC(_wrap_MeshVertex_c_set), -1);
    rb_define_method(cMeshVertex.klass, "c", VALUEFUNC(_wrap_MeshVertex_c_get), -1);
    rb_define_method(cMeshVertex.klass, "n=", VALUEFUNC(_wrap_MeshVertex_n_set), -1);
    rb_define_method(cMeshVertex.klass, "n", VALUEFUNC(_wrap_MeshVertex_n_get), -1);
    rb_define_method(cMeshVertex.klass, "t=", VALUEFUNC(_wrap_MeshVertex_t_set), -1);
    rb_define_method(cMeshVertex.klass, "t", VALUEFUNC(_wrap_MeshVertex_t_get), -1);
    rb_define_method(cMeshVertex.klass, "<", VALUEFUNC(_wrap_MeshVertex___lt__), -1);
    cMeshVertex.mark = 0;
    cMeshVertex.destroy = (void (*)(void *)) free_MeshVertex;
    
    cMeshOptimizer.klass = rb_define_class_under(mLibantargis, "MeshOptimizer", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_MeshOptimizer, (void *) &cMeshOptimizer);
    rb_define_alloc_func(cMeshOptimizer.klass, _wrap_MeshOptimizer_allocate);
    rb_define_method(cMeshOptimizer.klass, "initialize", VALUEFUNC(_wrap_new_MeshOptimizer), -1);
    rb_define_method(cMeshOptimizer.klass, "add", VALUEFUNC(_wrap_MeshOptimizer_add), -1);
    rb_define_method(cMeshOptimizer.klass, "getArray", VALUEFUNC(_wrap_MeshOptimizer_getArray), -1);
    cMeshOptimizer.mark = 0;
    cMeshOptimizer.destroy = (void (*)(void *)) free_MeshOptimizer;
    rb_define_module_function(mLibantargis, "disown_MeshData", VALUEFUNC(_wrap_disown_MeshData), -1);
    
    cMeshData.klass = rb_define_class_under(mLibantargis, "MeshData", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_MeshData, (void *) &cMeshData);
    rb_define_alloc_func(cMeshData.klass, _wrap_MeshData_allocate);
    rb_define_method(cMeshData.klass, "initialize", VALUEFUNC(_wrap_new_MeshData), -1);
    rb_define_method(cMeshData.klass, "draw", VALUEFUNC(_wrap_MeshData_draw), -1);
    rb_define_method(cMeshData.klass, "drawShadow", VALUEFUNC(_wrap_MeshData_drawShadow), -1);
    rb_define_method(cMeshData.klass, "drawDepth", VALUEFUNC(_wrap_MeshData_drawDepth), -1);
    rb_define_method(cMeshData.klass, "getTriangles", VALUEFUNC(_wrap_MeshData_getTriangles), -1);
    rb_define_method(cMeshData.klass, "lineHit", VALUEFUNC(_wrap_MeshData_lineHit), -1);
    cMeshData.mark = 0;
    cMeshData.destroy = (void (*)(void *)) free_MeshData;
    rb_define_module_function(mLibantargis, "disown_Mesh", VALUEFUNC(_wrap_disown_Mesh), -1);
    
    cMesh.klass = rb_define_class_under(mLibantargis, "Mesh", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_Mesh, (void *) &cMesh);
    rb_define_alloc_func(cMesh.klass, _wrap_Mesh_allocate);
    rb_define_method(cMesh.klass, "initialize", VALUEFUNC(_wrap_new_Mesh), -1);
    rb_define_method(cMesh.klass, "draw", VALUEFUNC(_wrap_Mesh_draw), -1);
    rb_define_method(cMesh.klass, "drawDepth", VALUEFUNC(_wrap_Mesh_drawDepth), -1);
    rb_define_method(cMesh.klass, "drawShadow", VALUEFUNC(_wrap_Mesh_drawShadow), -1);
    rb_define_method(cMesh.klass, "lineHit", VALUEFUNC(_wrap_Mesh_lineHit), -1);
    rb_define_method(cMesh.klass, "getTriangles", VALUEFUNC(_wrap_Mesh_getTriangles), -1);
    rb_define_method(cMesh.klass, "setPos", VALUEFUNC(_wrap_Mesh_setPos), -1);
    rb_define_method(cMesh.klass, "setRotation", VALUEFUNC(_wrap_Mesh_setRotation), -1);
    cMesh.mark = 0;
    cMesh.destroy = (void (*)(void *)) free_Mesh;
    rb_define_module_function(mLibantargis, "toMesh", VALUEFUNC(_wrap_toMesh), -1);
    
    cPickNode.klass = rb_define_class_under(mLibantargis, "PickNode", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_PickNode, (void *) &cPickNode);
    rb_define_alloc_func(cPickNode.klass, _wrap_PickNode_allocate);
    rb_define_method(cPickNode.klass, "initialize", VALUEFUNC(_wrap_new_PickNode), -1);
    rb_define_method(cPickNode.klass, "pos=", VALUEFUNC(_wrap_PickNode_pos_set), -1);
    rb_define_method(cPickNode.klass, "pos", VALUEFUNC(_wrap_PickNode_pos_get), -1);
    rb_define_method(cPickNode.klass, "node=", VALUEFUNC(_wrap_PickNode_node_set), -1);
    rb_define_method(cPickNode.klass, "node", VALUEFUNC(_wrap_PickNode_node_get), -1);
    rb_define_method(cPickNode.klass, "camDist=", VALUEFUNC(_wrap_PickNode_camDist_set), -1);
    rb_define_method(cPickNode.klass, "camDist", VALUEFUNC(_wrap_PickNode_camDist_get), -1);
    rb_define_method(cPickNode.klass, "<", VALUEFUNC(_wrap_PickNode___lt__), -1);
    cPickNode.mark = 0;
    cPickNode.destroy = (void (*)(void *)) free_PickNode;
    rb_define_module_function(mLibantargis, "Scene_markfunc", VALUEFUNC(_wrap_Scene_markfunc), -1);
    
    cScene.klass = rb_define_class_under(mLibantargis, "Scene", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Scene, (void *) &cScene);
    rb_define_alloc_func(cScene.klass, _wrap_Scene_allocate);
    rb_define_method(cScene.klass, "initialize", VALUEFUNC(_wrap_new_Scene), -1);
    rb_define_method(cScene.klass, "draw", VALUEFUNC(_wrap_Scene_draw), -1);
    rb_define_method(cScene.klass, "setShadow", VALUEFUNC(_wrap_Scene_setShadow), -1);
    rb_define_method(cScene.klass, "getShadow", VALUEFUNC(_wrap_Scene_getShadow), -1);
    rb_define_method(cScene.klass, "addNode", VALUEFUNC(_wrap_Scene_addNode), -1);
    rb_define_method(cScene.klass, "removeNode", VALUEFUNC(_wrap_Scene_removeNode), -1);
    rb_define_method(cScene.klass, "clear", VALUEFUNC(_wrap_Scene_clear), -1);
    rb_define_method(cScene.klass, "setCamera", VALUEFUNC(_wrap_Scene_setCamera), -1);
    rb_define_method(cScene.klass, "advance", VALUEFUNC(_wrap_Scene_advance), -1);
    rb_define_method(cScene.klass, "lineHit", VALUEFUNC(_wrap_Scene_lineHit), -1);
    rb_define_method(cScene.klass, "getLine", VALUEFUNC(_wrap_Scene_getLine), -1);
    rb_define_method(cScene.klass, "mapChanged", VALUEFUNC(_wrap_Scene_mapChanged), -1);
    rb_define_method(cScene.klass, "mRubyObject=", VALUEFUNC(_wrap_Scene_mRubyObject_set), -1);
    rb_define_method(cScene.klass, "mRubyObject", VALUEFUNC(_wrap_Scene_mRubyObject_get), -1);
    rb_define_method(cScene.klass, "mRUBY=", VALUEFUNC(_wrap_Scene_mRUBY_set), -1);
    rb_define_method(cScene.klass, "mRUBY", VALUEFUNC(_wrap_Scene_mRUBY_get), -1);
    cScene.mark = (void (*)(void *)) Scene_markfunc;
    cScene.destroy = (void (*)(void *)) free_Scene;
    rb_define_module_function(mLibantargis, "GLApp_markfunc", VALUEFUNC(_wrap_GLApp_markfunc), -1);
    rb_define_module_function(mLibantargis, "disown_GLApp", VALUEFUNC(_wrap_disown_GLApp), -1);
    
    cGLApp.klass = rb_define_class_under(mLibantargis, "GLApp", ((swig_class *) SWIGTYPE_p_AGApplication->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_GLApp, (void *) &cGLApp);
    rb_define_alloc_func(cGLApp.klass, _wrap_GLApp_allocate);
    rb_define_method(cGLApp.klass, "initialize", VALUEFUNC(_wrap_new_GLApp), -1);
    rb_define_method(cGLApp.klass, "draw", VALUEFUNC(_wrap_GLApp_draw), -1);
    rb_define_method(cGLApp.klass, "drawGL", VALUEFUNC(_wrap_GLApp_drawGL), -1);
    rb_define_method(cGLApp.klass, "eventFrame", VALUEFUNC(_wrap_GLApp_eventFrame), -1);
    rb_define_method(cGLApp.klass, "eventClick", VALUEFUNC(_wrap_GLApp_eventClick), -1);
    rb_define_method(cGLApp.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_GLApp_eventMouseButtonDown), -1);
    rb_define_method(cGLApp.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_GLApp_eventMouseButtonUp), -1);
    rb_define_method(cGLApp.klass, "eventMouseMotion", VALUEFUNC(_wrap_GLApp_eventMouseMotion), -1);
    rb_define_method(cGLApp.klass, "eventKeyDown", VALUEFUNC(_wrap_GLApp_eventKeyDown), -1);
    rb_define_method(cGLApp.klass, "setupLight", VALUEFUNC(_wrap_GLApp_setupLight), -1);
    rb_define_method(cGLApp.klass, "getScene", VALUEFUNC(_wrap_GLApp_getScene), -1);
    cGLApp.mark = (void (*)(void *)) GLApp_markfunc;
    cGLApp.destroy = (void (*)(void *)) free_GLApp;
    
    cResource.klass = rb_define_class_under(mLibantargis, "Resource", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Resource, (void *) &cResource);
    rb_define_alloc_func(cResource.klass, _wrap_Resource_allocate);
    rb_define_method(cResource.klass, "initialize", VALUEFUNC(_wrap_new_Resource), -1);
    rb_define_method(cResource.klass, "get", VALUEFUNC(_wrap_Resource_get), -1);
    rb_define_method(cResource.klass, "add", VALUEFUNC(_wrap_Resource_add), -1);
    rb_define_method(cResource.klass, "sub", VALUEFUNC(_wrap_Resource_sub), -1);
    rb_define_method(cResource.klass, "set", VALUEFUNC(_wrap_Resource_set), -1);
    rb_define_method(cResource.klass, "getAll", VALUEFUNC(_wrap_Resource_getAll), -1);
    rb_define_method(cResource.klass, "takeAll", VALUEFUNC(_wrap_Resource_takeAll), -1);
    cResource.mark = 0;
    cResource.destroy = (void (*)(void *)) free_Resource;
    rb_define_module_function(mLibantargis, "AntEntity_markfunc", VALUEFUNC(_wrap_AntEntity_markfunc), -1);
    rb_define_module_function(mLibantargis, "disown_AntEntity", VALUEFUNC(_wrap_disown_AntEntity), -1);
    
    cAntEntity.klass = rb_define_class_under(mLibantargis, "AntEntity", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AntEntity, (void *) &cAntEntity);
    rb_define_alloc_func(cAntEntity.klass, _wrap_AntEntity_allocate);
    rb_define_method(cAntEntity.klass, "initialize", VALUEFUNC(_wrap_new_AntEntity), -1);
    rb_define_method(cAntEntity.klass, "mDir=", VALUEFUNC(_wrap_AntEntity_mDir_set), -1);
    rb_define_method(cAntEntity.klass, "mDir", VALUEFUNC(_wrap_AntEntity_mDir_get), -1);
    rb_define_method(cAntEntity.klass, "resource=", VALUEFUNC(_wrap_AntEntity_resource_set), -1);
    rb_define_method(cAntEntity.klass, "resource", VALUEFUNC(_wrap_AntEntity_resource_get), -1);
    rb_define_method(cAntEntity.klass, "getPos3D", VALUEFUNC(_wrap_AntEntity_getPos3D), -1);
    rb_define_method(cAntEntity.klass, "getPos2D", VALUEFUNC(_wrap_AntEntity_getPos2D), -1);
    rb_define_method(cAntEntity.klass, "setPos", VALUEFUNC(_wrap_AntEntity_setPos), -1);
    rb_define_method(cAntEntity.klass, "getID", VALUEFUNC(_wrap_AntEntity_getID), -1);
    rb_define_method(cAntEntity.klass, "getName", VALUEFUNC(_wrap_AntEntity_getName), -1);
    rb_define_method(cAntEntity.klass, "setName", VALUEFUNC(_wrap_AntEntity_setName), -1);
    rb_define_method(cAntEntity.klass, "setType", VALUEFUNC(_wrap_AntEntity_setType), -1);
    rb_define_method(cAntEntity.klass, "getType", VALUEFUNC(_wrap_AntEntity_getType), -1);
    rb_define_method(cAntEntity.klass, "xmlName", VALUEFUNC(_wrap_AntEntity_xmlName), -1);
    rb_define_method(cAntEntity.klass, "saveXML", VALUEFUNC(_wrap_AntEntity_saveXML), -1);
    rb_define_method(cAntEntity.klass, "loadXML", VALUEFUNC(_wrap_AntEntity_loadXML), -1);
    rb_define_method(cAntEntity.klass, "newRestJob", VALUEFUNC(_wrap_AntEntity_newRestJob), -1);
    rb_define_method(cAntEntity.klass, "newFetchJob", VALUEFUNC(_wrap_AntEntity_newFetchJob), -1);
    rb_define_method(cAntEntity.klass, "newMoveJob", VALUEFUNC(_wrap_AntEntity_newMoveJob), -1);
    rb_define_method(cAntEntity.klass, "newFightJob", VALUEFUNC(_wrap_AntEntity_newFightJob), -1);
    rb_define_method(cAntEntity.klass, "delJob", VALUEFUNC(_wrap_AntEntity_delJob), -1);
    rb_define_method(cAntEntity.klass, "resourceChanged", VALUEFUNC(_wrap_AntEntity_resourceChanged), -1);
    rb_define_method(cAntEntity.klass, "hasJob", VALUEFUNC(_wrap_AntEntity_hasJob), -1);
    rb_define_method(cAntEntity.klass, "getRect", VALUEFUNC(_wrap_AntEntity_getRect), -1);
    rb_define_method(cAntEntity.klass, "eventNoJob", VALUEFUNC(_wrap_AntEntity_eventNoJob), -1);
    rb_define_method(cAntEntity.klass, "eventJobFinished", VALUEFUNC(_wrap_AntEntity_eventJobFinished), -1);
    rb_define_method(cAntEntity.klass, "eventGotNewJob", VALUEFUNC(_wrap_AntEntity_eventGotNewJob), -1);
    rb_define_method(cAntEntity.klass, "eventGotFight", VALUEFUNC(_wrap_AntEntity_eventGotFight), -1);
    rb_define_method(cAntEntity.klass, "setSpeed", VALUEFUNC(_wrap_AntEntity_setSpeed), -1);
    rb_define_method(cAntEntity.klass, "getSpeed", VALUEFUNC(_wrap_AntEntity_getSpeed), -1);
    rb_define_method(cAntEntity.klass, "getHealSpeed", VALUEFUNC(_wrap_AntEntity_getHealSpeed), -1);
    rb_define_method(cAntEntity.klass, "setHealSpeed", VALUEFUNC(_wrap_AntEntity_setHealSpeed), -1);
    rb_define_method(cAntEntity.klass, "setAggression", VALUEFUNC(_wrap_AntEntity_setAggression), -1);
    rb_define_method(cAntEntity.klass, "getAggression", VALUEFUNC(_wrap_AntEntity_getAggression), -1);
    rb_define_method(cAntEntity.klass, "eventDie", VALUEFUNC(_wrap_AntEntity_eventDie), -1);
    rb_define_method(cAntEntity.klass, "eventDefeated", VALUEFUNC(_wrap_AntEntity_eventDefeated), -1);
    rb_define_method(cAntEntity.klass, "getEnergy", VALUEFUNC(_wrap_AntEntity_getEnergy), -1);
    rb_define_method(cAntEntity.klass, "getMorale", VALUEFUNC(_wrap_AntEntity_getMorale), -1);
    rb_define_method(cAntEntity.klass, "setMesh", VALUEFUNC(_wrap_AntEntity_setMesh), -1);
    rb_define_method(cAntEntity.klass, "getMesh", VALUEFUNC(_wrap_AntEntity_getMesh), -1);
    rb_define_method(cAntEntity.klass, "addMesh", VALUEFUNC(_wrap_AntEntity_addMesh), -1);
    rb_define_method(cAntEntity.klass, "setDirection", VALUEFUNC(_wrap_AntEntity_setDirection), -1);
    rb_define_method(cAntEntity.klass, "decEnergy", VALUEFUNC(_wrap_AntEntity_decEnergy), -1);
    rb_define_method(cAntEntity.klass, "decMorale", VALUEFUNC(_wrap_AntEntity_decMorale), -1);
    rb_define_method(cAntEntity.klass, "eventMapChanged", VALUEFUNC(_wrap_AntEntity_eventMapChanged), -1);
    rb_define_method(cAntEntity.klass, "move", VALUEFUNC(_wrap_AntEntity_move), -1);
    rb_define_method(cAntEntity.klass, "mRubyObject=", VALUEFUNC(_wrap_AntEntity_mRubyObject_set), -1);
    rb_define_method(cAntEntity.klass, "mRubyObject", VALUEFUNC(_wrap_AntEntity_mRubyObject_get), -1);
    rb_define_method(cAntEntity.klass, "mRUBY=", VALUEFUNC(_wrap_AntEntity_mRUBY_set), -1);
    rb_define_method(cAntEntity.klass, "mRUBY", VALUEFUNC(_wrap_AntEntity_mRUBY_get), -1);
    cAntEntity.mark = (void (*)(void *)) AntEntity_markfunc;
    cAntEntity.destroy = (void (*)(void *)) free_AntEntity;
    
    cAntEntityPtr.klass = rb_define_class_under(mLibantargis, "AntEntityPtr", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AntEntityPtr, (void *) &cAntEntityPtr);
    rb_define_alloc_func(cAntEntityPtr.klass, _wrap_AntEntityPtr_allocate);
    rb_define_method(cAntEntityPtr.klass, "initialize", VALUEFUNC(_wrap_new_AntEntityPtr), -1);
    rb_define_method(cAntEntityPtr.klass, "get", VALUEFUNC(_wrap_AntEntityPtr_get), -1);
    cAntEntityPtr.mark = 0;
    cAntEntityPtr.destroy = (void (*)(void *)) free_AntEntityPtr;
    rb_define_module_function(mLibantargis, "disown_TerrainPieceVA", VALUEFUNC(_wrap_disown_TerrainPieceVA), -1);
    
    cTerrainPieceVA.klass = rb_define_class_under(mLibantargis, "TerrainPieceVA", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_TerrainPieceVA, (void *) &cTerrainPieceVA);
    rb_define_alloc_func(cTerrainPieceVA.klass, _wrap_TerrainPieceVA_allocate);
    rb_define_method(cTerrainPieceVA.klass, "initialize", VALUEFUNC(_wrap_new_TerrainPieceVA), -1);
    rb_define_method(cTerrainPieceVA.klass, "draw", VALUEFUNC(_wrap_TerrainPieceVA_draw), -1);
    rb_define_method(cTerrainPieceVA.klass, "drawShadow", VALUEFUNC(_wrap_TerrainPieceVA_drawShadow), -1);
    rb_define_method(cTerrainPieceVA.klass, "drawDepth", VALUEFUNC(_wrap_TerrainPieceVA_drawDepth), -1);
    rb_define_method(cTerrainPieceVA.klass, "lineHit", VALUEFUNC(_wrap_TerrainPieceVA_lineHit), -1);
    rb_define_method(cTerrainPieceVA.klass, "getTriangles", VALUEFUNC(_wrap_TerrainPieceVA_getTriangles), -1);
    rb_define_method(cTerrainPieceVA.klass, "mapChanged", VALUEFUNC(_wrap_TerrainPieceVA_mapChanged), -1);
    cTerrainPieceVA.mark = 0;
    cTerrainPieceVA.destroy = (void (*)(void *)) free_TerrainPieceVA;
    rb_define_module_function(mLibantargis, "disown_TerrainMesh", VALUEFUNC(_wrap_disown_TerrainMesh), -1);
    
    cTerrainMesh.klass = rb_define_class_under(mLibantargis, "TerrainMesh", ((swig_class *) SWIGTYPE_p_SceneNode->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_TerrainMesh, (void *) &cTerrainMesh);
    rb_define_alloc_func(cTerrainMesh.klass, _wrap_TerrainMesh_allocate);
    rb_define_method(cTerrainMesh.klass, "initialize", VALUEFUNC(_wrap_new_TerrainMesh), -1);
    rb_define_method(cTerrainMesh.klass, "advance", VALUEFUNC(_wrap_TerrainMesh_advance), -1);
    rb_define_method(cTerrainMesh.klass, "draw", VALUEFUNC(_wrap_TerrainMesh_draw), -1);
    rb_define_method(cTerrainMesh.klass, "drawShadow", VALUEFUNC(_wrap_TerrainMesh_drawShadow), -1);
    rb_define_method(cTerrainMesh.klass, "drawDepth", VALUEFUNC(_wrap_TerrainMesh_drawDepth), -1);
    rb_define_method(cTerrainMesh.klass, "sort", VALUEFUNC(_wrap_TerrainMesh_sort), -1);
    rb_define_method(cTerrainMesh.klass, "lineHit", VALUEFUNC(_wrap_TerrainMesh_lineHit), -1);
    rb_define_method(cTerrainMesh.klass, "getTriangles", VALUEFUNC(_wrap_TerrainMesh_getTriangles), -1);
    rb_define_method(cTerrainMesh.klass, "mapChanged", VALUEFUNC(_wrap_TerrainMesh_mapChanged), -1);
    cTerrainMesh.mark = 0;
    cTerrainMesh.destroy = (void (*)(void *)) free_TerrainMesh;
    rb_define_module_function(mLibantargis, "toTerrainMesh", VALUEFUNC(_wrap_toTerrainMesh), -1);
    rb_define_module_function(mLibantargis, "disown_GLTree", VALUEFUNC(_wrap_disown_GLTree), -1);
    
    cGLTree.klass = rb_define_class_under(mLibantargis, "GLTree", ((swig_class *) SWIGTYPE_p_Mesh->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_GLTree, (void *) &cGLTree);
    rb_define_alloc_func(cGLTree.klass, _wrap_GLTree_allocate);
    rb_define_method(cGLTree.klass, "initialize", VALUEFUNC(_wrap_new_GLTree), -1);
    rb_define_method(cGLTree.klass, "draw", VALUEFUNC(_wrap_GLTree_draw), -1);
    rb_define_method(cGLTree.klass, "drawDepth", VALUEFUNC(_wrap_GLTree_drawDepth), -1);
    rb_define_method(cGLTree.klass, "drawShadow", VALUEFUNC(_wrap_GLTree_drawShadow), -1);
    rb_define_method(cGLTree.klass, "mydraw", VALUEFUNC(_wrap_GLTree_mydraw), -1);
    rb_define_method(cGLTree.klass, "drawVertex", VALUEFUNC(_wrap_GLTree_drawVertex), -1);
    cGLTree.mark = 0;
    cGLTree.destroy = (void (*)(void *)) free_GLTree;
}


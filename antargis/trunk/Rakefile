#!/usr/bin/env ruby

require 'mkmf'
require 'build/mkmf_support.rb'
require 'build/shell.rb'
require 'pp'
require 'rake/clean.rb'

# run configure if config.rb is not yet present
sh(checkMkmf("$(bindir)/$(ruby_install_name) configure",CONFIG)) unless File.exists?("config.rb")

load 'config.rb'


PKG_VERSION=$CONFIG["version"]

$SOURCEDIRS=[
	"ext/external",
	"ext/basic",
	"ext/sound",
	"ext/math",
	"ext/video",
	"ext/gui",
	"ext/3dengine",
	"ext/game",
]

$LIBDEPS={"ext/basic"=>["SDL","RUBY"]}

$BOASOURCES=$SOURCEDIRS.select{|dir|not dir=~/external/}

MYINCLUDES=$SOURCEDIRS.map{|dir|"-I#{dir}"}.join(" ")

def dependencies(c)
end

def build(file)
	type=nil
	compiler=nil
	case file
		when /\.c$/
			type=:c
			compiler=$CONFIG["CC"]
		when /\.c(c|pp)$/
			type=:c
			compiler=$CONFIG["CXX"]
	end
	if type==:c
		if $CONFIG["CCACHE"]
			compiler=$CONFIG["CCACHE"]+" "+compiler
		end

		output=file.sub(/\.c$/,".o").sub(/\.(cc|cpp)$/,".oo")
		Dir.mkdir(".deps") unless File.exists?(".deps")
		dep=".deps/"+output.gsub("/","_")
		cmd=compiler+" "+$CONFIG["CFLAGS"]+" "+$CONFIG["INCLUDEPATH"]+" "+MYINCLUDES+" -Wp,-MD,#{dep} -o "+output+" -c "+File.expand_path(file)
	else
		raise "Unknown source file"
	end	
	sh cmd
	$?
end

def generateSwigDeps(dir)
	output=File.join(".deps",dir.gsub("/","_")+"_swig.cc")
	input=dir+"/interface.i"
	cflags=$CONFIG["INCLUDEPATH"]+" "+$CONFIG["DEFINES"]+" -DAGEXPORT"
	puts ""
	cmd=$CONFIG["SWIG"]+" #{cflags} -ruby -c++ -M #{input} >#{output}"
	sh cmd
	$?
end

def generateSwig(dir)
	output=dir+"/swig.cc"
	input=dir+"/interface.i"
	cflags=$CONFIG["INCLUDEPATH"]+" "+$CONFIG["DEFINES"]+" -DAGEXPORT"
	cmd=$CONFIG["SWIG"]+" #{cflags} -v -Wall -ruby -c++ -o #{output} #{input}"
	puts ""
	pp cmd
	sh cmd
	$?
end

def linkLib(name,objects)
	name=name.to_s
	winadd=""
	if $CONFIG["target_os"]=="windows"
		winadd="-Wl,--enable-auto-image-base -Xlinker --out-implib -Xlinker #{name.gsub(/\.so$/,".dll")}.a"
	end

	cmd=$CONFIG["CXX"]+" -dH -shared -o #{name} -Lext #{winadd} -Wl,-\\( #{$CONFIG["LDFLAGS"]} #{$CONFIG["LIBPATH"]} #{objects.join(" ")}"
	if $CONFIG["CCACHE"]
		cmd=$CONFIG["CCACHE"]+" "+cmd
	end
	puts ""
	#pp cmd
	sh cmd
	$?
end

def makeDepFilename(file)
	File.join(".deps",file.gsub("\\","_").gsub("/","_"))
end

def getDepsFromCache(filename,source)
	depfile=makeDepFilename(filename)
	if File.exists?(depfile)
		file=File.open(depfile)
		content=file.read
		file.close
		content=content.gsub("\\\n"," ").gsub(/^[^:]*:/,"").split(" ").map{|fn|fn.chomp}
		return [source]+(content-[source])
	end
	[source]
end



desc "Managing dependencies for c/++ files"
getDeps=lambda{|args|
	cfile=args.sub(/\.oo$/,".cc").sub(/\.o$/,".c")
	getDepsFromCache(args,cfile)
}

rule '.o' => getDeps do |t|
	source=t.sources[0]
	build(source)
end
rule '.oo' => getDeps do |t|
	source=t.sources[0]
	build(source)
end


def isWindows
	#return true
	$CONFIG["target_os"]=="windows"
end



libdeps=[]
$SOURCEDIRS.each{|dir|
	base=dir.split("/")[1]
	lib="ext/libantargis#{base}.so"

	# FIXME: check for windows
	if isWindows
		libadd=libdeps.map{|l|"-l#{l.sub(/^.*\/lib(.*)\.so$/,'\1')}"}
	else	
		libadd=libdeps.dup #.map{|l|"-l#{l.sub(/^.*\/(.*)\.so$/,'\1')}"}
	end

	libadd+=$CONFIG["LIBS"].split(" ") if libdeps.length==0
	libadd+=["-Lext"]

	objs=(Dir[dir+"/*.cc"]+Dir[dir+"/*.c"]).select{|file|not file=~/swig/}.map{|file|file.sub(/\.cc$/,".oo").sub(/\.c$/,".o")}

	desc "Build dynamic library #{lib}"
	task lib=>libdeps+objs do |t|
		linkLib(lib,libadd+objs)
	end
	libdeps << lib
}



$SOURCEDIRS.each{|dir|
	base=dir.split("/")[1]
	lib="ext/antargis#{base}.so"

	objs=[dir+"/swig.oo"]

	libdeps=[]
	$SOURCEDIRS.each{|cdir|
		cbase=cdir.split("/")[1]
		libdeps << "ext/libantargis#{cbase}.so"
		break if cdir==dir
	}

	libadd=$CONFIG["LIBS"].split(" ")+["-Lext"]

	
	desc "Build ruby-extension library #{lib}"
	task lib=>libdeps+objs do |t|
		lib=t
		mlibdeps=t.prerequisites
		mlibdeps=t.prerequisites.map{|l|l.sub(/^.*\/lib(.*)\.so$/,'-l\1')} if isWindows
		linkLib(lib,mlibdeps+libadd)
	end
	libdeps=libdeps+[lib]
}




swigDeps=lambda{|t|
	dir=File.join(File.split(t)[0..-2])

	
	deps=getDepsFromCache(t,dir+"/interface.i")
	return deps if deps.length>0

	# FIXME: del this ???

	# FIXME: include correct dependencies
	deps=Dir[dir+"/templates.i"]+Dir[dir+"/*.h"]+[dir+"/interface.i"]

	$SOURCEDIRS.each{|ct|
		if ct=~/#{dir}/
			break
		else
			deps << ct+"/interface.i"  unless ct=~/external/
		end
	}

	pp "DEPS2:",deps
	deps
}

$BOASOURCES.each{|dir|
	swig=dir+"/swig.cc"
	myDeps=swigDeps.call(swig)
	#rule 'swig.cc'=>swigDeps do |t|
	task swig=>myDeps do |t|
		dir=File.join(File.split(t.name)[0..-2])
		generateSwigDeps(dir)
		generateSwig(dir)
	end
}









def importsForInterface(name)
	mdeps=[]
	$SOURCEDIRS.each{|t|
		if name=~/#{t}/
			break
		else
			mdeps << t+"/interface.i" unless t=~/external/
		end
	}
	return mdeps.join(":")
end

interfaceSrc = lambda { |t|
	dir=File.join(File.split(t)[0..-2])
	Dir[dir+"/*.h"].select{|file|not file=~/swig/}
}

rule 'interface.i' => interfaceSrc do |t|
	output=t.name.sub(/\/interface.[a-z]*/,"")
	input=importsForInterface(t.name)
	cmd=$CONFIG["RUBY"]+" build/create_interface.rb -d=#{output} -i=#{input}"
	puts ""	
	sh cmd
end











$BOA_LIBRARIES=$SOURCEDIRS.map{|dir|"ext/libantargis"+dir.split("/")[1]+".so"}+$BOASOURCES.map{|dir|"ext/antargis"+dir.split("/")[1]+".so"}
task :libraries=>$BOA_LIBRARIES do
end

task "ext/antargis.so" => ((Dir["ext/*/*.cc"]+Dir["ext/*/*.c"]).map{|file|file.sub(".cc",".oo").sub(".c",".o")}+["ext/swig.oo"]) do |t|
#+$SOURCEDIRS.map{|dir|"ext/libantargis"+dir.split("/")[1]+".so"}) do|t|
	linkLib(t.name,t.prerequisites+$CONFIG["LIBS"].split(" "))
end


task :library=>"ext/antargis.so" do
end

task "ext/swig.cc"=>($SOURCEDIRS[1..-1].map{|dir|dir+"/interface.i"}) do
	output="ext/swig.cc"
	input=$BOASOURCES.map{|dir|File.join(dir,"interface.i")}
	file=File.open("ext/interface.i","w")
	file.puts '%module(directors="1") antargis'
	input.each{|filename|file.puts "%include \"#{filename}\""}
	file.close
	cflags=$CONFIG["INCLUDEPATH"]+" "+$CONFIG["DEFINES"]+" -DAGEXPORT"
	cmd=$CONFIG["SWIG"]+" #{cflags} -v -Wall -ruby -c++ -o #{output} ext/interface.i"
	puts ""
#	pp cmd
	sh cmd
	$?
end


desc "Build all"
task :default=>[:library] do
end


task :allclean=>[:clobber_package] do
	File.delete("config.rb")
end


CLEAN << Dir["**/*.o"]+Dir["**/*.oo"]+Dir["**/*.so"]+Dir["ext/*/interface.i"]+Dir["ext/*/swig.*"]+Dir[".deps/*"]+Dir["ext/*.so*"]+Dir["ext/*.dll*"]







##########################
#
# Gems
##

require 'rubygems'
require 'rake/gempackagetask.rb'

DATA_FILES=Dir["data/**/*"].select{|file|not (file=~/svn/ or file=~/xcf/ or file=~/\.svg/)}
PKG_FILES=Dir["ruby/**/*.rb"]+Dir["*.rb"]+DATA_FILES+Dir["build/*.rb"]+Dir["build/*/*.rb"] # +$BOA_LIBRARIES

  spec = Gem::Specification.new do |s|
    s.platform = Gem::Platform::LINUX_586
    s.summary = "A real-time strategy game."
    s.name = 'antargis-linux'
    s.version = PKG_VERSION
    s.requirements << 'none'
    #s.require_path = 'lib'
		s.require_paths << 'ext'
    s.autorequire = 'rake'
    s.files = PKG_FILES
		s.bindir="." #File.join("build","bin")
		s.executables << "antargis"
		#s.extensions=
    s.description = <<EOF
Battles of Antargis is a medieval-like realtime strategy game. 
You are a hero who was betrayed and you have to unify the kingdom 
and rebuild the old empire. Old myths will pass your way.
Its gameplay is very similar to that of Powermonger.
EOF
  end

  Rake::GemPackageTask.new(spec) do |pkg|
    pkg.need_zip = true
    pkg.need_tar = true
  end



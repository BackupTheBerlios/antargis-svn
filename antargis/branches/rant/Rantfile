import "md5"
import "autoclean"
require 'mkmf'

require 'build/base_tools.rb'
    
#puts self
#puts self.methods.sort.join("\n")


def getConfig(s)
  r=CONFIG[s]
  return r if r.nil?
  r.gsub(/\$\(([^\)]*)\)/) {|a|getConfig(a[2..-2])}
end

# sitearchdir - include in usr/local

#CONFIG.each{|a,b|
# puts "#{a} --  #{getConfig(a)}"
#}
#exit
rubyIncDir=getConfig("archdir")

sdlLibs=[`sdl-config --libs`]
   
sourceDeps=[
	["ext/external",["-lz"]],
	["ext/basic",["ext/external"]+sdlLibs],
	["ext/math",["ext/basic"]],
	["ext/video",["ext/math","ext/basic","-lSDL_image","-lSDL_ttf","-lGL","-lGLU"]],
	["ext/sound",["ext/basic"]],
	["ext/gui",["ext/video"]],
	["ext/game",["ext/basic","ext/gui"]],
]

sourceDirs=sourceDeps.collect{|a|a[0]}

# puts sourceDirs
# exit

externalIncludes=`sdl-config --cflags`.gsub("\n","")
    
var :INCLUDES => sourceDirs+[rubyIncDir,"."] #.collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes+" "+rubyIncDir
var :INCLUDESTR => var[:INCLUDES].collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes

var :CFLAGS => var[:INCLUDESTR]
    
var.env %w(CC CFLAGS)
    
sources=sourceDirs.collect{|dir,deps|sys[dir+"/*.cc"]}.flatten.collect{|f|f.sub_ext("oo")}

sources+=(sourceDirs-["ext/external"]).collect{|dir|dir+"/swig.oo"}

###########################################
# all-target
buildLibs=sourceDirs.collect{|d|"ext"+Dir.separator+"lib"+makeLibName(d)+".so"}
interfaceLibs=sourceDirs.collect{|d|"ext"+Dir.separator+makeLibName(d)+".so"}
allTargets = buildLibs + interfaceLibs
task :all => allTargets
#
###########################################



###########################################
# configure - clean-task
gen AutoClean, :clean
var[:clean].include "**/marker.i"
var[:clean].include "**/*swig.h"
var[:clean].include "**/*swig.cc"
var[:clean].include "**/*.so"
###########################################


    

###########################################
# build libraries (without swig)
#
sourceDeps.each{|pair|
	dir,dep=pair
	target="ext"+Dir.separator+"lib"+makeLibName(dir)+".so"
	tsources=Dir[dir+Dir.separator+"*.cc"]-[dir+Dir.separator+"swig.cc"]
	tsources.collect!{|f|f.sub_ext("oo")}
	tsources+=Dir[dir+Dir.separator+"*.c"].collect!{|f|f.sub_ext("o")}
	extlibs=[]
	dep.each{|d|
		if d[0..0]=="-"
			extlibs << d
		else
			tsources+=["ext"+Dir.separator+"lib"+makeLibName(d)+".so"]
		end
	}
# 	puts "DIR:",dir
# 	puts "TSOURCES:"
# 	puts tsources
# 	puts "TARGET:",target
	task target => tsources do |t|
# 		puts extlibs
# 		puts t.prerequisites
		cmd="g++ -shared -o "+sys.expand_path(t.name)+" "+(t.prerequisites.collect{|f|sys.expand_path(f)}+ extlibs).join(" ")
		sys cmd
		#sys %w(g++ -shared -o ), sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}+ extlibs
	end
}
#exit
###########################################


###########################################
# build extension libraries
#
sourceDeps.each{|pair|
	dir,dep=pair
	libname=makeLibName(dir)
	target="ext"+Dir.separator+makeLibName(dir)+".so"
	tsources=[dir+Dir.separator+libname+"swig.cc"]
	tsources.collect!{|f|f.sub_ext("oo")}
	tsources+=["ext"+Dir.separator+"lib"+makeLibName(dir)+".so"]
	dep.each{|d|
		if d[0..0]!="-"
			tsources+=["ext"+Dir.separator+makeLibName(d)+".so"]
		end
	}
#  	puts "DIR:",dir
#  	puts "TSOURCES:"
#  	puts tsources
#  	puts "TARGET:",target
	task target => tsources do |t|
		sys %w(g++ -shared -o ), sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}
	end
}
# task "libantargis.so" => sources do |t|
#   sys %w(g++ -shared -o ), sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}
# end
###########################################
    

###########################################
# build c
#
gen Rule, '.o' => '.c' do |t|
        sys "ccache gcc -c -o #{sys.expand_path(t.name)} #{var :CFLAGS} #{sys.expand_path(t.source)}"
end
###########################################

###########################################
# build c++
#
gen Rule, '.oo' => '.cc' do |t|
        sys "ccache g++ -c -o #{sys.expand_path(t.name)} #{var :CFLAGS} #{sys.expand_path(t.source)}"
end

# # task "ext/math/swig.oo" => "ext/math/swig.cc" do |t|
# # 	raise 123
# # end
# # 
# # swigOsrc = lambda {|target|
# # 	[target.sub("swig.oo","swig.cc")]
# # }
# # gen Rule, /^.*swig.oo/ => swigOsrc do |t|
# #         sys "ccache g++ -c -o #{sys.expand_path(t.name)} #{var :CFLAGS} #{sys.expand_path(t.source)}"
# # end
###########################################


###########################################
# swig - interfacing for ruby
#
swigSrc = lambda { |target| 
	dir=getDir(target)
	name=makeLibName(dir)
	[target.sub(name+"swig.cc","interface.i")]+sys["build/*.i"]+importsForInterface(target).split(":") 
}

gen Rule, /^.*swig.cc$/ => swigSrc do |t|
	sys "swig -v -Wall -ruby -c++ -o #{sys.expand_path(t.name)} -DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}"
end
#
###########################################



###########################################
# interface-files for swig
#

def importsForInterface(name)
	case name
		when /ext\/math/
			"ext/basic/interface.i"
		when /ext\/video/
			"ext/basic/interface.i:ext/math/interface.i"
		else
			""
	end
#	puts "NAME:",name
#	exit
end

interfaceSrc = lambda { |target| 
	list=Dir[getDir(target)+Dir.separator+"*.h"].select{|f|not f=~/swig.h/}+Dir["build/*.rb"] # FIXME:replace
	list+=importsForInterface(target).split(":")
	puts "LIST:",list,"---"
	list
}
gen Rule, /^.*interface.i$/ => interfaceSrc do |t|
	sys "ruby build/create_interface.rb -d=#{getDir(sys.expand_path(t.name))} -i=#{importsForInterface(t.name)}"
end
#
###########################################

#import "md5"                          # md5 is needed for automatic checksum-check for changes in files
import "autoclean"                    # autoclean includes the a simple facility for a clean-make-target

require 'build/base_tools.rb'

require 'config.rb'                   # include build-options
    


# get library-dependencies for libSDL
sdlLibs=[`sdl-config --libs`]

# configure source-directories.
# DLLs will be build for each directory and in the given order.
# on the left the directory containing the sources is given
# on the right the dependencies, which can be one of the following:
# - an external library, which then marked by "-l" in front, like "-lz" for the z-library
# - an internal dependency on a directory
# NOTE: dependencies are not automatically inherited, you have to include them yourself!

sourceDeps=[
	["ext/external",["-lz"]],
	["ext/basic",["ext/external"]+sdlLibs],
	["ext/math",["ext/basic"]],
	["ext/video",["ext/math","ext/basic","-lSDL_image","-lSDL_ttf","-lGL","-lGLU"]],
	["ext/gui",["ext/basic","ext/math","ext/video"]],
	["ext/sound",["ext/basic","-lSDL_mixer"]],
	["ext/3dengine",["ext/basic"]],
	["ext/game",["ext/basic","ext/math","ext/video","ext/gui","ext/3dengine"]],
]

$sourceDeps=sourceDeps

sourceDirs=sourceDeps.collect{|a|a[0]}    # collect dirs containing source (in the correct order !)

externalIncludes=`sdl-config --cflags`.gsub("\n","")

# sitearchdir - include in usr/local
rubyIncDir=getConfig("archdir")
    
# gather include-directories (separately from other cflags, so they can be used for swig later on
var :INCLUDES => sourceDirs+[rubyIncDir,"."]
var :INCLUDESTR => var[:INCLUDES].collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes    # build include-string (-I...)


# configure cflags out of config.rb
cflags=""
cflags+=" -DGCDEBUG" if $config["gcdebug"]   # enable debuggin of garbage-collection
cflags+=" -g -O0"    if $config["debug"]     # disable optimizations for better debugging
cflags+=" -O2"       unless $config["debug"] # enable optimizations
	

var :CFLAGS => var[:INCLUDESTR]+cflags          # store cflags in "var" for later read-out while compiling

var.env %w(CC CFLAGS)                           # get cflags from environment

###########################################
# all-target
buildLibs=sourceDirs.collect{|d|"ext"+Dir.separator+"lib"+makeLibName(d)+".so"}
interfaceLibs=sourceDirs.collect{|d|"ext"+Dir.separator+makeLibName(d)+".so"}
allTargets = buildLibs + interfaceLibs
task :all => allTargets
#
###########################################



###########################################
# configure - clean-task
gen AutoClean, :clean
var[:clean].include "**/marker.i"   # not needed any more - managed by Rule
var[:clean].include "ext/*.so"
###########################################


    

###########################################
# build libraries (without swig)
#
sourceDeps.each{|pair|
	dir,dep=pair                                                               # get directory and dependencies
	target="ext"+Dir.separator+"lib"+makeLibName(dir)+".so"                    # make library name like "ext/libantargisgui.so"
	tsources=Dir[dir+Dir.separator+"*.cc"].select{|f|not f=~/swig/}            # get all *.cc files (without the swig-generated file)
	tsources.collect!{|f|f.sub_ext("oo")}                                      # translate the .cc files to .oo
	tsources+=Dir[dir+Dir.separator+"*.c"].collect!{|f|f.sub_ext("o")}         # add *.c files if there are any
	extlibs=[]
	dep.each{|d|
		if d[0..0]=="-"
			extlibs << d                                                           # gather external libraries (-lz)
		else
			tsources+=["ext"+Dir.separator+"lib"+makeLibName(d)+".so"]             # gather internal deps like (ext/libantargisbasic.so)
		end
	}
	task target => tsources do |t|
		# build command
		cmd=makeCommand("LINK_SHARED",sys.expand_path(t.name), (t.prerequisites.collect{|f|sys.expand_path(f)}+extlibs).join(" "))
		sys cmd
	end
}
#
###########################################


###########################################
# build extension libraries
#
sourceDeps.each{|pair|
	dir,dep=pair
	libname=makeLibName(dir)
	target="ext"+Dir.separator+makeLibName(dir)+".so"
	tsources=[dir+Dir.separator+libname+"swig.cc"]
	tsources.collect!{|f|f.sub_ext("oo")}
	tsources+=["ext"+Dir.separator+"lib"+makeLibName(dir)+".so"]
	dep.each{|d|
		if d[0..0]!="-"
			tsources+=["ext"+Dir.separator+makeLibName(d)+".so"]
		end
	}
	task target => tsources do |t|
		cmd=makeCommand("LINK_SHARED",sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}.join(" "))
		sys cmd
	end
}
###########################################
    

###########################################
# build c
#
gen Rule, '.o' => '.c' do |t|
	cmd=makeCommand("CC_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
	sys cmd
end
###########################################

###########################################
# build c++
#
gen Rule, '.oo' => '.cc' do |t|
	cmd=makeCommand("CXX_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
	sys cmd
end
#
###########################################


###########################################
# swig - interfacing for ruby
#
swigSrc = lambda { |target| 
	dir=getDir(target)
	name=makeLibName(dir)
	[target.sub(name+"swig.cc","interface.i")]+sys["build/*.i"]+importsForInterface(target).split(":") 
}

gen Rule, /^.*swig.(cc|h)$/ => swigSrc do |t|
	cmd=makeCommand("SWIG_CALL",sys.expand_path(t.name),"-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}")
	sys cmd
end
#
###########################################



###########################################
# interface-files for swig
#

def importsForInterface(name)
	$sourceDeps.each{|t|
		if name=~/#{t[0]}/
			return t[1].select{|f|not f=~/-.*/}.collect{|f|f+"/interface.i"}.join(":")
		end
	}
	return ""
end

interfaceSrc = lambda { |target| 
	list=Dir[getDir(target)+Dir.separator+"*.h"].select{|f|not f=~/swig.h/}+Dir["build/*.rb"] # FIXME:replace
	list+=importsForInterface(target).split(":")
	list
}
gen Rule, /^.*interface.i$/ => interfaceSrc do |t|
	cmd=makeCommand("CREATEINTERFACE",getDir(sys.expand_path(t.name)),importsForInterface(t.name))
	sys cmd
end
#
###########################################




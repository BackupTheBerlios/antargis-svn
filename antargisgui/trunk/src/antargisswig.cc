/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.25
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIG_DIRECTORS

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif

/***********************************************************************
 *
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 *
 ************************************************************************/

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
#  if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#    define SWIGTEMPLATEDISAMBIGUATOR template
#  else
#    define SWIGTEMPLATEDISAMBIGUATOR 
#  endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__) || defined(__ICC)
#   define SWIGUNUSED __attribute__ ((unused)) 
# else
#   define SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods for Windows DLLs */
#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   define SWIGEXPORT
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif


/* ruby.swg */
/* Implementation : RUBY */
#define SWIGRUBY 1

#include "ruby.h"

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

#define NUM2USHRT(n) (\
    (0 <= NUM2UINT(n) && NUM2UINT(n) <= USHRT_MAX)\
    ? (unsigned short) NUM2UINT(n) \
    : (rb_raise(rb_eArgError, "integer %d out of range of `unsigned short'",\
               NUM2UINT(n)), (short)0)\
)

#define NUM2SHRT(n) (\
    (SHRT_MIN <= NUM2INT(n) && NUM2INT(n) <= SHRT_MAX)\
    ? (short)NUM2INT(n)\
    : (rb_raise(rb_eArgError, "integer %d out of range of `short'",\
               NUM2INT(n)), (short)0)\
)

/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
} swig_class;

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING(RB_STRING_VALUE(s))->ptr
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING(RB_STRING_VALUE(s))->len
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

/* Contract support */

#define SWIG_contract_assert(expr, msg) if (!(expr)) { rb_raise(rb_eRuntimeError, (char *) msg ); } else


/***********************************************************************
 * swigrun.swg
 *
 *     This file contains generic CAPI SWIG runtime support for pointer
 *     type checking.
 *
 ************************************************************************/

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "2"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store inforomation on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;


/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (int)(*f1 - *f2);
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/* think of this as a c++ template<> or a scheme macro */
#define SWIG_TypeCheck_Template(comparison, ty)         \
  if (ty) {                                             \
    swig_cast_info *iter = ty->cast;                    \
    while (iter) {                                      \
      if (comparison) {                                 \
        if (iter == ty->cast) return iter;              \
        /* Move iter to the top of the linked list */   \
        iter->prev->next = iter->next;                  \
        if (iter->next)                                 \
          iter->next->prev = iter->prev;                \
        iter->next = ty->cast;                          \
        iter->prev = 0;                                 \
        if (ty->cast) ty->cast->prev = iter;            \
        ty->cast = iter;                                \
        return iter;                                    \
      }                                                 \
      iter = iter->next;                                \
    }                                                   \
  }                                                     \
  return 0

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
}

/* Same as previous function, except strcmp is replaced with a pointer comparison */
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
  SWIG_TypeCheck_Template(iter->type == from, into);
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  if (!ti->clientdata) {
    swig_cast_info *cast = ti->cast;
    /* if (ti->clientdata == clientdata) return; */
    ti->clientdata = clientdata;
    
    while (cast) {
      if (!cast->converter)
	SWIG_TypeClientData(cast->type, clientdata);
      cast = cast->next;
    }
  }
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}


/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu = 0;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags) \
  SWIG_Ruby_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags) \
  SWIG_Ruby_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags) \
  SWIG_Ruby_MustGetPtr(p, type, argnum, flags)
#define SWIG_GetModule(clientdata) \
  SWIG_Ruby_GetModule()
#define SWIG_SetModule(clientdata, pointer) \
  SWIG_Ruby_SetModule(pointer)

/* Ruby-specific SWIG API */

#define SWIG_InitRuntime() \
  SWIG_Ruby_InitRuntime()
#define SWIG_define_class(ty) \
  SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty) \
  SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value) \
  SWIG_Ruby_MangleStr(value)
#define SWIG_CheckConvert(value, ty) \
  SWIG_Ruby_CheckConvert(value, ty)
#define SWIG_NewPackedObj(ptr, sz, ty) \
  SWIG_Ruby_NewPackedObj(ptr, sz, ty)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)

/* rubydef.swg */
#ifdef __cplusplus
extern "C" {
#endif

static VALUE _mSWIG = Qnil;
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Initialize Ruby runtime support */
static void
SWIG_Ruby_InitRuntime(void)
{
    if (_mSWIG == Qnil) {
        _mSWIG = rb_define_module("SWIG");
    }
}

/* Define Ruby class for C type */
static void
SWIG_Ruby_define_class(swig_type_info *type)
{
    VALUE klass;
    char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    if (NIL_P(_cSWIG_Pointer)) {
	_cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
	rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
    }
    klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
    free((void *) klass_name);
}

/* Create a new pointer object */
static VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int own)
{
    char *klass_name;
    swig_class *sklass;
    VALUE klass;
    VALUE obj;
    
    if (!ptr)
	return Qnil;
    
    if (type->clientdata) {
      sklass = (swig_class *) type->clientdata;
      obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);
    } else {
      klass_name = (char *) malloc(4 + strlen(type->name) + 1);
      sprintf(klass_name, "TYPE%s", type->name);
      klass = rb_const_get(_mSWIG, rb_intern(klass_name));
      free((void *) klass_name);
      obj = Data_Wrap_Struct(klass, 0, 0, ptr);
    }
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Create a new class instance (always owned) */
static VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
    VALUE obj;
    swig_class *sklass = (swig_class *) type->clientdata;
    obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Get type mangle from class name */
static SWIGINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "__swigtype__");
  return StringValuePtr(stype);
}

/* Convert a pointer value */
static int
SWIG_Ruby_ConvertPtr(VALUE obj, void **ptr, swig_type_info *ty, int flags)
{
  char *c;
  swig_cast_info *tc;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return 0;
  } else {
    Data_Get_Struct(obj, void, *ptr);
  }
  
  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
        if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
          if (*ptr == 0)
            rb_raise(rb_eRuntimeError, "This %s already released", ty->str);
          return 0;
        }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      if (flags & SWIG_POINTER_EXCEPTION)
        rb_raise(rb_eTypeError, "Expected %s", ty->str);
      else
        return -1;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      if (flags & SWIG_POINTER_EXCEPTION)
        rb_raise(rb_eTypeError, "Expected %s", ty->str);
      else
        return -1;
    }
    *ptr = SWIG_TypeCast(tc, *ptr);
  }
  return 0;
}

/* Convert a pointer value, signal an exception on a type mismatch */
static SWIGINLINE void *
SWIG_Ruby_MustGetPtr(VALUE obj, swig_type_info *ty, int argnum, int flags)
{
  void *result;
  SWIG_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
  return result;
}

/* Check convert */
static SWIGINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c)
    return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

static VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
static void
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return;

type_error:

  if (flags) {
    if (ty) {
      rb_raise(rb_eTypeError, "Type error. Expected %s", ty->name);
    } else {
      rb_raise(rb_eTypeError, "Expected a pointer");
    }
  }
}

static swig_module_info *SWIG_Ruby_GetModule() {
    VALUE pointer;
    swig_module_info *ret = 0;

   /* first check if pointer already created */
    pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
    if (pointer != Qnil) {
      Data_Get_Struct(pointer, swig_module_info, ret);
    }
    return ret;
}

static void SWIG_Ruby_SetModule(swig_module_info *pointer) {
      /* register a new class */
      VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
      /* create and store the structure pointer to a global variable */
      swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
      rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

#ifdef __cplusplus
}
#endif



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_AGAngle swig_types[0]
#define SWIGTYPE_p_AGApplication swig_types[1]
#define SWIGTYPE_p_AGBackground swig_types[2]
#define SWIGTYPE_p_AGBox3 swig_types[3]
#define SWIGTYPE_p_AGButton swig_types[4]
#define SWIGTYPE_p_AGCPPListener swig_types[5]
#define SWIGTYPE_p_AGCaption swig_types[6]
#define SWIGTYPE_p_AGCheckBox swig_types[7]
#define SWIGTYPE_p_AGCircle2 swig_types[8]
#define SWIGTYPE_p_AGCollisionData swig_types[9]
#define SWIGTYPE_p_AGColor swig_types[10]
#define SWIGTYPE_p_AGColorButton swig_types[11]
#define SWIGTYPE_p_AGDialog swig_types[12]
#define SWIGTYPE_p_AGEdit swig_types[13]
#define SWIGTYPE_p_AGEditLine swig_types[14]
#define SWIGTYPE_p_AGEvent swig_types[15]
#define SWIGTYPE_p_AGFont swig_types[16]
#define SWIGTYPE_p_AGFontEngine swig_types[17]
#define SWIGTYPE_p_AGGLWidget swig_types[18]
#define SWIGTYPE_p_AGHTiler swig_types[19]
#define SWIGTYPE_p_AGImage swig_types[20]
#define SWIGTYPE_p_AGLayout swig_types[21]
#define SWIGTYPE_p_AGLayoutCreator swig_types[22]
#define SWIGTYPE_p_AGLayoutFactory swig_types[23]
#define SWIGTYPE_p_AGLine2 swig_types[24]
#define SWIGTYPE_p_AGLine3 swig_types[25]
#define SWIGTYPE_p_AGListBox swig_types[26]
#define SWIGTYPE_p_AGListBoxItem swig_types[27]
#define SWIGTYPE_p_AGListener swig_types[28]
#define SWIGTYPE_p_AGMain swig_types[29]
#define SWIGTYPE_p_AGMatrix3 swig_types[30]
#define SWIGTYPE_p_AGMatrix4 swig_types[31]
#define SWIGTYPE_p_AGMenu swig_types[32]
#define SWIGTYPE_p_AGMenuEvent swig_types[33]
#define SWIGTYPE_p_AGMessageObject swig_types[34]
#define SWIGTYPE_p_AGMouseEvent swig_types[35]
#define SWIGTYPE_p_AGPaintTarget swig_types[36]
#define SWIGTYPE_p_AGPainter swig_types[37]
#define SWIGTYPE_p_AGPoint swig_types[38]
#define SWIGTYPE_p_AGPoint3 swig_types[39]
#define SWIGTYPE_p_AGRadio swig_types[40]
#define SWIGTYPE_p_AGRadioGroup swig_types[41]
#define SWIGTYPE_p_AGRect swig_types[42]
#define SWIGTYPE_p_AGRect2 swig_types[43]
#define SWIGTYPE_p_AGRect3 swig_types[44]
#define SWIGTYPE_p_AGSDLEvent swig_types[45]
#define SWIGTYPE_p_AGSDLScreen swig_types[46]
#define SWIGTYPE_p_AGScreen swig_types[47]
#define SWIGTYPE_p_AGScreenWidget swig_types[48]
#define SWIGTYPE_p_AGSignal swig_types[49]
#define SWIGTYPE_p_AGSound swig_types[50]
#define SWIGTYPE_p_AGSurface swig_types[51]
#define SWIGTYPE_p_AGSurfaceManager swig_types[52]
#define SWIGTYPE_p_AGTable swig_types[53]
#define SWIGTYPE_p_AGText swig_types[54]
#define SWIGTYPE_p_AGTexture swig_types[55]
#define SWIGTYPE_p_AGTextureManager swig_types[56]
#define SWIGTYPE_p_AGTheme swig_types[57]
#define SWIGTYPE_p_AGTriangle2 swig_types[58]
#define SWIGTYPE_p_AGTriangle3 swig_types[59]
#define SWIGTYPE_p_AGVTiler swig_types[60]
#define SWIGTYPE_p_AGVector2 swig_types[61]
#define SWIGTYPE_p_AGVector3 swig_types[62]
#define SWIGTYPE_p_AGVector4 swig_types[63]
#define SWIGTYPE_p_AGWidget swig_types[64]
#define SWIGTYPE_p_AGWindow swig_types[65]
#define SWIGTYPE_p_Attributes swig_types[66]
#define SWIGTYPE_p_Document swig_types[67]
#define SWIGTYPE_p_DomParser swig_types[68]
#define SWIGTYPE_p_GLuint swig_types[69]
#define SWIGTYPE_p_Node swig_types[70]
#define SWIGTYPE_p_NodeVector swig_types[71]
#define SWIGTYPE_p_Node__NodeVector__const_iterator swig_types[72]
#define SWIGTYPE_p_Node__NodeVector__iterator swig_types[73]
#define SWIGTYPE_p_Parser swig_types[74]
#define SWIGTYPE_p_SDLKey swig_types[75]
#define SWIGTYPE_p_SDLMod swig_types[76]
#define SWIGTYPE_p_SDL_Event swig_types[77]
#define SWIGTYPE_p_SDL_PixelFormat swig_types[78]
#define SWIGTYPE_p_SDL_Rect swig_types[79]
#define SWIGTYPE_p_SDL_Surface swig_types[80]
#define SWIGTYPE_p_Uint32 swig_types[81]
#define SWIGTYPE_p_Uint8 swig_types[82]
#define SWIGTYPE_p_const_iterator swig_types[83]
#define SWIGTYPE_p_float swig_types[84]
#define SWIGTYPE_p_iterator swig_types[85]
#define SWIGTYPE_p_p_Node swig_types[86]
#define SWIGTYPE_p_std__listTAGRect2_t swig_types[87]
#define SWIGTYPE_p_std__mapTstd__string_std__string_t swig_types[88]
#define SWIGTYPE_p_std__ostringstream swig_types[89]
#define SWIGTYPE_p_std__pairTstd__string_bool_t swig_types[90]
#define SWIGTYPE_p_std__string swig_types[91]
#define SWIGTYPE_p_std__vectorTAGBox3_t swig_types[92]
#define SWIGTYPE_p_std__vectorTAGLine2_t swig_types[93]
#define SWIGTYPE_p_std__vectorTAGRect3_t swig_types[94]
#define SWIGTYPE_p_std__vectorTAGVector3_t swig_types[95]
#define SWIGTYPE_p_std__vectorTAGVector4_t swig_types[96]
#define SWIGTYPE_p_std__vectorTNode_p_t swig_types[97]
#define SWIGTYPE_p_std__vectorTNode_t swig_types[98]
#define SWIGTYPE_p_std__vectorTstd__string_t swig_types[99]
#define SWIGTYPE_p_unsigned_long swig_types[100]
static swig_type_info *swig_types[101];
static swig_module_info swig_module = {swig_types, 101, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_libantargisgui
#define SWIG_name    "Libantargisgui"

static VALUE mLibantargisgui;

static void SWIG_AsVal(VALUE obj, int *val)
{
    *val = (int) NUM2INT(obj);
}


#ifdef __cplusplus
extern "C" {
#endif
#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
struct timeval rb_time_timeval(VALUE);
#endif
#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
#include "rubyio.h"
#ifdef __cplusplus
}
#endif


#include "antargisgui.h"


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


SWIGINTERN void SWIG_exception_(int code, const char *msg) {
    switch (code) {
        case SWIG_MemoryError:
            rb_raise(rb_eNoMemError, msg);
            break;
        case SWIG_IOError:
            rb_raise(rb_eIOError, msg);
            break;
        case SWIG_RuntimeError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        case SWIG_IndexError:
            rb_raise(rb_eIndexError, msg);
            break;
        case SWIG_TypeError:
            rb_raise(rb_eTypeError, msg);
            break;
        case SWIG_DivisionByZero:
            rb_raise(rb_eZeroDivError, msg);
            break;
        case SWIG_OverflowError:
            rb_raise(rb_eRangeError, msg);
            break;
        case SWIG_SyntaxError:
            rb_raise(rb_eSyntaxError, msg);
            break;
        case SWIG_ValueError:
            rb_raise(rb_eArgError, msg);
            break;
        case SWIG_SystemError:
            rb_raise(rb_eFatal, msg);
            break;
        case SWIG_UnknownError:
            rb_raise(rb_eRuntimeError, msg);
            break;
        default:
            break;
    }
}

#define SWIG_exception(a, b) SWIG_exception_((a), (b))


#include <stdexcept>


#include <string>


#include <string>

#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))

bool SWIG_BOOL_P(VALUE) {
    // dummy test, RTEST should take care of everything
    return true;
}
bool SWIG_RB2BOOL(VALUE x) {
    return RTEST(x);
}
VALUE SWIG_BOOL2RB(bool b) {
    return b ? Qtrue : Qfalse;
}
double SWIG_NUM2DBL(VALUE x) {
    return (FIXNUM_P(x) ? FIX2INT(x) : NUM2DBL(x));
}
bool SWIG_STRING_P(VALUE x) {
    return TYPE(x) == T_STRING;
}
std::string SWIG_RB2STR(VALUE x) {
    return std::string(StringValuePtr(x));
}
VALUE SWIG_STR2RB(const std::string& s) {
    return rb_str_new2(s.c_str());
}


#include <vector>
#include <algorithm>
#include <stdexcept>

static std::string std_vector_Sl_std_string_Sg__pop(std::vector<std::string > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                std::string x = self->back();
                self->pop_back();
                return x;
            }
static std::string std_vector_Sl_std_string_Sg____getitem__(std::vector<std::string > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_std_string_Sg____setitem__(std::vector<std::string > *self,int i,std::string x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_std_string_Sg__each(std::vector<std::string > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(SWIG_STR2RB((*self)[i]));
            }
static AGLine2 std_vector_Sl_AGLine2_Sg__pop(std::vector<AGLine2 > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                AGLine2 x = self->back();
                self->pop_back();
                return x;
            }
static AGLine2 &std_vector_Sl_AGLine2_Sg____getitem__(std::vector<AGLine2 > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGLine2_Sg____setitem__(std::vector<AGLine2 > *self,int i,AGLine2 const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGLine2_Sg__each(std::vector<AGLine2 > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    AGLine2* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_AGLine2, 0));
                }
            }
extern AGWidget *agNoParent;
static Node std_vector_Sl_Node_Sg__pop(std::vector<Node > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                Node x = self->back();
                self->pop_back();
                return x;
            }
static Node &std_vector_Sl_Node_Sg____getitem__(std::vector<Node > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sg____setitem__(std::vector<Node > *self,int i,Node const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sg__each(std::vector<Node > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    Node* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_Node, 0));
                }
            }
static Node *std_vector_Sl_Node_Sm__Sg__pop(std::vector<Node * > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                Node* x = self->back();
                self->pop_back();
                return x;
            }
static Node *std_vector_Sl_Node_Sm__Sg____getitem__(std::vector<Node * > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sm__Sg____setitem__(std::vector<Node * > *self,int i,Node *x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_Node_Sm__Sg__each(std::vector<Node * > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    Node* x = (*self)[i];
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_Node, 0));
                }
            }
static AGVector3 std_vector_Sl_AGVector3_Sg__pop(std::vector<AGVector3 > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                AGVector3 x = self->back();
                self->pop_back();
                return x;
            }
static AGVector3 &std_vector_Sl_AGVector3_Sg____getitem__(std::vector<AGVector3 > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGVector3_Sg____setitem__(std::vector<AGVector3 > *self,int i,AGVector3 const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGVector3_Sg__each(std::vector<AGVector3 > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    AGVector3* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_AGVector3, 0));
                }
            }
static AGVector4 std_vector_Sl_AGVector4_Sg__pop(std::vector<AGVector4 > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                AGVector4 x = self->back();
                self->pop_back();
                return x;
            }
static AGVector4 &std_vector_Sl_AGVector4_Sg____getitem__(std::vector<AGVector4 > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGVector4_Sg____setitem__(std::vector<AGVector4 > *self,int i,AGVector4 const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
static void std_vector_Sl_AGVector4_Sg__each(std::vector<AGVector4 > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    AGVector4* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_AGVector4, 0));
                }
            }
/***********************************************************************
 * director.swg
 *
 * This file contains support for director classes that proxy
 * method calls from C++ to Ruby extensions.
 *
 * Author : Lyle Johnson (lyle@users.sourceforge.net)
 *          Based on the original Python implementation by
 *          Mark Rose (mrose@stm.lbl.gov).
 ************************************************************************/

#ifdef __cplusplus

#include <string>

namespace Swig {
  struct body_args {
    VALUE recv;
    ID id;
    int argc;
    VALUE *argv;
  };

  /* Base class for director exceptions */
  class DirectorException {
    protected:
      VALUE swig_error;
    protected:
      DirectorException(VALUE error=Qnil) : swig_error(error) {}
    public:
      VALUE getType() const  { 
        return CLASS_OF(swig_error); 
      }
      VALUE getError() const {
        return swig_error;
      }
      virtual ~DirectorException() {}
  };

  /* Type mismatch in the return value from a Ruby method call */
  class DirectorTypeMismatchException : public Swig::DirectorException {
    public:
      DirectorTypeMismatchException(const char *msg="") {
        VALUE str = rb_str_new2("Swig director type mismatch: ");
        rb_str_concat(str, rb_str_new2(msg));
        swig_error = rb_exc_new3(rb_eTypeError, str);
      }
  };

  /* Any Ruby exception that occurs during a director method call */
  class DirectorMethodException : public Swig::DirectorException {
    public:
      DirectorMethodException(VALUE error) : Swig::DirectorException(error) {}
  };

  /* Attempted to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public Swig::DirectorException {};


  /* Simple thread abstraction for pthreads on win32 */
#ifdef __THREAD__
#define __PTHREAD__
#if defined(_WIN32) || defined(__WIN32__)
#define pthread_mutex_lock EnterCriticalSection
#define pthread_mutex_unlock LeaveCriticalSection
#define pthread_mutex_t CRITICAL_SECTION
#define MUTEX_INIT(var) CRITICAL_SECTION var
#else
#include <pthread.h>
#define MUTEX_INIT(var) pthread_mutex_t var = PTHREAD_MUTEX_INITIALIZER 
#endif
#endif

  /* director base class */
  class Director {
    private:
      /* pointer to the wrapped Ruby object */
      VALUE swig_self;
      /* flag indicating whether the object is owned by Ruby or c++ */
      mutable bool swig_disown_flag;
      /* shared flag for breaking recursive director calls */
      static bool swig_up;

#ifdef __PTHREAD__
      /* locks for sharing the swig_up flag in a threaded environment */
      static pthread_mutex_t swig_mutex_up;
      static bool swig_mutex_active;
      static pthread_t swig_mutex_thread;
#endif

      /* reset the swig_up flag once the routing direction has been determined */
#ifdef __PTHREAD__
      void swig_clear_up() const { 
        Swig::Director::swig_up = false; 
        Swig::Director::swig_mutex_active = false;
        pthread_mutex_unlock(&swig_mutex_up);
      }
#else
      void swig_clear_up() const { 
        Swig::Director::swig_up = false; 
      }
#endif

    public:
      /* wrap a Ruby object, optionally taking ownership */
      Director(VALUE self) : swig_self(self), swig_disown_flag(false) {
      }

      /* discard our reference at destruction */
      virtual ~Director() {
      }

      /* return a pointer to the wrapped Ruby object */
      VALUE swig_get_self() const { 
        return swig_self; 
      }

      /* get the swig_up flag to determine if the method call should be routed
       * to the c++ base class or through the wrapped Ruby object
       */
#ifdef __PTHREAD__
      bool swig_get_up() const { 
        if (Swig::Director::swig_mutex_active) {
          if (pthread_equal(Swig::Director::swig_mutex_thread, pthread_self())) {
            bool up = swig_up;
            swig_clear_up();
            return up;
          }
        }
        return false;
      }
#else 
      bool swig_get_up() const { 
        bool up = swig_up;
        swig_up = false;
        return up;
      }
#endif

      /* set the swig_up flag if the next method call should be directed to
       * the c++ base class rather than the wrapped Ruby object
       */
#ifdef __PTHREAD__
      void swig_set_up() const { 
        pthread_mutex_lock(&Swig::Director::swig_mutex_up);
        Swig::Director::swig_mutex_thread = pthread_self();
        Swig::Director::swig_mutex_active = true;
        Swig::Director::swig_up = true;
      }
#else 
      void swig_set_up() const { 
        Swig::Director::swig_up = true; 
      }
#endif

      /* acquire ownership of the wrapped Ruby object (the sense of "disown"
       * is from Ruby) */
      void swig_disown() const { 
        if (!swig_disown_flag) { 
          swig_disown_flag = true;
        } 
      }
  };

  bool Swig::Director::swig_up = false;

#ifdef __PTHREAD__
  MUTEX_INIT(Swig::Director::swig_mutex_up);
  pthread_t Swig::Director::swig_mutex_thread;
  bool Swig::Director::swig_mutex_active = false;
#endif

}

#endif /* __cplusplus */




/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "antargisswig.h"

SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self): AGSurface(), Swig::Director(self) {
    
}



SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self, int w, int h): AGSurface(w, h), Swig::Director(self) {
    
}



SwigDirector_AGSurface::SwigDirector_AGSurface(VALUE self, AGSurface const &p): AGSurface(p), Swig::Director(self) {
    
}



SwigDirector_AGSurface::~SwigDirector_AGSurface() {
}

void SwigDirector_AGSurface::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSurface::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc, AGColor const &pColor) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_pColor = const_cast<AGColor *>(&pColor) ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSurface::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_pColor, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


SwigDirector_AGScreen::SwigDirector_AGScreen(VALUE self) : Swig::Director(self) {
    
}



size_t SwigDirector_AGScreen::getWidth() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGScreen::getWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getWidth"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


size_t SwigDirector_AGScreen::getHeight() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGScreen::getHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getHeight"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_AGScreen::flip() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::flip();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("flip"), 0, NULL);
}


void SwigDirector_AGScreen::begin() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::begin();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("begin"), 0, NULL);
}


SwigDirector_AGSDLScreen::SwigDirector_AGSDLScreen(VALUE self, SDL_Surface *s): AGSDLScreen(s), Swig::Director(self) {
    
}



void SwigDirector_AGSDLScreen::tile(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::tile(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGSDLScreen::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


AGSurface SwigDirector_AGSDLScreen::loadSurface(std::string const &pFilename) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGSurface c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSDLScreen::loadSurface(pFilename);
    }
    obj0=rb_str_new2(pFilename.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("loadSurface"), 1,obj0);
    {
        AGSurface *b;
        Data_Get_Struct(result,AGSurface,b);
        c_result=*b;
    }
    return (AGSurface) c_result;
}


void SwigDirector_AGSDLScreen::tile(AGTexture const &pSource) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::tile(pSource);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 1,obj0);
}


void SwigDirector_AGSDLScreen::drawGradient(AGRect const &rect, AGColor const &ul, AGColor const &ur, AGColor const &dl, AGColor const &dr) {
    AGRect * nc_tmp_rect = const_cast<AGRect *>(&rect) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_ul = const_cast<AGColor *>(&ul) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_ur = const_cast<AGColor *>(&ur) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_dl = const_cast<AGColor *>(&dl) ;
    VALUE obj3 = Qnil ;
    AGColor * nc_tmp_dr = const_cast<AGColor *>(&dr) ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawGradient(rect,ul,ur,dl,dr);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_rect, SWIGTYPE_p_AGRect, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_ul, SWIGTYPE_p_AGColor, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_ur, SWIGTYPE_p_AGColor, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_dl, SWIGTYPE_p_AGColor, 0);
    obj4 = SWIG_NewPointerObj(nc_tmp_dr, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawGradient"), 5,obj0,obj1,obj2,obj3,obj4);
}


void SwigDirector_AGSDLScreen::drawGradientAlpha(AGRect const &rect, AGColor const &ul, AGColor const &ur, AGColor const &dl, AGColor const &dr) {
    AGRect * nc_tmp_rect = const_cast<AGRect *>(&rect) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_ul = const_cast<AGColor *>(&ul) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_ur = const_cast<AGColor *>(&ur) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_dl = const_cast<AGColor *>(&dl) ;
    VALUE obj3 = Qnil ;
    AGColor * nc_tmp_dr = const_cast<AGColor *>(&dr) ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawGradientAlpha(rect,ul,ur,dl,dr);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_rect, SWIGTYPE_p_AGRect, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_ul, SWIGTYPE_p_AGColor, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_ur, SWIGTYPE_p_AGColor, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_dl, SWIGTYPE_p_AGColor, 0);
    obj4 = SWIG_NewPointerObj(nc_tmp_dr, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawGradientAlpha"), 5,obj0,obj1,obj2,obj3,obj4);
}


void SwigDirector_AGSDLScreen::renderText(AGRect const &pClipRect, int BaseLineX, int BaseLineY, std::string const &pText, AGFont const &ParamIn) {
    std::string temp4 ;
    std::string temp40 ;
    AGRect * nc_tmp_pClipRect = const_cast<AGRect *>(&pClipRect) ;
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    VALUE obj3 = Qnil ;
    AGFont * nc_tmp_ParamIn = const_cast<AGFont *>(&ParamIn) ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::renderText(pClipRect,BaseLineX,BaseLineY,pText,ParamIn);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pClipRect, SWIGTYPE_p_AGRect, 0);
    obj1 = INT2NUM(BaseLineX);
    obj2 = INT2NUM(BaseLineY);
    obj3=rb_str_new2(pText.c_str());
    obj4 = SWIG_NewPointerObj(nc_tmp_ParamIn, SWIGTYPE_p_AGFont, 0);
    result = rb_funcall(swig_get_self(), rb_intern("renderText"), 5,obj0,obj1,obj2,obj3,obj4);
}


void SwigDirector_AGSDLScreen::drawLine(AGPoint const &p0, AGPoint const &p1, AGColor const &c) {
    AGPoint * nc_tmp_p0 = const_cast<AGPoint *>(&p0) ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_p1 = const_cast<AGPoint *>(&p1) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_p0, SWIGTYPE_p_AGPoint, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_p1, SWIGTYPE_p_AGPoint, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


size_t SwigDirector_AGSDLScreen::getWidth() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSDLScreen::getWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getWidth"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


size_t SwigDirector_AGSDLScreen::getHeight() const {
    size_t c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSDLScreen::getHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getHeight"), 0, NULL);
    c_result = (unsigned long) NUM2INT(result);
    return (size_t) c_result;
}


void SwigDirector_AGSDLScreen::tile(AGTexture const &pSource, AGRect const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::tile(pSource,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 2,obj0,obj1);
}


void SwigDirector_AGSDLScreen::blit(AGTexture const &pSource, AGRect const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::blit(pSource,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 2,obj0,obj1);
}


void SwigDirector_AGSDLScreen::begin() {
    VALUE result;
    
    if (swig_get_up()) {
        AGScreen::begin();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("begin"), 0, NULL);
}


void SwigDirector_AGSDLScreen::drawRect(AGRect const &pRect, AGColor const &c) {
    AGRect * nc_tmp_pRect = const_cast<AGRect *>(&pRect) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawRect(pRect,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pRect, SWIGTYPE_p_AGRect, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawRect"), 2,obj0,obj1);
}


void SwigDirector_AGSDLScreen::flip() {
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::flip();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("flip"), 0, NULL);
}


void SwigDirector_AGSDLScreen::drawBorder(AGRect const &rect, int W, AGColor const &c1, AGColor const &c2) {
    AGRect * nc_tmp_rect = const_cast<AGRect *>(&rect) ;
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c1 = const_cast<AGColor *>(&c1) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_c2 = const_cast<AGColor *>(&c2) ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::drawBorder(rect,W,c1,c2);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_rect, SWIGTYPE_p_AGRect, 0);
    obj1 = INT2NUM(W);
    obj2 = SWIG_NewPointerObj(nc_tmp_c1, SWIGTYPE_p_AGColor, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_c2, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawBorder"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGSDLScreen::putPixel(int x, int y, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGSDLScreen::putPixel(x,y,c);
        return;
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 3,obj0,obj1,obj2);
}


SDL_Surface *SwigDirector_AGSDLScreen::newSurface(int x, int y) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    SDL_Surface *c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGSDLScreen::newSurface(x,y);
    }
    obj0 = INT2NUM(x);
    obj1 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("newSurface"), 2,obj0,obj1);
    if ((SWIG_ConvertPtr(result,(void **) &c_result, SWIGTYPE_p_SDL_Surface,SWIG_POINTER_EXCEPTION | 0 )) == -1) throw Swig::DirectorTypeMismatchException("Pointer conversion failed.");
    return (SDL_Surface *) c_result;
}


SwigDirector_AGEvent::SwigDirector_AGEvent(VALUE self, AGListener *pCaller): AGEvent(pCaller), Swig::Director(self) {
    
}



SwigDirector_AGEvent::~SwigDirector_AGEvent() {
}

SwigDirector_AGSDLEvent::SwigDirector_AGSDLEvent(VALUE self, AGListener *pCaller, SDL_Event const *pEvent): AGSDLEvent(pCaller, pEvent), Swig::Director(self) {
    
}



SwigDirector_AGSDLEvent::~SwigDirector_AGSDLEvent() {
}

SwigDirector_AGMouseEvent::SwigDirector_AGMouseEvent(VALUE self, AGListener *pCaller, SDL_Event *pEvent): AGMouseEvent(pCaller, pEvent), Swig::Director(self) {
    
}



SwigDirector_AGMouseEvent::~SwigDirector_AGMouseEvent() {
}

SwigDirector_AGListener::SwigDirector_AGListener(VALUE self): AGListener(), Swig::Director(self) {
    
}



SwigDirector_AGListener::~SwigDirector_AGListener() {
}

bool SwigDirector_AGListener::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCPPListener::SwigDirector_AGCPPListener(VALUE self) : Swig::Director(self) {
    
}



SwigDirector_AGCPPListener::~SwigDirector_AGCPPListener() {
}

bool SwigDirector_AGCPPListener::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) const {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        throw Swig::DirectorPureVirtualException();
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self): AGSignal(), Swig::Director(self) {
    
}



SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self, AGMessageObject *pCaller): AGSignal(pCaller), Swig::Director(self) {
    
}



SwigDirector_AGSignal::SwigDirector_AGSignal(VALUE self, AGMessageObject *pCaller, std::string const &pName): AGSignal(pCaller, pName), Swig::Director(self) {
    
}



SwigDirector_AGSignal::~SwigDirector_AGSignal() {
}

SwigDirector_AGMessageObject::SwigDirector_AGMessageObject(VALUE self): AGMessageObject(), Swig::Director(self) {
    
}



bool SwigDirector_AGMessageObject::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMessageObject::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGMessageObject::~SwigDirector_AGMessageObject() {
}

bool SwigDirector_AGMessageObject::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGWidget::SwigDirector_AGWidget(VALUE self, AGWidget *pParent, AGRect const &r): AGWidget(pParent, r), Swig::Director(self) {
    
}



bool SwigDirector_AGWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGWidget::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGWidget::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGWidget::~SwigDirector_AGWidget() {
}

bool SwigDirector_AGWidget::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGWidget::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGWidget::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGWidget::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGWidget::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWidget::addChildBack(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGWidget::addChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGWidget::removeChild(AGWidget *w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGButton::SwigDirector_AGButton(VALUE self, AGWidget *pParent, AGRect const &r, std::string const &pText, int id): AGButton(pParent, r, pText, id), Swig::Director(self) {
    
}



bool SwigDirector_AGButton::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGButton::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGButton::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGButton::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


std::string SwigDirector_AGButton::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGButton::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGButton::~SwigDirector_AGButton() {
}

bool SwigDirector_AGButton::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGButton::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGButton::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGButton::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGButton::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGButton::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGButton::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGButton::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGButton::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGButton::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGButton::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGApplication::SwigDirector_AGApplication(VALUE self): AGApplication(), Swig::Director(self) {
    
}



bool SwigDirector_AGApplication::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventKeyDown(AGEvent const *m2) {
    AGEvent * nc_tmp_m2 = const_cast<AGEvent *>(m2) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventKeyDown(m2);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m2);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m2, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventFrame(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrame(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrame"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::eventFrameEnd(float pTime) {
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventFrameEnd(pTime);
    }
    obj0 = rb_float_new(pTime);
    result = rb_funcall(swig_get_self(), rb_intern("eventFrameEnd"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::eventChangedRes() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::eventChangedRes();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventChangedRes"), 0, NULL);
}


SwigDirector_AGApplication::~SwigDirector_AGApplication() {
}

bool SwigDirector_AGApplication::eventIdle() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGApplication::eventIdle();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventIdle"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGApplication::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGApplication::draw() {
    VALUE result;
    
    if (swig_get_up()) {
        AGApplication::draw();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 0, NULL);
}


SwigDirector_AGText::SwigDirector_AGText(VALUE self, AGWidget *pParent, AGRect const &pRect, std::string const &pText, AGFont const &pFont): AGText(pParent, pRect, pText, pFont), Swig::Director(self) {
    
}



bool SwigDirector_AGText::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGText::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGText::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGText::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGText::~SwigDirector_AGText() {
}

bool SwigDirector_AGText::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGText::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGText::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGText::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGText::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGText::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGText::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGText::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGText::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGText::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGText::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGText::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGVTiler::SwigDirector_AGVTiler(VALUE self, AGWidget *pParent, AGRect const &pRect, bool pAdaptMyHeight): AGVTiler(pParent, pRect, pAdaptMyHeight), Swig::Director(self) {
    
}



bool SwigDirector_AGVTiler::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


int SwigDirector_AGVTiler::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGVTiler::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGVTiler::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGVTiler::~SwigDirector_AGVTiler() {
}

bool SwigDirector_AGVTiler::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGVTiler::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGVTiler::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGVTiler::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGVTiler::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGVTiler::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGVTiler::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGVTiler::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGVTiler::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGVTiler::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGVTiler::addChild(AGWidget *pWidget) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(pWidget);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(pWidget, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


SwigDirector_AGHTiler::SwigDirector_AGHTiler(VALUE self, AGWidget *pParent, AGRect const &pRect, bool pAdaptMyHeight): AGHTiler(pParent, pRect, pAdaptMyHeight), Swig::Director(self) {
    
}



bool SwigDirector_AGHTiler::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGHTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


int SwigDirector_AGHTiler::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGHTiler::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGHTiler::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGHTiler::~SwigDirector_AGHTiler() {
}

bool SwigDirector_AGHTiler::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGHTiler::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGHTiler::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGHTiler::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGHTiler::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGHTiler::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGHTiler::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGHTiler::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGHTiler::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGHTiler::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGHTiler::addChild(AGWidget *pWidget) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(pWidget);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(pWidget, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


SwigDirector_AGTheme::SwigDirector_AGTheme(VALUE self): AGTheme(), Swig::Director(self) {
    
}



SwigDirector_AGTheme::~SwigDirector_AGTheme() {
}

SwigDirector_AGMenuEvent::SwigDirector_AGMenuEvent(VALUE self, AGListener *pListener, std::string const &pName): AGMenuEvent(pListener, pName), Swig::Director(self) {
    
}



SwigDirector_AGMenuEvent::~SwigDirector_AGMenuEvent() {
}

SwigDirector_AGMenu::SwigDirector_AGMenu(VALUE self, AGWidget *pParent, AGPoint pWishPos, std::string const &pName): AGMenu(pParent, pWishPos, pName), Swig::Director(self) {
    
}



bool SwigDirector_AGMenu::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::rePosition() {
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::rePosition();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("rePosition"), 0, NULL);
}


int SwigDirector_AGMenu::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGMenu::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGMenu::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGMenu::~SwigDirector_AGMenu() {
}

bool SwigDirector_AGMenu::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGMenu::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGMenu::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGMenu::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGMenu::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGMenu::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGMenu::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGMenu::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGMenu::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGMenu::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGMenu::addChild(AGWidget *pWidget) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGVTiler::addChild(pWidget);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(pWidget);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(pWidget, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


SwigDirector_AGScreenWidget::SwigDirector_AGScreenWidget(VALUE self): AGScreenWidget(), Swig::Director(self) {
    
}



bool SwigDirector_AGScreenWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGScreenWidget::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGScreenWidget::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGScreenWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGScreenWidget::~SwigDirector_AGScreenWidget() {
}

bool SwigDirector_AGScreenWidget::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGScreenWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGScreenWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGScreenWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGScreenWidget::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGScreenWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGScreenWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGScreenWidget::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGScreenWidget::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGScreenWidget::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGEditLine::SwigDirector_AGEditLine(VALUE self, std::string const &pText, AGFont pFont, bool pHardEnd): AGEditLine(pText, pFont, pHardEnd), Swig::Director(self) {
    
}



SwigDirector_AGEditLine::~SwigDirector_AGEditLine() {
}

void SwigDirector_AGEditLine::drawCursor(AGPainter &p, int cx, AGPoint const &pPoint, AGRect const &pClip, AGColor const &c) {
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGPoint * nc_tmp_pPoint = const_cast<AGPoint *>(&pPoint) ;
    VALUE obj2 = Qnil ;
    AGRect * nc_tmp_pClip = const_cast<AGRect *>(&pClip) ;
    VALUE obj3 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj4 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEditLine::drawCursor(p,cx,pPoint,pClip,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    obj1 = INT2NUM(cx);
    obj2 = SWIG_NewPointerObj(nc_tmp_pPoint, SWIGTYPE_p_AGPoint, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_pClip, SWIGTYPE_p_AGRect, 0);
    obj4 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawCursor"), 5,obj0,obj1,obj2,obj3,obj4);
}


void SwigDirector_AGEditLine::draw(AGPainter &p, AGPoint const &pPoint, AGRect const &pClip) {
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pPoint = const_cast<AGPoint *>(&pPoint) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pClip = const_cast<AGRect *>(&pClip) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEditLine::draw(p,pPoint,pClip);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pPoint, SWIGTYPE_p_AGPoint, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pClip, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 3,obj0,obj1,obj2);
}


SwigDirector_AGEdit::SwigDirector_AGEdit(VALUE self, AGWidget *pParent, AGRect const &pRect): AGEdit(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGEdit::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGEdit::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGEdit::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGEdit::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGEdit::~SwigDirector_AGEdit() {
}

bool SwigDirector_AGEdit::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGEdit::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGEdit::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGEdit::drawBackground(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGEdit::drawBackground(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawBackground"), 1,obj0);
}


void SwigDirector_AGEdit::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGEdit::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGEdit::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGEdit::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGEdit::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGEdit::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGEdit::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGEdit::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGEdit::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGCheckBox::SwigDirector_AGCheckBox(VALUE self, AGWidget *pParent, AGRect pRect): AGCheckBox(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGCheckBox::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGCheckBox::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGCheckBox::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGCheckBox::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


std::string SwigDirector_AGCheckBox::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGCheckBox::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCheckBox::~SwigDirector_AGCheckBox() {
}

bool SwigDirector_AGCheckBox::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGCheckBox::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGCheckBox::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGCheckBox::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGCheckBox::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGCheckBox::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCheckBox::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCheckBox::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGCheckBox::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGCheckBox::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGCheckBox::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGCheckBox::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGRadioGroup::SwigDirector_AGRadioGroup(VALUE self, AGWidget *pParent, AGRect const &pr): AGRadioGroup(pParent, pr), Swig::Director(self) {
    
}



bool SwigDirector_AGRadioGroup::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGRadioGroup::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGRadioGroup::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGRadioGroup::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::eventChange(std::string const &p) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGRadioGroup::eventChange(p);
        return;
    }
    obj0=rb_str_new2(p.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("eventChange"), 1,obj0);
}


bool SwigDirector_AGRadioGroup::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGRadioGroup::~SwigDirector_AGRadioGroup() {
}

bool SwigDirector_AGRadioGroup::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGRadioGroup::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGRadioGroup::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGRadioGroup::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadioGroup::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadioGroup::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGRadioGroup::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGRadioGroup::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGRadio::SwigDirector_AGRadio(VALUE self, AGWidget *pParent, AGRect pRect): AGRadio(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGRadio::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::setChecked(bool pChecked) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGRadio::setChecked(pChecked);
        return;
    }
    obj0 = pChecked ? Qtrue : Qfalse;
    result = rb_funcall(swig_get_self(), rb_intern("setChecked"), 1,obj0);
}


bool SwigDirector_AGRadio::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGRadio::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGRadio::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


std::string SwigDirector_AGRadio::getCaption() const {
    std::string c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::getCaption();
    }
    result = rb_funcall(swig_get_self(), rb_intern("getCaption"), 0, NULL);
    {
        if (TYPE(result) == T_STRING)
        //            c_result = std::string(StringValuePtr(result));
        c_result = std::string(RSTRING(result)->ptr,RSTRING(result)->len);
        else
        throw Swig::DirectorTypeMismatchException("string expected");
    }
    return (std::string) c_result;
}


bool SwigDirector_AGRadio::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGRadio::~SwigDirector_AGRadio() {
}

bool SwigDirector_AGRadio::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGCheckBox::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGRadio::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGRadio::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGRadio::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGRadio::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGRadio::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGButton::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGRadio::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGRadio::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGButton::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGRadio::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGRadio::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGRadio::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGTable::SwigDirector_AGTable(VALUE self, AGWidget *pWidget, AGRect const &pRect): AGTable(pWidget, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGTable::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGTable::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGTable::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGTable::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGTable::~SwigDirector_AGTable() {
}

bool SwigDirector_AGTable::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGTable::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGTable::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGTable::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGTable::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGTable::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGTable::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGTable::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGTable::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGTable::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGTable::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGWindow::SwigDirector_AGWindow(VALUE self, AGWidget *pWidget, AGRect const &pRect, std::string const &pTitle): AGWindow(pWidget, pRect, pTitle), Swig::Director(self) {
    
}



bool SwigDirector_AGWindow::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGWindow::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGWindow::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGWindow::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGWindow::~SwigDirector_AGWindow() {
}

bool SwigDirector_AGWindow::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWindow::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGWindow::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGWindow::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGWindow::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


bool SwigDirector_AGWindow::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGWindow::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGWindow::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


void SwigDirector_AGWindow::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGTable::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGWindow::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGWindow::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


void SwigDirector_AGWindow::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWindow::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


SwigDirector_AGImage::SwigDirector_AGImage(VALUE self, AGWidget *pParent, AGPoint const &p, AGSurface pSurface, bool pTile, AGRect const &pRect): AGImage(pParent, p, pSurface, pTile, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGImage::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGImage::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGImage::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGImage::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGImage::~SwigDirector_AGImage() {
}

bool SwigDirector_AGImage::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGImage::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGImage::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGImage::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGImage::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGImage::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGImage::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGImage::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGImage::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGImage::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGImage::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGImage::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGCaption::SwigDirector_AGCaption(VALUE self, AGWidget *pParent, AGRect const &pRect, std::string const &pText, AGFont const &pFont, AGBackground const &pBG): AGCaption(pParent, pRect, pText, pFont, pBG), Swig::Director(self) {
    
}



bool SwigDirector_AGCaption::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGCaption::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGCaption::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGCaption::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGCaption::~SwigDirector_AGCaption() {
}

bool SwigDirector_AGCaption::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGCaption::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGCaption::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGCaption::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGCaption::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGCaption::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGCaption::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGCaption::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGCaption::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGCaption::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGCaption::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGCaption::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGLayout::SwigDirector_AGLayout(VALUE self, AGWidget *pgParent, std::string const &pXMLData): AGLayout(pgParent, pXMLData), Swig::Director(self) {
    
}



bool SwigDirector_AGLayout::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGLayout::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGLayout::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGLayout::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGLayout::~SwigDirector_AGLayout() {
}

bool SwigDirector_AGLayout::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGLayout::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGLayout::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGLayout::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGLayout::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGLayout::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGLayout::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGLayout::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGLayout::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGLayout::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGLayout::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGLayoutCreator::SwigDirector_AGLayoutCreator(VALUE self, std::string const &pName): AGLayoutCreator(pName), Swig::Director(self) {
    
}



SwigDirector_AGLayoutCreator::~SwigDirector_AGLayoutCreator() {
}

AGWidget *SwigDirector_AGLayoutCreator::create(AGWidget *pParent, AGRect const &pRect, xmlpp::Node const &pNode) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pRect = const_cast<AGRect *>(&pRect) ;
    VALUE obj1 = Qnil ;
    xmlpp::Node * nc_tmp_pNode = const_cast<xmlpp::Node *>(&pNode) ;
    VALUE obj2 = Qnil ;
    AGWidget *c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGLayoutCreator::create(pParent,pRect,pNode);
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(pParent);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(pParent, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pRect, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pNode, SWIGTYPE_p_Node, 0);
    result = rb_funcall(swig_get_self(), rb_intern("create"), 3,obj0,obj1,obj2);
    if ((SWIG_ConvertPtr(result,(void **) &c_result, SWIGTYPE_p_AGWidget,SWIG_POINTER_EXCEPTION | 0 )) == -1) throw Swig::DirectorTypeMismatchException("Pointer conversion failed.");
    return (AGWidget *) c_result;
}


SwigDirector_Parser::SwigDirector_Parser(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_Parser::simpleTag(std::string const &pName, Node::Attributes const &pAttributes) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    Node::Attributes * nc_tmp_pAttributes = const_cast<Node::Attributes *>(&pAttributes) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::simpleTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj(nc_tmp_pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0);
    result = rb_funcall(swig_get_self(), rb_intern("simpleTag"), 2,obj0,obj1);
}


SwigDirector_Parser::~SwigDirector_Parser() {
}

void SwigDirector_Parser::startTag(std::string const &pName, Node::Attributes const &pAttributes) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    Node::Attributes * nc_tmp_pAttributes = const_cast<Node::Attributes *>(&pAttributes) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::startTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj(nc_tmp_pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0);
    result = rb_funcall(swig_get_self(), rb_intern("startTag"), 2,obj0,obj1);
}


void SwigDirector_Parser::endTag(std::string const &pName) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::endTag(pName);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("endTag"), 1,obj0);
}


void SwigDirector_Parser::text(std::string const &pText) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::text(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("text"), 1,obj0);
}


void SwigDirector_Parser::comment(std::string const &pText) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::comment(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("comment"), 1,obj0);
}


void SwigDirector_Parser::header(std::string const &pText) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        Parser::header(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("header"), 1,obj0);
}


SwigDirector_DomParser::SwigDirector_DomParser(VALUE self) : Swig::Director(self) {
    
}



void SwigDirector_DomParser::simpleTag(std::string const &pName, Node::Attributes const &pAttributes) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    Node::Attributes * nc_tmp_pAttributes = const_cast<Node::Attributes *>(&pAttributes) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::simpleTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj(nc_tmp_pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0);
    result = rb_funcall(swig_get_self(), rb_intern("simpleTag"), 2,obj0,obj1);
}


SwigDirector_DomParser::~SwigDirector_DomParser() {
}

void SwigDirector_DomParser::startTag(std::string const &pName, Node::Attributes const &pAttributes) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    Node::Attributes * nc_tmp_pAttributes = const_cast<Node::Attributes *>(&pAttributes) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::startTag(pName,pAttributes);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    obj1 = SWIG_NewPointerObj(nc_tmp_pAttributes, SWIGTYPE_p_std__mapTstd__string_std__string_t, 0);
    result = rb_funcall(swig_get_self(), rb_intern("startTag"), 2,obj0,obj1);
}


void SwigDirector_DomParser::endTag(std::string const &pName) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::endTag(pName);
        return;
    }
    obj0=rb_str_new2(pName.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("endTag"), 1,obj0);
}


void SwigDirector_DomParser::text(std::string const &pText) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::text(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("text"), 1,obj0);
}


void SwigDirector_DomParser::comment(std::string const &pText) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::comment(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("comment"), 1,obj0);
}


void SwigDirector_DomParser::header(std::string const &pText) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        DomParser::header(pText);
        return;
    }
    obj0=rb_str_new2(pText.c_str());
    result = rb_funcall(swig_get_self(), rb_intern("header"), 1,obj0);
}


SwigDirector_AGSound::SwigDirector_AGSound(VALUE self): AGSound(), Swig::Director(self) {
    
}



bool SwigDirector_AGSound::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGSound::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGSound::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGSound::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGSound::~SwigDirector_AGSound() {
}

bool SwigDirector_AGSound::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGSound::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGSound::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGSound::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGSound::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGSound::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGSound::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGSound::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGSound::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGSound::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGSound::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGGLWidget::SwigDirector_AGGLWidget(VALUE self, AGWidget *pParent, AGRect const &r): AGGLWidget(pParent, r), Swig::Director(self) {
    
}



bool SwigDirector_AGGLWidget::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGGLWidget::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGGLWidget::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGGLWidget::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGGLWidget::~SwigDirector_AGGLWidget() {
}

bool SwigDirector_AGGLWidget::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::drawGL() {
    VALUE result;
    
    if (swig_get_up()) {
        AGGLWidget::drawGL();
        return;
    }
    result = rb_funcall(swig_get_self(), rb_intern("drawGL"), 0, NULL);
}


void SwigDirector_AGGLWidget::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGGLWidget::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGGLWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGGLWidget::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGGLWidget::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGGLWidget::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGGLWidget::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGGLWidget::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGGLWidget::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGGLWidget::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGGLWidget::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGGLWidget::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGColorButton::SwigDirector_AGColorButton(VALUE self, AGWidget *pParent, AGRect const &r, int x, int y): AGColorButton(pParent, r, x, y), Swig::Director(self) {
    
}



bool SwigDirector_AGColorButton::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGColorButton::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGColorButton::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGColorButton::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGColorButton::~SwigDirector_AGColorButton() {
}

bool SwigDirector_AGColorButton::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGColorButton::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGColorButton::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGColorButton::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGColorButton::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGColorButton::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGColorButton::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGColorButton::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGColorButton::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGColorButton::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGColorButton::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGColorButton::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGColorButton::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGDialog::SwigDirector_AGDialog(VALUE self, AGWidget *pgParent, std::string const &pXMLData): AGDialog(pgParent, pXMLData), Swig::Director(self) {
    
}



bool SwigDirector_AGDialog::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventClose(std::string const &pName, AGEvent const *event, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventClose(pName,event,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventClose"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGDialog::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGDialog::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGDialog::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGDialog::~SwigDirector_AGDialog() {
}

bool SwigDirector_AGDialog::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGDialog::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGDialog::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGDialog::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGDialog::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGDialog::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGDialog::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventCancel(std::string const &pName, AGEvent const *event, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventCancel(pName,event,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventCancel"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGDialog::eventOk(std::string const &pName, AGEvent const *event, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGDialog::eventOk(pName,event,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventOk"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGDialog::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGDialog::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGDialog::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGListBox::SwigDirector_AGListBox(VALUE self, AGWidget *pParent, AGRect const &pRect): AGListBox(pParent, pRect), Swig::Director(self) {
    
}



bool SwigDirector_AGListBox::eventLostFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventLostFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventLostFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventGotFocus() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventGotFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventGotFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventShow() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventShow();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventShow"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


int SwigDirector_AGListBox::minHeight() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minHeight();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minHeight"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


int SwigDirector_AGListBox::minWidth() const {
    int c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::minWidth();
    }
    result = rb_funcall(swig_get_self(), rb_intern("minWidth"), 0, NULL);
    c_result = (int) NUM2INT(result);
    return (int) c_result;
}


bool SwigDirector_AGListBox::canFocus() const {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::canFocus();
    }
    result = rb_funcall(swig_get_self(), rb_intern("canFocus"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


SwigDirector_AGListBox::~SwigDirector_AGListBox() {
}

bool SwigDirector_AGListBox::eventDragBy(AGEvent const *event, AGPoint const &pDiff) {
    AGEvent * nc_tmp_event = const_cast<AGEvent *>(event) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_pDiff = const_cast<AGPoint *>(&pDiff) ;
    VALUE obj1 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventDragBy(event,pDiff);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_event);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_event, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDiff, SWIGTYPE_p_AGPoint, 0);
    result = rb_funcall(swig_get_self(), rb_intern("eventDragBy"), 2,obj0,obj1);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseButtonUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseButtonDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseButtonDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseButtonDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseMotion(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseMotion(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseMotion"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::acceptEvent(SDL_Event const *pEvent) {
    SDL_Event * nc_tmp_pEvent = const_cast<SDL_Event *>(pEvent) ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::acceptEvent(pEvent);
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pEvent, SWIGTYPE_p_SDL_Event, 0);
    result = rb_funcall(swig_get_self(), rb_intern("acceptEvent"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventActive(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventActive(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventActive"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventKeyUp(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventKeyUp(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyUp"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventQuit(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuit(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuit"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventQuitModal(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventQuitModal(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventQuitModal"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventSysWM(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventSysWM(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventSysWM"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventResize(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGMessageObject::eventResize(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventResize"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventKeyDown(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListBox::eventKeyDown(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventKeyDown"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseClick(AGEvent const *m) {
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj0 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListBox::eventMouseClick(m);
    }
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj0 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj0 = director__p_AGEvent->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseClick"), 1,obj0);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventMouseEnter() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseEnter();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseEnter"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::signal(std::string const &pName, AGEvent const *m, AGMessageObject *pCaller) {
    std::string temp1 ;
    std::string temp10 ;
    VALUE obj0 = Qnil ;
    AGEvent * nc_tmp_m = const_cast<AGEvent *>(m) ;
    Swig::Director * director__p_AGEvent = 0 ;
    VALUE obj1 = Qnil ;
    Swig::Director * director__p_AGMessageObject = 0 ;
    VALUE obj2 = Qnil ;
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGListener::signal(pName,m,pCaller);
    }
    obj0=rb_str_new2(pName.c_str());
    director__p_AGEvent = dynamic_cast<Swig::Director *>(nc_tmp_m);
    if (!director__p_AGEvent) {
        obj1 = SWIG_NewPointerObj(nc_tmp_m, SWIGTYPE_p_AGEvent, 0);
    } else {
        obj1 = director__p_AGEvent->swig_get_self();
    }
    director__p_AGMessageObject = dynamic_cast<Swig::Director *>(pCaller);
    if (!director__p_AGMessageObject) {
        obj2 = SWIG_NewPointerObj(pCaller, SWIGTYPE_p_AGMessageObject, 0);
    } else {
        obj2 = director__p_AGMessageObject->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("signal"), 3,obj0,obj1,obj2);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::drawAll(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::drawAll(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawAll"), 1,obj0);
}


void SwigDirector_AGListBox::draw(AGPainter &p) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGListBox::draw(p);
        return;
    }
    obj0 = SWIG_NewPointerObj(&p, SWIGTYPE_p_AGPainter, 0);
    result = rb_funcall(swig_get_self(), rb_intern("draw"), 1,obj0);
}


void SwigDirector_AGListBox::setLeft(int x) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setLeft(x);
        return;
    }
    obj0 = INT2NUM(x);
    result = rb_funcall(swig_get_self(), rb_intern("setLeft"), 1,obj0);
}


void SwigDirector_AGListBox::setTop(int y) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setTop(y);
        return;
    }
    obj0 = INT2NUM(y);
    result = rb_funcall(swig_get_self(), rb_intern("setTop"), 1,obj0);
}


void SwigDirector_AGListBox::setHeight(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setHeight(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setHeight"), 1,obj0);
}


void SwigDirector_AGListBox::setWidth(int w) {
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::setWidth(w);
        return;
    }
    obj0 = INT2NUM(w);
    result = rb_funcall(swig_get_self(), rb_intern("setWidth"), 1,obj0);
}


bool SwigDirector_AGListBox::eventMouseLeave() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventMouseLeave();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventMouseLeave"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


bool SwigDirector_AGListBox::eventHide() {
    bool c_result ;
    VALUE result;
    
    if (swig_get_up()) {
        return AGWidget::eventHide();
    }
    result = rb_funcall(swig_get_self(), rb_intern("eventHide"), 0, NULL);
    c_result = (bool) RTEST(result);
    return (bool) c_result;
}


void SwigDirector_AGListBox::addChildBack(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChildBack(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChildBack"), 1,obj0);
}


void SwigDirector_AGListBox::addChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::addChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("addChild"), 1,obj0);
}


void SwigDirector_AGListBox::removeChild(AGWidget *w) {
    Swig::Director * director__p_AGWidget = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGWidget::removeChild(w);
        return;
    }
    director__p_AGWidget = dynamic_cast<Swig::Director *>(w);
    if (!director__p_AGWidget) {
        obj0 = SWIG_NewPointerObj(w, SWIGTYPE_p_AGWidget, 0);
    } else {
        obj0 = director__p_AGWidget->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("removeChild"), 1,obj0);
}


SwigDirector_AGPainter::SwigDirector_AGPainter(VALUE self): AGPainter(), Swig::Director(self) {
    
}



SwigDirector_AGPainter::SwigDirector_AGPainter(VALUE self, AGPainter const &p): AGPainter(p), Swig::Director(self) {
    
}



SwigDirector_AGPainter::SwigDirector_AGPainter(VALUE self, AGPaintTarget &pTarget): AGPainter(pTarget), Swig::Director(self) {
    
}



void SwigDirector_AGPainter::tile(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc, AGColor const &pColor) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    AGColor * nc_tmp_pColor = const_cast<AGColor *>(&pColor) ;
    VALUE obj3 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pSrc,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    obj3 = SWIG_NewPointerObj(nc_tmp_pColor, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 4,obj0,obj1,obj2,obj3);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect const &pDest, AGColor const &pColor) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_pColor = const_cast<AGColor *>(&pColor) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pColor);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pColor, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::blit(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pSrc);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::tile(AGSurface const &pSource, AGRect const &pDest, AGRect const &pSrc) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect * nc_tmp_pSrc = const_cast<AGRect *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource,pDest,pSrc);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::tile(AGTexture const &pSource) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 1,obj0);
}


void SwigDirector_AGPainter::drawCircle(AGPoint const &p, float rad, AGColor const &c) {
    AGPoint * nc_tmp_p = const_cast<AGPoint *>(&p) ;
    VALUE obj0 = Qnil ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::drawCircle(p,rad,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_p, SWIGTYPE_p_AGPoint, 0);
    obj1 = rb_float_new(rad);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawCircle"), 3,obj0,obj1,obj2);
}


SwigDirector_AGPainter::~SwigDirector_AGPainter() {
}

void SwigDirector_AGPainter::drawLine(AGPoint const &p0, AGPoint const &p1, AGColor const &c) {
    AGPoint * nc_tmp_p0 = const_cast<AGPoint *>(&p0) ;
    VALUE obj0 = Qnil ;
    AGPoint * nc_tmp_p1 = const_cast<AGPoint *>(&p1) ;
    VALUE obj1 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::drawLine(p0,p1,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_p0, SWIGTYPE_p_AGPoint, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_p1, SWIGTYPE_p_AGPoint, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawLine"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::blit(AGSurface const &pSource, AGRect const &pDest) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::tile(AGTexture const &pSource, AGRect const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::tile(AGSurface const &pSource, AGRect const &pDest) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    AGRect * nc_tmp_pDest = const_cast<AGRect *>(&pDest) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource,pDest);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect, 0);
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::blit(AGTexture const &pSource, AGRect2 const &pDest, AGRect2 const &pSrc) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGRect2 * nc_tmp_pDest = const_cast<AGRect2 *>(&pDest) ;
    VALUE obj1 = Qnil ;
    AGRect2 * nc_tmp_pSrc = const_cast<AGRect2 *>(&pSrc) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blit(pSource,pDest,pSrc);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGRect2, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGRect2, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blit"), 3,obj0,obj1,obj2);
}


void SwigDirector_AGPainter::tile(AGSurface const &pSource) {
    AGSurface * nc_tmp_pSource = const_cast<AGSurface *>(&pSource) ;
    Swig::Director * director__p_AGSurface = 0 ;
    VALUE obj0 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::tile(pSource);
        return;
    }
    director__p_AGSurface = dynamic_cast<Swig::Director *>(nc_tmp_pSource);
    if (!director__p_AGSurface) {
        obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGSurface, 0);
    } else {
        obj0 = director__p_AGSurface->swig_get_self();
    }
    result = rb_funcall(swig_get_self(), rb_intern("tile"), 1,obj0);
}


void SwigDirector_AGPainter::putPixel(AGPoint const &p, AGColor const &c) {
    AGPoint * nc_tmp_p = const_cast<AGPoint *>(&p) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::putPixel(p,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_p, SWIGTYPE_p_AGPoint, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("putPixel"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::drawRect(AGRect const &pRect, AGColor const &c) {
    AGRect * nc_tmp_pRect = const_cast<AGRect *>(&pRect) ;
    VALUE obj0 = Qnil ;
    AGColor * nc_tmp_c = const_cast<AGColor *>(&c) ;
    VALUE obj1 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::drawRect(pRect,c);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pRect, SWIGTYPE_p_AGRect, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_c, SWIGTYPE_p_AGColor, 0);
    result = rb_funcall(swig_get_self(), rb_intern("drawRect"), 2,obj0,obj1);
}


void SwigDirector_AGPainter::blitTri(AGTexture const &pSource, AGTriangle2 const &pSrc, AGTriangle2 const &pDest) {
    AGTexture * nc_tmp_pSource = const_cast<AGTexture *>(&pSource) ;
    VALUE obj0 = Qnil ;
    AGTriangle2 * nc_tmp_pSrc = const_cast<AGTriangle2 *>(&pSrc) ;
    VALUE obj1 = Qnil ;
    AGTriangle2 * nc_tmp_pDest = const_cast<AGTriangle2 *>(&pDest) ;
    VALUE obj2 = Qnil ;
    VALUE result;
    
    if (swig_get_up()) {
        AGPainter::blitTri(pSource,pSrc,pDest);
        return;
    }
    obj0 = SWIG_NewPointerObj(nc_tmp_pSource, SWIGTYPE_p_AGTexture, 0);
    obj1 = SWIG_NewPointerObj(nc_tmp_pSrc, SWIGTYPE_p_AGTriangle2, 0);
    obj2 = SWIG_NewPointerObj(nc_tmp_pDest, SWIGTYPE_p_AGTriangle2, 0);
    result = rb_funcall(swig_get_self(), rb_intern("blitTri"), 3,obj0,obj1,obj2);
}


swig_class cStringVector;

static VALUE
_wrap_new_StringVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<std::string > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<std::string > *)new std::vector<std::string >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_StringVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<std::string > *)new std::vector<std::string >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_StringVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::string *arg2 = 0 ;
    std::vector<std::string > *result;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (std::vector<std::string > *)new std::vector<std::string >(arg1,(std::string const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_StringVector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_StringVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTstd__string_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_StringVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = 0 ;
    std::vector<std::string > *result;
    std::vector<std::string > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (std::vector<std::string > *)new std::vector<std::string >((std::vector<std::string > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_StringVector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_StringVector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if (SWIG_STRING_P(o))
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<std::string >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTstd__string_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_StringVector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_StringVector'");
    return Qnil;
}


static VALUE
_wrap_StringVector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    unsigned int result;
    std::vector<std::string > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (unsigned int)((std::vector<std::string > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_StringVector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    bool result;
    std::vector<std::string > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<std::string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                if (SWIG_STRING_P(o))
                temp1[i] = (std::string)(SWIG_RB2STR(o));
                else
                rb_raise(rb_eTypeError,
                "wrong argument type"
                " (expected vector<""std::string" ">)");
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
        }
    }
    result = (bool)((std::vector<std::string > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_StringVector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_StringVector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->push_back(arg2);
    
    return Qnil;
}


static VALUE
_wrap_StringVector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    {
        try {
            result = std_vector_Sl_std_string_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_StringVector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    int arg2 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            result = std_vector_Sl_std_string_Sg____getitem__(arg1,arg2);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_StringVector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    int arg2 ;
    std::string arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg3 = std::string(StringValuePtr(argv[1]));
            arg3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        try {
            std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_StringVector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__string_t, 1);
    std_vector_Sl_std_string_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_std_string_Sg_(std::vector<std::string > *arg1) {
    delete arg1;
}
swig_class cLine2Vector;

static VALUE
_wrap_new_Line2Vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<AGLine2 > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<AGLine2 > *)new std::vector<AGLine2 >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_Line2Vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<AGLine2 > *)new std::vector<AGLine2 >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_Line2Vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    AGLine2 *arg2 = 0 ;
    std::vector<AGLine2 > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<AGLine2 > *)new std::vector<AGLine2 >(arg1,(AGLine2 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Line2Vector_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Line2Vector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTAGLine2_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Line2Vector__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *arg1 = 0 ;
    std::vector<AGLine2 > *result;
    std::vector<AGLine2 > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<AGLine2 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                AGLine2* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGLine2, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
        }
    }
    result = (std::vector<AGLine2 > *)new std::vector<AGLine2 >((std::vector<AGLine2 > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_Line2Vector(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Line2Vector__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Line2Vector__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    AGLine2* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_AGLine2,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<AGLine2 >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTAGLine2_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_Line2Vector__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGLine2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_Line2Vector__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Line2Vector'");
    return Qnil;
}


static VALUE
_wrap_Line2Vector___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *arg1 = (std::vector<AGLine2 > *) 0 ;
    unsigned int result;
    std::vector<AGLine2 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGLine2 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGLine2* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGLine2, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
        }
    }
    result = (unsigned int)((std::vector<AGLine2 > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Line2Vector_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *arg1 = (std::vector<AGLine2 > *) 0 ;
    bool result;
    std::vector<AGLine2 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGLine2 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGLine2* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGLine2, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
        }
    }
    result = (bool)((std::vector<AGLine2 > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Line2Vector_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *arg1 = (std::vector<AGLine2 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_Line2Vector_push(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *arg1 = (std::vector<AGLine2 > *) 0 ;
    AGLine2 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((AGLine2 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Line2Vector_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *arg1 = (std::vector<AGLine2 > *) 0 ;
    AGLine2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
    {
        try {
            result = std_vector_Sl_AGLine2_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        AGLine2 * resultptr;
        resultptr = new AGLine2((AGLine2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGLine2, 1);
    }
    return vresult;
}


static VALUE
_wrap_Line2Vector___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *arg1 = (std::vector<AGLine2 > *) 0 ;
    int arg2 ;
    AGLine2 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                AGLine2 &_result_ref = std_vector_Sl_AGLine2_Sg____getitem__(arg1,arg2);
                result = (AGLine2 *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLine2,0);
    return vresult;
}


static VALUE
_wrap_Line2Vector___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *arg1 = (std::vector<AGLine2 > *) 0 ;
    int arg2 ;
    AGLine2 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGLine2, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_AGLine2_Sg____setitem__(arg1,arg2,(AGLine2 const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_Line2Vector_each(int argc, VALUE *argv, VALUE self) {
    std::vector<AGLine2 > *arg1 = (std::vector<AGLine2 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGLine2_t, 1);
    std_vector_Sl_AGLine2_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_AGLine2_Sg_(std::vector<AGLine2 > *arg1) {
    delete arg1;
}
swig_class cAGMain;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMain_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMain_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMain);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMain(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    bool arg4 ;
    bool arg5 ;
    AGMain *result;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    arg4 = RTEST(argv[3]);
    arg5 = RTEST(argv[4]);
    result = (AGMain *)new AGMain(arg1,arg2,arg3,arg4,arg5);
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGMain(AGMain *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGMain_flip(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGMain_changeRes(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    bool arg5 ;
    bool arg6 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    arg5 = RTEST(argv[3]);
    arg6 = RTEST(argv[4]);
    (arg1)->changeRes(arg2,arg3,arg4,arg5,arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGMain_toggleFull(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    (arg1)->toggleFull();
    
    return Qnil;
}


static VALUE
_wrap_AGMain_width(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    result = (int)((AGMain const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGMain_height(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    result = (int)((AGMain const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGMain_setIcon(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setIcon((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMain_setCaption(int argc, VALUE *argv, VALUE self) {
    AGMain *arg1 = (AGMain *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMain, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setCaption((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_getMain(int argc, VALUE *argv, VALUE self) {
    AGMain *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMain *)getMain();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMain,0);
    return vresult;
}


static VALUE
_wrap_hasQuit(int argc, VALUE *argv, VALUE self) {
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (bool)hasQuit();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


swig_class cAGSurface;

static VALUE
_wrap_new_AGSurface__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1);
        
    } else {
        result = (AGSurface *)new AGSurface();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGSurface__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    int arg2 ;
    int arg3 ;
    AGSurface *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    char *classname = "Libantargisgui::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1,arg2,arg3);
        
    } else {
        result = (AGSurface *)new AGSurface(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSurface_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSurface_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSurface);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSurface__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSurface *arg2 = 0 ;
    AGSurface *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargisgui::AGSurface";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSurface *)new SwigDirector_AGSurface(arg1,(AGSurface const &)*arg2);
        
    } else {
        result = (AGSurface *)new AGSurface((AGSurface const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGSurface(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGSurface__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGSurface__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGSurface__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGSurface'");
    return Qnil;
}


static void
free_AGSurface(AGSurface *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGSurface_width(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (int)((AGSurface const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSurface_height(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (int)((AGSurface const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSurface_surface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    SDL_Surface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (SDL_Surface *)(arg1)->surface();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


static VALUE
_wrap_AGSurface_getRect(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = ((AGSurface const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_getSubSurface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    AGSurface result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGSurface const *)arg1)->getSubSurface((AGRect const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_clone(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (AGSurface *)((AGSurface const *)arg1)->clone();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSurface,0);
    }
    return vresult;
}


static VALUE
_wrap_AGSurface_valid(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    result = (bool)((AGSurface const *)arg1)->valid();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSurface_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE _wrap_AGSurface_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGSurface_blit__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGSurface_blit__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSurface_blit'");
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradient((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawGradientAlpha(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradientAlpha((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawBorder((AGRect const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_putPixel(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSurface_getPixel(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSurface const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_disown_AGSurface(int argc, VALUE *argv, VALUE self) {
    AGSurface *arg1 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSurface, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGTexture;

static VALUE
_wrap_new_AGTexture__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGTexture *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTexture *)new AGTexture();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTexture_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTexture_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTexture);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTexture__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = 0 ;
    AGTexture *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTexture, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTexture *)new AGTexture((AGTexture const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGTexture(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGTexture__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGTexture__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGTexture'");
    return Qnil;
}


static void
free_AGTexture(AGTexture *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGTexture_width(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (int)((AGTexture const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_height(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (int)((AGTexture const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_testSave(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    ((AGTexture const *)arg1)->testSave();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_getRect(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = ((AGTexture const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_getPixel(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = ((AGTexture const *)arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_getTW(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (float)((AGTexture const *)arg1)->getTW();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_getTH(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (float)((AGTexture const *)arg1)->getTH();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGTexture_hasTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (bool)((AGTexture const *)arg1)->hasTexture();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTexture_textureUsed(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (bool)((AGTexture const *)arg1)->textureUsed();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTexture_clearTexture(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    (arg1)->clearTexture();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_clearTextureUsed(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    (arg1)->clearTextureUsed();
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_setTextureID(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    GLuint arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    {
        GLuint * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_GLuint, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setTextureID(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTexture_getTextureID(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    GLuint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (arg1)->getTextureID();
    
    {
        GLuint * resultptr;
        resultptr = new GLuint((GLuint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_GLuint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTexture_surface(int argc, VALUE *argv, VALUE self) {
    AGTexture *arg1 = (AGTexture *) 0 ;
    SDL_Surface *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTexture, 1);
    result = (SDL_Surface *)(arg1)->surface();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


swig_class cAGScreen;

static VALUE
_wrap_AGScreen_begin(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->begin();
    
    return Qnil;
}


static VALUE
_wrap_AGScreen_flip(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGScreen_getWidth(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGScreen const *)arg1)->getWidth();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGScreen_getHeight(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGScreen const *)arg1)->getHeight();
    
    vresult = UINT2NUM(result);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGScreen_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGScreen_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGScreen);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGScreen(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGScreen *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGScreen";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGScreen *)new SwigDirector_AGScreen(arg1);
        
    } else {
        result = (AGScreen *)new AGScreen();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGScreen(AGScreen *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        AGScreen &_result_ref = getScreen();
        result = (AGScreen *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreen,0);
    return vresult;
}


static VALUE
_wrap_setScreen(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    setScreen(arg1);
    
    return Qnil;
}


swig_class cAGSurfaceManager;

static void
free_AGSurfaceManager(AGSurfaceManager *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGSurfaceManager_loadSurface(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->loadSurface((std::string const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurfaceManager_fromSDL(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    SDL_Surface *arg2 = (SDL_Surface *) 0 ;
    AGSurface result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Surface, 1);
    result = (arg1)->fromSDL(arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSurfaceManager_registerSurface(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGSurface *arg2 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1);
    (arg1)->registerSurface(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_deregisterSurface(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    AGSurface *arg2 = (AGSurface *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1);
    (arg1)->deregisterSurface(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_cleanup(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    (arg1)->cleanup();
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_enableGC(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    (arg1)->enableGC();
    
    return Qnil;
}


static VALUE
_wrap_AGSurfaceManager_disableGC(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *arg1 = (AGSurfaceManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSurfaceManager, 1);
    (arg1)->disableGC();
    
    return Qnil;
}


static VALUE
_wrap_getSurfaceManager(int argc, VALUE *argv, VALUE self) {
    AGSurfaceManager *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGSurfaceManager *)getSurfaceManager();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSurfaceManager,0);
    return vresult;
}


swig_class cAGTextureManager;

static void
free_AGTextureManager(AGTextureManager *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGTextureManager_registerTexture(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    AGTexture *arg2 = (AGTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1);
    (arg1)->registerTexture(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTextureManager_deregisterTexture(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    AGTexture *arg2 = (AGTexture *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1);
    (arg1)->deregisterTexture(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTextureManager_cleanup(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    (arg1)->cleanup();
    
    return Qnil;
}


static VALUE
_wrap_AGTextureManager_checkUnused(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    (arg1)->checkUnused();
    
    return Qnil;
}


static VALUE
_wrap_AGTextureManager_makeTexture(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    AGSurface *arg2 = 0 ;
    AGTexture result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (arg1)->makeTexture((AGSurface const &)*arg2);
    
    {
        AGTexture * resultptr;
        resultptr = new AGTexture((AGTexture &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTexture, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTextureManager_makeTexture3D(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    AGSurface *arg2 = 0 ;
    AGTexture result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (arg1)->makeTexture3D((AGSurface const &)*arg2);
    
    {
        AGTexture * resultptr;
        resultptr = new AGTexture((AGTexture &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTexture, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTextureManager_clear(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *arg1 = (AGTextureManager *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTextureManager, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_getTextureManager(int argc, VALUE *argv, VALUE self) {
    AGTextureManager *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTextureManager *)getTextureManager();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTextureManager,0);
    return vresult;
}


swig_class cAGSDLScreen;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSDLScreen_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSDLScreen_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSDLScreen);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSDLScreen(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    SDL_Surface *arg2 = (SDL_Surface *) 0 ;
    AGSDLScreen *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Surface, 1);
    {
        char *classname = "Libantargisgui::AGSDLScreen";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGSDLScreen *)new SwigDirector_AGSDLScreen(arg1,arg2);
            
        } else {
            result = (AGSDLScreen *)new AGSDLScreen(arg2);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGSDLScreen_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGSDLScreen_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSDLScreen_blit__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGSDLScreen_blit__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSDLScreen_blit'");
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_tile__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_tile__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_tile__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGSDLScreen_tile(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSDLScreen_tile__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGSDLScreen_tile__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSDLScreen, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGSDLScreen_tile__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSDLScreen_tile'");
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_flip(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->flip();
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_getRect(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSDLScreen const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_drawRect(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawRect((AGRect const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_drawLine(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawLine((AGPoint const &)*arg2,(AGPoint const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_drawGradientAlpha(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGradientAlpha((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGradient((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_renderText(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    int arg4 ;
    std::string *arg5 = 0 ;
    AGFont *arg6 = 0 ;
    std::string temp5 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    arg4 = NUM2INT(argv[2]);
    {
        if (TYPE(argv[3]) == T_STRING) {
            //            temp5 = std::string(StringValuePtr(argv[3]));
            temp5 = std::string(RSTRING(argv[3])->ptr,RSTRING(argv[3])->len);
            arg5 = &temp5;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGFont, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->renderText((AGRect const &)*arg2,arg3,arg4,(std::string const &)*arg5,(AGFont const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawBorder((AGRect const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_putPixel(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGSDLScreen_newSurface(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    int arg2 ;
    int arg3 ;
    SDL_Surface *result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (SDL_Surface *)(arg1)->newSurface(arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Surface,0);
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_loadSurface(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (arg1)->loadSurface((std::string const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_displayFormat(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    SDL_Surface *arg2 = (SDL_Surface *) 0 ;
    AGTexture result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Surface, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (arg1)->displayFormat(arg2);
    
    {
        AGTexture * resultptr;
        resultptr = new AGTexture((AGTexture &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTexture, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_makeTexture(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    AGSurface *arg2 = 0 ;
    AGTexture result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (arg1)->makeTexture((AGSurface const &)*arg2);
    
    {
        AGTexture * resultptr;
        resultptr = new AGTexture((AGTexture &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTexture, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_getWidth(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSDLScreen const *)arg1)->getWidth();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSDLScreen_getHeight(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    size_t result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGSDLScreen const *)arg1)->getHeight();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static void
free_AGSDLScreen(AGSDLScreen *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGSDLScreen(int argc, VALUE *argv, VALUE self) {
    AGSDLScreen *arg1 = (AGSDLScreen *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSDLScreen, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGEvent;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEvent(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    AGEvent *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1);
    char *classname = "Libantargisgui::AGEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEvent *)new SwigDirector_AGEvent(arg1,arg2);
        
    } else {
        result = (AGEvent *)new AGEvent(arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGEvent(AGEvent *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGEvent_getCaller(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    AGListener *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEvent, 1);
    result = (AGListener *)((AGEvent const *)arg1)->getCaller();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListener,0);
    return vresult;
}


static VALUE
_wrap_disown_AGEvent(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = (AGEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEvent, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSDLEvent;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSDLEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSDLEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSDLEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSDLEvent(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    SDL_Event *arg3 = (SDL_Event *) 0 ;
    AGSDLEvent *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_SDL_Event, 1);
    char *classname = "Libantargisgui::AGSDLEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSDLEvent *)new SwigDirector_AGSDLEvent(arg1,arg2,(SDL_Event const *)arg3);
        
    } else {
        result = (AGSDLEvent *)new AGSDLEvent(arg2,(SDL_Event const *)arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGSDLEvent_getMousePosition(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = ((AGSDLEvent const *)arg1)->getMousePosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGSDLEvent_getKey(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    SDLKey result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = (SDLKey)((AGSDLEvent const *)arg1)->getKey();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSDLEvent_getMod(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    SDLMod result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = (SDLMod)((AGSDLEvent const *)arg1)->getMod();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSDLEvent_getButton(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = (int)((AGSDLEvent const *)arg1)->getButton();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGSDLEvent_get(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    SDL_Event *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    result = (SDL_Event *)((AGSDLEvent const *)arg1)->get();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SDL_Event,0);
    return vresult;
}


static void
free_AGSDLEvent(AGSDLEvent *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGSDLEvent(int argc, VALUE *argv, VALUE self) {
    AGSDLEvent *arg1 = (AGSDLEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSDLEvent, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGMouseEvent;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMouseEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMouseEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMouseEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMouseEvent(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    SDL_Event *arg3 = (SDL_Event *) 0 ;
    AGMouseEvent *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_SDL_Event, 1);
    char *classname = "Libantargisgui::AGMouseEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGMouseEvent *)new SwigDirector_AGMouseEvent(arg1,arg2,arg3);
        
    } else {
        result = (AGMouseEvent *)new AGMouseEvent(arg2,arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGMouseEvent(AGMouseEvent *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGMouseEvent(int argc, VALUE *argv, VALUE self) {
    AGMouseEvent *arg1 = (AGMouseEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMouseEvent, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGListener;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListener_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListener_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListener);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListener(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGListener";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGListener *)new SwigDirector_AGListener(arg1);
        
    } else {
        result = (AGListener *)new AGListener();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGListener(AGListener *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGListener_signal(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListener, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->signal((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGListener(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListener, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGCPPListener;

static void
free_AGCPPListener(AGCPPListener *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGCPPListener_signal(int argc, VALUE *argv, VALUE self) {
    AGCPPListener *arg1 = (AGCPPListener *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCPPListener, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGCPPListener const *)arg1)->signal((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCPPListener_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCPPListener_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCPPListener);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCPPListener(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGCPPListener *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGCPPListener";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGCPPListener *)new SwigDirector_AGCPPListener(arg1);
        
    } else {
        rb_raise(rb_eNameError,"accessing abstract class or protected constructor"); 
        return Qnil;
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_disown_AGCPPListener(int argc, VALUE *argv, VALUE self) {
    AGCPPListener *arg1 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCPPListener, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSignal;

static VALUE
_wrap_new_AGSignal__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSignal *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1);
        
    } else {
        result = (AGSignal *)new AGSignal();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGSignal__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *arg2 = (AGMessageObject *) 0 ;
    AGSignal *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMessageObject, 1);
    char *classname = "Libantargisgui::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1,arg2);
        
    } else {
        result = (AGSignal *)new AGSignal(arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSignal_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSignal_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSignal);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSignal__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *arg2 = (AGMessageObject *) 0 ;
    std::string *arg3 = 0 ;
    AGSignal *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMessageObject, 1);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargisgui::AGSignal";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSignal *)new SwigDirector_AGSignal(arg1,arg2,(std::string const &)*arg3);
        
    } else {
        result = (AGSignal *)new AGSignal(arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGSignal(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGSignal__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMessageObject, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGSignal__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMessageObject, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (TYPE(argv[2]) == T_STRING) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGSignal__SWIG_2(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGSignal'");
    return Qnil;
}


static void
free_AGSignal(AGSignal *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGSignal_connect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGListener *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->connect(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSignal_disconnect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGListener *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->disconnect(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGSignal_connect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGCPPListener *arg2 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGCPPListener, 1);
    (arg1)->connect(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSignal_connect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_connect__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGCPPListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_connect__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSignal_connect'");
    return Qnil;
}


static VALUE
_wrap_AGSignal_disconnect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGCPPListener *arg2 = (AGCPPListener *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGCPPListener, 1);
    (arg1)->disconnect(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGSignal_disconnect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_disconnect__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGSignal, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGCPPListener, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGSignal_disconnect__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGSignal_disconnect'");
    return Qnil;
}


static VALUE
_wrap_AGSignal_signal(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->signal((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSignal___call__(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->operator ()((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGSignal(int argc, VALUE *argv, VALUE self) {
    AGSignal *arg1 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSignal, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGMessageObject;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMessageObject_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMessageObject_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMessageObject);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMessageObject(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGMessageObject *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGMessageObject";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGMessageObject *)new SwigDirector_AGMessageObject(arg1);
        
    } else {
        result = (AGMessageObject *)new AGMessageObject();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGMessageObject(AGMessageObject *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGMessageObject_processEvent(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->processEvent((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_acceptEvent(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    SDL_Event *arg2 = (SDL_Event *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_Event, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->acceptEvent((SDL_Event const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventActive(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventActive((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventKeyUp(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventQuit(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuit((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventQuitModal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuitModal((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventSysWM(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventSysWM((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_eventResize(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventResize((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGMessageObject_getButtonState(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    Uint8 result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGMessageObject const *)arg1)->getButtonState();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMessageObject_getMousePosition(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGPoint result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGMessageObject const *)arg1)->getMousePosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigActive_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigActive = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigActive_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigActive);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigKeyDown_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigKeyDown = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigKeyDown_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigKeyDown);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigKeyUp_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigKeyUp = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigKeyUp_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigKeyUp);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseMotion_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseMotion = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseMotion_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigMouseMotion);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonDown_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseButtonDown = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonDown_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigMouseButtonDown);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonUp_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseButtonUp = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigMouseButtonUp_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigMouseButtonUp);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigQuit_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigQuit = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigQuit_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigQuit);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigSysWM_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigSysWM = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigSysWM_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigSysWM);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_sigVideoResize_set(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigVideoResize = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_sigVideoResize_get(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGSignal *)& ((arg1)->sigVideoResize);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGMessageObject_pushSignal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    (arg1)->pushSignal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMessageObject_popSignal(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    (arg1)->popSignal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGMessageObject(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_newEvent(int argc, VALUE *argv, VALUE self) {
    AGListener *arg1 = (AGListener *) 0 ;
    SDL_Event *arg2 = (SDL_Event *) 0 ;
    AGEvent *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListener, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_SDL_Event, 1);
    result = (AGEvent *)newEvent(arg1,(SDL_Event const *)arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEvent,0);
    return vresult;
}


static VALUE
_wrap_toAGSDLEvent(int argc, VALUE *argv, VALUE self) {
    AGEvent *arg1 = 0 ;
    AGSDLEvent *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEvent, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSDLEvent &_result_ref = toAGSDLEvent(*arg1);
        result = (AGSDLEvent *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSDLEvent,0);
    return vresult;
}


swig_class cAGWidget;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGWidget *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWidget *)new SwigDirector_AGWidget(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGWidget *)new AGWidget(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGWidget(AGWidget *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGWidget_draw(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_drawAll(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAll(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = ((AGWidget const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGWidget const *)arg1)->getClientRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setRect((AGRect const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setParent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->setParent(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getParent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (AGWidget *)(arg1)->getParent();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_eventShow(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventShow();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventHide(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventHide();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseMotion(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseMotion((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventGotFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventGotFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_eventLostFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventLostFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_canFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGWidget const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_processEvent(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->processEvent((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_sigMouseEnter_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseEnter = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigMouseEnter_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (AGSignal *)& ((arg1)->sigMouseEnter);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_sigMouseLeave_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMouseLeave = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigMouseLeave_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (AGSignal *)& ((arg1)->sigMouseLeave);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_sigClick_set(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigClick = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_sigClick_get(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (AGSignal *)& ((arg1)->sigClick);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGWidget_minWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (int)((AGWidget const *)arg1)->minWidth();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_minHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (int)((AGWidget const *)arg1)->minHeight();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_width(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (int)((AGWidget const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_height(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (int)((AGWidget const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_top(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (int)((AGWidget const *)arg1)->top();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_left(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (int)((AGWidget const *)arg1)->left();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGWidget_setWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setTop(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setTop(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_setLeft(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setLeft(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_fixedWidth(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (bool)((AGWidget const *)arg1)->fixedWidth();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_fixedHeight(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (bool)((AGWidget const *)arg1)->fixedHeight();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_show(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->show();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_hide(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->hide();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_addChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_addChildBack(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChildBack(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_removeChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->removeChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_clear(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getScreenRect(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = ((AGWidget const *)arg1)->getScreenRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_getScreenPosition(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = ((AGWidget const *)arg1)->getScreenPosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_fromScreen(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGWidget const *)arg1)->fromScreen((AGPoint const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_gainFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->gainFocus(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->gainFocus();
    
    return Qnil;
}


static VALUE _wrap_AGWidget_gainFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_gainFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_gainFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_gainFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainCompleteFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->gainCompleteFocus(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_gainCompleteFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    (arg1)->gainCompleteFocus();
    
    return Qnil;
}


static VALUE _wrap_AGWidget_gainCompleteFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_gainCompleteFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_gainCompleteFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_gainCompleteFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_eventDragBy(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    AGPoint *arg3 = 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventDragBy((AGEvent const *)arg2,(AGPoint const &)*arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_getFocus(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (bool)((AGWidget const *)arg1)->getFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_hasFocus__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    result = (bool)(arg1)->hasFocus((AGWidget const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWidget_hasFocus__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = (bool)(arg1)->hasFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGWidget_hasFocus(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_AGWidget_hasFocus__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGWidget_hasFocus__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGWidget_hasFocus'");
    return Qnil;
}


static VALUE
_wrap_AGWidget_getName(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    result = ((AGWidget const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setName(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_getChild(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    std::string *arg2 = 0 ;
    AGWidget *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGWidget *)(arg1)->getChild((std::string const &)*arg2);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_AGWidget_setModal(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setModal(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_erase(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->erase(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_eventChildrenDeleted(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->eventChildrenDeleted(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWidget_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, 1);
    AGWidget_markfunc(arg1);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGWidget(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGWidget(int argc, VALUE *argv, VALUE self) {
    AGMessageObject *arg1 = (AGMessageObject *) 0 ;
    AGWidget *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMessageObject, 1);
    result = (AGWidget *)toAGWidget(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    return vresult;
}


static VALUE
agNoParent_get(VALUE self) {
    VALUE _val;
    
    _val = SWIG_NewPointerObj((void *) agNoParent, SWIGTYPE_p_AGWidget,0);    return _val;
}


static VALUE
agNoParent_set(VALUE self, VALUE _val) {
    SWIG_ConvertPtr(_val, (void **) &agNoParent, SWIGTYPE_p_AGWidget, 1);
    return _val;
}


swig_class cAGPoint;

static VALUE
_wrap_AGPoint_x_set(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    arg2 = NUM2INT(argv[0]);
    if (arg1) (arg1)->x = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGPoint_x_get(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    result = (int) ((arg1)->x);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGPoint_y_set(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    arg2 = NUM2INT(argv[0]);
    if (arg1) (arg1)->y = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGPoint_y_get(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    result = (int) ((arg1)->y);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_new_AGPoint__SWIG_0(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    AGPoint *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    result = (AGPoint *)new AGPoint(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPoint_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPoint_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPoint);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPoint__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPoint *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGPoint *)new AGPoint();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGPoint(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGPoint__SWIG_1(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGPoint__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGPoint'");
    return Qnil;
}


static VALUE
_wrap_AGPoint___sub__(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGPoint const *)arg1)->operator -((AGPoint const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPoint___add__(int argc, VALUE *argv, VALUE self) {
    AGPoint *arg1 = (AGPoint *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPoint, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGPoint const *)arg1)->operator +((AGPoint const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static void
free_AGPoint(AGPoint *arg1) {
    delete arg1;
}
swig_class cAGRect;

static VALUE
_wrap_new_AGRect__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGRect *)new AGRect();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGRect__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = 0 ;
    AGRect *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRect, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect *)new AGRect((AGRect const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGRect__SWIG_2(int argc, VALUE *argv, VALUE self) {
    SDL_Rect *arg1 = 0 ;
    AGRect *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_SDL_Rect, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect *)new AGRect((SDL_Rect const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGRect__SWIG_3(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    AGRect *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    arg4 = NUM2INT(argv[3]);
    result = (AGRect *)new AGRect(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect__SWIG_4(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGRect *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGRect *)new AGRect((std::string const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGRect(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGRect__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGRect__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SDL_Rect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGRect__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGRect__SWIG_4(nargs, args, self);
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGRect__SWIG_3(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGRect'");
    return Qnil;
}


static VALUE
_wrap_AGRect_setX(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect_setY(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect_setW(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setW(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect_setH(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->setH(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect_getX(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (int)((AGRect const *)arg1)->getX();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGRect_getY(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (int)((AGRect const *)arg1)->getY();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGRect_width(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (int)((AGRect const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGRect_height(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (int)((AGRect const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGRect_intersect(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect const *)arg1)->intersect((AGRect const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_isNull(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = (bool)((AGRect const *)arg1)->isNull();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect_shrink(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    result = ((AGRect const *)arg1)->shrink(arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_shrinkRB(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    int arg2 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    arg2 = NUM2INT(argv[0]);
    result = ((AGRect const *)arg1)->shrinkRB(arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_contains__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect const *)arg1)->contains((AGPoint const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect_contains__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect const *)arg1)->contains((AGRect const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGRect_contains(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGPoint, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect_contains__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect_contains__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGRect_contains'");
    return Qnil;
}


static VALUE
_wrap_AGRect_project__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect const *)arg1)->project((AGRect const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_project__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect const *)arg1)->project((AGPoint const &)*arg2);
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE _wrap_AGRect_project(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect_project__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGPoint, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect_project__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGRect_project'");
    return Qnil;
}


static VALUE
_wrap_AGRect_getMiddle(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = ((AGRect const *)arg1)->getMiddle();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_origin(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = ((AGRect const *)arg1)->origin();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_getPosition(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = ((AGRect const *)arg1)->getPosition();
    
    {
        AGPoint * resultptr;
        resultptr = new AGPoint((AGPoint &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect_to_s(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    result = ((AGRect const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGRect___eq__(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGRect *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect const *)arg1)->operator ==((AGRect const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect___add__(int argc, VALUE *argv, VALUE self) {
    AGRect *arg1 = (AGRect *) 0 ;
    AGPoint *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect const *)arg1)->operator +((AGPoint const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static void
free_AGRect(AGRect *arg1) {
    delete arg1;
}
swig_class cAGAngle;

static VALUE
_wrap_AGAngle_angle_set(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = (AGAngle *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGAngle, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    if (arg1) (arg1)->angle = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGAngle_angle_get(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = (AGAngle *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGAngle, 1);
    result = (float) ((arg1)->angle);
    
    vresult = rb_float_new(result);
    return vresult;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGAngle_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGAngle_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGAngle);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGAngle(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    AGAngle *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    result = (AGAngle *)new AGAngle(arg1);
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGAngle(AGAngle *arg1) {
    delete arg1;
}
swig_class cAGVector2;

static VALUE
_wrap_AGVector2_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 1);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector2_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGVector2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector2 *)new AGVector2(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGVector2 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector2 *)new AGVector2((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector2__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = 0 ;
    AGVector2 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector2, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector2 *)new AGVector2((AGVector2 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector2__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector2 *)new AGVector2();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector2__SWIG_3(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector2__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector2__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector2__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector2'");
    return Qnil;
}


static VALUE
_wrap_AGVector2_setX(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_setY(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_x(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float)((AGVector2 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_y(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float)((AGVector2 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_getAngle(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    SwigValueWrapper<AGAngle > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = ((AGVector2 const *)arg1)->getAngle();
    
    {
        AGAngle * resultptr;
        resultptr = new AGAngle((AGAngle &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGAngle, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector2 const *)arg1)->operator -((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___add__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector2 const *)arg1)->operator +((AGVector2 const &)*arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector2 const *)arg1)->operator *((AGVector2 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector2 const *)arg1)->operator *(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector2___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector2___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector2___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector2___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector2___div__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float arg2 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector2 const *)arg1)->operator /(arg2);
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector2 const *)arg1)->operator ==((AGVector2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector2_length(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float)((AGVector2 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_length2(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (float)((AGVector2 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector2_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = ((AGVector2 const *)arg1)->normalized();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_normal(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    AGVector2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = ((AGVector2 const *)arg1)->normal();
    
    {
        AGVector2 * resultptr;
        resultptr = new AGVector2((AGVector2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector2_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = (bool)((AGVector2 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector2_saveXML(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((AGVector2 const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_loadXML(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector2_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector2 *arg1 = (AGVector2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector2, 1);
    result = ((AGVector2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGVector2(AGVector2 *arg1) {
    delete arg1;
}
swig_class cAGVector3;

static VALUE
_wrap_AGVector3_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 1);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector3_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGVector3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGVector3 *)new AGVector3(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGVector3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector3 *)new AGVector3(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector3 *)new AGVector3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector3__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGVector3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector3 *)new AGVector3();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector3__SWIG_4(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector3__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVector3__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector3'");
    return Qnil;
}


static VALUE
_wrap_AGVector3_setX(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_setY(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_setZ(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setZ(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_x(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_y(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_z(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->getZ();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_getAngle(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    SwigValueWrapper<AGAngle > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = ((AGVector3 const *)arg1)->getAngle();
    
    {
        AGAngle * resultptr;
        resultptr = new AGAngle((AGAngle &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGAngle, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___neg__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = ((AGVector3 const *)arg1)->operator -();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator -((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___add__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator +((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_add(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector3 &_result_ref = (arg1)->operator +=((AGVector3 const &)*arg2);
        result = (AGVector3 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3_sub(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector3 &_result_ref = (arg1)->operator -=((AGVector3 const &)*arg2);
        result = (AGVector3 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector3 const *)arg1)->operator *((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector3 const *)arg1)->operator *(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector3___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector3___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector3___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector3___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector3___div__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float arg2 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector3 const *)arg1)->operator /(arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___mod__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector3 const *)arg1)->operator %((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector3 const *)arg1)->operator ==((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3_length(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_length2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (float)((AGVector3 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector3_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = ((AGVector3 const *)arg1)->normalized();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_normal(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = ((AGVector3 const *)arg1)->normal();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = (bool)((AGVector3 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3_saveXML(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((AGVector3 const *)arg1)->saveXML(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_loadXML(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->loadXML((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = (AGVector3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector3, 1);
    result = ((AGVector3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGVector3(AGVector3 *arg1) {
    delete arg1;
}
swig_class cAGPoint3;

static VALUE
_wrap_new_AGPoint3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPoint3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGPoint3 *)new AGPoint3();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGPoint3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGPoint3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGPoint3 *)new AGPoint3(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGPoint3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    AGPoint3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGPoint3 *)new AGPoint3(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPoint3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPoint3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPoint3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPoint3__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGPoint3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGPoint3 *)new AGPoint3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGPoint3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGPoint3__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGPoint3__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGPoint3__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGPoint3__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGPoint3'");
    return Qnil;
}


static void
free_AGPoint3(AGPoint3 *arg1) {
    delete arg1;
}
swig_class cAGMatrix3;

static VALUE
_wrap_new_AGMatrix3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMatrix3 *)new AGMatrix3();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGMatrix3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGAngle *arg1 = 0 ;
    AGMatrix3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGAngle, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix3 *)new AGMatrix3((AGAngle const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMatrix3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMatrix3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMatrix3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMatrix3__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGMatrix3 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix3 *)new AGMatrix3((AGVector3 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGMatrix3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGMatrix3__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGAngle, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix3__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix3__SWIG_2(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGMatrix3'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3_set(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGMatrix3_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix3 const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix3_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->get(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix3_get(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix3_get__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix3_get__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix3_get'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix3 const *)arg1)->operator *((AGMatrix3 const &)*arg2);
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix3 const *)arg1)->operator *((AGVector3 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE _wrap_AGMatrix3___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix3___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix3___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix3___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix3___neg__(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    result = ((AGMatrix3 const *)arg1)->operator -();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_inverted(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    result = ((AGMatrix3 const *)arg1)->inverted();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_transposed(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    result = ((AGMatrix3 const *)arg1)->transposed();
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix3_to_s(int argc, VALUE *argv, VALUE self) {
    AGMatrix3 *arg1 = (AGMatrix3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix3, 1);
    result = ((AGMatrix3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGMatrix3(AGMatrix3 *arg1) {
    delete arg1;
}
swig_class cAGLine2;

static VALUE
_wrap_new_AGLine2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGLine2 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLine2 *)new AGLine2();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLine2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLine2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLine2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLine2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGLine2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGLine2 *)new AGLine2((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGLine2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGLine2__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGLine2__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGLine2'");
    return Qnil;
}


static VALUE
_wrap_AGLine2_getV0(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->getV0();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_getV1(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->getV1();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_has(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->has((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_collide(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->collide((AGLine2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_collisionPoint(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGLine2 const *)arg1)->collisionPoint((AGLine2 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_collisionPointNI(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGLine2 const *)arg1)->collisionPointNI((AGLine2 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_includes(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine2 const *)arg1)->includes((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine2_getBBox(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    SwigValueWrapper<AGRect2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->getBBox();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_normal(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->normal();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_direction(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->direction();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine2_distance(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGLine2 const *)arg1)->distance((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGLine2_to_s(int argc, VALUE *argv, VALUE self) {
    AGLine2 *arg1 = (AGLine2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine2, 1);
    result = ((AGLine2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGLine2(AGLine2 *arg1) {
    delete arg1;
}
swig_class cAGLine3;

static VALUE
_wrap_new_AGLine3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGLine3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLine3 *)new AGLine3();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLine3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLine3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLine3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLine3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGLine3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGLine3 *)new AGLine3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGLine3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGLine3__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGLine3__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGLine3'");
    return Qnil;
}


static VALUE
_wrap_AGLine3_getV0(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    result = ((AGLine3 const *)arg1)->getV0();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_getV1(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    result = ((AGLine3 const *)arg1)->getV1();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_has(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGLine3 const *)arg1)->has((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGLine3_direction(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    result = ((AGLine3 const *)arg1)->direction();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGLine3_distance(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGLine3 const *)arg1)->distance((AGVector3 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGLine3_to_s(int argc, VALUE *argv, VALUE self) {
    AGLine3 *arg1 = (AGLine3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLine3, 1);
    result = ((AGLine3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGLine3(AGLine3 *arg1) {
    delete arg1;
}
swig_class cAGCollisionData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCollisionData_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCollisionData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCollisionData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCollisionData(int argc, VALUE *argv, VALUE self) {
    AGCollisionData *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGCollisionData *)new AGCollisionData();
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGCollisionData(AGCollisionData *arg1) {
    delete arg1;
}
swig_class cAGTriangle2;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTriangle2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTriangle2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTriangle2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTriangle2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *arg3 = 0 ;
    AGTriangle2 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_AGVector3, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTriangle2 *)new AGTriangle2((AGVector3 const &)*arg1,(AGVector3 const &)*arg2,(AGVector3 const &)*arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGTriangle2_get(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    int arg2 ;
    AGPoint3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    arg2 = NUM2INT(argv[0]);
    result = ((AGTriangle2 const *)arg1)->get(arg2);
    
    {
        AGPoint3 * resultptr;
        resultptr = new AGPoint3((AGPoint3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_collide(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGTriangle2 const *)arg1)->collide((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getNormals(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    std::vector<AGVector3 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    result = ((AGTriangle2 const *)arg1)->getNormals();
    
    {
        std::vector<AGVector3 > * resultptr;
        resultptr = new std::vector<AGVector3 >((std::vector<AGVector3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_apply(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->apply((AGMatrix3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTriangle2_applied(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGMatrix3 *arg2 = 0 ;
    SwigValueWrapper<AGTriangle2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->applied((AGMatrix3 const &)*arg2);
    
    {
        AGTriangle2 * resultptr;
        resultptr = new AGTriangle2((AGTriangle2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGTriangle2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_touchPoint(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    AGPoint3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->touchPoint((AGTriangle2 const &)*arg2);
    
    {
        AGPoint3 * resultptr;
        resultptr = new AGPoint3((AGPoint3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGPoint3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_touchVector(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->touchVector((AGTriangle2 const &)*arg2);
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_collisionPoints(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGLine2 *arg2 = 0 ;
    std::vector<AGVector3 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->collisionPoints((AGLine2 const &)*arg2);
    
    {
        std::vector<AGVector3 > * resultptr;
        resultptr = new std::vector<AGVector3 >((std::vector<AGVector3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_contains(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGPoint3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGTriangle2 const *)arg1)->contains((AGPoint3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getBBox(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    SwigValueWrapper<AGRect2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    result = ((AGTriangle2 const *)arg1)->getBBox();
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_nearestLine(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGLine2 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle2 const *)arg1)->nearestLine((AGVector3 const &)*arg2);
    
    {
        AGLine2 * resultptr;
        resultptr = new AGLine2((AGLine2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGLine2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_getLines(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    std::vector<AGLine2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    result = ((AGTriangle2 const *)arg1)->getLines();
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            AGLine2* x = new AGLine2(((std::vector<AGLine2 > &)result)[i]);
            rb_ary_store(vresult,i,
            SWIG_NewPointerObj((void *) x, 
            SWIGTYPE_p_AGLine2, 1));
        }
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle2_to_s(int argc, VALUE *argv, VALUE self) {
    AGTriangle2 *arg1 = (AGTriangle2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle2, 1);
    result = ((AGTriangle2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGTriangle2(AGTriangle2 *arg1) {
    delete arg1;
}
swig_class cAGCircle2;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCircle2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCircle2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCircle2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCircle2(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    float arg2 ;
    AGCircle2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGCircle2 *)new AGCircle2((AGVector3 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGCircle2_inCircle__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->inCircle((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGCircle2_outCircle__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGTriangle2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTriangle2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->outCircle((AGTriangle2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGCircle2_inCircle__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->inCircle((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGCircle2_inCircle(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTriangle2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_inCircle__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_inCircle__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGCircle2_inCircle'");
    return Qnil;
}


static VALUE
_wrap_AGCircle2_outCircle__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGCircle2 const *)arg1)->outCircle((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGCircle2_outCircle(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTriangle2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_outCircle__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGCircle2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGCircle2_outCircle__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGCircle2_outCircle'");
    return Qnil;
}


static VALUE
_wrap_AGCircle2_getPos(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    result = ((AGCircle2 const *)arg1)->getPos();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGCircle2_getRadius(int argc, VALUE *argv, VALUE self) {
    AGCircle2 *arg1 = (AGCircle2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCircle2, 1);
    result = (float)((AGCircle2 const *)arg1)->getRadius();
    
    vresult = rb_float_new(result);
    return vresult;
}


static void
free_AGCircle2(AGCircle2 *arg1) {
    delete arg1;
}
swig_class cAGTriangle3;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTriangle3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTriangle3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTriangle3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTriangle3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGVector3 *arg3 = 0 ;
    AGTriangle3 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg3, SWIGTYPE_p_AGVector3, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGTriangle3 *)new AGTriangle3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2,(AGVector3 const &)*arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGTriangle3_collide(int argc, VALUE *argv, VALUE self) {
    AGTriangle3 *arg1 = (AGTriangle3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGTriangle3 const *)arg1)->collide((AGLine3 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTriangle3_toString(int argc, VALUE *argv, VALUE self) {
    AGTriangle3 *arg1 = (AGTriangle3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTriangle3, 1);
    result = ((AGTriangle3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGTriangle3(AGTriangle3 *arg1) {
    delete arg1;
}
swig_class cAGRect2;

static VALUE
_wrap_new_AGRect2__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGRect2 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect2 *)new AGRect2((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect2_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect2__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    AGRect2 *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    arg4 = (float) NUM2DBL(argv[3]);
    result = (AGRect2 *)new AGRect2(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGRect2(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGRect2__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FLOAT) || (TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGRect2__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGRect2'");
    return Qnil;
}


static VALUE
_wrap_AGRect2_collide(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->collide((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2___add__(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    SwigValueWrapper<AGRect2 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGRect2 const *)arg1)->operator +((AGVector3 const &)*arg2);
    
    {
        AGRect2 * resultptr;
        resultptr = new AGRect2((AGRect2 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect2, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_contains__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->contains((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect2_contains__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGRect2 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect2, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect2 const *)arg1)->contains((AGRect2 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGRect2_contains(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect2_contains__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGRect2_contains__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGRect2_contains'");
    return Qnil;
}


static VALUE
_wrap_AGRect2_split(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    SwigValueWrapper<std::list<AGRect2 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->split();
    
    {
        std::list<AGRect2 > * resultptr;
        resultptr = new std::list<AGRect2 >((std::list<AGRect2 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__listTAGRect2_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV0(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->getV0();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV1(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->getV1();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV01(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->getV01();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_getV10(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->getV10();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGRect2_setX(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_setY(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRect2_x(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = (float)((AGRect2 const *)arg1)->x();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_y(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = (float)((AGRect2 const *)arg1)->y();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_w(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = (float)((AGRect2 const *)arg1)->w();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_h(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = (float)((AGRect2 const *)arg1)->h();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGRect2_to_s(int argc, VALUE *argv, VALUE self) {
    AGRect2 *arg1 = (AGRect2 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect2, 1);
    result = ((AGRect2 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGRect2(AGRect2 *arg1) {
    delete arg1;
}
swig_class cAGVector4;

static VALUE
_wrap_AGVector4_v_set(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float *arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_float, 1);
    {
        size_t ii;
        float *b = (float *) arg1->v;
        for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
    }
    return Qnil;
}


static VALUE
_wrap_AGVector4_v_get(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float *)(float *) ((arg1)->v);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE
_wrap_new_AGVector4__SWIG_0(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    AGVector4 *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    arg4 = (float) NUM2DBL(argv[3]);
    result = (AGVector4 *)new AGVector4(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    float arg2 ;
    float arg3 ;
    AGVector4 *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    arg2 = (float) NUM2DBL(argv[1]);
    arg3 = (float) NUM2DBL(argv[2]);
    result = (AGVector4 *)new AGVector4(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = 0 ;
    AGVector4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector4, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGVector4 *)new AGVector4((AGVector4 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    float arg2 ;
    AGVector4 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg2 = (float) NUM2DBL(argv[1]);
    result = (AGVector4 *)new AGVector4((AGVector3 const &)*arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector4_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVector4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector4__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGVector4 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGVector4 *)new AGVector4();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector4(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector4__SWIG_4(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector4__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector4__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVector4__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FLOAT) || (TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FLOAT) || (TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGVector4__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector4'");
    return Qnil;
}


static VALUE
_wrap_AGVector4_setX(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setX(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setY(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setY(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setZ(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setZ(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_setW(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->setW(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_x(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->getX();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_y(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->getY();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_z(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->getZ();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_w(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->getW();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4___sub__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator -((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___add__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator +((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_add(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector4 &_result_ref = (arg1)->operator +=((AGVector4 const &)*arg2);
        result = (AGVector4 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4_sub(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGVector4 &_result_ref = (arg1)->operator -=((AGVector4 const &)*arg2);
        result = (AGVector4 *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (float)((AGVector4 const *)arg1)->operator *((AGVector4 const &)*arg2);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector4 const *)arg1)->operator *(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE _wrap_AGVector4___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector4___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FLOAT) || (TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGVector4___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGVector4___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGVector4___div__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGVector4 const *)arg1)->operator /(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___neg__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->operator -();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4___eq__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGVector4 const *)arg1)->operator ==((AGVector4 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4_length(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->length();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_length2(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->length2();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_length3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (float)((AGVector4 const *)arg1)->length3();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGVector4_normalized(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->normalized();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_normalize(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    (arg1)->normalize();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_normalized3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->normalized3();
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_normalize3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    (arg1)->normalize3();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4_nonZero(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = (bool)((AGVector4 const *)arg1)->nonZero();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4___mod__(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->operator %((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_cross(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGVector4 const *)arg1)->cross((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_dim3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->dim3();
    
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4_to_s(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = (AGVector4 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVector4, 1);
    result = ((AGVector4 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGVector4(AGVector4 *arg1) {
    delete arg1;
}
swig_class cAGMatrix4;

static VALUE
_wrap_new_AGMatrix4__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGMatrix4 *)new AGMatrix4();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGMatrix4__SWIG_1(int argc, VALUE *argv, VALUE self) {
    float *arg1 ;
    AGMatrix4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_float, 1);
    result = (AGMatrix4 *)new AGMatrix4(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGMatrix4__SWIG_2(int argc, VALUE *argv, VALUE self) {
    float arg1 ;
    AGVector3 *arg2 = 0 ;
    AGMatrix4 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = (float) NUM2DBL(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix4 *)new AGMatrix4(arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMatrix4_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMatrix4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMatrix4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMatrix4__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGVector4 *arg1 = 0 ;
    AGMatrix4 *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector4, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGMatrix4 *)new AGMatrix4((AGVector4 const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGMatrix4(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGMatrix4__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_float, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix4__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGMatrix4__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FLOAT) || (TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGMatrix4__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGMatrix4'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_set(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->set(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix4 const *)arg1)->get(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix4_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->get(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix4_get(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4_get__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4_get__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4_get'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 *arg2 = 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix4 const *)arg1)->operator *((AGMatrix4 const &)*arg2);
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_get3x3(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    AGMatrix3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = ((AGMatrix4 const *)arg1)->get3x3(arg2,arg3);
    
    {
        AGMatrix3 * resultptr;
        resultptr = new AGMatrix3((AGMatrix3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGVector4 *arg2 = 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGMatrix4 const *)arg1)->operator *((AGVector4 const &)*arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE _wrap_AGMatrix4___mul__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix4___mul____SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGMatrix4___mul____SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4___mul__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4___call____SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (float)((AGMatrix4 const *)arg1)->operator ()(arg2,arg3);
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGMatrix4___call____SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    size_t arg3 ;
    float *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    {
        float &_result_ref = (arg1)->operator ()(arg2,arg3);
        result = (float *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float,0);
    return vresult;
}


static VALUE _wrap_AGMatrix4___call__(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4___call____SWIG_0(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGMatrix4___call____SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGMatrix4___call__'");
    return Qnil;
}


static VALUE
_wrap_AGMatrix4_inverted(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    result = ((AGMatrix4 const *)arg1)->inverted();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_transposed(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    AGMatrix4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    result = ((AGMatrix4 const *)arg1)->transposed();
    
    {
        AGMatrix4 * resultptr;
        resultptr = new AGMatrix4((AGMatrix4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGMatrix4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_to_s(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    result = ((AGMatrix4 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGMatrix4_getRow(int argc, VALUE *argv, VALUE self) {
    AGMatrix4 *arg1 = (AGMatrix4 *) 0 ;
    size_t arg2 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMatrix4, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = ((AGMatrix4 const *)arg1)->getRow(arg2);
    
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static void
free_AGMatrix4(AGMatrix4 *arg1) {
    delete arg1;
}
swig_class cAGRect3;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRect3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRect3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRect3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRect3(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGRect3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGRect3 *)new AGRect3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGRect3_collides(int argc, VALUE *argv, VALUE self) {
    AGRect3 *arg1 = (AGRect3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGRect3 const *)arg1)->collides((AGLine3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGRect3_toString(int argc, VALUE *argv, VALUE self) {
    AGRect3 *arg1 = (AGRect3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRect3, 1);
    result = ((AGRect3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGRect3(AGRect3 *arg1) {
    delete arg1;
}
swig_class cAGBox3;

static VALUE
_wrap_AGBox3_base_set(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1);
    if (arg1) (arg1)->base = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_base_get(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = (AGVector3 *)& ((arg1)->base);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGBox3_dir_set(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = (AGVector3 *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1);
    if (arg1) (arg1)->dir = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_dir_get(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = (AGVector3 *)& ((arg1)->dir);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_new_AGBox3__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGBox3 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGBox3 *)new AGBox3();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBox3_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBox3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBox3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBox3__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGVector3 *arg1 = 0 ;
    AGVector3 *arg2 = 0 ;
    AGBox3 *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVector3, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGBox3 *)new AGBox3((AGVector3 const &)*arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGBox3(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGBox3__SWIG_0(nargs, args, self);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGBox3__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGBox3'");
    return Qnil;
}


static VALUE
_wrap_AGBox3_include(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->include((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGBox3_includes(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGBox3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBox3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)(arg1)->includes((AGBox3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGVector3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGLine3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGLine3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGLine3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGBox3 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBox3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGBox3 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGBox3_getSides(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGRect3 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = ((AGBox3 const *)arg1)->getSides();
    
    {
        std::vector<AGRect3 > * resultptr;
        resultptr = new std::vector<AGRect3 >((std::vector<AGRect3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGRect3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_toString(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = ((AGBox3 const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_split(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    SwigValueWrapper<std::vector<AGBox3 > > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = ((AGBox3 const *)arg1)->split();
    
    {
        std::vector<AGBox3 > * resultptr;
        resultptr = new std::vector<AGBox3 >((std::vector<AGBox3 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGBox3_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3_collides__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGMatrix4 *arg2 = 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGMatrix4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)((AGBox3 const *)arg1)->collides((AGMatrix4 const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE _wrap_AGBox3_collides(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGLine3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_2(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGBox3, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGMatrix4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGBox3_collides__SWIG_3(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGBox3_collides'");
    return Qnil;
}


static VALUE
_wrap_AGBox3_getVertices(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    std::vector<AGVector4 > result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    result = ((AGBox3 const *)arg1)->getVertices();
    
    {
        std::vector<AGVector4 > * resultptr;
        resultptr = new std::vector<AGVector4 >((std::vector<AGVector4 > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGBox3___add__(int argc, VALUE *argv, VALUE self) {
    AGBox3 *arg1 = (AGBox3 *) 0 ;
    AGVector3 *arg2 = 0 ;
    AGBox3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBox3, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGBox3 const *)arg1)->operator +((AGVector3 const &)*arg2);
    
    {
        AGBox3 * resultptr;
        resultptr = new AGBox3((AGBox3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGBox3, 1);
    }
    return vresult;
}


static void
free_AGBox3(AGBox3 *arg1) {
    delete arg1;
}
swig_class cAGColor;

static VALUE
_wrap_new_AGColor__SWIG_0(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    AGColor *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    arg4 = NUM2INT(argv[3]);
    result = (AGColor *)new AGColor(arg1,arg2,arg3,arg4);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_1(int argc, VALUE *argv, VALUE self) {
    int arg1 ;
    int arg2 ;
    int arg3 ;
    AGColor *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = NUM2INT(argv[0]);
    arg2 = NUM2INT(argv[1]);
    arg3 = NUM2INT(argv[2]);
    result = (AGColor *)new AGColor(arg1,arg2,arg3);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = 0 ;
    AGColor *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColor, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGColor *)new AGColor((AGColor const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_3(int argc, VALUE *argv, VALUE self) {
    Uint32 arg1 ;
    AGSurface *arg2 = 0 ;
    AGColor *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        Uint32 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint32, 1);
        if (ptr) arg1 = *ptr;
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGColor *)new AGColor(arg1,(AGSurface const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGColor__SWIG_4(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGColor *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGColor *)new AGColor((std::string const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGColor_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGColor_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGColor);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGColor__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGColor *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGColor *)new AGColor();
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGColor(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGColor__SWIG_5(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGColor__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGColor__SWIG_4(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Uint32, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGColor__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGColor__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = ((TYPE(argv[3]) == T_FIXNUM) || (TYPE(argv[3]) == T_BIGNUM)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGColor__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGColor'");
    return Qnil;
}


static VALUE
_wrap_AGColor___mul__(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    float arg2 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    result = ((AGColor const *)arg1)->operator *(arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor___add__(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    AGColor *arg2 = 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = ((AGColor const *)arg1)->operator +((AGColor const &)*arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_mapRGB(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    SDL_PixelFormat *arg2 = (SDL_PixelFormat *) 0 ;
    Uint32 result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_SDL_PixelFormat, 1);
    result = ((AGColor const *)arg1)->mapRGB(arg2);
    
    {
        Uint32 * resultptr;
        resultptr = new Uint32((Uint32 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint32, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_toString(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    result = ((AGColor const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGColor_grey(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    result = ((AGColor const *)arg1)->grey();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_brightness(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    result = ((AGColor const *)arg1)->brightness();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColor_light(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->light(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColor_a_set(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg2 = *ptr;
    }
    if (arg1) (arg1)->a = arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGColor_a_get(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = (AGColor *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColor, 1);
    result =  ((arg1)->a);
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static void
free_AGColor(AGColor *arg1) {
    delete arg1;
}
static VALUE
_wrap_toInt(int argc, VALUE *argv, VALUE self) {
    Uint8 arg1 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg1 = *ptr;
    }
    result = (int)toInt(arg1);
    
    vresult = INT2NUM(result);
    return vresult;
}


swig_class cAGFont;

static VALUE
_wrap_new_AGFont__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGFont *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGFont *)new AGFont();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGFont__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    int arg2 ;
    AGFont *result;
    std::string temp1 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg2 = NUM2INT(argv[1]);
    result = (AGFont *)new AGFont((std::string const &)*arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFont_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFont_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFont);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFont__SWIG_2(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    AGFont *result;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGFont *)new AGFont((std::string const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGFont(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGFont__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGFont__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGFont__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGFont'");
    return Qnil;
}


static VALUE
_wrap_AGFont_setColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getColor(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = ((AGFont const *)arg1)->getColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setAlpha(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setAlpha(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getAlpha(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = ((AGFont const *)arg1)->getAlpha();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setSize(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        Uint8 * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Uint8, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSize(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getSize(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    Uint8 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = ((AGFont const *)arg1)->getSize();
    
    {
        Uint8 * resultptr;
        resultptr = new Uint8((Uint8 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Uint8, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGFont_setStyle(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGFont::Style *arg2 = 0 ;
    AGFont::Style temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    temp2 = (AGFont::Style) NUM2INT(argv[0]);
    arg2 = &temp2;
    (arg1)->setStyle((enum AGFont::Style const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getStyle(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    AGFont::Style result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = (AGFont::Style)((AGFont const *)arg1)->getStyle();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_setName(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGFont_getName(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    result = ((AGFont const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGFont_getWidth(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)((AGFont const *)arg1)->getWidth((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFont_getHeight(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = (AGFont *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGFont, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)((AGFont const *)arg1)->getHeight((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static void
free_AGFont(AGFont *arg1) {
    delete arg1;
}
swig_class cAGFontEngine;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGFontEngine_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGFontEngine_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGFontEngine);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGFontEngine(int argc, VALUE *argv, VALUE self) {
    AGFontEngine *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGFontEngine *)new AGFontEngine();
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGFontEngine(AGFontEngine *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGFontEngine_renderText(int argc, VALUE *argv, VALUE self) {
    AGScreen *arg1 = (AGScreen *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    int arg4 ;
    std::string *arg5 = 0 ;
    AGFont *arg6 = 0 ;
    bool result;
    std::string temp5 ;
    VALUE vresult = Qnil;
    
    if ((argc < 6) || (argc > 6))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreen, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[2]);
    arg4 = NUM2INT(argv[3]);
    {
        if (TYPE(argv[4]) == T_STRING) {
            //            temp5 = std::string(StringValuePtr(argv[4]));
            temp5 = std::string(RSTRING(argv[4])->ptr,RSTRING(argv[4])->len);
            arg5 = &temp5;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[5], (void **) &arg6, SWIGTYPE_p_AGFont, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (bool)AGFontEngine::renderText(arg1,(AGRect const &)*arg2,arg3,arg4,(std::string const &)*arg5,(AGFont const &)*arg6);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGFontEngine_getWidth(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGFont, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)AGFontEngine::getWidth((AGFont const &)*arg1,(std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGFontEngine_getHeight(int argc, VALUE *argv, VALUE self) {
    AGFont *arg1 = 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGFont, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)AGFontEngine::getHeight((AGFont const &)*arg1,(std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


swig_class cAGButton;

static VALUE
_wrap_new_AGButton__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    int arg5 ;
    AGButton *result;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg5 = NUM2INT(argv[3]);
    {
        char *classname = "Libantargisgui::AGButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGButton *)new SwigDirector_AGButton(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4,arg5);
            
        } else {
            result = (AGButton *)new AGButton(arg2,(AGRect const &)*arg3,(std::string const &)*arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGButton_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGButton_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGButton);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGButton__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGButton *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGButton *)new SwigDirector_AGButton(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGButton *)new AGButton(arg2,(AGRect const &)*arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGButton(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGButton__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = ((TYPE(argv[4]) == T_FIXNUM) || (TYPE(argv[4]) == T_BIGNUM)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGButton__SWIG_0(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGButton'");
    return Qnil;
}


static VALUE
_wrap_AGButton_setSurface__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGSurface arg2 ;
    bool arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg2 = *ptr;
    }
    arg3 = RTEST(argv[1]);
    (arg1)->setSurface(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setSurface__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGSurface arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSurface(arg2);
    
    return Qnil;
}


static VALUE _wrap_AGButton_setSurface(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGButton_setSurface__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGButton_setSurface__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGButton_setSurface'");
    return Qnil;
}


static VALUE
_wrap_AGButton_draw(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_eventMouseEnter(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseEnter();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseLeave(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseLeave();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_eventMouseButtonUp(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_setWidth(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setHeight(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_getCaption(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGButton const *)arg1)->getCaption();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGButton_setEnabled(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setEnabled(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setTheme(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setTheme((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setCaption(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setCaption((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setState(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    AGButton::State *arg2 = 0 ;
    AGButton::State temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    temp2 = (AGButton::State) NUM2INT(argv[0]);
    arg2 = &temp2;
    (arg1)->setState((enum AGButton::State const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_setChecked(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    arg2 = RTEST(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setChecked(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGButton_isChecked(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    result = (bool)((AGButton const *)arg1)->isChecked();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGButton_canFocus(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGButton const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGButton(AGButton *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGButton(int argc, VALUE *argv, VALUE self) {
    AGButton *arg1 = (AGButton *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGButton, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGButton(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGButton *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGButton &_result_ref = toAGButton(*arg1);
        result = (AGButton *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
    return vresult;
}


swig_class cAGApplication;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGApplication_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGApplication_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGApplication);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGApplication(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGApplication *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargisgui::AGApplication";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGApplication *)new SwigDirector_AGApplication(arg1);
            
        } else {
            result = (AGApplication *)new AGApplication();
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
        //	printf("register:AGApplication\n");
    }
    return self;
}


static VALUE
_wrap_AGApplication_run(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    result = (bool)(arg1)->run();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventIdle(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventIdle();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventFrame(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrame(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventFrameEnd(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    float arg2 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventFrameEnd(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventQuit(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventQuit((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGApplication_eventChangedRes(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventChangedRes();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_setMainWidget(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    (arg1)->setMainWidget(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_draw(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_tryQuit(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    (arg1)->tryQuit();
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_getTicks(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    long result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    result = (long)((AGApplication const *)arg1)->getTicks();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGApplication_delay(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->delay(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGApplication_markfunc(int argc, VALUE *argv, VALUE self) {
    void *arg1 = (void *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, 0, 1);
    AGApplication_markfunc(arg1);
    
    return Qnil;
}


static void
free_AGApplication(AGApplication *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGApplication(int argc, VALUE *argv, VALUE self) {
    AGApplication *arg1 = (AGApplication *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGApplication, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_disableKeyrepeat(int argc, VALUE *argv, VALUE self) {
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    disableKeyrepeat();
    
    return Qnil;
}


swig_class cAGText;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGText_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGText_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGText);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGText(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGFont *arg5 = 0 ;
    AGText *result;
    std::string temp4 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGFont, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGText";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGText *)new SwigDirector_AGText(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5);
            
        } else {
            result = (AGText *)new AGText(arg2,(AGRect const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGText_setDeriveRect(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 1);
    (arg1)->setDeriveRect();
    
    return Qnil;
}


static VALUE
_wrap_AGText_draw(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGText_setText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGText_getText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGText, 1);
    result = ((AGText const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGText(AGText *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGText(int argc, VALUE *argv, VALUE self) {
    AGText *arg1 = (AGText *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGText, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGText(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGText *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGText &_result_ref = toAGText(*arg1);
        result = (AGText *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
    return vresult;
}


swig_class cAGVTiler;

static VALUE
_wrap_new_AGVTiler__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    bool arg4 ;
    AGVTiler *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = RTEST(argv[2]);
    char *classname = "Libantargisgui::AGVTiler";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGVTiler *)new SwigDirector_AGVTiler(arg1,arg2,(AGRect const &)*arg3,arg4);
        
    } else {
        result = (AGVTiler *)new AGVTiler(arg2,(AGRect const &)*arg3,arg4);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVTiler_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVTiler_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGVTiler);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVTiler__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGVTiler *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargisgui::AGVTiler";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGVTiler *)new SwigDirector_AGVTiler(arg1,arg2,(AGRect const &)*arg3);
        
    } else {
        result = (AGVTiler *)new AGVTiler(arg2,(AGRect const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVTiler(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGVTiler__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (argv[3] == Qtrue || argv[3] == Qfalse) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGVTiler__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVTiler'");
    return Qnil;
}


static VALUE
_wrap_AGVTiler_addChild(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVTiler_rePosition(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->rePosition();
    
    return Qnil;
}


static VALUE
_wrap_AGVTiler_adaptHeightFromChildren(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    (arg1)->adaptHeightFromChildren();
    
    return Qnil;
}


static VALUE
_wrap_AGVTiler_adaptWidthFromChildren(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    (arg1)->adaptWidthFromChildren();
    
    return Qnil;
}


static void
free_AGVTiler(AGVTiler *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGVTiler(int argc, VALUE *argv, VALUE self) {
    AGVTiler *arg1 = (AGVTiler *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGVTiler, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGHTiler;

static VALUE
_wrap_new_AGHTiler__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    bool arg4 ;
    AGHTiler *result;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = RTEST(argv[2]);
    char *classname = "Libantargisgui::AGHTiler";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGHTiler *)new SwigDirector_AGHTiler(arg1,arg2,(AGRect const &)*arg3,arg4);
        
    } else {
        result = (AGHTiler *)new AGHTiler(arg2,(AGRect const &)*arg3,arg4);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGHTiler_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGHTiler_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGHTiler);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGHTiler__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGHTiler *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargisgui::AGHTiler";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGHTiler *)new SwigDirector_AGHTiler(arg1,arg2,(AGRect const &)*arg3);
        
    } else {
        result = (AGHTiler *)new AGHTiler(arg2,(AGRect const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGHTiler(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGHTiler__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (argv[3] == Qtrue || argv[3] == Qfalse) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGHTiler__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGHTiler'");
    return Qnil;
}


static VALUE
_wrap_AGHTiler_rePosition(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->rePosition();
    
    return Qnil;
}


static VALUE
_wrap_AGHTiler_adaptHeightFromChildren(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    (arg1)->adaptHeightFromChildren();
    
    return Qnil;
}


static VALUE
_wrap_AGHTiler_adaptWidthFromChildren(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    (arg1)->adaptWidthFromChildren();
    
    return Qnil;
}


static VALUE
_wrap_AGHTiler_adaptWidthFromParent(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    (arg1)->adaptWidthFromParent();
    
    return Qnil;
}


static void
free_AGHTiler(AGHTiler *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGHTiler(int argc, VALUE *argv, VALUE self) {
    AGHTiler *arg1 = (AGHTiler *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGHTiler, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGTheme;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTheme_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTheme_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTheme);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTheme(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGTheme *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGTheme";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGTheme *)new SwigDirector_AGTheme(arg1);
        
    } else {
        result = (AGTheme *)new AGTheme();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGTheme(AGTheme *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGTheme_getFont(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGFont result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getFont((std::string const &)*arg2);
    
    {
        AGFont * resultptr;
        resultptr = new AGFont((AGFont &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGFont, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_getColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGColor result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getColor((std::string const &)*arg2);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setFont(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGFont arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGFont * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGFont, 1);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setFont((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_setColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGColor arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGColor * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGColor, 1);
        if (ptr) arg3 = *ptr;
    }
    (arg1)->setColor((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getInt(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    int result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (int)(arg1)->getInt((std::string const &)*arg2);
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGTheme_setInt(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    arg3 = NUM2INT(argv[1]);
    (arg1)->setInt((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_getSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->getSurface((std::string const &)*arg2);
    
    {
        AGSurface * resultptr;
        resultptr = new AGSurface((AGSurface &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGSurface, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTheme_setSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    AGSurface *arg3 = 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGSurface, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setSurface((std::string const &)*arg2,(AGSurface const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGTheme_hasSurface(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)((AGTheme const *)arg1)->hasSurface((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGTheme_hasColor(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)((AGTheme const *)arg1)->hasColor((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_disown_AGTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = (AGTheme *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTheme, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_getTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGTheme *)getTheme();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTheme,0);
    return vresult;
}


static VALUE
_wrap_setTheme(int argc, VALUE *argv, VALUE self) {
    AGTheme *arg1 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTheme, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    setTheme((AGTheme const &)*arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadTheme(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    loadTheme((std::string const &)*arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadThemeFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    bool result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)loadThemeFile((std::string const &)*arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_addPoint(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = addPoint((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


swig_class cAGMenuEvent;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMenuEvent_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMenuEvent_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMenuEvent);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMenuEvent(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGListener *arg2 = (AGListener *) 0 ;
    std::string *arg3 = 0 ;
    AGMenuEvent *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGListener, 1);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargisgui::AGMenuEvent";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGMenuEvent *)new SwigDirector_AGMenuEvent(arg1,arg2,(std::string const &)*arg3);
        
    } else {
        result = (AGMenuEvent *)new AGMenuEvent(arg2,(std::string const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGMenuEvent_getName(int argc, VALUE *argv, VALUE self) {
    AGMenuEvent *arg1 = (AGMenuEvent *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenuEvent, 1);
    result = ((AGMenuEvent const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGMenuEvent(AGMenuEvent *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGMenuEvent(int argc, VALUE *argv, VALUE self) {
    AGMenuEvent *arg1 = (AGMenuEvent *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMenuEvent, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGMenu;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGMenu_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGMenu_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGMenu);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGMenu(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGPoint arg3 ;
    std::string *arg4 = 0 ;
    AGMenu *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        AGPoint * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGPoint, 1);
        if (ptr) arg3 = *ptr;
    }
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargisgui::AGMenu";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGMenu *)new SwigDirector_AGMenu(arg1,arg2,arg3,(std::string const &)*arg4);
        
    } else {
        result = (AGMenu *)new AGMenu(arg2,arg3,(std::string const &)*arg4);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGMenu_show(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGPoint arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        AGPoint * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGPoint, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->show(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_addItem(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->addItem((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_addMenu(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    AGMenu *result;
    std::string temp2 ;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGMenu &_result_ref = (arg1)->addMenu((std::string const &)*arg2);
        result = (AGMenu *) &_result_ref;
    }
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
    }
    return vresult;
}


static VALUE
_wrap_AGMenu_draw(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGRect *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw((AGRect const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_eventItemSelected(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->eventItemSelected((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_eventItemClicked(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->eventItemClicked((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_sigSelected_set(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigSelected = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGMenu_sigSelected_get(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    result = (AGSignal *)& ((arg1)->sigSelected);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static void
free_AGMenu(AGMenu *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGMenu(int argc, VALUE *argv, VALUE self) {
    AGMenu *arg1 = (AGMenu *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGMenu, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGScreenWidget;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGScreenWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGScreenWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGScreenWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGScreenWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGScreenWidget *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    {
        char *classname = "Libantargisgui::AGScreenWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGScreenWidget *)new SwigDirector_AGScreenWidget(arg1);
            
        } else {
            result = (AGScreenWidget *)new AGScreenWidget();
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGScreenWidget(AGScreenWidget *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGScreenWidget_draw(int argc, VALUE *argv, VALUE self) {
    AGScreenWidget *arg1 = (AGScreenWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGScreenWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGScreenWidget(int argc, VALUE *argv, VALUE self) {
    AGScreenWidget *arg1 = (AGScreenWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGScreenWidget, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGEditLine;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEditLine_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEditLine_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEditLine);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEditLine(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    AGFont arg3 ;
    bool arg4 ;
    AGEditLine *result;
    std::string temp2 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        AGFont * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGFont, 1);
        if (ptr) arg3 = *ptr;
    }
    arg4 = RTEST(argv[2]);
    char *classname = "Libantargisgui::AGEditLine";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGEditLine *)new SwigDirector_AGEditLine(arg1,(std::string const &)*arg2,arg3,arg4);
        
    } else {
        result = (AGEditLine *)new AGEditLine((std::string const &)*arg2,arg3,arg4);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGEditLine(AGEditLine *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGEditLine_setAlign(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = (AGAlign) NUM2INT(argv[0]);
    (arg1)->setAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_setVAlign(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGVAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = (AGVAlign) NUM2INT(argv[0]);
    (arg1)->setVAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_draw(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGPainter *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2,(AGPoint const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_drawCursor(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGPainter *arg2 = 0 ;
    int arg3 ;
    AGPoint *arg4 = 0 ;
    AGRect *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGPoint, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGRect, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawCursor(*arg2,arg3,(AGPoint const &)*arg4,(AGRect const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_height(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = (int)((AGEditLine const *)arg1)->height();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_width(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = (int)((AGEditLine const *)arg1)->width();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_insert(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    char arg2 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2CHR(argv[0]);
    arg3 = NUM2INT(argv[1]);
    (arg1)->insert(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_doDelete(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->doDelete(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_split(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    SwigValueWrapper<AGEditLine > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2INT(argv[0]);
    result = (arg1)->split(arg2);
    
    {
        AGEditLine * resultptr;
        resultptr = new AGEditLine((AGEditLine &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGEditLine, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_length(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = (int)((AGEditLine const *)arg1)->length();
    
    vresult = INT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGEditLine_append(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->append(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_prepend(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->prepend(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_getText(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = ((AGEditLine const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_getFont(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGFont result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = ((AGEditLine const *)arg1)->getFont();
    
    {
        AGFont * resultptr;
        resultptr = new AGFont((AGFont &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGFont, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_setText(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_hardEnd(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    result = (bool)((AGEditLine const *)arg1)->hardEnd();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEditLine_setHardEnd(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setHardEnd(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEditLine_checkUnwrap(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    std::string arg3 ;
    std::pair<std::string,bool > result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2INT(argv[0]);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg3 = std::string(StringValuePtr(argv[1]));
            arg3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (arg1)->checkUnwrap(arg2,arg3);
    
    {
        std::pair<std::string,bool > * resultptr;
        resultptr = new std::pair<std::string,bool >((std::pair<std::string,bool > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTstd__string_bool_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_checkWrap(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    int arg2 ;
    std::pair<std::string,bool > result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    arg2 = NUM2INT(argv[0]);
    result = (arg1)->checkWrap(arg2);
    
    {
        std::pair<std::string,bool > * resultptr;
        resultptr = new std::pair<std::string,bool >((std::pair<std::string,bool > &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__pairTstd__string_bool_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGEditLine_setFont(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGEditLine(int argc, VALUE *argv, VALUE self) {
    AGEditLine *arg1 = (AGEditLine *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEditLine, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGEdit;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGEdit_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGEdit_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGEdit);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGEdit(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGEdit *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGEdit";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGEdit *)new SwigDirector_AGEdit(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGEdit *)new AGEdit(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGEdit_draw(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_drawBackground(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawBackground(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_eventKeyUp(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyUp((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_setMulti(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setMulti(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_insert(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    char arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = NUM2CHR(argv[0]);
    (arg1)->insert(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_doDelete(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    int arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = NUM2INT(argv[0]);
    (arg1)->doDelete(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setText(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setText((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setFont(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGFont *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGFont, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setFont((AGFont const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_clear(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setMutable(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setMutable(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setAlign(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = (AGAlign) NUM2INT(argv[0]);
    (arg1)->setAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setVAlign(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGVAlign arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = (AGVAlign) NUM2INT(argv[0]);
    (arg1)->setVAlign(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setBackground__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    arg2 = RTEST(argv[0]);
    (arg1)->setBackground(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_setBackground__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    AGBackground *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGBackground, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setBackground((AGBackground const &)*arg2);
    
    return Qnil;
}


static VALUE _wrap_AGEdit_setBackground(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGEdit, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGBackground, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGEdit_setBackground__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGEdit, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGEdit_setBackground__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGEdit_setBackground'");
    return Qnil;
}


static VALUE
_wrap_AGEdit_setTheme(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setTheme((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGEdit_canFocus(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)((AGEdit const *)arg1)->canFocus();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGEdit_getText(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    result = ((AGEdit const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static void
free_AGEdit(AGEdit *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGEdit(int argc, VALUE *argv, VALUE self) {
    AGEdit *arg1 = (AGEdit *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGEdit, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGEdit(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGEdit *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGEdit &_result_ref = toAGEdit(*arg1);
        result = (AGEdit *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
    return vresult;
}


swig_class cAGCheckBox;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCheckBox_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCheckBox_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCheckBox);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCheckBox(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect arg3 ;
    AGCheckBox *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        AGRect * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect, 1);
        if (ptr) arg3 = *ptr;
    }
    {
        char *classname = "Libantargisgui::AGCheckBox";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGCheckBox *)new SwigDirector_AGCheckBox(arg1,arg2,arg3);
            
        } else {
            result = (AGCheckBox *)new AGCheckBox(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGCheckBox_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGCheckBox *arg1 = (AGCheckBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCheckBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGCheckBox(AGCheckBox *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGCheckBox(int argc, VALUE *argv, VALUE self) {
    AGCheckBox *arg1 = (AGCheckBox *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCheckBox, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGRadioGroup;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRadioGroup_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRadioGroup_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRadioGroup);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRadioGroup(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGRadioGroup *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargisgui::AGRadioGroup";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGRadioGroup *)new SwigDirector_AGRadioGroup(arg1,arg2,(AGRect const &)*arg3);
        
    } else {
        result = (AGRadioGroup *)new AGRadioGroup(arg2,(AGRect const &)*arg3);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGRadioGroup(AGRadioGroup *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGRadioGroup_eventChange(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->eventChange((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_add(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGRadio *arg2 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadio, 1);
    (arg1)->add(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_erase(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGRadio *arg2 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadio, 1);
    (arg1)->erase(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_sigChanged_set(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigChanged = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGRadioGroup_sigChanged_get(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    result = (AGSignal *)& ((arg1)->sigChanged);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_disown_AGRadioGroup(int argc, VALUE *argv, VALUE self) {
    AGRadioGroup *arg1 = (AGRadioGroup *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRadioGroup, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGRadio;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGRadio_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGRadio_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRadio);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGRadio(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect arg3 ;
    AGRadio *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        AGRect * ptr;
        SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_AGRect, 1);
        if (ptr) arg3 = *ptr;
    }
    {
        char *classname = "Libantargisgui::AGRadio";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGRadio *)new SwigDirector_AGRadio(arg1,arg2,arg3);
            
        } else {
            result = (AGRadio *)new AGRadio(arg2,arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGRadio(AGRadio *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGRadio_setGroup(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    AGRadioGroup *arg2 = (AGRadioGroup *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRadioGroup, 1);
    (arg1)->setGroup(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGRadio_deselect(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 1);
    (arg1)->deselect();
    
    return Qnil;
}


static VALUE
_wrap_AGRadio_setChecked(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    bool arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGRadio, 1);
    arg2 = RTEST(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setChecked(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGRadio(int argc, VALUE *argv, VALUE self) {
    AGRadio *arg1 = (AGRadio *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGRadio, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGTable_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGTable(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGTable *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGTable";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGTable *)new SwigDirector_AGTable(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGTable *)new AGTable(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static void
free_AGTable(AGTable *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGTable_addFixedColumn(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addFixedColumn(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addFixedRow(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addFixedRow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addColumn(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addColumn(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addRow(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    float arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    (arg1)->addRow(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_addChild(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    int arg3 ;
    AGWidget *arg4 = (AGWidget *) 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGWidget, 1);
    (arg1)->addChild(arg2,arg3,arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    int arg3 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    result = ((AGTable const *)arg1)->getClientRect(arg2,arg3);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGTable_arrange(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    (arg1)->arrange();
    
    return Qnil;
}


static VALUE
_wrap_AGTable_setWidth(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setWidth(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGTable_setHeight(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    int arg2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    arg2 = NUM2INT(argv[0]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->setHeight(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGTable(int argc, VALUE *argv, VALUE self) {
    AGTable *arg1 = (AGTable *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGTable, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGWindow;

static VALUE
_wrap_new_AGWindow__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGWindow *result;
    std::string temp4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect const &)*arg3,(std::string const &)*arg4);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGWindow_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGWindow_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGWindow);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGWindow__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGWindow *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGWindow";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGWindow *)new SwigDirector_AGWindow(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGWindow *)new AGWindow(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGWindow(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AGWindow__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (TYPE(argv[3]) == T_STRING) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_AGWindow__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGWindow'");
    return Qnil;
}


static VALUE
_wrap_AGWindow_addChild(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->addChild(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_getClient(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    result = (AGWidget *)(arg1)->getClient();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_AGWindow_eventMouseButtonDown(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseButtonDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_eventDragBy(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    AGPoint *arg3 = 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventDragBy((AGEvent const *)arg2,(AGPoint const &)*arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_close(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    (arg1)->close();
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_tryClose(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    result = (bool)(arg1)->tryClose((std::string const &)*arg2,(AGEvent const *)arg3);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGWindow_getClientRect(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGRect result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = ((AGWindow const *)arg1)->getClientRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGWindow_sigClose_set(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigClose = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGWindow_sigClose_get(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    result = (AGSignal *)& ((arg1)->sigClose);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static void
free_AGWindow(AGWindow *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGWindow(int argc, VALUE *argv, VALUE self) {
    AGWindow *arg1 = (AGWindow *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWindow, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGWindow(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGWindow *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGWindow &_result_ref = toAGWindow(*arg1);
        result = (AGWindow *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
    return vresult;
}


swig_class cAGImage;

static VALUE
_wrap_new_AGImage__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGPoint *arg3 = 0 ;
    AGSurface arg4 ;
    bool arg5 ;
    AGRect *arg6 = 0 ;
    AGImage *result;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg4 = *ptr;
    }
    arg5 = RTEST(argv[3]);
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGRect, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGImage";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGImage *)new SwigDirector_AGImage(arg1,arg2,(AGPoint const &)*arg3,arg4,arg5,(AGRect const &)*arg6);
            
        } else {
            result = (AGImage *)new AGImage(arg2,(AGPoint const &)*arg3,arg4,arg5,(AGRect const &)*arg6);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGImage_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGImage_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGImage);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGImage__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGPoint *arg3 = 0 ;
    AGSurface arg4 ;
    bool arg5 ;
    AGImage *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg4 = *ptr;
    }
    arg5 = RTEST(argv[3]);
    {
        char *classname = "Libantargisgui::AGImage";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGImage *)new SwigDirector_AGImage(arg1,arg2,(AGPoint const &)*arg3,arg4,arg5);
            
        } else {
            result = (AGImage *)new AGImage(arg2,(AGPoint const &)*arg3,arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE _wrap_new_AGImage(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[7];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 6); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 5) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGPoint, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_new_AGImage__SWIG_1(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    if (argc == 6) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGWidget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGPoint, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (argv[4] == Qtrue || argv[4] == Qfalse) ? 1 : 0;
                        }
                        if (_v) {
                            {
                                void *ptr;
                                _v = (NIL_P(argv[5]) || (TYPE(argv[5]) == T_DATA && SWIG_ConvertPtr(argv[5], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                            }
                            if (_v) {
                                return _wrap_new_AGImage__SWIG_0(nargs, args, self);
                            }
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGImage'");
    return Qnil;
}


static void
free_AGImage(AGImage *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGImage_draw(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGImage_setSurface(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    AGSurface arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGImage, 1);
    {
        AGSurface * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGSurface, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setSurface(arg2);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGImage(int argc, VALUE *argv, VALUE self) {
    AGImage *arg1 = (AGImage *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGImage, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGCaption;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGCaption_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGCaption_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGCaption);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGCaption(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    std::string *arg4 = 0 ;
    AGFont *arg5 = 0 ;
    AGBackground *arg6 = 0 ;
    AGCaption *result;
    std::string temp4 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        if (TYPE(argv[2]) == T_STRING) {
            //            temp4 = std::string(StringValuePtr(argv[2]));
            temp4 = std::string(RSTRING(argv[2])->ptr,RSTRING(argv[2])->len);
            arg4 = &temp4;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGFont, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGBackground, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGCaption";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGCaption *)new SwigDirector_AGCaption(arg1,arg2,(AGRect const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5,(AGBackground const &)*arg6);
            
        } else {
            result = (AGCaption *)new AGCaption(arg2,(AGRect const &)*arg3,(std::string const &)*arg4,(AGFont const &)*arg5,(AGBackground const &)*arg6);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGCaption_draw(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCaption, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGCaption_setBackground(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    AGBackground arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGCaption, 1);
    {
        AGBackground * ptr;
        SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AGBackground, 1);
        if (ptr) arg2 = *ptr;
    }
    (arg1)->setBackground(arg2);
    
    return Qnil;
}


static void
free_AGCaption(AGCaption *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGCaption(int argc, VALUE *argv, VALUE self) {
    AGCaption *arg1 = (AGCaption *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGCaption, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGBackground;

static VALUE
_wrap_new_AGBackground__SWIG_0(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    AGBackground *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGBackground *)new AGBackground(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGBackground__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGBackground *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGBackground *)new AGBackground();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGBackground_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGBackground_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBackground);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGBackground__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGColor *arg1 = 0 ;
    AGBackground *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColor, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGBackground *)new AGBackground((AGColor const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGBackground(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGBackground__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBackground__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGBackground__SWIG_0(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGBackground'");
    return Qnil;
}


static VALUE
_wrap_AGBackground_draw(int argc, VALUE *argv, VALUE self) {
    AGBackground *arg1 = (AGBackground *) 0 ;
    AGPainter *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGBackground, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static void
free_AGBackground(AGBackground *arg1) {
    delete arg1;
}
swig_class cAGLayout;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLayout_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLayout_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLayout);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLayout(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGLayout *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGLayout";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGLayout *)new SwigDirector_AGLayout(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGLayout *)new AGLayout(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGLayout_addTabIndex(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    int arg2 ;
    AGWidget *arg3 = (AGWidget *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayout, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGWidget, 1);
    (arg1)->addTabIndex(arg2,arg3);
    
    return Qnil;
}


static void
free_AGLayout(AGLayout *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGLayout(int argc, VALUE *argv, VALUE self) {
    AGLayout *arg1 = (AGLayout *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGLayout, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_parseNode(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AGWidget *result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGWidget *)parseNode(arg1,(Node const &)*arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    return vresult;
}


static VALUE
_wrap_parseChildren(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    parseChildren(arg1,(Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_getLayoutGeometry(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = (AGWidget *) 0 ;
    xmlpp::Node *arg2 = 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = getLayoutGeometry(arg1,(Node const &)*arg2);
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


swig_class cAGLayoutCreator;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGLayoutCreator_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGLayoutCreator_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGLayoutCreator);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGLayoutCreator(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    std::string *arg2 = 0 ;
    AGLayoutCreator *result;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    char *classname = "Libantargisgui::AGLayoutCreator";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGLayoutCreator *)new SwigDirector_AGLayoutCreator(arg1,(std::string const &)*arg2);
        
    } else {
        result = (AGLayoutCreator *)new AGLayoutCreator((std::string const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGLayoutCreator(AGLayoutCreator *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGLayoutCreator_create(int argc, VALUE *argv, VALUE self) {
    AGLayoutCreator *arg1 = (AGLayoutCreator *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    xmlpp::Node *arg4 = 0 ;
    AGWidget *result;
    Swig::Director *director = 0;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutCreator, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_Node, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (AGWidget *)(arg1)->create(arg2,(AGRect const &)*arg3,(Node const &)*arg4);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_disown_AGLayoutCreator(int argc, VALUE *argv, VALUE self) {
    AGLayoutCreator *arg1 = (AGLayoutCreator *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGLayoutCreator, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGLayoutFactory;

static void
free_AGLayoutFactory(AGLayoutFactory *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGLayoutFactory_addCreator(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *arg1 = (AGLayoutFactory *) 0 ;
    std::string *arg2 = 0 ;
    AGLayoutCreator *arg3 = (AGLayoutCreator *) 0 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutFactory, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGLayoutCreator, 1);
    (arg1)->addCreator((std::string const &)*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGLayoutFactory_create(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *arg1 = (AGLayoutFactory *) 0 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    xmlpp::Node *arg4 = 0 ;
    AGWidget *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGLayoutFactory, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_Node, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (AGWidget *)(arg1)->create(arg2,(AGRect const &)*arg3,(Node const &)*arg4);
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
    }
    return vresult;
}


static VALUE
_wrap_getLayoutFactory(int argc, VALUE *argv, VALUE self) {
    AGLayoutFactory *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGLayoutFactory *)getLayoutFactory();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayoutFactory,0);
    return vresult;
}


swig_class cNode;

static VALUE
_wrap_new_Node__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Node *)new Node();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_Node__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Node *)new Node(arg1);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Node_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Node_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Node);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Node__SWIG_2(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = 0 ;
    Node *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Node, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (Node *)new Node((Node const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_Node(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Node__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_2(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Node__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Node'");
    return Qnil;
}


static void
free_Node(Node *arg1) {
    delete arg1;
}
static VALUE
_wrap_Node_setName(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setName(arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_get_children__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::NodeVector result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->get_children();
    
    {
        Node::NodeVector * resultptr;
        resultptr = new Node::NodeVector((Node::NodeVector &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_get_children__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    Node::NodeVector result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->get_children(arg2);
    
    {
        Node::NodeVector * resultptr;
        resultptr = new Node::NodeVector((Node::NodeVector &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_get_children(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_get_children__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_get_children__SWIG_1(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_get_children'");
    return Qnil;
}


static VALUE
_wrap_Node_getName(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->getName();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_get_name(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->get_name();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_setAttributes(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::Attributes *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setAttributes((std::map<std::string,std::string > const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_newChild(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        Node &_result_ref = (arg1)->newChild(arg2);
        result = (Node *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Node_add_child(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Node *)(arg1)->add_child(arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Node_remove_child(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->remove_child(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_begin__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = (arg1)->begin();
    
    {
        Node::iterator * resultptr;
        resultptr = new Node::iterator((Node::iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__iterator, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_begin__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::const_iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->begin();
    
    {
        Node::const_iterator * resultptr;
        resultptr = new Node::const_iterator((Node::const_iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__const_iterator, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_begin(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_begin__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_begin__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_begin'");
    return Qnil;
}


static VALUE
_wrap_Node_end__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = (arg1)->end();
    
    {
        Node::iterator * resultptr;
        resultptr = new Node::iterator((Node::iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__iterator, 1);
    }
    return vresult;
}


static VALUE
_wrap_Node_end__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    Node::const_iterator result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->end();
    
    {
        Node::const_iterator * resultptr;
        resultptr = new Node::const_iterator((Node::const_iterator &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node__NodeVector__const_iterator, 1);
    }
    return vresult;
}


static VALUE _wrap_Node_end(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_end__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_end__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_end'");
    return Qnil;
}


static VALUE
_wrap_Node_setContent(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->setContent((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_getContent__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->getContent();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_set(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->set((std::string const &)*arg2,(std::string const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_get(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->get((std::string const &)*arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_clear(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_Node_escape(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->escape((std::string const &)*arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_unescape(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string *arg2 = 0 ;
    std::string result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = ((Node const *)arg1)->unescape((std::string const &)*arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_getStart__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    bool arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = RTEST(argv[1]);
    ((Node const *)arg1)->getStart(*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_getStart__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((Node const *)arg1)->getStart(*arg2);
    
    return Qnil;
}


static VALUE _wrap_Node_getStart(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_getStart__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (argv[2] == Qtrue || argv[2] == Qfalse) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Node_getStart__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getStart'");
    return Qnil;
}


static VALUE
_wrap_Node_getEnd(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    ((Node const *)arg1)->getEnd(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Node_indent(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    ((Node const *)arg1)->indent(*arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_Node_getContent__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::ostringstream *arg2 = 0 ;
    int arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__ostringstream, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    ((Node const *)arg1)->getContent(*arg2,arg3);
    
    return Qnil;
}


static VALUE _wrap_Node_getContent(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_getContent__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_std__ostringstream, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Node_getContent__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_getContent'");
    return Qnil;
}


static VALUE
_wrap_Node_toString__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool arg2 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    arg2 = RTEST(argv[0]);
    result = ((Node const *)arg1)->toString(arg2);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_toString__SWIG_1(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE _wrap_Node_toString(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Node_toString__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (argv[1] == Qtrue || argv[1] == Qfalse) ? 1 : 0;
            }
            if (_v) {
                return _wrap_Node_toString__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Node_toString'");
    return Qnil;
}


static VALUE
_wrap_Node_isTextNode(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = (bool)((Node const *)arg1)->isTextNode();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Node_getText(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->getText();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Node_hasTextNode(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = (bool)((Node const *)arg1)->hasTextNode();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Node_size(int argc, VALUE *argv, VALUE self) {
    Node *arg1 = (Node *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Node, 1);
    result = ((Node const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


swig_class cDocument;

static VALUE
_wrap_new_Document__SWIG_0(int argc, VALUE *argv, VALUE self) {
    Document *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (Document *)new Document();
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Document_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Document_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Document);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Document__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    Document *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Document *)new Document(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_Document(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[1];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_Document__SWIG_0(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (TYPE(argv[0]) == T_STRING) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_Document__SWIG_1(nargs, args, self);
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_Document'");
    return Qnil;
}


static void
free_Document(Document *arg1) {
    delete arg1;
}
static VALUE
_wrap_Document_parseFile(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)(arg1)->parseFile(arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Document_root(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    {
        Node &_result_ref = (arg1)->root();
        result = (Node *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Document_get_root_node(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    result = (Node *)(arg1)->get_root_node();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_Document_toString(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    result = ((Document const *)arg1)->toString();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_Document_parse_memory(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parse_memory((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Document_parseMemory(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parseMemory((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Document_get_document(int argc, VALUE *argv, VALUE self) {
    Document *arg1 = (Document *) 0 ;
    Document *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Document, 1);
    result = (Document *)(arg1)->get_document();
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


swig_class cParser;

static void
free_Parser(Parser *arg1) {
    delete arg1;
}
static VALUE
_wrap_Parser_parse(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->parse((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_getLine(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    size_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    result = ((Parser const *)arg1)->getLine();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Parser_simpleTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->simpleTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Parser_startTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->startTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_Parser_endTag(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endTag((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_text(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->text((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_comment(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->comment((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_Parser_header(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->header((std::string const &)*arg2);
    
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_Parser_allocate(VALUE self) {
#else
    static VALUE
    _wrap_Parser_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Parser);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_Parser(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    Parser *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::Parser";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (Parser *)new SwigDirector_Parser(arg1);
        
    } else {
        result = (Parser *)new Parser();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_disown_Parser(int argc, VALUE *argv, VALUE self) {
    Parser *arg1 = (Parser *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_Parser, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cDomParser;

static VALUE
_wrap_DomParser_simpleTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->simpleTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_startTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Node::Attributes *arg3 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__mapTstd__string_std__string_t, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->startTag((std::string const &)*arg2,(std::map<std::string,std::string > const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_endTag(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->endTag((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_text(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->text((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_comment(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->comment((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_header(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->header((std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_DomParser_parse__SWIG_0(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Document *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (Document *)(arg1)->parse((std::string const &)*arg2);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


static VALUE
_wrap_DomParser_parse__SWIG_1(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    std::string *arg2 = 0 ;
    Document *arg3 = (Document *) 0 ;
    Document *result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Document, 1);
    result = (Document *)(arg1)->parse((std::string const &)*arg2,arg3);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Document,0);
    return vresult;
}


static VALUE _wrap_DomParser_parse(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_DomParser, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_DomParser_parse__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_DomParser, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_Document, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_DomParser_parse__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'DomParser_parse'");
    return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_DomParser_allocate(VALUE self) {
#else
    static VALUE
    _wrap_DomParser_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_DomParser);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_DomParser(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    DomParser *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::DomParser";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (DomParser *)new SwigDirector_DomParser(arg1);
        
    } else {
        result = (DomParser *)new DomParser();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_DomParser(DomParser *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_DomParser(int argc, VALUE *argv, VALUE self) {
    DomParser *arg1 = (DomParser *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_DomParser, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGSound;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGSound_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGSound_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGSound);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGSound(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGSound *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGSound";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGSound *)new SwigDirector_AGSound(arg1);
        
    } else {
        result = (AGSound *)new AGSound();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static void
free_AGSound(AGSound *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGSound_playMp3(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    std::string *arg2 = 0 ;
    bool result;
    std::string temp2 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)(arg1)->playMp3((std::string const &)*arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGSound_stopMp3(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    (arg1)->stopMp3();
    
    return Qnil;
}


static VALUE
_wrap_AGSound_checkFinished(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    (arg1)->checkFinished();
    
    return Qnil;
}


static VALUE
_wrap_AGSound_sigMp3Finished_set(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigMp3Finished = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGSound_sigMp3Finished_get(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    result = (AGSignal *)& ((arg1)->sigMp3Finished);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_getSoundManager(int argc, VALUE *argv, VALUE self) {
    AGSound *result;
    Swig::Director *resultdirector = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (AGSound *)getSoundManager();
    
    resultdirector = dynamic_cast<Swig::Director *>(result);
    if (resultdirector) {
        vresult = resultdirector->swig_get_self();
    } else {
        vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
    }
    return vresult;
}


static VALUE
_wrap_disown_AGSound(int argc, VALUE *argv, VALUE self) {
    AGSound *arg1 = (AGSound *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGSound, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGGLWidget;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGGLWidget_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGGLWidget_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGGLWidget);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGGLWidget(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGGLWidget *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGGLWidget";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGGLWidget *)new SwigDirector_AGGLWidget(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGGLWidget *)new AGGLWidget(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGGLWidget_drawGL(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawGL();
    
    return Qnil;
}


static VALUE
_wrap_AGGLWidget_drawAll(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawAll(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGGLWidget_getRatio(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    float result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    result = (float)((AGGLWidget const *)arg1)->getRatio();
    
    vresult = rb_float_new(result);
    return vresult;
}


static VALUE
_wrap_AGGLWidget_setPerspective(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    arg2 = (float) NUM2DBL(argv[0]);
    arg3 = (float) NUM2DBL(argv[1]);
    arg4 = (float) NUM2DBL(argv[2]);
    (arg1)->setPerspective(arg2,arg3,arg4);
    
    return Qnil;
}


static void
free_AGGLWidget(AGGLWidget *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGGLWidget(int argc, VALUE *argv, VALUE self) {
    AGGLWidget *arg1 = (AGGLWidget *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGGLWidget, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGColorButton;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGColorButton_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGColorButton_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGColorButton);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGColorButton(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    int arg4 ;
    int arg5 ;
    AGColorButton *result;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg4 = NUM2INT(argv[2]);
    arg5 = NUM2INT(argv[3]);
    {
        char *classname = "Libantargisgui::AGColorButton";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGColorButton *)new SwigDirector_AGColorButton(arg1,arg2,(AGRect const &)*arg3,arg4,arg5);
            
        } else {
            result = (AGColorButton *)new AGColorButton(arg2,(AGRect const &)*arg3,arg4,arg5);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGColorButton_draw(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColorButton_getColor(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGColor result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    result = ((AGColorButton const *)arg1)->getColor();
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGColorButton_setColor__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGColor *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGColor, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor((AGColor const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGColorButton_setColor__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setColor(arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGColorButton_setColor(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColorButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGColorButton_setColor__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGColorButton, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGColorButton_setColor__SWIG_1(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGColorButton_setColor'");
    return Qnil;
}


static VALUE
_wrap_AGColorButton_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGColorButton(AGColorButton *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGColorButton(int argc, VALUE *argv, VALUE self) {
    AGColorButton *arg1 = (AGColorButton *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGColorButton, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGColorButton(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGColorButton *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGColorButton &_result_ref = toAGColorButton(*arg1);
        result = (AGColorButton *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
    return vresult;
}


swig_class cAGDialog;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGDialog_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGDialog_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGDialog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGDialog(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    std::string *arg3 = 0 ;
    AGDialog *result;
    std::string temp3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp3 = std::string(StringValuePtr(argv[1]));
            temp3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        char *classname = "Libantargisgui::AGDialog";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGDialog *)new SwigDirector_AGDialog(arg1,arg2,(std::string const &)*arg3);
            
        } else {
            result = (AGDialog *)new AGDialog(arg2,(std::string const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGDialog_eventOk(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventOk((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGDialog_eventCancel(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventCancel((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGDialog_eventClose(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    std::string *arg2 = 0 ;
    AGEvent *arg3 = (AGEvent *) 0 ;
    AGMessageObject *arg4 = (AGMessageObject *) 0 ;
    bool result;
    std::string temp2 ;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGDialog, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGEvent, 1);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGMessageObject, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventClose((std::string const &)*arg2,(AGEvent const *)arg3,arg4);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static void
free_AGDialog(AGDialog *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGDialog(int argc, VALUE *argv, VALUE self) {
    AGDialog *arg1 = (AGDialog *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGDialog, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_initFS(int argc, VALUE *argv, VALUE self) {
    char *arg1 = (char *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = StringValuePtr(argv[0]);
    initFS((char const *)arg1);
    
    return Qnil;
}


static VALUE
_wrap_loadFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = loadFile((std::string const &)*arg1);
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_saveFile(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[1]));
            temp2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    saveFile((std::string const &)*arg1,(std::string const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_fileExists(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    bool result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (bool)fileExists((std::string const &)*arg1);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_getDirectory(int argc, VALUE *argv, VALUE self) {
    std::string *arg1 = 0 ;
    std::vector<std::string > result;
    std::string temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp1 = std::string(StringValuePtr(argv[0]));
            temp1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg1 = &temp1;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = getDirectory((std::string const &)*arg1);
    
    {
        vresult = rb_ary_new2((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++)
        rb_ary_store(vresult,i,SWIG_STR2RB(((std::vector<std::string > &)result)[i]));
    }
    return vresult;
}


swig_class cAGListBoxItem;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListBoxItem_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListBoxItem_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListBoxItem);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListBoxItem(int argc, VALUE *argv, VALUE self) {
    std::string arg1 ;
    std::string arg2 ;
    AGListBoxItem *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg1 = std::string(StringValuePtr(argv[0]));
            arg1 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[1]));
            arg2 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    result = (AGListBoxItem *)new AGListBoxItem(arg1,arg2);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_AGListBoxItem_id_set(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->id = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBoxItem_id_get(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 1);
    result = (std::string *)& ((arg1)->id);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static VALUE
_wrap_AGListBoxItem_value_set(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *arg2 = (std::string *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__string, 1);
    if (arg1) (arg1)->value = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBoxItem_value_get(int argc, VALUE *argv, VALUE self) {
    AGListBoxItem *arg1 = (AGListBoxItem *) 0 ;
    std::string *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBoxItem, 1);
    result = (std::string *)& ((arg1)->value);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string,0);
    return vresult;
}


static void
free_AGListBoxItem(AGListBoxItem *arg1) {
    delete arg1;
}
swig_class cAGListBox;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGListBox_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGListBox_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGListBox);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGListBox(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGWidget *arg2 = (AGWidget *) 0 ;
    AGRect *arg3 = 0 ;
    AGListBox *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGWidget, 1);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        char *classname = "Libantargisgui::AGListBox";
        if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
            /* subclassed */
            result = (AGListBox *)new SwigDirector_AGListBox(arg1,arg2,(AGRect const &)*arg3);
            
        } else {
            result = (AGListBox *)new AGListBox(arg2,(AGRect const &)*arg3);
            
        }
        DATA_PTR(self) = result;
        result->mRUBY=self;
        result->mRubyObject=true;
    }
    return self;
}


static VALUE
_wrap_AGListBox_insertItem(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string arg2 ;
    std::string arg3 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    {
        if (TYPE(argv[1]) == T_STRING) {
            //            arg3 = std::string(StringValuePtr(argv[1]));
            arg3 = std::string(RSTRING(argv[1])->ptr,RSTRING(argv[1])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->insertItem(arg2,arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_selectItem(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string arg2 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            arg2 = std::string(StringValuePtr(argv[0]));
            arg2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    (arg1)->selectItem(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_getSelectedID(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    result = ((AGListBox const *)arg1)->getSelectedID();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGListBox_getSelectedValue(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    std::string result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    result = ((AGListBox const *)arg1)->getSelectedValue();
    
    {
        vresult = rb_str_new((&result)->c_str(),(&result)->length());
    }
    return vresult;
}


static VALUE
_wrap_AGListBox_eventKeyDown(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventKeyDown((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGListBox_sigSelect_set(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigSelect = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_sigSelect_get(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    result = (AGSignal *)& ((arg1)->sigSelect);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGListBox_sigDoubleClick_set(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *arg2 = (AGSignal *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSignal, 1);
    if (arg1) (arg1)->sigDoubleClick = *arg2;
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_sigDoubleClick_get(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGSignal *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    result = (AGSignal *)& ((arg1)->sigDoubleClick);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSignal,0);
    return vresult;
}


static VALUE
_wrap_AGListBox_draw(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGPainter *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->draw(*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGListBox_eventMouseClick(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    AGEvent *arg2 = (AGEvent *) 0 ;
    bool result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGEvent, 1);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (bool)(arg1)->eventMouseClick((AGEvent const *)arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGListBox_clearList(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    (arg1)->clearList();
    
    return Qnil;
}


static void
free_AGListBox(AGListBox *arg1) {
    delete arg1;
}
static VALUE
_wrap_disown_AGListBox(int argc, VALUE *argv, VALUE self) {
    AGListBox *arg1 = (AGListBox *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGListBox, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


static VALUE
_wrap_toAGListBox(int argc, VALUE *argv, VALUE self) {
    AGWidget *arg1 = 0 ;
    AGListBox *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGWidget, 1); if (arg1 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        AGListBox &_result_ref = toAGListBox(*arg1);
        result = (AGListBox *) &_result_ref;
    }
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
    return vresult;
}


swig_class cAGPainter;

static VALUE
_wrap_new_AGPainter__SWIG_0(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGPainter *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    arg1 = self;
    char *classname = "Libantargisgui::AGPainter";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGPainter *)new SwigDirector_AGPainter(arg1);
        
    } else {
        result = (AGPainter *)new AGPainter();
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGPainter__SWIG_1(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGPainter *arg2 = 0 ;
    AGPainter *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPainter, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargisgui::AGPainter";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGPainter *)new SwigDirector_AGPainter(arg1,(AGPainter const &)*arg2);
        
    } else {
        result = (AGPainter *)new AGPainter((AGPainter const &)*arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGPainter_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGPainter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGPainter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGPainter__SWIG_2(int argc, VALUE *argv, VALUE self) {
    VALUE arg1 ;
    AGPaintTarget *arg2 = 0 ;
    AGPainter *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = self;
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPaintTarget, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    char *classname = "Libantargisgui::AGPainter";
    if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
        /* subclassed */
        result = (AGPainter *)new SwigDirector_AGPainter(arg1,*arg2);
        
    } else {
        result = (AGPainter *)new AGPainter(*arg2);
        
    }
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGPainter(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            return _wrap_new_AGPainter__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGPainter__SWIG_1(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        _v = (argv[0] != T_NONE);
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGPaintTarget, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGPainter__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGPainter'");
    return Qnil;
}


static void
free_AGPainter(AGPainter *arg1) {
    delete arg1;
}
static VALUE
_wrap_AGPainter_putPixel(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->putPixel((AGPoint const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_getPixel(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    int arg2 ;
    int arg3 ;
    AGColor result;
    Swig::Director *director = 0;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    arg2 = NUM2INT(argv[0]);
    arg3 = NUM2INT(argv[1]);
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    result = (arg1)->getPixel(arg2,arg3);
    
    {
        AGColor * resultptr;
        resultptr = new AGColor((AGColor &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGColor, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_drawCircle(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    float arg3 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = (float) NUM2DBL(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawCircle((AGPoint const &)*arg2,arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blitTri(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGTriangle2 *arg3 = 0 ;
    AGTriangle2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGTriangle2, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGTriangle2, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blitTri((AGTexture const &)*arg2,(AGTriangle2 const &)*arg3,(AGTriangle2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect2 *arg3 = 0 ;
    AGRect2 *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect2, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect2, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect2 const &)*arg3,(AGRect2 const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_0(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_1(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_2(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGTexture *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGTexture, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGTexture const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_blit__SWIG_6(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->blit((AGSurface const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPainter_blit(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[6];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_blit__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_blit__SWIG_5(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_3(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect2, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_0(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_blit__SWIG_6(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            void *ptr;
                            _v = (NIL_P(argv[4]) || (TYPE(argv[4]) == T_DATA && SWIG_ConvertPtr(argv[4], &ptr, SWIGTYPE_p_AGColor, 0) != -1)) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_AGPainter_blit__SWIG_4(nargs, args, self);
                        }
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPainter_blit'");
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_3(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGSurface const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_4(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGSurface const &)*arg2,(AGRect const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_tile__SWIG_5(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGSurface *arg2 = 0 ;
    AGRect *arg3 = 0 ;
    AGRect *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGSurface, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGRect, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGRect, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->tile((AGSurface const &)*arg2,(AGRect const &)*arg3,(AGRect const &)*arg4);
    
    return Qnil;
}


static VALUE _wrap_AGPainter_tile(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[5];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGPainter_tile__SWIG_0(nargs, args, self);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AGPainter_tile__SWIG_3(nargs, args, self);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_tile__SWIG_1(nargs, args, self);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_AGPainter_tile__SWIG_4(nargs, args, self);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGTexture, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_tile__SWIG_2(nargs, args, self);
                    }
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_AGPainter, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGSurface, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                {
                    void *ptr;
                    _v = (NIL_P(argv[2]) || (TYPE(argv[2]) == T_DATA && SWIG_ConvertPtr(argv[2], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        _v = (NIL_P(argv[3]) || (TYPE(argv[3]) == T_DATA && SWIG_ConvertPtr(argv[3], &ptr, SWIGTYPE_p_AGRect, 0) != -1)) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_AGPainter_tile__SWIG_5(nargs, args, self);
                    }
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'AGPainter_tile'");
    return Qnil;
}


static VALUE
_wrap_AGPainter_transform(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->transform((AGRect const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_setNull(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->setNull((AGPoint const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_renderText(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    std::string *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGFont *arg4 = 0 ;
    std::string temp2 ;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    {
        if (TYPE(argv[0]) == T_STRING) {
            //            temp2 = std::string(StringValuePtr(argv[0]));
            temp2 = std::string(RSTRING(argv[0])->ptr,RSTRING(argv[0])->len);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "not a string");
        }
    }
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGFont, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->renderText((std::string const &)*arg2,(AGPoint const &)*arg3,(AGFont const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_getRect(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    result = ((AGPainter const *)arg1)->getRect();
    
    {
        AGRect * resultptr;
        resultptr = new AGRect((AGRect &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGRect, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGPainter_drawGradient(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    AGColor *arg6 = 0 ;
    
    if ((argc < 5) || (argc > 5))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[4], (void **) &arg6, SWIGTYPE_p_AGColor, 1); if (arg6 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawGradient((AGRect const &)*arg2,(AGColor const &)*arg3,(AGColor const &)*arg4,(AGColor const &)*arg5,(AGColor const &)*arg6);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawBorder(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    int arg3 ;
    AGColor *arg4 = 0 ;
    AGColor *arg5 = 0 ;
    
    if ((argc < 4) || (argc > 4))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    arg3 = NUM2INT(argv[1]);
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[3], (void **) &arg5, SWIGTYPE_p_AGColor, 1); if (arg5 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->drawBorder((AGRect const &)*arg2,arg3,(AGColor const &)*arg4,(AGColor const &)*arg5);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawRect(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGRect *arg2 = 0 ;
    AGColor *arg3 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGRect, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGColor, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawRect((AGRect const &)*arg2,(AGColor const &)*arg3);
    
    return Qnil;
}


static VALUE
_wrap_AGPainter_drawLine(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    AGPoint *arg2 = 0 ;
    AGPoint *arg3 = 0 ;
    AGColor *arg4 = 0 ;
    Swig::Director *director = 0;
    
    if ((argc < 3) || (argc > 3))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGPoint, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGPoint, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_AGColor, 1); if (arg4 == NULL) rb_raise(rb_eTypeError, "null reference");
    director = dynamic_cast<Swig::Director *>(arg1);
    if (director && (director->swig_get_self() == self)) director->swig_set_up();
    (arg1)->drawLine((AGPoint const &)*arg2,(AGPoint const &)*arg3,(AGColor const &)*arg4);
    
    return Qnil;
}


static VALUE
_wrap_disown_AGPainter(int argc, VALUE *argv, VALUE self) {
    AGPainter *arg1 = (AGPainter *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_AGPainter, 1);
    {
        Swig::Director *director = dynamic_cast<Swig::Director *>(arg1);
        if (director) director->swig_disown();
    }
    
    return Qnil;
}


swig_class cAGNodeList;

static VALUE
_wrap_new_AGNodeList__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<Node > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<Node > *)new std::vector<Node >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGNodeList__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<Node > *)new std::vector<Node >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGNodeList__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    Node *arg2 = 0 ;
    std::vector<Node > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<Node > *)new std::vector<Node >(arg1,(Node const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGNodeList_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGNodeList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTNode_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGNodeList__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = 0 ;
    std::vector<Node > *result;
    std::vector<Node > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<Node >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
        }
    }
    result = (std::vector<Node > *)new std::vector<Node >((std::vector<Node > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGNodeList(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGNodeList__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGNodeList__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    Node* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_Node,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<Node >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTNode_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGNodeList__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_Node, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGNodeList__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGNodeList'");
    return Qnil;
}


static VALUE
_wrap_AGNodeList___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    unsigned int result;
    std::vector<Node > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
        }
    }
    result = (unsigned int)((std::vector<Node > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGNodeList_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    bool result;
    std::vector<Node > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
        }
    }
    result = (bool)((std::vector<Node > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGNodeList_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGNodeList_push(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    Node *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((Node const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGNodeList_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    Node result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    {
        try {
            result = std_vector_Sl_Node_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        Node * resultptr;
        resultptr = new Node((Node &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_Node, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGNodeList___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    int arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                Node &_result_ref = std_vector_Sl_Node_Sg____getitem__(arg1,arg2);
                result = (Node *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_AGNodeList___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    int arg2 ;
    Node *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Node, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_Node_Sg____setitem__(arg1,arg2,(Node const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_AGNodeList_each(int argc, VALUE *argv, VALUE self) {
    std::vector<Node > *arg1 = (std::vector<Node > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_t, 1);
    std_vector_Sl_Node_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_Node_Sg_(std::vector<Node > *arg1) {
    delete arg1;
}
swig_class cAGNodePList;

static VALUE
_wrap_new_AGNodePList__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<Node * > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<Node * > *)new std::vector<Node * >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGNodePList__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<Node * > *)new std::vector<Node * >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGNodePList__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    Node **arg2 = 0 ;
    std::vector<Node * > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_p_Node, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<Node * > *)new std::vector<Node * >(arg1,*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGNodePList_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGNodePList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTNode_p_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGNodePList__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = 0 ;
    std::vector<Node * > *result;
    std::vector<Node * > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (std::vector<Node * > *)new std::vector<Node * >((std::vector<Node * > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGNodePList(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGNodePList__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGNodePList__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    Node* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_Node,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<Node* >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTNode_p_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGNodePList__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_p_Node, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGNodePList__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGNodePList'");
    return Qnil;
}


static VALUE
_wrap_AGNodePList___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    unsigned int result;
    std::vector<Node * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (unsigned int)((std::vector<Node * > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGNodePList_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    bool result;
    std::vector<Node * > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<Node* >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                Node* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_Node, 1);
                temp1[i] = x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
        }
    }
    result = (bool)((std::vector<Node * > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGNodePList_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGNodePList_push(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    Node *arg2 = (Node *) 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_Node, 1);
    (arg1)->push_back(arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGNodePList_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    {
        try {
            result = (Node *)std_vector_Sl_Node_Sm__Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_AGNodePList___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    int arg2 ;
    Node *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            result = (Node *)std_vector_Sl_Node_Sm__Sg____getitem__(arg1,arg2);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Node,0);
    return vresult;
}


static VALUE
_wrap_AGNodePList___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    int arg2 ;
    Node *arg3 = (Node *) 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_Node, 1);
    {
        try {
            std_vector_Sl_Node_Sm__Sg____setitem__(arg1,arg2,arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_AGNodePList_each(int argc, VALUE *argv, VALUE self) {
    std::vector<Node * > *arg1 = (std::vector<Node * > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTNode_p_t, 1);
    std_vector_Sl_Node_Sm__Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_Node_Sm__Sg_(std::vector<Node * > *arg1) {
    delete arg1;
}
swig_class cAGVector3List;

static VALUE
_wrap_new_AGVector3List__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<AGVector3 > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<AGVector3 > *)new std::vector<AGVector3 >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3List__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<AGVector3 > *)new std::vector<AGVector3 >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector3List__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    AGVector3 *arg2 = 0 ;
    std::vector<AGVector3 > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<AGVector3 > *)new std::vector<AGVector3 >(arg1,(AGVector3 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector3List_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector3List_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTAGVector3_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector3List__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = 0 ;
    std::vector<AGVector3 > *result;
    std::vector<AGVector3 > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<AGVector3 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                AGVector3* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector3, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
        }
    }
    result = (std::vector<AGVector3 > *)new std::vector<AGVector3 >((std::vector<AGVector3 > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector3List(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector3List__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector3List__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    AGVector3* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_AGVector3,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<AGVector3 >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTAGVector3_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGVector3List__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector3, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector3List__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector3List'");
    return Qnil;
}


static VALUE
_wrap_AGVector3List___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    unsigned int result;
    std::vector<AGVector3 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGVector3 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGVector3* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector3, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
        }
    }
    result = (unsigned int)((std::vector<AGVector3 > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGVector3List_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    bool result;
    std::vector<AGVector3 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGVector3 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGVector3* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector3, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
        }
    }
    result = (bool)((std::vector<AGVector3 > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector3List_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGVector3List_push(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    AGVector3 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector3, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((AGVector3 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector3List_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    AGVector3 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    {
        try {
            result = std_vector_Sl_AGVector3_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        AGVector3 * resultptr;
        resultptr = new AGVector3((AGVector3 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector3, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector3List___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    int arg2 ;
    AGVector3 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                AGVector3 &_result_ref = std_vector_Sl_AGVector3_Sg____getitem__(arg1,arg2);
                result = (AGVector3 *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector3,0);
    return vresult;
}


static VALUE
_wrap_AGVector3List___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    int arg2 ;
    AGVector3 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector3, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_AGVector3_Sg____setitem__(arg1,arg2,(AGVector3 const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_AGVector3List_each(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector3 > *arg1 = (std::vector<AGVector3 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector3_t, 1);
    std_vector_Sl_AGVector3_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_AGVector3_Sg_(std::vector<AGVector3 > *arg1) {
    delete arg1;
}
swig_class cAGVector4List;

static VALUE
_wrap_new_AGVector4List__SWIG_0(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    std::vector<AGVector4 > *result;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    arg1 = NUM2UINT(argv[0]);
    result = (std::vector<AGVector4 > *)new std::vector<AGVector4 >(arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4List__SWIG_1(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (std::vector<AGVector4 > *)new std::vector<AGVector4 >();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_new_AGVector4List__SWIG_2(int argc, VALUE *argv, VALUE self) {
    unsigned int arg1 ;
    AGVector4 *arg2 = 0 ;
    std::vector<AGVector4 > *result;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    arg1 = NUM2UINT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    result = (std::vector<AGVector4 > *)new std::vector<AGVector4 >(arg1,(AGVector4 const &)*arg2);
    DATA_PTR(self) = result;
    return self;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
static VALUE
_wrap_AGVector4List_allocate(VALUE self) {
#else
    static VALUE
    _wrap_AGVector4List_allocate(int argc, VALUE *argv, VALUE self) {
#endif
        
        
        VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTAGVector4_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
        rb_obj_call_init(vresult, argc, argv);
#endif
        return vresult;
    }
    

static VALUE
_wrap_new_AGVector4List__SWIG_3(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = 0 ;
    std::vector<AGVector4 > *result;
    std::vector<AGVector4 > temp1 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    {
        if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
            unsigned int size = RARRAY(argv[0])->len;
            temp1 = std::vector<AGVector4 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(argv[0])->ptr[i];
                AGVector4* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector4, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
        }
    }
    result = (std::vector<AGVector4 > *)new std::vector<AGVector4 >((std::vector<AGVector4 > const &)*arg1);
    DATA_PTR(self) = result;
    return self;
}


static VALUE _wrap_new_AGVector4List(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[2];
    int ii;
    
    argc = nargs;
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii];
    }
    if (argc == 0) {
        return _wrap_new_AGVector4List__SWIG_1(nargs, args, self);
    }
    if (argc == 1) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AGVector4List__SWIG_0(nargs, args, self);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
                unsigned int size = RARRAY(argv[0])->len;
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                } else {
                    /* check the first element only */
                    AGVector4* x;
                    VALUE o = RARRAY(argv[0])->ptr[0];
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_AGVector4,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                }
            } else {
                /* wrapped vector? */
                std::vector<AGVector4 >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTAGVector4_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_AGVector4List__SWIG_3(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = ((TYPE(argv[0]) == T_FIXNUM) || (TYPE(argv[0]) == T_BIGNUM)) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                _v = (NIL_P(argv[1]) || (TYPE(argv[1]) == T_DATA && SWIG_ConvertPtr(argv[1], &ptr, SWIGTYPE_p_AGVector4, 0) != -1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AGVector4List__SWIG_2(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'new_AGVector4List'");
    return Qnil;
}


static VALUE
_wrap_AGVector4List___len__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    unsigned int result;
    std::vector<AGVector4 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGVector4 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGVector4* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector4, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
        }
    }
    result = (unsigned int)((std::vector<AGVector4 > const *)arg1)->size();
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_AGVector4List_emptyq___(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    bool result;
    std::vector<AGVector4 > temp1 ;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    {
        if (rb_obj_is_kind_of(self,rb_cArray)) {
            unsigned int size = RARRAY(self)->len;
            temp1 = std::vector<AGVector4 >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                VALUE o = RARRAY(self)->ptr[i];
                AGVector4* x;
                SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_AGVector4, 1);
                temp1[i] = *x;
            }
        } else {
            SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
        }
    }
    result = (bool)((std::vector<AGVector4 > const *)arg1)->empty();
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_AGVector4List_clear(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    (arg1)->clear();
    
    return Qnil;
}


static VALUE
_wrap_AGVector4List_push(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    AGVector4 *arg2 = 0 ;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_AGVector4, 1); if (arg2 == NULL) rb_raise(rb_eTypeError, "null reference");
    (arg1)->push_back((AGVector4 const &)*arg2);
    
    return Qnil;
}


static VALUE
_wrap_AGVector4List_pop(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    AGVector4 result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    {
        try {
            result = std_vector_Sl_AGVector4_Sg__pop(arg1);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        AGVector4 * resultptr;
        resultptr = new AGVector4((AGVector4 &)result);
        vresult = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_AGVector4, 1);
    }
    return vresult;
}


static VALUE
_wrap_AGVector4List___getitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    int arg2 ;
    AGVector4 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    arg2 = NUM2INT(argv[0]);
    {
        try {
            {
                AGVector4 &_result_ref = std_vector_Sl_AGVector4_Sg____getitem__(arg1,arg2);
                result = (AGVector4 *) &_result_ref;
            }
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGVector4,0);
    return vresult;
}


static VALUE
_wrap_AGVector4List___setitem__(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    int arg2 ;
    AGVector4 *arg3 = 0 ;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    arg2 = NUM2INT(argv[0]);
    SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_AGVector4, 1); if (arg3 == NULL) rb_raise(rb_eTypeError, "null reference");
    {
        try {
            std_vector_Sl_AGVector4_Sg____setitem__(arg1,arg2,(AGVector4 const &)*arg3);
            
        } catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    return Qnil;
}


static VALUE
_wrap_AGVector4List_each(int argc, VALUE *argv, VALUE self) {
    std::vector<AGVector4 > *arg1 = (std::vector<AGVector4 > *) 0 ;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTAGVector4_t, 1);
    std_vector_Sl_AGVector4_Sg__each(arg1);
    
    return Qnil;
}


static void
free_std_vector_Sl_AGVector4_Sg_(std::vector<AGVector4 > *arg1) {
    delete arg1;
}

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_AGDialogTo_p_AGLayout(void *x) {
    return (void *)((AGLayout *)  ((AGDialog *) x));
}
static void *_p_AGHTilerTo_p_AGVTiler(void *x) {
    return (void *)((AGVTiler *)  ((AGHTiler *) x));
}
static void *_p_AGMenuTo_p_AGVTiler(void *x) {
    return (void *)((AGVTiler *)  ((AGMenu *) x));
}
static void *_p_AGRadioTo_p_AGCheckBox(void *x) {
    return (void *)((AGCheckBox *)  ((AGRadio *) x));
}
static void *_p_AGSDLScreenTo_p_AGScreen(void *x) {
    return (void *)((AGScreen *)  ((AGSDLScreen *) x));
}
static void *_p_AGWindowTo_p_AGTable(void *x) {
    return (void *)((AGTable *)  ((AGWindow *) x));
}
static void *_p_AGRadioTo_p_AGButton(void *x) {
    return (void *)((AGButton *) (AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGCheckBoxTo_p_AGButton(void *x) {
    return (void *)((AGButton *)  ((AGCheckBox *) x));
}
static void *_p_AGWindowTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGTable *) ((AGWindow *) x));
}
static void *_p_AGListBoxTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGListBox *) x));
}
static void *_p_AGCaptionTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGText *) ((AGCaption *) x));
}
static void *_p_AGButtonTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGVTiler *) x));
}
static void *_p_AGTableTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGTable *) x));
}
static void *_p_AGMenuTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGColorButton *) x));
}
static void *_p_AGHTilerTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGScreenWidgetTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGScreenWidget *) x));
}
static void *_p_AGImageTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGImage *) x));
}
static void *_p_AGGLWidgetTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGGLWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGLayout *) x));
}
static void *_p_AGRadioTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGDialogTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *) (AGLayout *) ((AGDialog *) x));
}
static void *_p_AGTextTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGWidget(void *x) {
    return (void *)((AGWidget *)  ((AGSound *) x));
}
static void *_p_AGWindowTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_AGListBoxTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGListBox *) x));
}
static void *_p_AGCaptionTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGApplicationTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *)  ((AGApplication *) x));
}
static void *_p_AGButtonTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGVTiler *) x));
}
static void *_p_AGTableTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGTable *) x));
}
static void *_p_AGWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *)  ((AGWidget *) x));
}
static void *_p_AGMenuTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGColorButton *) x));
}
static void *_p_AGHTilerTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGScreenWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGScreenWidget *) x));
}
static void *_p_AGImageTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGImage *) x));
}
static void *_p_AGGLWidgetTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGGLWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGLayout *) x));
}
static void *_p_AGRadioTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGDialogTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGTextTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGMessageObject(void *x) {
    return (void *)((AGMessageObject *) (AGWidget *) ((AGSound *) x));
}
static void *_p_AGRectTo_p_SDL_Rect(void *x) {
    return (void *)((SDL_Rect *)  ((AGRect *) x));
}
static void *_p_AGPoint3To_p_AGVector3(void *x) {
    return (void *)((AGVector3 *)  ((AGPoint3 *) x));
}
static void *_p_AGSDLEventTo_p_AGEvent(void *x) {
    return (void *)((AGEvent *)  ((AGSDLEvent *) x));
}
static void *_p_AGMouseEventTo_p_AGEvent(void *x) {
    return (void *)((AGEvent *)  ((AGMouseEvent *) x));
}
static void *_p_AGMenuEventTo_p_AGEvent(void *x) {
    return (void *)((AGEvent *)  ((AGMenuEvent *) x));
}
static void *_p_DomParserTo_p_Parser(void *x) {
    return (void *)((Parser *)  ((DomParser *) x));
}
static void *_p_AGCaptionTo_p_AGText(void *x) {
    return (void *)((AGText *)  ((AGCaption *) x));
}
static void *_p_AGSurfaceTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGSurface *) x));
}
static void *_p_AGSDLScreenTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *) (AGScreen *) ((AGSDLScreen *) x));
}
static void *_p_AGScreenTo_p_AGPaintTarget(void *x) {
    return (void *)((AGPaintTarget *)  ((AGScreen *) x));
}
static void *_p_AGWindowTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGTable *) ((AGWindow *) x));
}
static void *_p_AGListBoxTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGListBox *) x));
}
static void *_p_AGCaptionTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGText *) ((AGCaption *) x));
}
static void *_p_AGApplicationTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *) ((AGApplication *) x));
}
static void *_p_AGButtonTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGButton *) x));
}
static void *_p_AGVTilerTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGVTiler *) x));
}
static void *_p_AGTableTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGTable *) x));
}
static void *_p_AGWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *) ((AGWidget *) x));
}
static void *_p_AGMenuTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGVTiler *) ((AGMenu *) x));
}
static void *_p_AGEditTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGEdit *) x));
}
static void *_p_AGColorButtonTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGColorButton *) x));
}
static void *_p_AGHTilerTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGVTiler *) ((AGHTiler *) x));
}
static void *_p_AGScreenWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGScreenWidget *) x));
}
static void *_p_AGImageTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGImage *) x));
}
static void *_p_AGGLWidgetTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGGLWidget *) x));
}
static void *_p_AGCheckBoxTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGButton *) ((AGCheckBox *) x));
}
static void *_p_AGLayoutTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGLayout *) x));
}
static void *_p_AGMessageObjectTo_p_AGListener(void *x) {
    return (void *)((AGListener *)  ((AGMessageObject *) x));
}
static void *_p_AGRadioTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGButton *)(AGCheckBox *) ((AGRadio *) x));
}
static void *_p_AGDialogTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *)(AGLayout *) ((AGDialog *) x));
}
static void *_p_AGTextTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGText *) x));
}
static void *_p_AGRadioGroupTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGRadioGroup *) x));
}
static void *_p_AGSoundTo_p_AGListener(void *x) {
    return (void *)((AGListener *) (AGMessageObject *)(AGWidget *) ((AGSound *) x));
}
static swig_type_info _swigt__p_AGAngle = {"_p_AGAngle", "AGAngle *", 0, 0, 0};
static swig_type_info _swigt__p_AGApplication = {"_p_AGApplication", "AGApplication *", 0, 0, 0};
static swig_type_info _swigt__p_AGBackground = {"_p_AGBackground", "AGBackground *", 0, 0, 0};
static swig_type_info _swigt__p_AGBox3 = {"_p_AGBox3", "AGBox3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGButton = {"_p_AGButton", "AGButton *", 0, 0, 0};
static swig_type_info _swigt__p_AGCPPListener = {"_p_AGCPPListener", "AGCPPListener *", 0, 0, 0};
static swig_type_info _swigt__p_AGCaption = {"_p_AGCaption", "AGCaption *", 0, 0, 0};
static swig_type_info _swigt__p_AGCheckBox = {"_p_AGCheckBox", "AGCheckBox *", 0, 0, 0};
static swig_type_info _swigt__p_AGCircle2 = {"_p_AGCircle2", "AGCircle2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGCollisionData = {"_p_AGCollisionData", "AGCollisionData *", 0, 0, 0};
static swig_type_info _swigt__p_AGColor = {"_p_AGColor", "AGColor *", 0, 0, 0};
static swig_type_info _swigt__p_AGColorButton = {"_p_AGColorButton", "AGColorButton *", 0, 0, 0};
static swig_type_info _swigt__p_AGDialog = {"_p_AGDialog", "AGDialog *", 0, 0, 0};
static swig_type_info _swigt__p_AGEdit = {"_p_AGEdit", "AGEdit *", 0, 0, 0};
static swig_type_info _swigt__p_AGEditLine = {"_p_AGEditLine", "AGEditLine *", 0, 0, 0};
static swig_type_info _swigt__p_AGEvent = {"_p_AGEvent", "AGEvent *", 0, 0, 0};
static swig_type_info _swigt__p_AGFont = {"_p_AGFont", "AGFont *", 0, 0, 0};
static swig_type_info _swigt__p_AGFontEngine = {"_p_AGFontEngine", "AGFontEngine *", 0, 0, 0};
static swig_type_info _swigt__p_AGGLWidget = {"_p_AGGLWidget", "AGGLWidget *", 0, 0, 0};
static swig_type_info _swigt__p_AGHTiler = {"_p_AGHTiler", "AGHTiler *", 0, 0, 0};
static swig_type_info _swigt__p_AGImage = {"_p_AGImage", "AGImage *", 0, 0, 0};
static swig_type_info _swigt__p_AGLayout = {"_p_AGLayout", "AGLayout *", 0, 0, 0};
static swig_type_info _swigt__p_AGLayoutCreator = {"_p_AGLayoutCreator", "AGLayoutCreator *", 0, 0, 0};
static swig_type_info _swigt__p_AGLayoutFactory = {"_p_AGLayoutFactory", "AGLayoutFactory *", 0, 0, 0};
static swig_type_info _swigt__p_AGLine2 = {"_p_AGLine2", "AGLine2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGLine3 = {"_p_AGLine3", "AGLine3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGListBox = {"_p_AGListBox", "AGListBox *", 0, 0, 0};
static swig_type_info _swigt__p_AGListBoxItem = {"_p_AGListBoxItem", "AGListBoxItem *", 0, 0, 0};
static swig_type_info _swigt__p_AGListener = {"_p_AGListener", "AGListener *", 0, 0, 0};
static swig_type_info _swigt__p_AGMain = {"_p_AGMain", "AGMain *", 0, 0, 0};
static swig_type_info _swigt__p_AGMatrix3 = {"_p_AGMatrix3", "AGMatrix3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGMatrix4 = {"_p_AGMatrix4", "AGMatrix4 *", 0, 0, 0};
static swig_type_info _swigt__p_AGMenu = {"_p_AGMenu", "AGMenu *", 0, 0, 0};
static swig_type_info _swigt__p_AGMenuEvent = {"_p_AGMenuEvent", "AGMenuEvent *", 0, 0, 0};
static swig_type_info _swigt__p_AGMessageObject = {"_p_AGMessageObject", "AGMessageObject *", 0, 0, 0};
static swig_type_info _swigt__p_AGMouseEvent = {"_p_AGMouseEvent", "AGMouseEvent *", 0, 0, 0};
static swig_type_info _swigt__p_AGPaintTarget = {"_p_AGPaintTarget", "AGPaintTarget *", 0, 0, 0};
static swig_type_info _swigt__p_AGPainter = {"_p_AGPainter", "AGPainter *", 0, 0, 0};
static swig_type_info _swigt__p_AGPoint = {"_p_AGPoint", "AGPoint *", 0, 0, 0};
static swig_type_info _swigt__p_AGPoint3 = {"_p_AGPoint3", "AGPoint3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGRadio = {"_p_AGRadio", "AGRadio *", 0, 0, 0};
static swig_type_info _swigt__p_AGRadioGroup = {"_p_AGRadioGroup", "AGRadioGroup *", 0, 0, 0};
static swig_type_info _swigt__p_AGRect = {"_p_AGRect", "AGRect *", 0, 0, 0};
static swig_type_info _swigt__p_AGRect2 = {"_p_AGRect2", "AGRect2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGRect3 = {"_p_AGRect3", "AGRect3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGSDLEvent = {"_p_AGSDLEvent", "AGSDLEvent *", 0, 0, 0};
static swig_type_info _swigt__p_AGSDLScreen = {"_p_AGSDLScreen", "AGSDLScreen *", 0, 0, 0};
static swig_type_info _swigt__p_AGScreen = {"_p_AGScreen", "AGScreen *", 0, 0, 0};
static swig_type_info _swigt__p_AGScreenWidget = {"_p_AGScreenWidget", "AGScreenWidget *", 0, 0, 0};
static swig_type_info _swigt__p_AGSignal = {"_p_AGSignal", "AGSignal *", 0, 0, 0};
static swig_type_info _swigt__p_AGSound = {"_p_AGSound", "AGSound *", 0, 0, 0};
static swig_type_info _swigt__p_AGSurface = {"_p_AGSurface", "AGSurface *", 0, 0, 0};
static swig_type_info _swigt__p_AGSurfaceManager = {"_p_AGSurfaceManager", "AGSurfaceManager *", 0, 0, 0};
static swig_type_info _swigt__p_AGTable = {"_p_AGTable", "AGTable *", 0, 0, 0};
static swig_type_info _swigt__p_AGText = {"_p_AGText", "AGText *", 0, 0, 0};
static swig_type_info _swigt__p_AGTexture = {"_p_AGTexture", "AGTexture *", 0, 0, 0};
static swig_type_info _swigt__p_AGTextureManager = {"_p_AGTextureManager", "AGTextureManager *", 0, 0, 0};
static swig_type_info _swigt__p_AGTheme = {"_p_AGTheme", "AGTheme *", 0, 0, 0};
static swig_type_info _swigt__p_AGTriangle2 = {"_p_AGTriangle2", "AGTriangle2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGTriangle3 = {"_p_AGTriangle3", "AGTriangle3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGVTiler = {"_p_AGVTiler", "AGVTiler *", 0, 0, 0};
static swig_type_info _swigt__p_AGVector2 = {"_p_AGVector2", "AGVector2 *", 0, 0, 0};
static swig_type_info _swigt__p_AGVector3 = {"_p_AGVector3", "AGVector3 *", 0, 0, 0};
static swig_type_info _swigt__p_AGVector4 = {"_p_AGVector4", "AGVector4 *", 0, 0, 0};
static swig_type_info _swigt__p_AGWidget = {"_p_AGWidget", "AGWidget *", 0, 0, 0};
static swig_type_info _swigt__p_AGWindow = {"_p_AGWindow", "AGWindow *", 0, 0, 0};
static swig_type_info _swigt__p_Attributes = {"_p_Attributes", "Attributes *", 0, 0, 0};
static swig_type_info _swigt__p_Document = {"_p_Document", "Document *|xmlpp::Document *", 0, 0, 0};
static swig_type_info _swigt__p_DomParser = {"_p_DomParser", "DomParser *", 0, 0, 0};
static swig_type_info _swigt__p_GLuint = {"_p_GLuint", "GLuint *", 0, 0, 0};
static swig_type_info _swigt__p_Node = {"_p_Node", "Node *", 0, 0, 0};
static swig_type_info _swigt__p_NodeVector = {"_p_NodeVector", "NodeVector *", 0, 0, 0};
static swig_type_info _swigt__p_Node__NodeVector__const_iterator = {"_p_Node__NodeVector__const_iterator", "Node::NodeVector::const_iterator *|Node::const_iterator *", 0, 0, 0};
static swig_type_info _swigt__p_Node__NodeVector__iterator = {"_p_Node__NodeVector__iterator", "Node::NodeVector::iterator *|Node::iterator *", 0, 0, 0};
static swig_type_info _swigt__p_Parser = {"_p_Parser", "Parser *", 0, 0, 0};
static swig_type_info _swigt__p_SDLKey = {"_p_SDLKey", "enum SDLKey *|SDLKey *", 0, 0, 0};
static swig_type_info _swigt__p_SDLMod = {"_p_SDLMod", "enum SDLMod *|SDLMod *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_Event = {"_p_SDL_Event", "SDL_Event *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_PixelFormat = {"_p_SDL_PixelFormat", "SDL_PixelFormat *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_Rect = {"_p_SDL_Rect", "SDL_Rect *", 0, 0, 0};
static swig_type_info _swigt__p_SDL_Surface = {"_p_SDL_Surface", "SDL_Surface *", 0, 0, 0};
static swig_type_info _swigt__p_Uint32 = {"_p_Uint32", "Uint32 *", 0, 0, 0};
static swig_type_info _swigt__p_Uint8 = {"_p_Uint8", "Uint8 *", 0, 0, 0};
static swig_type_info _swigt__p_const_iterator = {"_p_const_iterator", "const_iterator *", 0, 0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *", 0, 0, 0};
static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, 0};
static swig_type_info _swigt__p_p_Node = {"_p_p_Node", "Node **", 0, 0, 0};
static swig_type_info _swigt__p_std__listTAGRect2_t = {"_p_std__listTAGRect2_t", "std::list<AGRect2 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__mapTstd__string_std__string_t = {"_p_std__mapTstd__string_std__string_t", "std::map<std::string,std::string > *|Node::Attributes *", 0, 0, 0};
static swig_type_info _swigt__p_std__ostringstream = {"_p_std__ostringstream", "std::ostringstream *", 0, 0, 0};
static swig_type_info _swigt__p_std__pairTstd__string_bool_t = {"_p_std__pairTstd__string_bool_t", "std::pair<std::string,bool > *", 0, 0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGBox3_t = {"_p_std__vectorTAGBox3_t", "std::vector<AGBox3 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGLine2_t = {"_p_std__vectorTAGLine2_t", "std::vector<AGLine2 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGRect3_t = {"_p_std__vectorTAGRect3_t", "std::vector<AGRect3 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGVector3_t = {"_p_std__vectorTAGVector3_t", "std::vector<AGVector3 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTAGVector4_t = {"_p_std__vectorTAGVector4_t", "std::vector<AGVector4 > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTNode_p_t = {"_p_std__vectorTNode_p_t", "std::vector<Node * > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTNode_t = {"_p_std__vectorTNode_t", "std::vector<Node > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTstd__string_t = {"_p_std__vectorTstd__string_t", "std::vector<std::string > *", 0, 0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "unsigned long *|VALUE *", 0, 0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_AGAngle,
  &_swigt__p_AGApplication,
  &_swigt__p_AGBackground,
  &_swigt__p_AGBox3,
  &_swigt__p_AGButton,
  &_swigt__p_AGCPPListener,
  &_swigt__p_AGCaption,
  &_swigt__p_AGCheckBox,
  &_swigt__p_AGCircle2,
  &_swigt__p_AGCollisionData,
  &_swigt__p_AGColor,
  &_swigt__p_AGColorButton,
  &_swigt__p_AGDialog,
  &_swigt__p_AGEdit,
  &_swigt__p_AGEditLine,
  &_swigt__p_AGEvent,
  &_swigt__p_AGFont,
  &_swigt__p_AGFontEngine,
  &_swigt__p_AGGLWidget,
  &_swigt__p_AGHTiler,
  &_swigt__p_AGImage,
  &_swigt__p_AGLayout,
  &_swigt__p_AGLayoutCreator,
  &_swigt__p_AGLayoutFactory,
  &_swigt__p_AGLine2,
  &_swigt__p_AGLine3,
  &_swigt__p_AGListBox,
  &_swigt__p_AGListBoxItem,
  &_swigt__p_AGListener,
  &_swigt__p_AGMain,
  &_swigt__p_AGMatrix3,
  &_swigt__p_AGMatrix4,
  &_swigt__p_AGMenu,
  &_swigt__p_AGMenuEvent,
  &_swigt__p_AGMessageObject,
  &_swigt__p_AGMouseEvent,
  &_swigt__p_AGPaintTarget,
  &_swigt__p_AGPainter,
  &_swigt__p_AGPoint,
  &_swigt__p_AGPoint3,
  &_swigt__p_AGRadio,
  &_swigt__p_AGRadioGroup,
  &_swigt__p_AGRect,
  &_swigt__p_AGRect2,
  &_swigt__p_AGRect3,
  &_swigt__p_AGSDLEvent,
  &_swigt__p_AGSDLScreen,
  &_swigt__p_AGScreen,
  &_swigt__p_AGScreenWidget,
  &_swigt__p_AGSignal,
  &_swigt__p_AGSound,
  &_swigt__p_AGSurface,
  &_swigt__p_AGSurfaceManager,
  &_swigt__p_AGTable,
  &_swigt__p_AGText,
  &_swigt__p_AGTexture,
  &_swigt__p_AGTextureManager,
  &_swigt__p_AGTheme,
  &_swigt__p_AGTriangle2,
  &_swigt__p_AGTriangle3,
  &_swigt__p_AGVTiler,
  &_swigt__p_AGVector2,
  &_swigt__p_AGVector3,
  &_swigt__p_AGVector4,
  &_swigt__p_AGWidget,
  &_swigt__p_AGWindow,
  &_swigt__p_Attributes,
  &_swigt__p_Document,
  &_swigt__p_DomParser,
  &_swigt__p_GLuint,
  &_swigt__p_Node,
  &_swigt__p_NodeVector,
  &_swigt__p_Node__NodeVector__const_iterator,
  &_swigt__p_Node__NodeVector__iterator,
  &_swigt__p_Parser,
  &_swigt__p_SDLKey,
  &_swigt__p_SDLMod,
  &_swigt__p_SDL_Event,
  &_swigt__p_SDL_PixelFormat,
  &_swigt__p_SDL_Rect,
  &_swigt__p_SDL_Surface,
  &_swigt__p_Uint32,
  &_swigt__p_Uint8,
  &_swigt__p_const_iterator,
  &_swigt__p_float,
  &_swigt__p_iterator,
  &_swigt__p_p_Node,
  &_swigt__p_std__listTAGRect2_t,
  &_swigt__p_std__mapTstd__string_std__string_t,
  &_swigt__p_std__ostringstream,
  &_swigt__p_std__pairTstd__string_bool_t,
  &_swigt__p_std__string,
  &_swigt__p_std__vectorTAGBox3_t,
  &_swigt__p_std__vectorTAGLine2_t,
  &_swigt__p_std__vectorTAGRect3_t,
  &_swigt__p_std__vectorTAGVector3_t,
  &_swigt__p_std__vectorTAGVector4_t,
  &_swigt__p_std__vectorTNode_p_t,
  &_swigt__p_std__vectorTNode_t,
  &_swigt__p_std__vectorTstd__string_t,
  &_swigt__p_unsigned_long,
};

static swig_cast_info _swigc__p_AGAngle[] = {  {&_swigt__p_AGAngle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGApplication[] = {  {&_swigt__p_AGApplication, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGBackground[] = {  {&_swigt__p_AGBackground, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGBox3[] = {  {&_swigt__p_AGBox3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGButton[] = {  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGButton, 0, 0},  {&_swigt__p_AGButton, 0, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGButton, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCPPListener[] = {  {&_swigt__p_AGCPPListener, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCaption[] = {  {&_swigt__p_AGCaption, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCheckBox[] = {  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGCheckBox, 0, 0},  {&_swigt__p_AGCheckBox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCircle2[] = {  {&_swigt__p_AGCircle2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGCollisionData[] = {  {&_swigt__p_AGCollisionData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGColor[] = {  {&_swigt__p_AGColor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGColorButton[] = {  {&_swigt__p_AGColorButton, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGDialog[] = {  {&_swigt__p_AGDialog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGEdit[] = {  {&_swigt__p_AGEdit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGEditLine[] = {  {&_swigt__p_AGEditLine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGEvent[] = {  {&_swigt__p_AGSDLEvent, _p_AGSDLEventTo_p_AGEvent, 0, 0},  {&_swigt__p_AGMouseEvent, _p_AGMouseEventTo_p_AGEvent, 0, 0},  {&_swigt__p_AGEvent, 0, 0, 0},  {&_swigt__p_AGMenuEvent, _p_AGMenuEventTo_p_AGEvent, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGFont[] = {  {&_swigt__p_AGFont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGFontEngine[] = {  {&_swigt__p_AGFontEngine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGGLWidget[] = {  {&_swigt__p_AGGLWidget, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGHTiler[] = {  {&_swigt__p_AGHTiler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGImage[] = {  {&_swigt__p_AGImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLayout[] = {  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGLayout, 0, 0},  {&_swigt__p_AGLayout, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLayoutCreator[] = {  {&_swigt__p_AGLayoutCreator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLayoutFactory[] = {  {&_swigt__p_AGLayoutFactory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLine2[] = {  {&_swigt__p_AGLine2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGLine3[] = {  {&_swigt__p_AGLine3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGListBox[] = {  {&_swigt__p_AGListBox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGListBoxItem[] = {  {&_swigt__p_AGListBoxItem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGListener[] = {  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGListener, 0, 0},  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGListener, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGListener, 0, 0},  {&_swigt__p_AGMenu, _p_AGMenuTo_p_AGListener, 0, 0},  {&_swigt__p_AGApplication, _p_AGApplicationTo_p_AGListener, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGListener, 0, 0},  {&_swigt__p_AGVTiler, _p_AGVTilerTo_p_AGListener, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGListener, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGListener, 0, 0},  {&_swigt__p_AGWidget, _p_AGWidgetTo_p_AGListener, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGListener, 0, 0},  {&_swigt__p_AGListener, 0, 0, 0},  {&_swigt__p_AGHTiler, _p_AGHTilerTo_p_AGListener, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGListener, 0, 0},  {&_swigt__p_AGScreenWidget, _p_AGScreenWidgetTo_p_AGListener, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGListener, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGListener, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGListener, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGListener, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGListener, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGListener, 0, 0},  {&_swigt__p_AGMessageObject, _p_AGMessageObjectTo_p_AGListener, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGListener, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGListener, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMain[] = {  {&_swigt__p_AGMain, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMatrix3[] = {  {&_swigt__p_AGMatrix3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMatrix4[] = {  {&_swigt__p_AGMatrix4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMenu[] = {  {&_swigt__p_AGMenu, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMenuEvent[] = {  {&_swigt__p_AGMenuEvent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMessageObject[] = {  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGMenu, _p_AGMenuTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGApplication, _p_AGApplicationTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGVTiler, _p_AGVTilerTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGWidget, _p_AGWidgetTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGHTiler, _p_AGHTilerTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGScreenWidget, _p_AGScreenWidgetTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGMessageObject, 0, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGMessageObject, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGMessageObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGMouseEvent[] = {  {&_swigt__p_AGMouseEvent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGPaintTarget[] = {  {&_swigt__p_AGPaintTarget, 0, 0, 0},  {&_swigt__p_AGSurface, _p_AGSurfaceTo_p_AGPaintTarget, 0, 0},  {&_swigt__p_AGSDLScreen, _p_AGSDLScreenTo_p_AGPaintTarget, 0, 0},  {&_swigt__p_AGScreen, _p_AGScreenTo_p_AGPaintTarget, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGPainter[] = {  {&_swigt__p_AGPainter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGPoint[] = {  {&_swigt__p_AGPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGPoint3[] = {  {&_swigt__p_AGPoint3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRadio[] = {  {&_swigt__p_AGRadio, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRadioGroup[] = {  {&_swigt__p_AGRadioGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRect[] = {  {&_swigt__p_AGRect, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRect2[] = {  {&_swigt__p_AGRect2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGRect3[] = {  {&_swigt__p_AGRect3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSDLEvent[] = {  {&_swigt__p_AGSDLEvent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSDLScreen[] = {  {&_swigt__p_AGSDLScreen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGScreen[] = {  {&_swigt__p_AGSDLScreen, _p_AGSDLScreenTo_p_AGScreen, 0, 0},  {&_swigt__p_AGScreen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGScreenWidget[] = {  {&_swigt__p_AGScreenWidget, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSignal[] = {  {&_swigt__p_AGSignal, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSound[] = {  {&_swigt__p_AGSound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSurface[] = {  {&_swigt__p_AGSurface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGSurfaceManager[] = {  {&_swigt__p_AGSurfaceManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTable[] = {  {&_swigt__p_AGTable, 0, 0, 0},  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGTable, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGText[] = {  {&_swigt__p_AGText, 0, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGText, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTexture[] = {  {&_swigt__p_AGTexture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTextureManager[] = {  {&_swigt__p_AGTextureManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTheme[] = {  {&_swigt__p_AGTheme, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTriangle2[] = {  {&_swigt__p_AGTriangle2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGTriangle3[] = {  {&_swigt__p_AGTriangle3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVTiler[] = {  {&_swigt__p_AGVTiler, 0, 0, 0},  {&_swigt__p_AGHTiler, _p_AGHTilerTo_p_AGVTiler, 0, 0},  {&_swigt__p_AGMenu, _p_AGMenuTo_p_AGVTiler, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVector2[] = {  {&_swigt__p_AGVector2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVector3[] = {  {&_swigt__p_AGPoint3, _p_AGPoint3To_p_AGVector3, 0, 0},  {&_swigt__p_AGVector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGVector4[] = {  {&_swigt__p_AGVector4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGWidget[] = {  {&_swigt__p_AGWindow, _p_AGWindowTo_p_AGWidget, 0, 0},  {&_swigt__p_AGListBox, _p_AGListBoxTo_p_AGWidget, 0, 0},  {&_swigt__p_AGCaption, _p_AGCaptionTo_p_AGWidget, 0, 0},  {&_swigt__p_AGMenu, _p_AGMenuTo_p_AGWidget, 0, 0},  {&_swigt__p_AGButton, _p_AGButtonTo_p_AGWidget, 0, 0},  {&_swigt__p_AGVTiler, _p_AGVTilerTo_p_AGWidget, 0, 0},  {&_swigt__p_AGEdit, _p_AGEditTo_p_AGWidget, 0, 0},  {&_swigt__p_AGTable, _p_AGTableTo_p_AGWidget, 0, 0},  {&_swigt__p_AGWidget, 0, 0, 0},  {&_swigt__p_AGColorButton, _p_AGColorButtonTo_p_AGWidget, 0, 0},  {&_swigt__p_AGHTiler, _p_AGHTilerTo_p_AGWidget, 0, 0},  {&_swigt__p_AGGLWidget, _p_AGGLWidgetTo_p_AGWidget, 0, 0},  {&_swigt__p_AGScreenWidget, _p_AGScreenWidgetTo_p_AGWidget, 0, 0},  {&_swigt__p_AGImage, _p_AGImageTo_p_AGWidget, 0, 0},  {&_swigt__p_AGText, _p_AGTextTo_p_AGWidget, 0, 0},  {&_swigt__p_AGCheckBox, _p_AGCheckBoxTo_p_AGWidget, 0, 0},  {&_swigt__p_AGLayout, _p_AGLayoutTo_p_AGWidget, 0, 0},  {&_swigt__p_AGRadio, _p_AGRadioTo_p_AGWidget, 0, 0},  {&_swigt__p_AGDialog, _p_AGDialogTo_p_AGWidget, 0, 0},  {&_swigt__p_AGRadioGroup, _p_AGRadioGroupTo_p_AGWidget, 0, 0},  {&_swigt__p_AGSound, _p_AGSoundTo_p_AGWidget, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AGWindow[] = {  {&_swigt__p_AGWindow, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Attributes[] = {  {&_swigt__p_Attributes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Document[] = {  {&_swigt__p_Document, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DomParser[] = {  {&_swigt__p_DomParser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLuint[] = {  {&_swigt__p_GLuint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Node[] = {  {&_swigt__p_Node, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NodeVector[] = {  {&_swigt__p_NodeVector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Node__NodeVector__const_iterator[] = {  {&_swigt__p_Node__NodeVector__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Node__NodeVector__iterator[] = {  {&_swigt__p_Node__NodeVector__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Parser[] = {  {&_swigt__p_Parser, 0, 0, 0},  {&_swigt__p_DomParser, _p_DomParserTo_p_Parser, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDLKey[] = {  {&_swigt__p_SDLKey, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDLMod[] = {  {&_swigt__p_SDLMod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_Event[] = {  {&_swigt__p_SDL_Event, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_PixelFormat[] = {  {&_swigt__p_SDL_PixelFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_Rect[] = {  {&_swigt__p_SDL_Rect, 0, 0, 0},  {&_swigt__p_AGRect, _p_AGRectTo_p_SDL_Rect, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDL_Surface[] = {  {&_swigt__p_SDL_Surface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Uint32[] = {  {&_swigt__p_Uint32, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Uint8[] = {  {&_swigt__p_Uint8, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_iterator[] = {  {&_swigt__p_const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_Node[] = {  {&_swigt__p_p_Node, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listTAGRect2_t[] = {  {&_swigt__p_std__listTAGRect2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTstd__string_std__string_t[] = {  {&_swigt__p_std__mapTstd__string_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostringstream[] = {  {&_swigt__p_std__ostringstream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairTstd__string_bool_t[] = {  {&_swigt__p_std__pairTstd__string_bool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGBox3_t[] = {  {&_swigt__p_std__vectorTAGBox3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGLine2_t[] = {  {&_swigt__p_std__vectorTAGLine2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGRect3_t[] = {  {&_swigt__p_std__vectorTAGRect3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGVector3_t[] = {  {&_swigt__p_std__vectorTAGVector3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAGVector4_t[] = {  {&_swigt__p_std__vectorTAGVector4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTNode_p_t[] = {  {&_swigt__p_std__vectorTNode_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTNode_t[] = {  {&_swigt__p_std__vectorTNode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__string_t[] = {  {&_swigt__p_std__vectorTstd__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_AGAngle,
  _swigc__p_AGApplication,
  _swigc__p_AGBackground,
  _swigc__p_AGBox3,
  _swigc__p_AGButton,
  _swigc__p_AGCPPListener,
  _swigc__p_AGCaption,
  _swigc__p_AGCheckBox,
  _swigc__p_AGCircle2,
  _swigc__p_AGCollisionData,
  _swigc__p_AGColor,
  _swigc__p_AGColorButton,
  _swigc__p_AGDialog,
  _swigc__p_AGEdit,
  _swigc__p_AGEditLine,
  _swigc__p_AGEvent,
  _swigc__p_AGFont,
  _swigc__p_AGFontEngine,
  _swigc__p_AGGLWidget,
  _swigc__p_AGHTiler,
  _swigc__p_AGImage,
  _swigc__p_AGLayout,
  _swigc__p_AGLayoutCreator,
  _swigc__p_AGLayoutFactory,
  _swigc__p_AGLine2,
  _swigc__p_AGLine3,
  _swigc__p_AGListBox,
  _swigc__p_AGListBoxItem,
  _swigc__p_AGListener,
  _swigc__p_AGMain,
  _swigc__p_AGMatrix3,
  _swigc__p_AGMatrix4,
  _swigc__p_AGMenu,
  _swigc__p_AGMenuEvent,
  _swigc__p_AGMessageObject,
  _swigc__p_AGMouseEvent,
  _swigc__p_AGPaintTarget,
  _swigc__p_AGPainter,
  _swigc__p_AGPoint,
  _swigc__p_AGPoint3,
  _swigc__p_AGRadio,
  _swigc__p_AGRadioGroup,
  _swigc__p_AGRect,
  _swigc__p_AGRect2,
  _swigc__p_AGRect3,
  _swigc__p_AGSDLEvent,
  _swigc__p_AGSDLScreen,
  _swigc__p_AGScreen,
  _swigc__p_AGScreenWidget,
  _swigc__p_AGSignal,
  _swigc__p_AGSound,
  _swigc__p_AGSurface,
  _swigc__p_AGSurfaceManager,
  _swigc__p_AGTable,
  _swigc__p_AGText,
  _swigc__p_AGTexture,
  _swigc__p_AGTextureManager,
  _swigc__p_AGTheme,
  _swigc__p_AGTriangle2,
  _swigc__p_AGTriangle3,
  _swigc__p_AGVTiler,
  _swigc__p_AGVector2,
  _swigc__p_AGVector3,
  _swigc__p_AGVector4,
  _swigc__p_AGWidget,
  _swigc__p_AGWindow,
  _swigc__p_Attributes,
  _swigc__p_Document,
  _swigc__p_DomParser,
  _swigc__p_GLuint,
  _swigc__p_Node,
  _swigc__p_NodeVector,
  _swigc__p_Node__NodeVector__const_iterator,
  _swigc__p_Node__NodeVector__iterator,
  _swigc__p_Parser,
  _swigc__p_SDLKey,
  _swigc__p_SDLMod,
  _swigc__p_SDL_Event,
  _swigc__p_SDL_PixelFormat,
  _swigc__p_SDL_Rect,
  _swigc__p_SDL_Surface,
  _swigc__p_Uint32,
  _swigc__p_Uint8,
  _swigc__p_const_iterator,
  _swigc__p_float,
  _swigc__p_iterator,
  _swigc__p_p_Node,
  _swigc__p_std__listTAGRect2_t,
  _swigc__p_std__mapTstd__string_std__string_t,
  _swigc__p_std__ostringstream,
  _swigc__p_std__pairTstd__string_bool_t,
  _swigc__p_std__string,
  _swigc__p_std__vectorTAGBox3_t,
  _swigc__p_std__vectorTAGLine2_t,
  _swigc__p_std__vectorTAGRect3_t,
  _swigc__p_std__vectorTAGVector3_t,
  _swigc__p_std__vectorTAGVector4_t,
  _swigc__p_std__vectorTNode_p_t,
  _swigc__p_std__vectorTNode_t,
  _swigc__p_std__vectorTstd__string_t,
  _swigc__p_unsigned_long,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/*************************************************************************
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.

 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop though that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.

 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
**/

#ifdef __cplusplus
extern "C" {
#endif

SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  swig_type_info *type, *ret;
  swig_cast_info *cast;
  size_t i;
  swig_module_info *module_head;
  static int init_run = 0;

  clientdata = clientdata;

  if (init_run) return;
  init_run = 1;

  /* Initialize the swig_module */
  swig_module.type_initial = swig_type_initial;
  swig_module.cast_initial = swig_cast_initial;

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (module_head) {
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  } else {
    /* This is the first module loaded */
    swig_module.next = &swig_module;
    SWIG_SetModule(clientdata, &swig_module);
  }
		 
  /* Now work on filling in swig_module.types */
  for (i = 0; i < swig_module.size; ++i) {
    type = 0;

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
      if (swig_module.type_initial[i]->clientdata) type->clientdata = swig_module.type_initial[i]->clientdata;
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
      }
      if (ret && type == swig_module.type_initial[i]) {
        cast->type = ret;
        ret = 0;
      }
      
      if (!ret) {
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }

      cast++;
    }

    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_libantargisgui(void) {
    int i;
    
    SWIG_InitRuntime();
    mLibantargisgui = rb_define_module("Libantargisgui");
    
    SWIG_InitializeModule(0);
    for (i = 0; i < swig_module.size; i++) {
        SWIG_define_class(swig_module.types[i]);
    }
    
    
    cStringVector.klass = rb_define_class_under(mLibantargisgui, "StringVector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__string_t, (void *) &cStringVector);
    rb_include_module(cStringVector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cStringVector.klass, _wrap_StringVector_allocate);
    rb_define_method(cStringVector.klass, "initialize", VALUEFUNC(_wrap_new_StringVector), -1);
    rb_define_method(cStringVector.klass, "length", VALUEFUNC(_wrap_StringVector___len__), -1);
    rb_define_method(cStringVector.klass, "empty?", VALUEFUNC(_wrap_StringVector_emptyq___), -1);
    rb_define_method(cStringVector.klass, "clear", VALUEFUNC(_wrap_StringVector_clear), -1);
    rb_define_method(cStringVector.klass, "push", VALUEFUNC(_wrap_StringVector_push), -1);
    rb_define_method(cStringVector.klass, "pop", VALUEFUNC(_wrap_StringVector_pop), -1);
    rb_define_method(cStringVector.klass, "[]", VALUEFUNC(_wrap_StringVector___getitem__), -1);
    rb_define_method(cStringVector.klass, "[]=", VALUEFUNC(_wrap_StringVector___setitem__), -1);
    rb_define_method(cStringVector.klass, "each", VALUEFUNC(_wrap_StringVector_each), -1);
    cStringVector.mark = 0;
    cStringVector.destroy = (void (*)(void *)) free_std_vector_Sl_std_string_Sg_;
    
    cLine2Vector.klass = rb_define_class_under(mLibantargisgui, "Line2Vector", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTAGLine2_t, (void *) &cLine2Vector);
    rb_include_module(cLine2Vector.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cLine2Vector.klass, _wrap_Line2Vector_allocate);
    rb_define_method(cLine2Vector.klass, "initialize", VALUEFUNC(_wrap_new_Line2Vector), -1);
    rb_define_method(cLine2Vector.klass, "length", VALUEFUNC(_wrap_Line2Vector___len__), -1);
    rb_define_method(cLine2Vector.klass, "empty?", VALUEFUNC(_wrap_Line2Vector_emptyq___), -1);
    rb_define_method(cLine2Vector.klass, "clear", VALUEFUNC(_wrap_Line2Vector_clear), -1);
    rb_define_method(cLine2Vector.klass, "push", VALUEFUNC(_wrap_Line2Vector_push), -1);
    rb_define_method(cLine2Vector.klass, "pop", VALUEFUNC(_wrap_Line2Vector_pop), -1);
    rb_define_method(cLine2Vector.klass, "[]", VALUEFUNC(_wrap_Line2Vector___getitem__), -1);
    rb_define_method(cLine2Vector.klass, "[]=", VALUEFUNC(_wrap_Line2Vector___setitem__), -1);
    rb_define_method(cLine2Vector.klass, "each", VALUEFUNC(_wrap_Line2Vector_each), -1);
    cLine2Vector.mark = 0;
    cLine2Vector.destroy = (void (*)(void *)) free_std_vector_Sl_AGLine2_Sg_;
    
    cAGMain.klass = rb_define_class_under(mLibantargisgui, "AGMain", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMain, (void *) &cAGMain);
    rb_define_alloc_func(cAGMain.klass, _wrap_AGMain_allocate);
    rb_define_method(cAGMain.klass, "initialize", VALUEFUNC(_wrap_new_AGMain), -1);
    rb_define_method(cAGMain.klass, "flip", VALUEFUNC(_wrap_AGMain_flip), -1);
    rb_define_method(cAGMain.klass, "changeRes", VALUEFUNC(_wrap_AGMain_changeRes), -1);
    rb_define_method(cAGMain.klass, "toggleFull", VALUEFUNC(_wrap_AGMain_toggleFull), -1);
    rb_define_method(cAGMain.klass, "width", VALUEFUNC(_wrap_AGMain_width), -1);
    rb_define_method(cAGMain.klass, "height", VALUEFUNC(_wrap_AGMain_height), -1);
    rb_define_method(cAGMain.klass, "setIcon", VALUEFUNC(_wrap_AGMain_setIcon), -1);
    rb_define_method(cAGMain.klass, "setCaption", VALUEFUNC(_wrap_AGMain_setCaption), -1);
    cAGMain.mark = 0;
    cAGMain.destroy = (void (*)(void *)) free_AGMain;
    rb_define_module_function(mLibantargisgui, "getMain", VALUEFUNC(_wrap_getMain), -1);
    rb_define_module_function(mLibantargisgui, "hasQuit", VALUEFUNC(_wrap_hasQuit), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGSurface", VALUEFUNC(_wrap_disown_AGSurface), -1);
    
    cAGSurface.klass = rb_define_class_under(mLibantargisgui, "AGSurface", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGSurface, (void *) &cAGSurface);
    rb_define_alloc_func(cAGSurface.klass, _wrap_AGSurface_allocate);
    rb_define_method(cAGSurface.klass, "initialize", VALUEFUNC(_wrap_new_AGSurface), -1);
    rb_define_method(cAGSurface.klass, "width", VALUEFUNC(_wrap_AGSurface_width), -1);
    rb_define_method(cAGSurface.klass, "height", VALUEFUNC(_wrap_AGSurface_height), -1);
    rb_define_method(cAGSurface.klass, "surface", VALUEFUNC(_wrap_AGSurface_surface), -1);
    rb_define_method(cAGSurface.klass, "getRect", VALUEFUNC(_wrap_AGSurface_getRect), -1);
    rb_define_method(cAGSurface.klass, "getSubSurface", VALUEFUNC(_wrap_AGSurface_getSubSurface), -1);
    rb_define_method(cAGSurface.klass, "clone", VALUEFUNC(_wrap_AGSurface_clone), -1);
    rb_define_method(cAGSurface.klass, "valid", VALUEFUNC(_wrap_AGSurface_valid), -1);
    rb_define_method(cAGSurface.klass, "blit", VALUEFUNC(_wrap_AGSurface_blit), -1);
    rb_define_method(cAGSurface.klass, "drawGradient", VALUEFUNC(_wrap_AGSurface_drawGradient), -1);
    rb_define_method(cAGSurface.klass, "drawGradientAlpha", VALUEFUNC(_wrap_AGSurface_drawGradientAlpha), -1);
    rb_define_method(cAGSurface.klass, "drawBorder", VALUEFUNC(_wrap_AGSurface_drawBorder), -1);
    rb_define_method(cAGSurface.klass, "putPixel", VALUEFUNC(_wrap_AGSurface_putPixel), -1);
    rb_define_method(cAGSurface.klass, "getPixel", VALUEFUNC(_wrap_AGSurface_getPixel), -1);
    cAGSurface.mark = 0;
    cAGSurface.destroy = (void (*)(void *)) free_AGSurface;
    
    cAGTexture.klass = rb_define_class_under(mLibantargisgui, "AGTexture", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTexture, (void *) &cAGTexture);
    rb_define_alloc_func(cAGTexture.klass, _wrap_AGTexture_allocate);
    rb_define_method(cAGTexture.klass, "initialize", VALUEFUNC(_wrap_new_AGTexture), -1);
    rb_define_method(cAGTexture.klass, "width", VALUEFUNC(_wrap_AGTexture_width), -1);
    rb_define_method(cAGTexture.klass, "height", VALUEFUNC(_wrap_AGTexture_height), -1);
    rb_define_method(cAGTexture.klass, "testSave", VALUEFUNC(_wrap_AGTexture_testSave), -1);
    rb_define_method(cAGTexture.klass, "getRect", VALUEFUNC(_wrap_AGTexture_getRect), -1);
    rb_define_method(cAGTexture.klass, "getPixel", VALUEFUNC(_wrap_AGTexture_getPixel), -1);
    rb_define_method(cAGTexture.klass, "getTW", VALUEFUNC(_wrap_AGTexture_getTW), -1);
    rb_define_method(cAGTexture.klass, "getTH", VALUEFUNC(_wrap_AGTexture_getTH), -1);
    rb_define_method(cAGTexture.klass, "hasTexture", VALUEFUNC(_wrap_AGTexture_hasTexture), -1);
    rb_define_method(cAGTexture.klass, "textureUsed", VALUEFUNC(_wrap_AGTexture_textureUsed), -1);
    rb_define_method(cAGTexture.klass, "clearTexture", VALUEFUNC(_wrap_AGTexture_clearTexture), -1);
    rb_define_method(cAGTexture.klass, "clearTextureUsed", VALUEFUNC(_wrap_AGTexture_clearTextureUsed), -1);
    rb_define_method(cAGTexture.klass, "setTextureID", VALUEFUNC(_wrap_AGTexture_setTextureID), -1);
    rb_define_method(cAGTexture.klass, "getTextureID", VALUEFUNC(_wrap_AGTexture_getTextureID), -1);
    rb_define_method(cAGTexture.klass, "surface", VALUEFUNC(_wrap_AGTexture_surface), -1);
    cAGTexture.mark = 0;
    cAGTexture.destroy = (void (*)(void *)) free_AGTexture;
    rb_define_module_function(mLibantargisgui, "disown_AGScreen", VALUEFUNC(_wrap_disown_AGScreen), -1);
    
    cAGScreen.klass = rb_define_class_under(mLibantargisgui, "AGScreen", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGScreen, (void *) &cAGScreen);
    rb_define_alloc_func(cAGScreen.klass, _wrap_AGScreen_allocate);
    rb_define_method(cAGScreen.klass, "initialize", VALUEFUNC(_wrap_new_AGScreen), -1);
    rb_define_method(cAGScreen.klass, "begin", VALUEFUNC(_wrap_AGScreen_begin), -1);
    rb_define_method(cAGScreen.klass, "flip", VALUEFUNC(_wrap_AGScreen_flip), -1);
    rb_define_method(cAGScreen.klass, "getWidth", VALUEFUNC(_wrap_AGScreen_getWidth), -1);
    rb_define_method(cAGScreen.klass, "getHeight", VALUEFUNC(_wrap_AGScreen_getHeight), -1);
    cAGScreen.mark = 0;
    cAGScreen.destroy = (void (*)(void *)) free_AGScreen;
    rb_define_module_function(mLibantargisgui, "getScreen", VALUEFUNC(_wrap_getScreen), -1);
    rb_define_module_function(mLibantargisgui, "setScreen", VALUEFUNC(_wrap_setScreen), -1);
    rb_define_module_function(mLibantargisgui, "getSurfaceManager", VALUEFUNC(_wrap_getSurfaceManager), -1);
    
    cAGSurfaceManager.klass = rb_define_class_under(mLibantargisgui, "AGSurfaceManager", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGSurfaceManager, (void *) &cAGSurfaceManager);
    rb_undef_alloc_func(cAGSurfaceManager.klass);
    rb_define_method(cAGSurfaceManager.klass, "loadSurface", VALUEFUNC(_wrap_AGSurfaceManager_loadSurface), -1);
    rb_define_method(cAGSurfaceManager.klass, "fromSDL", VALUEFUNC(_wrap_AGSurfaceManager_fromSDL), -1);
    rb_define_method(cAGSurfaceManager.klass, "registerSurface", VALUEFUNC(_wrap_AGSurfaceManager_registerSurface), -1);
    rb_define_method(cAGSurfaceManager.klass, "deregisterSurface", VALUEFUNC(_wrap_AGSurfaceManager_deregisterSurface), -1);
    rb_define_method(cAGSurfaceManager.klass, "cleanup", VALUEFUNC(_wrap_AGSurfaceManager_cleanup), -1);
    rb_define_method(cAGSurfaceManager.klass, "enableGC", VALUEFUNC(_wrap_AGSurfaceManager_enableGC), -1);
    rb_define_method(cAGSurfaceManager.klass, "disableGC", VALUEFUNC(_wrap_AGSurfaceManager_disableGC), -1);
    cAGSurfaceManager.mark = 0;
    cAGSurfaceManager.destroy = (void (*)(void *)) free_AGSurfaceManager;
    rb_define_module_function(mLibantargisgui, "getTextureManager", VALUEFUNC(_wrap_getTextureManager), -1);
    
    cAGTextureManager.klass = rb_define_class_under(mLibantargisgui, "AGTextureManager", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTextureManager, (void *) &cAGTextureManager);
    rb_undef_alloc_func(cAGTextureManager.klass);
    rb_define_method(cAGTextureManager.klass, "registerTexture", VALUEFUNC(_wrap_AGTextureManager_registerTexture), -1);
    rb_define_method(cAGTextureManager.klass, "deregisterTexture", VALUEFUNC(_wrap_AGTextureManager_deregisterTexture), -1);
    rb_define_method(cAGTextureManager.klass, "cleanup", VALUEFUNC(_wrap_AGTextureManager_cleanup), -1);
    rb_define_method(cAGTextureManager.klass, "checkUnused", VALUEFUNC(_wrap_AGTextureManager_checkUnused), -1);
    rb_define_method(cAGTextureManager.klass, "makeTexture", VALUEFUNC(_wrap_AGTextureManager_makeTexture), -1);
    rb_define_method(cAGTextureManager.klass, "makeTexture3D", VALUEFUNC(_wrap_AGTextureManager_makeTexture3D), -1);
    rb_define_method(cAGTextureManager.klass, "clear", VALUEFUNC(_wrap_AGTextureManager_clear), -1);
    cAGTextureManager.mark = 0;
    cAGTextureManager.destroy = (void (*)(void *)) free_AGTextureManager;
    rb_define_module_function(mLibantargisgui, "disown_AGSDLScreen", VALUEFUNC(_wrap_disown_AGSDLScreen), -1);
    
    cAGSDLScreen.klass = rb_define_class_under(mLibantargisgui, "AGSDLScreen", ((swig_class *) SWIGTYPE_p_AGScreen->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSDLScreen, (void *) &cAGSDLScreen);
    rb_define_alloc_func(cAGSDLScreen.klass, _wrap_AGSDLScreen_allocate);
    rb_define_method(cAGSDLScreen.klass, "initialize", VALUEFUNC(_wrap_new_AGSDLScreen), -1);
    rb_define_method(cAGSDLScreen.klass, "blit", VALUEFUNC(_wrap_AGSDLScreen_blit), -1);
    rb_define_method(cAGSDLScreen.klass, "tile", VALUEFUNC(_wrap_AGSDLScreen_tile), -1);
    rb_define_method(cAGSDLScreen.klass, "flip", VALUEFUNC(_wrap_AGSDLScreen_flip), -1);
    rb_define_method(cAGSDLScreen.klass, "getRect", VALUEFUNC(_wrap_AGSDLScreen_getRect), -1);
    rb_define_method(cAGSDLScreen.klass, "drawRect", VALUEFUNC(_wrap_AGSDLScreen_drawRect), -1);
    rb_define_method(cAGSDLScreen.klass, "drawLine", VALUEFUNC(_wrap_AGSDLScreen_drawLine), -1);
    rb_define_method(cAGSDLScreen.klass, "drawGradientAlpha", VALUEFUNC(_wrap_AGSDLScreen_drawGradientAlpha), -1);
    rb_define_method(cAGSDLScreen.klass, "drawGradient", VALUEFUNC(_wrap_AGSDLScreen_drawGradient), -1);
    rb_define_method(cAGSDLScreen.klass, "renderText", VALUEFUNC(_wrap_AGSDLScreen_renderText), -1);
    rb_define_method(cAGSDLScreen.klass, "drawBorder", VALUEFUNC(_wrap_AGSDLScreen_drawBorder), -1);
    rb_define_method(cAGSDLScreen.klass, "putPixel", VALUEFUNC(_wrap_AGSDLScreen_putPixel), -1);
    rb_define_method(cAGSDLScreen.klass, "newSurface", VALUEFUNC(_wrap_AGSDLScreen_newSurface), -1);
    rb_define_method(cAGSDLScreen.klass, "loadSurface", VALUEFUNC(_wrap_AGSDLScreen_loadSurface), -1);
    rb_define_method(cAGSDLScreen.klass, "displayFormat", VALUEFUNC(_wrap_AGSDLScreen_displayFormat), -1);
    rb_define_method(cAGSDLScreen.klass, "makeTexture", VALUEFUNC(_wrap_AGSDLScreen_makeTexture), -1);
    rb_define_method(cAGSDLScreen.klass, "getWidth", VALUEFUNC(_wrap_AGSDLScreen_getWidth), -1);
    rb_define_method(cAGSDLScreen.klass, "getHeight", VALUEFUNC(_wrap_AGSDLScreen_getHeight), -1);
    cAGSDLScreen.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGSDLScreen.destroy = (void (*)(void *)) free_AGSDLScreen;
    rb_define_module_function(mLibantargisgui, "disown_AGEvent", VALUEFUNC(_wrap_disown_AGEvent), -1);
    
    cAGEvent.klass = rb_define_class_under(mLibantargisgui, "AGEvent", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGEvent, (void *) &cAGEvent);
    rb_define_alloc_func(cAGEvent.klass, _wrap_AGEvent_allocate);
    rb_define_method(cAGEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGEvent), -1);
    rb_define_method(cAGEvent.klass, "getCaller", VALUEFUNC(_wrap_AGEvent_getCaller), -1);
    cAGEvent.mark = 0;
    cAGEvent.destroy = (void (*)(void *)) free_AGEvent;
    rb_define_module_function(mLibantargisgui, "disown_AGSDLEvent", VALUEFUNC(_wrap_disown_AGSDLEvent), -1);
    
    cAGSDLEvent.klass = rb_define_class_under(mLibantargisgui, "AGSDLEvent", ((swig_class *) SWIGTYPE_p_AGEvent->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSDLEvent, (void *) &cAGSDLEvent);
    rb_define_alloc_func(cAGSDLEvent.klass, _wrap_AGSDLEvent_allocate);
    rb_define_method(cAGSDLEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGSDLEvent), -1);
    rb_define_method(cAGSDLEvent.klass, "getMousePosition", VALUEFUNC(_wrap_AGSDLEvent_getMousePosition), -1);
    rb_define_method(cAGSDLEvent.klass, "getKey", VALUEFUNC(_wrap_AGSDLEvent_getKey), -1);
    rb_define_method(cAGSDLEvent.klass, "getMod", VALUEFUNC(_wrap_AGSDLEvent_getMod), -1);
    rb_define_method(cAGSDLEvent.klass, "getButton", VALUEFUNC(_wrap_AGSDLEvent_getButton), -1);
    rb_define_method(cAGSDLEvent.klass, "get", VALUEFUNC(_wrap_AGSDLEvent_get), -1);
    cAGSDLEvent.mark = 0;
    cAGSDLEvent.destroy = (void (*)(void *)) free_AGSDLEvent;
    rb_define_module_function(mLibantargisgui, "disown_AGMouseEvent", VALUEFUNC(_wrap_disown_AGMouseEvent), -1);
    
    cAGMouseEvent.klass = rb_define_class_under(mLibantargisgui, "AGMouseEvent", ((swig_class *) SWIGTYPE_p_AGEvent->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMouseEvent, (void *) &cAGMouseEvent);
    rb_define_alloc_func(cAGMouseEvent.klass, _wrap_AGMouseEvent_allocate);
    rb_define_method(cAGMouseEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGMouseEvent), -1);
    cAGMouseEvent.mark = 0;
    cAGMouseEvent.destroy = (void (*)(void *)) free_AGMouseEvent;
    rb_define_module_function(mLibantargisgui, "disown_AGListener", VALUEFUNC(_wrap_disown_AGListener), -1);
    
    cAGListener.klass = rb_define_class_under(mLibantargisgui, "AGListener", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGListener, (void *) &cAGListener);
    rb_define_alloc_func(cAGListener.klass, _wrap_AGListener_allocate);
    rb_define_method(cAGListener.klass, "initialize", VALUEFUNC(_wrap_new_AGListener), -1);
    rb_define_method(cAGListener.klass, "signal", VALUEFUNC(_wrap_AGListener_signal), -1);
    cAGListener.mark = 0;
    cAGListener.destroy = (void (*)(void *)) free_AGListener;
    rb_define_module_function(mLibantargisgui, "disown_AGCPPListener", VALUEFUNC(_wrap_disown_AGCPPListener), -1);
    
    cAGCPPListener.klass = rb_define_class_under(mLibantargisgui, "AGCPPListener", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCPPListener, (void *) &cAGCPPListener);
    rb_define_alloc_func(cAGCPPListener.klass, _wrap_AGCPPListener_allocate);
    rb_define_method(cAGCPPListener.klass, "initialize", VALUEFUNC(_wrap_new_AGCPPListener), -1);
    rb_define_method(cAGCPPListener.klass, "signal", VALUEFUNC(_wrap_AGCPPListener_signal), -1);
    cAGCPPListener.mark = 0;
    cAGCPPListener.destroy = (void (*)(void *)) free_AGCPPListener;
    rb_define_module_function(mLibantargisgui, "disown_AGSignal", VALUEFUNC(_wrap_disown_AGSignal), -1);
    
    cAGSignal.klass = rb_define_class_under(mLibantargisgui, "AGSignal", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGSignal, (void *) &cAGSignal);
    rb_define_alloc_func(cAGSignal.klass, _wrap_AGSignal_allocate);
    rb_define_method(cAGSignal.klass, "initialize", VALUEFUNC(_wrap_new_AGSignal), -1);
    rb_define_method(cAGSignal.klass, "connect", VALUEFUNC(_wrap_AGSignal_connect), -1);
    rb_define_method(cAGSignal.klass, "disconnect", VALUEFUNC(_wrap_AGSignal_disconnect), -1);
    rb_define_method(cAGSignal.klass, "signal", VALUEFUNC(_wrap_AGSignal_signal), -1);
    rb_define_method(cAGSignal.klass, "call", VALUEFUNC(_wrap_AGSignal___call__), -1);
    cAGSignal.mark = 0;
    cAGSignal.destroy = (void (*)(void *)) free_AGSignal;
    rb_define_module_function(mLibantargisgui, "disown_AGMessageObject", VALUEFUNC(_wrap_disown_AGMessageObject), -1);
    
    cAGMessageObject.klass = rb_define_class_under(mLibantargisgui, "AGMessageObject", ((swig_class *) SWIGTYPE_p_AGListener->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMessageObject, (void *) &cAGMessageObject);
    rb_define_alloc_func(cAGMessageObject.klass, _wrap_AGMessageObject_allocate);
    rb_define_method(cAGMessageObject.klass, "initialize", VALUEFUNC(_wrap_new_AGMessageObject), -1);
    rb_define_method(cAGMessageObject.klass, "processEvent", VALUEFUNC(_wrap_AGMessageObject_processEvent), -1);
    rb_define_method(cAGMessageObject.klass, "acceptEvent", VALUEFUNC(_wrap_AGMessageObject_acceptEvent), -1);
    rb_define_method(cAGMessageObject.klass, "eventActive", VALUEFUNC(_wrap_AGMessageObject_eventActive), -1);
    rb_define_method(cAGMessageObject.klass, "eventKeyDown", VALUEFUNC(_wrap_AGMessageObject_eventKeyDown), -1);
    rb_define_method(cAGMessageObject.klass, "eventKeyUp", VALUEFUNC(_wrap_AGMessageObject_eventKeyUp), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseMotion", VALUEFUNC(_wrap_AGMessageObject_eventMouseMotion), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGMessageObject_eventMouseButtonDown), -1);
    rb_define_method(cAGMessageObject.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGMessageObject_eventMouseButtonUp), -1);
    rb_define_method(cAGMessageObject.klass, "eventQuit", VALUEFUNC(_wrap_AGMessageObject_eventQuit), -1);
    rb_define_method(cAGMessageObject.klass, "eventQuitModal", VALUEFUNC(_wrap_AGMessageObject_eventQuitModal), -1);
    rb_define_method(cAGMessageObject.klass, "eventSysWM", VALUEFUNC(_wrap_AGMessageObject_eventSysWM), -1);
    rb_define_method(cAGMessageObject.klass, "eventResize", VALUEFUNC(_wrap_AGMessageObject_eventResize), -1);
    rb_define_method(cAGMessageObject.klass, "getButtonState", VALUEFUNC(_wrap_AGMessageObject_getButtonState), -1);
    rb_define_method(cAGMessageObject.klass, "getMousePosition", VALUEFUNC(_wrap_AGMessageObject_getMousePosition), -1);
    rb_define_method(cAGMessageObject.klass, "sigActive=", VALUEFUNC(_wrap_AGMessageObject_sigActive_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigActive", VALUEFUNC(_wrap_AGMessageObject_sigActive_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyDown=", VALUEFUNC(_wrap_AGMessageObject_sigKeyDown_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyDown", VALUEFUNC(_wrap_AGMessageObject_sigKeyDown_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyUp=", VALUEFUNC(_wrap_AGMessageObject_sigKeyUp_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigKeyUp", VALUEFUNC(_wrap_AGMessageObject_sigKeyUp_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseMotion=", VALUEFUNC(_wrap_AGMessageObject_sigMouseMotion_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseMotion", VALUEFUNC(_wrap_AGMessageObject_sigMouseMotion_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonDown=", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonDown_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonDown", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonDown_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonUp=", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonUp_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigMouseButtonUp", VALUEFUNC(_wrap_AGMessageObject_sigMouseButtonUp_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigQuit=", VALUEFUNC(_wrap_AGMessageObject_sigQuit_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigQuit", VALUEFUNC(_wrap_AGMessageObject_sigQuit_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigSysWM=", VALUEFUNC(_wrap_AGMessageObject_sigSysWM_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigSysWM", VALUEFUNC(_wrap_AGMessageObject_sigSysWM_get), -1);
    rb_define_method(cAGMessageObject.klass, "sigVideoResize=", VALUEFUNC(_wrap_AGMessageObject_sigVideoResize_set), -1);
    rb_define_method(cAGMessageObject.klass, "sigVideoResize", VALUEFUNC(_wrap_AGMessageObject_sigVideoResize_get), -1);
    rb_define_method(cAGMessageObject.klass, "pushSignal", VALUEFUNC(_wrap_AGMessageObject_pushSignal), -1);
    rb_define_method(cAGMessageObject.klass, "popSignal", VALUEFUNC(_wrap_AGMessageObject_popSignal), -1);
    cAGMessageObject.mark = 0;
    cAGMessageObject.destroy = (void (*)(void *)) free_AGMessageObject;
    rb_define_module_function(mLibantargisgui, "newEvent", VALUEFUNC(_wrap_newEvent), -1);
    rb_define_module_function(mLibantargisgui, "toAGSDLEvent", VALUEFUNC(_wrap_toAGSDLEvent), -1);
    rb_define_module_function(mLibantargisgui, "AGWidget_markfunc", VALUEFUNC(_wrap_AGWidget_markfunc), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGWidget", VALUEFUNC(_wrap_disown_AGWidget), -1);
    
    cAGWidget.klass = rb_define_class_under(mLibantargisgui, "AGWidget", ((swig_class *) SWIGTYPE_p_AGMessageObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGWidget, (void *) &cAGWidget);
    rb_define_alloc_func(cAGWidget.klass, _wrap_AGWidget_allocate);
    rb_define_method(cAGWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGWidget), -1);
    rb_define_method(cAGWidget.klass, "draw", VALUEFUNC(_wrap_AGWidget_draw), -1);
    rb_define_method(cAGWidget.klass, "drawAll", VALUEFUNC(_wrap_AGWidget_drawAll), -1);
    rb_define_method(cAGWidget.klass, "getRect", VALUEFUNC(_wrap_AGWidget_getRect), -1);
    rb_define_method(cAGWidget.klass, "getClientRect", VALUEFUNC(_wrap_AGWidget_getClientRect), -1);
    rb_define_method(cAGWidget.klass, "setRect", VALUEFUNC(_wrap_AGWidget_setRect), -1);
    rb_define_method(cAGWidget.klass, "setParent", VALUEFUNC(_wrap_AGWidget_setParent), -1);
    rb_define_method(cAGWidget.klass, "getParent", VALUEFUNC(_wrap_AGWidget_getParent), -1);
    rb_define_method(cAGWidget.klass, "eventShow", VALUEFUNC(_wrap_AGWidget_eventShow), -1);
    rb_define_method(cAGWidget.klass, "eventHide", VALUEFUNC(_wrap_AGWidget_eventHide), -1);
    rb_define_method(cAGWidget.klass, "eventMouseMotion", VALUEFUNC(_wrap_AGWidget_eventMouseMotion), -1);
    rb_define_method(cAGWidget.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGWidget_eventMouseEnter), -1);
    rb_define_method(cAGWidget.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGWidget_eventMouseLeave), -1);
    rb_define_method(cAGWidget.klass, "eventMouseClick", VALUEFUNC(_wrap_AGWidget_eventMouseClick), -1);
    rb_define_method(cAGWidget.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGWidget_eventMouseButtonDown), -1);
    rb_define_method(cAGWidget.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGWidget_eventMouseButtonUp), -1);
    rb_define_method(cAGWidget.klass, "eventGotFocus", VALUEFUNC(_wrap_AGWidget_eventGotFocus), -1);
    rb_define_method(cAGWidget.klass, "eventLostFocus", VALUEFUNC(_wrap_AGWidget_eventLostFocus), -1);
    rb_define_method(cAGWidget.klass, "canFocus", VALUEFUNC(_wrap_AGWidget_canFocus), -1);
    rb_define_method(cAGWidget.klass, "processEvent", VALUEFUNC(_wrap_AGWidget_processEvent), -1);
    rb_define_method(cAGWidget.klass, "sigMouseEnter=", VALUEFUNC(_wrap_AGWidget_sigMouseEnter_set), -1);
    rb_define_method(cAGWidget.klass, "sigMouseEnter", VALUEFUNC(_wrap_AGWidget_sigMouseEnter_get), -1);
    rb_define_method(cAGWidget.klass, "sigMouseLeave=", VALUEFUNC(_wrap_AGWidget_sigMouseLeave_set), -1);
    rb_define_method(cAGWidget.klass, "sigMouseLeave", VALUEFUNC(_wrap_AGWidget_sigMouseLeave_get), -1);
    rb_define_method(cAGWidget.klass, "sigClick=", VALUEFUNC(_wrap_AGWidget_sigClick_set), -1);
    rb_define_method(cAGWidget.klass, "sigClick", VALUEFUNC(_wrap_AGWidget_sigClick_get), -1);
    rb_define_method(cAGWidget.klass, "minWidth", VALUEFUNC(_wrap_AGWidget_minWidth), -1);
    rb_define_method(cAGWidget.klass, "minHeight", VALUEFUNC(_wrap_AGWidget_minHeight), -1);
    rb_define_method(cAGWidget.klass, "width", VALUEFUNC(_wrap_AGWidget_width), -1);
    rb_define_method(cAGWidget.klass, "height", VALUEFUNC(_wrap_AGWidget_height), -1);
    rb_define_method(cAGWidget.klass, "top", VALUEFUNC(_wrap_AGWidget_top), -1);
    rb_define_method(cAGWidget.klass, "left", VALUEFUNC(_wrap_AGWidget_left), -1);
    rb_define_method(cAGWidget.klass, "setWidth", VALUEFUNC(_wrap_AGWidget_setWidth), -1);
    rb_define_method(cAGWidget.klass, "setHeight", VALUEFUNC(_wrap_AGWidget_setHeight), -1);
    rb_define_method(cAGWidget.klass, "setTop", VALUEFUNC(_wrap_AGWidget_setTop), -1);
    rb_define_method(cAGWidget.klass, "setLeft", VALUEFUNC(_wrap_AGWidget_setLeft), -1);
    rb_define_method(cAGWidget.klass, "fixedWidth", VALUEFUNC(_wrap_AGWidget_fixedWidth), -1);
    rb_define_method(cAGWidget.klass, "fixedHeight", VALUEFUNC(_wrap_AGWidget_fixedHeight), -1);
    rb_define_method(cAGWidget.klass, "show", VALUEFUNC(_wrap_AGWidget_show), -1);
    rb_define_method(cAGWidget.klass, "hide", VALUEFUNC(_wrap_AGWidget_hide), -1);
    rb_define_method(cAGWidget.klass, "addChild", VALUEFUNC(_wrap_AGWidget_addChild), -1);
    rb_define_method(cAGWidget.klass, "addChildBack", VALUEFUNC(_wrap_AGWidget_addChildBack), -1);
    rb_define_method(cAGWidget.klass, "removeChild", VALUEFUNC(_wrap_AGWidget_removeChild), -1);
    rb_define_method(cAGWidget.klass, "clear", VALUEFUNC(_wrap_AGWidget_clear), -1);
    rb_define_method(cAGWidget.klass, "getScreenRect", VALUEFUNC(_wrap_AGWidget_getScreenRect), -1);
    rb_define_method(cAGWidget.klass, "getScreenPosition", VALUEFUNC(_wrap_AGWidget_getScreenPosition), -1);
    rb_define_method(cAGWidget.klass, "fromScreen", VALUEFUNC(_wrap_AGWidget_fromScreen), -1);
    rb_define_method(cAGWidget.klass, "gainFocus", VALUEFUNC(_wrap_AGWidget_gainFocus), -1);
    rb_define_method(cAGWidget.klass, "gainCompleteFocus", VALUEFUNC(_wrap_AGWidget_gainCompleteFocus), -1);
    rb_define_method(cAGWidget.klass, "eventDragBy", VALUEFUNC(_wrap_AGWidget_eventDragBy), -1);
    rb_define_method(cAGWidget.klass, "getFocus", VALUEFUNC(_wrap_AGWidget_getFocus), -1);
    rb_define_method(cAGWidget.klass, "hasFocus", VALUEFUNC(_wrap_AGWidget_hasFocus), -1);
    rb_define_method(cAGWidget.klass, "getName", VALUEFUNC(_wrap_AGWidget_getName), -1);
    rb_define_method(cAGWidget.klass, "setName", VALUEFUNC(_wrap_AGWidget_setName), -1);
    rb_define_method(cAGWidget.klass, "getChild", VALUEFUNC(_wrap_AGWidget_getChild), -1);
    rb_define_method(cAGWidget.klass, "setModal", VALUEFUNC(_wrap_AGWidget_setModal), -1);
    rb_define_method(cAGWidget.klass, "erase", VALUEFUNC(_wrap_AGWidget_erase), -1);
    rb_define_method(cAGWidget.klass, "eventChildrenDeleted", VALUEFUNC(_wrap_AGWidget_eventChildrenDeleted), -1);
    cAGWidget.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGWidget.destroy = (void (*)(void *)) free_AGWidget;
    rb_define_module_function(mLibantargisgui, "toAGWidget", VALUEFUNC(_wrap_toAGWidget), -1);
    rb_define_singleton_method(mLibantargisgui, "agNoParent", VALUEFUNC(agNoParent_get), 0);
    rb_define_singleton_method(mLibantargisgui, "agNoParent=", VALUEFUNC(agNoParent_set), 1);
    
    cAGPoint.klass = rb_define_class_under(mLibantargisgui, "AGPoint", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGPoint, (void *) &cAGPoint);
    rb_define_alloc_func(cAGPoint.klass, _wrap_AGPoint_allocate);
    rb_define_method(cAGPoint.klass, "initialize", VALUEFUNC(_wrap_new_AGPoint), -1);
    rb_define_method(cAGPoint.klass, "x=", VALUEFUNC(_wrap_AGPoint_x_set), -1);
    rb_define_method(cAGPoint.klass, "x", VALUEFUNC(_wrap_AGPoint_x_get), -1);
    rb_define_method(cAGPoint.klass, "y=", VALUEFUNC(_wrap_AGPoint_y_set), -1);
    rb_define_method(cAGPoint.klass, "y", VALUEFUNC(_wrap_AGPoint_y_get), -1);
    rb_define_method(cAGPoint.klass, "-", VALUEFUNC(_wrap_AGPoint___sub__), -1);
    rb_define_method(cAGPoint.klass, "+", VALUEFUNC(_wrap_AGPoint___add__), -1);
    cAGPoint.mark = 0;
    cAGPoint.destroy = (void (*)(void *)) free_AGPoint;
    
    cAGRect.klass = rb_define_class_under(mLibantargisgui, "AGRect", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect, (void *) &cAGRect);
    rb_define_alloc_func(cAGRect.klass, _wrap_AGRect_allocate);
    rb_define_method(cAGRect.klass, "initialize", VALUEFUNC(_wrap_new_AGRect), -1);
    rb_define_method(cAGRect.klass, "setX", VALUEFUNC(_wrap_AGRect_setX), -1);
    rb_define_method(cAGRect.klass, "setY", VALUEFUNC(_wrap_AGRect_setY), -1);
    rb_define_method(cAGRect.klass, "setW", VALUEFUNC(_wrap_AGRect_setW), -1);
    rb_define_method(cAGRect.klass, "setH", VALUEFUNC(_wrap_AGRect_setH), -1);
    rb_define_method(cAGRect.klass, "getX", VALUEFUNC(_wrap_AGRect_getX), -1);
    rb_define_method(cAGRect.klass, "getY", VALUEFUNC(_wrap_AGRect_getY), -1);
    rb_define_method(cAGRect.klass, "width", VALUEFUNC(_wrap_AGRect_width), -1);
    rb_define_method(cAGRect.klass, "height", VALUEFUNC(_wrap_AGRect_height), -1);
    rb_define_method(cAGRect.klass, "intersect", VALUEFUNC(_wrap_AGRect_intersect), -1);
    rb_define_method(cAGRect.klass, "isNull", VALUEFUNC(_wrap_AGRect_isNull), -1);
    rb_define_method(cAGRect.klass, "shrink", VALUEFUNC(_wrap_AGRect_shrink), -1);
    rb_define_method(cAGRect.klass, "shrinkRB", VALUEFUNC(_wrap_AGRect_shrinkRB), -1);
    rb_define_method(cAGRect.klass, "contains", VALUEFUNC(_wrap_AGRect_contains), -1);
    rb_define_method(cAGRect.klass, "project", VALUEFUNC(_wrap_AGRect_project), -1);
    rb_define_method(cAGRect.klass, "getMiddle", VALUEFUNC(_wrap_AGRect_getMiddle), -1);
    rb_define_method(cAGRect.klass, "origin", VALUEFUNC(_wrap_AGRect_origin), -1);
    rb_define_method(cAGRect.klass, "getPosition", VALUEFUNC(_wrap_AGRect_getPosition), -1);
    rb_define_method(cAGRect.klass, "to_s", VALUEFUNC(_wrap_AGRect_to_s), -1);
    rb_define_method(cAGRect.klass, "==", VALUEFUNC(_wrap_AGRect___eq__), -1);
    rb_define_method(cAGRect.klass, "+", VALUEFUNC(_wrap_AGRect___add__), -1);
    cAGRect.mark = 0;
    cAGRect.destroy = (void (*)(void *)) free_AGRect;
    
    cAGAngle.klass = rb_define_class_under(mLibantargisgui, "AGAngle", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGAngle, (void *) &cAGAngle);
    rb_define_alloc_func(cAGAngle.klass, _wrap_AGAngle_allocate);
    rb_define_method(cAGAngle.klass, "initialize", VALUEFUNC(_wrap_new_AGAngle), -1);
    rb_define_method(cAGAngle.klass, "angle=", VALUEFUNC(_wrap_AGAngle_angle_set), -1);
    rb_define_method(cAGAngle.klass, "angle", VALUEFUNC(_wrap_AGAngle_angle_get), -1);
    cAGAngle.mark = 0;
    cAGAngle.destroy = (void (*)(void *)) free_AGAngle;
    
    cAGVector2.klass = rb_define_class_under(mLibantargisgui, "AGVector2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector2, (void *) &cAGVector2);
    rb_define_alloc_func(cAGVector2.klass, _wrap_AGVector2_allocate);
    rb_define_method(cAGVector2.klass, "initialize", VALUEFUNC(_wrap_new_AGVector2), -1);
    rb_define_method(cAGVector2.klass, "v=", VALUEFUNC(_wrap_AGVector2_v_set), -1);
    rb_define_method(cAGVector2.klass, "v", VALUEFUNC(_wrap_AGVector2_v_get), -1);
    rb_define_method(cAGVector2.klass, "setX", VALUEFUNC(_wrap_AGVector2_setX), -1);
    rb_define_method(cAGVector2.klass, "setY", VALUEFUNC(_wrap_AGVector2_setY), -1);
    rb_define_method(cAGVector2.klass, "x", VALUEFUNC(_wrap_AGVector2_x), -1);
    rb_define_method(cAGVector2.klass, "y", VALUEFUNC(_wrap_AGVector2_y), -1);
    rb_define_method(cAGVector2.klass, "getAngle", VALUEFUNC(_wrap_AGVector2_getAngle), -1);
    rb_define_method(cAGVector2.klass, "-", VALUEFUNC(_wrap_AGVector2___sub__), -1);
    rb_define_method(cAGVector2.klass, "+", VALUEFUNC(_wrap_AGVector2___add__), -1);
    rb_define_method(cAGVector2.klass, "*", VALUEFUNC(_wrap_AGVector2___mul__), -1);
    rb_define_method(cAGVector2.klass, "/", VALUEFUNC(_wrap_AGVector2___div__), -1);
    rb_define_method(cAGVector2.klass, "==", VALUEFUNC(_wrap_AGVector2___eq__), -1);
    rb_define_method(cAGVector2.klass, "length", VALUEFUNC(_wrap_AGVector2_length), -1);
    rb_define_method(cAGVector2.klass, "length2", VALUEFUNC(_wrap_AGVector2_length2), -1);
    rb_define_method(cAGVector2.klass, "normalized", VALUEFUNC(_wrap_AGVector2_normalized), -1);
    rb_define_method(cAGVector2.klass, "normalize", VALUEFUNC(_wrap_AGVector2_normalize), -1);
    rb_define_method(cAGVector2.klass, "normal", VALUEFUNC(_wrap_AGVector2_normal), -1);
    rb_define_method(cAGVector2.klass, "nonZero", VALUEFUNC(_wrap_AGVector2_nonZero), -1);
    rb_define_method(cAGVector2.klass, "saveXML", VALUEFUNC(_wrap_AGVector2_saveXML), -1);
    rb_define_method(cAGVector2.klass, "loadXML", VALUEFUNC(_wrap_AGVector2_loadXML), -1);
    rb_define_method(cAGVector2.klass, "to_s", VALUEFUNC(_wrap_AGVector2_to_s), -1);
    cAGVector2.mark = 0;
    cAGVector2.destroy = (void (*)(void *)) free_AGVector2;
    
    cAGVector3.klass = rb_define_class_under(mLibantargisgui, "AGVector3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector3, (void *) &cAGVector3);
    rb_define_alloc_func(cAGVector3.klass, _wrap_AGVector3_allocate);
    rb_define_method(cAGVector3.klass, "initialize", VALUEFUNC(_wrap_new_AGVector3), -1);
    rb_define_method(cAGVector3.klass, "v=", VALUEFUNC(_wrap_AGVector3_v_set), -1);
    rb_define_method(cAGVector3.klass, "v", VALUEFUNC(_wrap_AGVector3_v_get), -1);
    rb_define_method(cAGVector3.klass, "setX", VALUEFUNC(_wrap_AGVector3_setX), -1);
    rb_define_method(cAGVector3.klass, "setY", VALUEFUNC(_wrap_AGVector3_setY), -1);
    rb_define_method(cAGVector3.klass, "setZ", VALUEFUNC(_wrap_AGVector3_setZ), -1);
    rb_define_method(cAGVector3.klass, "x", VALUEFUNC(_wrap_AGVector3_x), -1);
    rb_define_method(cAGVector3.klass, "y", VALUEFUNC(_wrap_AGVector3_y), -1);
    rb_define_method(cAGVector3.klass, "z", VALUEFUNC(_wrap_AGVector3_z), -1);
    rb_define_method(cAGVector3.klass, "getAngle", VALUEFUNC(_wrap_AGVector3_getAngle), -1);
    rb_define_method(cAGVector3.klass, "-@", VALUEFUNC(_wrap_AGVector3___neg__), -1);
    rb_define_method(cAGVector3.klass, "-", VALUEFUNC(_wrap_AGVector3___sub__), -1);
    rb_define_method(cAGVector3.klass, "+", VALUEFUNC(_wrap_AGVector3___add__), -1);
    rb_define_method(cAGVector3.klass, "add", VALUEFUNC(_wrap_AGVector3_add), -1);
    rb_define_method(cAGVector3.klass, "sub", VALUEFUNC(_wrap_AGVector3_sub), -1);
    rb_define_method(cAGVector3.klass, "*", VALUEFUNC(_wrap_AGVector3___mul__), -1);
    rb_define_method(cAGVector3.klass, "/", VALUEFUNC(_wrap_AGVector3___div__), -1);
    rb_define_method(cAGVector3.klass, "%", VALUEFUNC(_wrap_AGVector3___mod__), -1);
    rb_define_method(cAGVector3.klass, "==", VALUEFUNC(_wrap_AGVector3___eq__), -1);
    rb_define_method(cAGVector3.klass, "length", VALUEFUNC(_wrap_AGVector3_length), -1);
    rb_define_method(cAGVector3.klass, "length2", VALUEFUNC(_wrap_AGVector3_length2), -1);
    rb_define_method(cAGVector3.klass, "normalized", VALUEFUNC(_wrap_AGVector3_normalized), -1);
    rb_define_method(cAGVector3.klass, "normalize", VALUEFUNC(_wrap_AGVector3_normalize), -1);
    rb_define_method(cAGVector3.klass, "normal", VALUEFUNC(_wrap_AGVector3_normal), -1);
    rb_define_method(cAGVector3.klass, "nonZero", VALUEFUNC(_wrap_AGVector3_nonZero), -1);
    rb_define_method(cAGVector3.klass, "saveXML", VALUEFUNC(_wrap_AGVector3_saveXML), -1);
    rb_define_method(cAGVector3.klass, "loadXML", VALUEFUNC(_wrap_AGVector3_loadXML), -1);
    rb_define_method(cAGVector3.klass, "to_s", VALUEFUNC(_wrap_AGVector3_to_s), -1);
    cAGVector3.mark = 0;
    cAGVector3.destroy = (void (*)(void *)) free_AGVector3;
    
    cAGPoint3.klass = rb_define_class_under(mLibantargisgui, "AGPoint3", ((swig_class *) SWIGTYPE_p_AGVector3->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGPoint3, (void *) &cAGPoint3);
    rb_define_alloc_func(cAGPoint3.klass, _wrap_AGPoint3_allocate);
    rb_define_method(cAGPoint3.klass, "initialize", VALUEFUNC(_wrap_new_AGPoint3), -1);
    cAGPoint3.mark = 0;
    cAGPoint3.destroy = (void (*)(void *)) free_AGPoint3;
    
    cAGMatrix3.klass = rb_define_class_under(mLibantargisgui, "AGMatrix3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMatrix3, (void *) &cAGMatrix3);
    rb_define_alloc_func(cAGMatrix3.klass, _wrap_AGMatrix3_allocate);
    rb_define_method(cAGMatrix3.klass, "initialize", VALUEFUNC(_wrap_new_AGMatrix3), -1);
    rb_define_method(cAGMatrix3.klass, "set", VALUEFUNC(_wrap_AGMatrix3_set), -1);
    rb_define_method(cAGMatrix3.klass, "get", VALUEFUNC(_wrap_AGMatrix3_get), -1);
    rb_define_method(cAGMatrix3.klass, "*", VALUEFUNC(_wrap_AGMatrix3___mul__), -1);
    rb_define_method(cAGMatrix3.klass, "-@", VALUEFUNC(_wrap_AGMatrix3___neg__), -1);
    rb_define_method(cAGMatrix3.klass, "inverted", VALUEFUNC(_wrap_AGMatrix3_inverted), -1);
    rb_define_method(cAGMatrix3.klass, "transposed", VALUEFUNC(_wrap_AGMatrix3_transposed), -1);
    rb_define_method(cAGMatrix3.klass, "to_s", VALUEFUNC(_wrap_AGMatrix3_to_s), -1);
    cAGMatrix3.mark = 0;
    cAGMatrix3.destroy = (void (*)(void *)) free_AGMatrix3;
    
    cAGLine2.klass = rb_define_class_under(mLibantargisgui, "AGLine2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLine2, (void *) &cAGLine2);
    rb_define_alloc_func(cAGLine2.klass, _wrap_AGLine2_allocate);
    rb_define_method(cAGLine2.klass, "initialize", VALUEFUNC(_wrap_new_AGLine2), -1);
    rb_define_method(cAGLine2.klass, "getV0", VALUEFUNC(_wrap_AGLine2_getV0), -1);
    rb_define_method(cAGLine2.klass, "getV1", VALUEFUNC(_wrap_AGLine2_getV1), -1);
    rb_define_method(cAGLine2.klass, "has", VALUEFUNC(_wrap_AGLine2_has), -1);
    rb_define_method(cAGLine2.klass, "collide", VALUEFUNC(_wrap_AGLine2_collide), -1);
    rb_define_method(cAGLine2.klass, "collisionPoint", VALUEFUNC(_wrap_AGLine2_collisionPoint), -1);
    rb_define_method(cAGLine2.klass, "collisionPointNI", VALUEFUNC(_wrap_AGLine2_collisionPointNI), -1);
    rb_define_method(cAGLine2.klass, "includes", VALUEFUNC(_wrap_AGLine2_includes), -1);
    rb_define_method(cAGLine2.klass, "getBBox", VALUEFUNC(_wrap_AGLine2_getBBox), -1);
    rb_define_method(cAGLine2.klass, "normal", VALUEFUNC(_wrap_AGLine2_normal), -1);
    rb_define_method(cAGLine2.klass, "direction", VALUEFUNC(_wrap_AGLine2_direction), -1);
    rb_define_method(cAGLine2.klass, "distance", VALUEFUNC(_wrap_AGLine2_distance), -1);
    rb_define_method(cAGLine2.klass, "to_s", VALUEFUNC(_wrap_AGLine2_to_s), -1);
    cAGLine2.mark = 0;
    cAGLine2.destroy = (void (*)(void *)) free_AGLine2;
    
    cAGLine3.klass = rb_define_class_under(mLibantargisgui, "AGLine3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLine3, (void *) &cAGLine3);
    rb_define_alloc_func(cAGLine3.klass, _wrap_AGLine3_allocate);
    rb_define_method(cAGLine3.klass, "initialize", VALUEFUNC(_wrap_new_AGLine3), -1);
    rb_define_method(cAGLine3.klass, "getV0", VALUEFUNC(_wrap_AGLine3_getV0), -1);
    rb_define_method(cAGLine3.klass, "getV1", VALUEFUNC(_wrap_AGLine3_getV1), -1);
    rb_define_method(cAGLine3.klass, "has", VALUEFUNC(_wrap_AGLine3_has), -1);
    rb_define_method(cAGLine3.klass, "direction", VALUEFUNC(_wrap_AGLine3_direction), -1);
    rb_define_method(cAGLine3.klass, "distance", VALUEFUNC(_wrap_AGLine3_distance), -1);
    rb_define_method(cAGLine3.klass, "to_s", VALUEFUNC(_wrap_AGLine3_to_s), -1);
    cAGLine3.mark = 0;
    cAGLine3.destroy = (void (*)(void *)) free_AGLine3;
    
    cAGCollisionData.klass = rb_define_class_under(mLibantargisgui, "AGCollisionData", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCollisionData, (void *) &cAGCollisionData);
    rb_define_alloc_func(cAGCollisionData.klass, _wrap_AGCollisionData_allocate);
    rb_define_method(cAGCollisionData.klass, "initialize", VALUEFUNC(_wrap_new_AGCollisionData), -1);
    cAGCollisionData.mark = 0;
    cAGCollisionData.destroy = (void (*)(void *)) free_AGCollisionData;
    
    cAGTriangle2.klass = rb_define_class_under(mLibantargisgui, "AGTriangle2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTriangle2, (void *) &cAGTriangle2);
    rb_define_alloc_func(cAGTriangle2.klass, _wrap_AGTriangle2_allocate);
    rb_define_method(cAGTriangle2.klass, "initialize", VALUEFUNC(_wrap_new_AGTriangle2), -1);
    rb_define_method(cAGTriangle2.klass, "get", VALUEFUNC(_wrap_AGTriangle2_get), -1);
    rb_define_method(cAGTriangle2.klass, "collide", VALUEFUNC(_wrap_AGTriangle2_collide), -1);
    rb_define_method(cAGTriangle2.klass, "getNormals", VALUEFUNC(_wrap_AGTriangle2_getNormals), -1);
    rb_define_method(cAGTriangle2.klass, "apply", VALUEFUNC(_wrap_AGTriangle2_apply), -1);
    rb_define_method(cAGTriangle2.klass, "applied", VALUEFUNC(_wrap_AGTriangle2_applied), -1);
    rb_define_method(cAGTriangle2.klass, "touchPoint", VALUEFUNC(_wrap_AGTriangle2_touchPoint), -1);
    rb_define_method(cAGTriangle2.klass, "touchVector", VALUEFUNC(_wrap_AGTriangle2_touchVector), -1);
    rb_define_method(cAGTriangle2.klass, "collisionPoints", VALUEFUNC(_wrap_AGTriangle2_collisionPoints), -1);
    rb_define_method(cAGTriangle2.klass, "contains", VALUEFUNC(_wrap_AGTriangle2_contains), -1);
    rb_define_method(cAGTriangle2.klass, "getBBox", VALUEFUNC(_wrap_AGTriangle2_getBBox), -1);
    rb_define_method(cAGTriangle2.klass, "nearestLine", VALUEFUNC(_wrap_AGTriangle2_nearestLine), -1);
    rb_define_method(cAGTriangle2.klass, "getLines", VALUEFUNC(_wrap_AGTriangle2_getLines), -1);
    rb_define_method(cAGTriangle2.klass, "to_s", VALUEFUNC(_wrap_AGTriangle2_to_s), -1);
    cAGTriangle2.mark = 0;
    cAGTriangle2.destroy = (void (*)(void *)) free_AGTriangle2;
    
    cAGCircle2.klass = rb_define_class_under(mLibantargisgui, "AGCircle2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGCircle2, (void *) &cAGCircle2);
    rb_define_alloc_func(cAGCircle2.klass, _wrap_AGCircle2_allocate);
    rb_define_method(cAGCircle2.klass, "initialize", VALUEFUNC(_wrap_new_AGCircle2), -1);
    rb_define_method(cAGCircle2.klass, "inCircle", VALUEFUNC(_wrap_AGCircle2_inCircle), -1);
    rb_define_method(cAGCircle2.klass, "outCircle", VALUEFUNC(_wrap_AGCircle2_outCircle), -1);
    rb_define_method(cAGCircle2.klass, "getPos", VALUEFUNC(_wrap_AGCircle2_getPos), -1);
    rb_define_method(cAGCircle2.klass, "getRadius", VALUEFUNC(_wrap_AGCircle2_getRadius), -1);
    cAGCircle2.mark = 0;
    cAGCircle2.destroy = (void (*)(void *)) free_AGCircle2;
    
    cAGTriangle3.klass = rb_define_class_under(mLibantargisgui, "AGTriangle3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTriangle3, (void *) &cAGTriangle3);
    rb_define_alloc_func(cAGTriangle3.klass, _wrap_AGTriangle3_allocate);
    rb_define_method(cAGTriangle3.klass, "initialize", VALUEFUNC(_wrap_new_AGTriangle3), -1);
    rb_define_method(cAGTriangle3.klass, "collide", VALUEFUNC(_wrap_AGTriangle3_collide), -1);
    rb_define_method(cAGTriangle3.klass, "toString", VALUEFUNC(_wrap_AGTriangle3_toString), -1);
    cAGTriangle3.mark = 0;
    cAGTriangle3.destroy = (void (*)(void *)) free_AGTriangle3;
    
    cAGRect2.klass = rb_define_class_under(mLibantargisgui, "AGRect2", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect2, (void *) &cAGRect2);
    rb_define_alloc_func(cAGRect2.klass, _wrap_AGRect2_allocate);
    rb_define_method(cAGRect2.klass, "initialize", VALUEFUNC(_wrap_new_AGRect2), -1);
    rb_define_method(cAGRect2.klass, "collide", VALUEFUNC(_wrap_AGRect2_collide), -1);
    rb_define_method(cAGRect2.klass, "+", VALUEFUNC(_wrap_AGRect2___add__), -1);
    rb_define_method(cAGRect2.klass, "contains", VALUEFUNC(_wrap_AGRect2_contains), -1);
    rb_define_method(cAGRect2.klass, "split", VALUEFUNC(_wrap_AGRect2_split), -1);
    rb_define_method(cAGRect2.klass, "getV0", VALUEFUNC(_wrap_AGRect2_getV0), -1);
    rb_define_method(cAGRect2.klass, "getV1", VALUEFUNC(_wrap_AGRect2_getV1), -1);
    rb_define_method(cAGRect2.klass, "getV01", VALUEFUNC(_wrap_AGRect2_getV01), -1);
    rb_define_method(cAGRect2.klass, "getV10", VALUEFUNC(_wrap_AGRect2_getV10), -1);
    rb_define_method(cAGRect2.klass, "setX", VALUEFUNC(_wrap_AGRect2_setX), -1);
    rb_define_method(cAGRect2.klass, "setY", VALUEFUNC(_wrap_AGRect2_setY), -1);
    rb_define_method(cAGRect2.klass, "x", VALUEFUNC(_wrap_AGRect2_x), -1);
    rb_define_method(cAGRect2.klass, "y", VALUEFUNC(_wrap_AGRect2_y), -1);
    rb_define_method(cAGRect2.klass, "w", VALUEFUNC(_wrap_AGRect2_w), -1);
    rb_define_method(cAGRect2.klass, "h", VALUEFUNC(_wrap_AGRect2_h), -1);
    rb_define_method(cAGRect2.klass, "to_s", VALUEFUNC(_wrap_AGRect2_to_s), -1);
    cAGRect2.mark = 0;
    cAGRect2.destroy = (void (*)(void *)) free_AGRect2;
    
    cAGVector4.klass = rb_define_class_under(mLibantargisgui, "AGVector4", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGVector4, (void *) &cAGVector4);
    rb_define_alloc_func(cAGVector4.klass, _wrap_AGVector4_allocate);
    rb_define_method(cAGVector4.klass, "initialize", VALUEFUNC(_wrap_new_AGVector4), -1);
    rb_define_method(cAGVector4.klass, "v=", VALUEFUNC(_wrap_AGVector4_v_set), -1);
    rb_define_method(cAGVector4.klass, "v", VALUEFUNC(_wrap_AGVector4_v_get), -1);
    rb_define_method(cAGVector4.klass, "setX", VALUEFUNC(_wrap_AGVector4_setX), -1);
    rb_define_method(cAGVector4.klass, "setY", VALUEFUNC(_wrap_AGVector4_setY), -1);
    rb_define_method(cAGVector4.klass, "setZ", VALUEFUNC(_wrap_AGVector4_setZ), -1);
    rb_define_method(cAGVector4.klass, "setW", VALUEFUNC(_wrap_AGVector4_setW), -1);
    rb_define_method(cAGVector4.klass, "x", VALUEFUNC(_wrap_AGVector4_x), -1);
    rb_define_method(cAGVector4.klass, "y", VALUEFUNC(_wrap_AGVector4_y), -1);
    rb_define_method(cAGVector4.klass, "z", VALUEFUNC(_wrap_AGVector4_z), -1);
    rb_define_method(cAGVector4.klass, "w", VALUEFUNC(_wrap_AGVector4_w), -1);
    rb_define_method(cAGVector4.klass, "-", VALUEFUNC(_wrap_AGVector4___sub__), -1);
    rb_define_method(cAGVector4.klass, "+", VALUEFUNC(_wrap_AGVector4___add__), -1);
    rb_define_method(cAGVector4.klass, "add", VALUEFUNC(_wrap_AGVector4_add), -1);
    rb_define_method(cAGVector4.klass, "sub", VALUEFUNC(_wrap_AGVector4_sub), -1);
    rb_define_method(cAGVector4.klass, "*", VALUEFUNC(_wrap_AGVector4___mul__), -1);
    rb_define_method(cAGVector4.klass, "/", VALUEFUNC(_wrap_AGVector4___div__), -1);
    rb_define_method(cAGVector4.klass, "-@", VALUEFUNC(_wrap_AGVector4___neg__), -1);
    rb_define_method(cAGVector4.klass, "==", VALUEFUNC(_wrap_AGVector4___eq__), -1);
    rb_define_method(cAGVector4.klass, "length", VALUEFUNC(_wrap_AGVector4_length), -1);
    rb_define_method(cAGVector4.klass, "length2", VALUEFUNC(_wrap_AGVector4_length2), -1);
    rb_define_method(cAGVector4.klass, "length3", VALUEFUNC(_wrap_AGVector4_length3), -1);
    rb_define_method(cAGVector4.klass, "normalized", VALUEFUNC(_wrap_AGVector4_normalized), -1);
    rb_define_method(cAGVector4.klass, "normalize", VALUEFUNC(_wrap_AGVector4_normalize), -1);
    rb_define_method(cAGVector4.klass, "normalized3", VALUEFUNC(_wrap_AGVector4_normalized3), -1);
    rb_define_method(cAGVector4.klass, "normalize3", VALUEFUNC(_wrap_AGVector4_normalize3), -1);
    rb_define_method(cAGVector4.klass, "nonZero", VALUEFUNC(_wrap_AGVector4_nonZero), -1);
    rb_define_method(cAGVector4.klass, "%", VALUEFUNC(_wrap_AGVector4___mod__), -1);
    rb_define_method(cAGVector4.klass, "cross", VALUEFUNC(_wrap_AGVector4_cross), -1);
    rb_define_method(cAGVector4.klass, "dim3", VALUEFUNC(_wrap_AGVector4_dim3), -1);
    rb_define_method(cAGVector4.klass, "to_s", VALUEFUNC(_wrap_AGVector4_to_s), -1);
    cAGVector4.mark = 0;
    cAGVector4.destroy = (void (*)(void *)) free_AGVector4;
    
    cAGMatrix4.klass = rb_define_class_under(mLibantargisgui, "AGMatrix4", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGMatrix4, (void *) &cAGMatrix4);
    rb_define_alloc_func(cAGMatrix4.klass, _wrap_AGMatrix4_allocate);
    rb_define_method(cAGMatrix4.klass, "initialize", VALUEFUNC(_wrap_new_AGMatrix4), -1);
    rb_define_method(cAGMatrix4.klass, "set", VALUEFUNC(_wrap_AGMatrix4_set), -1);
    rb_define_method(cAGMatrix4.klass, "get", VALUEFUNC(_wrap_AGMatrix4_get), -1);
    rb_define_method(cAGMatrix4.klass, "get3x3", VALUEFUNC(_wrap_AGMatrix4_get3x3), -1);
    rb_define_method(cAGMatrix4.klass, "*", VALUEFUNC(_wrap_AGMatrix4___mul__), -1);
    rb_define_method(cAGMatrix4.klass, "call", VALUEFUNC(_wrap_AGMatrix4___call__), -1);
    rb_define_method(cAGMatrix4.klass, "inverted", VALUEFUNC(_wrap_AGMatrix4_inverted), -1);
    rb_define_method(cAGMatrix4.klass, "transposed", VALUEFUNC(_wrap_AGMatrix4_transposed), -1);
    rb_define_method(cAGMatrix4.klass, "to_s", VALUEFUNC(_wrap_AGMatrix4_to_s), -1);
    rb_define_method(cAGMatrix4.klass, "getRow", VALUEFUNC(_wrap_AGMatrix4_getRow), -1);
    cAGMatrix4.mark = 0;
    cAGMatrix4.destroy = (void (*)(void *)) free_AGMatrix4;
    
    cAGRect3.klass = rb_define_class_under(mLibantargisgui, "AGRect3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGRect3, (void *) &cAGRect3);
    rb_define_alloc_func(cAGRect3.klass, _wrap_AGRect3_allocate);
    rb_define_method(cAGRect3.klass, "initialize", VALUEFUNC(_wrap_new_AGRect3), -1);
    rb_define_method(cAGRect3.klass, "collides", VALUEFUNC(_wrap_AGRect3_collides), -1);
    rb_define_method(cAGRect3.klass, "toString", VALUEFUNC(_wrap_AGRect3_toString), -1);
    cAGRect3.mark = 0;
    cAGRect3.destroy = (void (*)(void *)) free_AGRect3;
    
    cAGBox3.klass = rb_define_class_under(mLibantargisgui, "AGBox3", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBox3, (void *) &cAGBox3);
    rb_define_alloc_func(cAGBox3.klass, _wrap_AGBox3_allocate);
    rb_define_method(cAGBox3.klass, "initialize", VALUEFUNC(_wrap_new_AGBox3), -1);
    rb_define_method(cAGBox3.klass, "base=", VALUEFUNC(_wrap_AGBox3_base_set), -1);
    rb_define_method(cAGBox3.klass, "base", VALUEFUNC(_wrap_AGBox3_base_get), -1);
    rb_define_method(cAGBox3.klass, "dir=", VALUEFUNC(_wrap_AGBox3_dir_set), -1);
    rb_define_method(cAGBox3.klass, "dir", VALUEFUNC(_wrap_AGBox3_dir_get), -1);
    rb_define_method(cAGBox3.klass, "include", VALUEFUNC(_wrap_AGBox3_include), -1);
    rb_define_method(cAGBox3.klass, "includes", VALUEFUNC(_wrap_AGBox3_includes), -1);
    rb_define_method(cAGBox3.klass, "getSides", VALUEFUNC(_wrap_AGBox3_getSides), -1);
    rb_define_method(cAGBox3.klass, "toString", VALUEFUNC(_wrap_AGBox3_toString), -1);
    rb_define_method(cAGBox3.klass, "split", VALUEFUNC(_wrap_AGBox3_split), -1);
    rb_define_method(cAGBox3.klass, "collides", VALUEFUNC(_wrap_AGBox3_collides), -1);
    rb_define_method(cAGBox3.klass, "getVertices", VALUEFUNC(_wrap_AGBox3_getVertices), -1);
    rb_define_method(cAGBox3.klass, "+", VALUEFUNC(_wrap_AGBox3___add__), -1);
    cAGBox3.mark = 0;
    cAGBox3.destroy = (void (*)(void *)) free_AGBox3;
    
    cAGColor.klass = rb_define_class_under(mLibantargisgui, "AGColor", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGColor, (void *) &cAGColor);
    rb_define_alloc_func(cAGColor.klass, _wrap_AGColor_allocate);
    rb_define_method(cAGColor.klass, "initialize", VALUEFUNC(_wrap_new_AGColor), -1);
    rb_define_method(cAGColor.klass, "*", VALUEFUNC(_wrap_AGColor___mul__), -1);
    rb_define_method(cAGColor.klass, "+", VALUEFUNC(_wrap_AGColor___add__), -1);
    rb_define_method(cAGColor.klass, "mapRGB", VALUEFUNC(_wrap_AGColor_mapRGB), -1);
    rb_define_method(cAGColor.klass, "toString", VALUEFUNC(_wrap_AGColor_toString), -1);
    rb_define_method(cAGColor.klass, "grey", VALUEFUNC(_wrap_AGColor_grey), -1);
    rb_define_method(cAGColor.klass, "brightness", VALUEFUNC(_wrap_AGColor_brightness), -1);
    rb_define_method(cAGColor.klass, "light", VALUEFUNC(_wrap_AGColor_light), -1);
    rb_define_method(cAGColor.klass, "a=", VALUEFUNC(_wrap_AGColor_a_set), -1);
    rb_define_method(cAGColor.klass, "a", VALUEFUNC(_wrap_AGColor_a_get), -1);
    cAGColor.mark = 0;
    cAGColor.destroy = (void (*)(void *)) free_AGColor;
    rb_define_module_function(mLibantargisgui, "toInt", VALUEFUNC(_wrap_toInt), -1);
    
    cAGFont.klass = rb_define_class_under(mLibantargisgui, "AGFont", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGFont, (void *) &cAGFont);
    rb_define_alloc_func(cAGFont.klass, _wrap_AGFont_allocate);
    rb_define_method(cAGFont.klass, "initialize", VALUEFUNC(_wrap_new_AGFont), -1);
    rb_define_const(cAGFont.klass,"NORMAL", INT2NUM(AGFont::NORMAL));
    rb_define_const(cAGFont.klass,"BOLD", INT2NUM(AGFont::BOLD));
    rb_define_const(cAGFont.klass,"UNDERLINE", INT2NUM(AGFont::UNDERLINE));
    rb_define_const(cAGFont.klass,"ITALIC", INT2NUM(AGFont::ITALIC));
    rb_define_method(cAGFont.klass, "setColor", VALUEFUNC(_wrap_AGFont_setColor), -1);
    rb_define_method(cAGFont.klass, "getColor", VALUEFUNC(_wrap_AGFont_getColor), -1);
    rb_define_method(cAGFont.klass, "setAlpha", VALUEFUNC(_wrap_AGFont_setAlpha), -1);
    rb_define_method(cAGFont.klass, "getAlpha", VALUEFUNC(_wrap_AGFont_getAlpha), -1);
    rb_define_method(cAGFont.klass, "setSize", VALUEFUNC(_wrap_AGFont_setSize), -1);
    rb_define_method(cAGFont.klass, "getSize", VALUEFUNC(_wrap_AGFont_getSize), -1);
    rb_define_method(cAGFont.klass, "setStyle", VALUEFUNC(_wrap_AGFont_setStyle), -1);
    rb_define_method(cAGFont.klass, "getStyle", VALUEFUNC(_wrap_AGFont_getStyle), -1);
    rb_define_method(cAGFont.klass, "setName", VALUEFUNC(_wrap_AGFont_setName), -1);
    rb_define_method(cAGFont.klass, "getName", VALUEFUNC(_wrap_AGFont_getName), -1);
    rb_define_method(cAGFont.klass, "getWidth", VALUEFUNC(_wrap_AGFont_getWidth), -1);
    rb_define_method(cAGFont.klass, "getHeight", VALUEFUNC(_wrap_AGFont_getHeight), -1);
    cAGFont.mark = 0;
    cAGFont.destroy = (void (*)(void *)) free_AGFont;
    
    cAGFontEngine.klass = rb_define_class_under(mLibantargisgui, "AGFontEngine", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGFontEngine, (void *) &cAGFontEngine);
    rb_define_alloc_func(cAGFontEngine.klass, _wrap_AGFontEngine_allocate);
    rb_define_method(cAGFontEngine.klass, "initialize", VALUEFUNC(_wrap_new_AGFontEngine), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "renderText", VALUEFUNC(_wrap_AGFontEngine_renderText), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "getWidth", VALUEFUNC(_wrap_AGFontEngine_getWidth), -1);
    rb_define_singleton_method(cAGFontEngine.klass, "getHeight", VALUEFUNC(_wrap_AGFontEngine_getHeight), -1);
    cAGFontEngine.mark = 0;
    cAGFontEngine.destroy = (void (*)(void *)) free_AGFontEngine;
    rb_define_module_function(mLibantargisgui, "disown_AGButton", VALUEFUNC(_wrap_disown_AGButton), -1);
    
    cAGButton.klass = rb_define_class_under(mLibantargisgui, "AGButton", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGButton, (void *) &cAGButton);
    rb_define_alloc_func(cAGButton.klass, _wrap_AGButton_allocate);
    rb_define_method(cAGButton.klass, "initialize", VALUEFUNC(_wrap_new_AGButton), -1);
    rb_define_const(cAGButton.klass,"NORMAL", INT2NUM(AGButton::NORMAL));
    rb_define_const(cAGButton.klass,"LIGHTED", INT2NUM(AGButton::LIGHTED));
    rb_define_const(cAGButton.klass,"PRESSED", INT2NUM(AGButton::PRESSED));
    rb_define_const(cAGButton.klass,"CHECKED", INT2NUM(AGButton::CHECKED));
    rb_define_const(cAGButton.klass,"CHECKEDLIGHTED", INT2NUM(AGButton::CHECKEDLIGHTED));
    rb_define_method(cAGButton.klass, "setSurface", VALUEFUNC(_wrap_AGButton_setSurface), -1);
    rb_define_method(cAGButton.klass, "draw", VALUEFUNC(_wrap_AGButton_draw), -1);
    rb_define_method(cAGButton.klass, "eventMouseEnter", VALUEFUNC(_wrap_AGButton_eventMouseEnter), -1);
    rb_define_method(cAGButton.klass, "eventMouseLeave", VALUEFUNC(_wrap_AGButton_eventMouseLeave), -1);
    rb_define_method(cAGButton.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGButton_eventMouseButtonDown), -1);
    rb_define_method(cAGButton.klass, "eventMouseButtonUp", VALUEFUNC(_wrap_AGButton_eventMouseButtonUp), -1);
    rb_define_method(cAGButton.klass, "setWidth", VALUEFUNC(_wrap_AGButton_setWidth), -1);
    rb_define_method(cAGButton.klass, "setHeight", VALUEFUNC(_wrap_AGButton_setHeight), -1);
    rb_define_method(cAGButton.klass, "getCaption", VALUEFUNC(_wrap_AGButton_getCaption), -1);
    rb_define_method(cAGButton.klass, "setEnabled", VALUEFUNC(_wrap_AGButton_setEnabled), -1);
    rb_define_method(cAGButton.klass, "setTheme", VALUEFUNC(_wrap_AGButton_setTheme), -1);
    rb_define_method(cAGButton.klass, "setCaption", VALUEFUNC(_wrap_AGButton_setCaption), -1);
    rb_define_method(cAGButton.klass, "setState", VALUEFUNC(_wrap_AGButton_setState), -1);
    rb_define_method(cAGButton.klass, "setChecked", VALUEFUNC(_wrap_AGButton_setChecked), -1);
    rb_define_method(cAGButton.klass, "isChecked", VALUEFUNC(_wrap_AGButton_isChecked), -1);
    rb_define_method(cAGButton.klass, "canFocus", VALUEFUNC(_wrap_AGButton_canFocus), -1);
    cAGButton.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGButton.destroy = (void (*)(void *)) free_AGButton;
    rb_define_module_function(mLibantargisgui, "toAGButton", VALUEFUNC(_wrap_toAGButton), -1);
    rb_define_module_function(mLibantargisgui, "AGApplication_markfunc", VALUEFUNC(_wrap_AGApplication_markfunc), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGApplication", VALUEFUNC(_wrap_disown_AGApplication), -1);
    
    cAGApplication.klass = rb_define_class_under(mLibantargisgui, "AGApplication", ((swig_class *) SWIGTYPE_p_AGMessageObject->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGApplication, (void *) &cAGApplication);
    rb_define_alloc_func(cAGApplication.klass, _wrap_AGApplication_allocate);
    rb_define_method(cAGApplication.klass, "initialize", VALUEFUNC(_wrap_new_AGApplication), -1);
    rb_define_method(cAGApplication.klass, "run", VALUEFUNC(_wrap_AGApplication_run), -1);
    rb_define_method(cAGApplication.klass, "eventIdle", VALUEFUNC(_wrap_AGApplication_eventIdle), -1);
    rb_define_method(cAGApplication.klass, "eventFrame", VALUEFUNC(_wrap_AGApplication_eventFrame), -1);
    rb_define_method(cAGApplication.klass, "eventFrameEnd", VALUEFUNC(_wrap_AGApplication_eventFrameEnd), -1);
    rb_define_method(cAGApplication.klass, "eventQuit", VALUEFUNC(_wrap_AGApplication_eventQuit), -1);
    rb_define_method(cAGApplication.klass, "eventKeyDown", VALUEFUNC(_wrap_AGApplication_eventKeyDown), -1);
    rb_define_method(cAGApplication.klass, "eventChangedRes", VALUEFUNC(_wrap_AGApplication_eventChangedRes), -1);
    rb_define_method(cAGApplication.klass, "setMainWidget", VALUEFUNC(_wrap_AGApplication_setMainWidget), -1);
    rb_define_method(cAGApplication.klass, "draw", VALUEFUNC(_wrap_AGApplication_draw), -1);
    rb_define_method(cAGApplication.klass, "tryQuit", VALUEFUNC(_wrap_AGApplication_tryQuit), -1);
    rb_define_method(cAGApplication.klass, "getTicks", VALUEFUNC(_wrap_AGApplication_getTicks), -1);
    rb_define_method(cAGApplication.klass, "delay", VALUEFUNC(_wrap_AGApplication_delay), -1);
    cAGApplication.mark = (void (*)(void *)) AGApplication_markfunc;
    cAGApplication.destroy = (void (*)(void *)) free_AGApplication;
    rb_define_module_function(mLibantargisgui, "disableKeyrepeat", VALUEFUNC(_wrap_disableKeyrepeat), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGText", VALUEFUNC(_wrap_disown_AGText), -1);
    
    cAGText.klass = rb_define_class_under(mLibantargisgui, "AGText", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGText, (void *) &cAGText);
    rb_define_alloc_func(cAGText.klass, _wrap_AGText_allocate);
    rb_define_method(cAGText.klass, "initialize", VALUEFUNC(_wrap_new_AGText), -1);
    rb_define_method(cAGText.klass, "setDeriveRect", VALUEFUNC(_wrap_AGText_setDeriveRect), -1);
    rb_define_method(cAGText.klass, "draw", VALUEFUNC(_wrap_AGText_draw), -1);
    rb_define_method(cAGText.klass, "setText", VALUEFUNC(_wrap_AGText_setText), -1);
    rb_define_method(cAGText.klass, "getText", VALUEFUNC(_wrap_AGText_getText), -1);
    cAGText.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGText.destroy = (void (*)(void *)) free_AGText;
    rb_define_module_function(mLibantargisgui, "toAGText", VALUEFUNC(_wrap_toAGText), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGVTiler", VALUEFUNC(_wrap_disown_AGVTiler), -1);
    
    cAGVTiler.klass = rb_define_class_under(mLibantargisgui, "AGVTiler", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGVTiler, (void *) &cAGVTiler);
    rb_define_alloc_func(cAGVTiler.klass, _wrap_AGVTiler_allocate);
    rb_define_method(cAGVTiler.klass, "initialize", VALUEFUNC(_wrap_new_AGVTiler), -1);
    rb_define_method(cAGVTiler.klass, "addChild", VALUEFUNC(_wrap_AGVTiler_addChild), -1);
    rb_define_method(cAGVTiler.klass, "rePosition", VALUEFUNC(_wrap_AGVTiler_rePosition), -1);
    rb_define_method(cAGVTiler.klass, "adaptHeightFromChildren", VALUEFUNC(_wrap_AGVTiler_adaptHeightFromChildren), -1);
    rb_define_method(cAGVTiler.klass, "adaptWidthFromChildren", VALUEFUNC(_wrap_AGVTiler_adaptWidthFromChildren), -1);
    cAGVTiler.mark = 0;
    cAGVTiler.destroy = (void (*)(void *)) free_AGVTiler;
    rb_define_module_function(mLibantargisgui, "disown_AGHTiler", VALUEFUNC(_wrap_disown_AGHTiler), -1);
    
    cAGHTiler.klass = rb_define_class_under(mLibantargisgui, "AGHTiler", ((swig_class *) SWIGTYPE_p_AGVTiler->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGHTiler, (void *) &cAGHTiler);
    rb_define_alloc_func(cAGHTiler.klass, _wrap_AGHTiler_allocate);
    rb_define_method(cAGHTiler.klass, "initialize", VALUEFUNC(_wrap_new_AGHTiler), -1);
    rb_define_method(cAGHTiler.klass, "rePosition", VALUEFUNC(_wrap_AGHTiler_rePosition), -1);
    rb_define_method(cAGHTiler.klass, "adaptHeightFromChildren", VALUEFUNC(_wrap_AGHTiler_adaptHeightFromChildren), -1);
    rb_define_method(cAGHTiler.klass, "adaptWidthFromChildren", VALUEFUNC(_wrap_AGHTiler_adaptWidthFromChildren), -1);
    rb_define_method(cAGHTiler.klass, "adaptWidthFromParent", VALUEFUNC(_wrap_AGHTiler_adaptWidthFromParent), -1);
    cAGHTiler.mark = 0;
    cAGHTiler.destroy = (void (*)(void *)) free_AGHTiler;
    rb_define_module_function(mLibantargisgui, "disown_AGTheme", VALUEFUNC(_wrap_disown_AGTheme), -1);
    
    cAGTheme.klass = rb_define_class_under(mLibantargisgui, "AGTheme", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGTheme, (void *) &cAGTheme);
    rb_define_alloc_func(cAGTheme.klass, _wrap_AGTheme_allocate);
    rb_define_method(cAGTheme.klass, "initialize", VALUEFUNC(_wrap_new_AGTheme), -1);
    rb_define_method(cAGTheme.klass, "getFont", VALUEFUNC(_wrap_AGTheme_getFont), -1);
    rb_define_method(cAGTheme.klass, "getColor", VALUEFUNC(_wrap_AGTheme_getColor), -1);
    rb_define_method(cAGTheme.klass, "setFont", VALUEFUNC(_wrap_AGTheme_setFont), -1);
    rb_define_method(cAGTheme.klass, "setColor", VALUEFUNC(_wrap_AGTheme_setColor), -1);
    rb_define_method(cAGTheme.klass, "getInt", VALUEFUNC(_wrap_AGTheme_getInt), -1);
    rb_define_method(cAGTheme.klass, "setInt", VALUEFUNC(_wrap_AGTheme_setInt), -1);
    rb_define_method(cAGTheme.klass, "getSurface", VALUEFUNC(_wrap_AGTheme_getSurface), -1);
    rb_define_method(cAGTheme.klass, "setSurface", VALUEFUNC(_wrap_AGTheme_setSurface), -1);
    rb_define_method(cAGTheme.klass, "hasSurface", VALUEFUNC(_wrap_AGTheme_hasSurface), -1);
    rb_define_method(cAGTheme.klass, "hasColor", VALUEFUNC(_wrap_AGTheme_hasColor), -1);
    cAGTheme.mark = 0;
    cAGTheme.destroy = (void (*)(void *)) free_AGTheme;
    rb_define_module_function(mLibantargisgui, "getTheme", VALUEFUNC(_wrap_getTheme), -1);
    rb_define_module_function(mLibantargisgui, "setTheme", VALUEFUNC(_wrap_setTheme), -1);
    rb_define_module_function(mLibantargisgui, "loadTheme", VALUEFUNC(_wrap_loadTheme), -1);
    rb_define_module_function(mLibantargisgui, "loadThemeFile", VALUEFUNC(_wrap_loadThemeFile), -1);
    rb_define_module_function(mLibantargisgui, "addPoint", VALUEFUNC(_wrap_addPoint), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGMenuEvent", VALUEFUNC(_wrap_disown_AGMenuEvent), -1);
    
    cAGMenuEvent.klass = rb_define_class_under(mLibantargisgui, "AGMenuEvent", ((swig_class *) SWIGTYPE_p_AGEvent->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMenuEvent, (void *) &cAGMenuEvent);
    rb_define_alloc_func(cAGMenuEvent.klass, _wrap_AGMenuEvent_allocate);
    rb_define_method(cAGMenuEvent.klass, "initialize", VALUEFUNC(_wrap_new_AGMenuEvent), -1);
    rb_define_method(cAGMenuEvent.klass, "getName", VALUEFUNC(_wrap_AGMenuEvent_getName), -1);
    cAGMenuEvent.mark = 0;
    cAGMenuEvent.destroy = (void (*)(void *)) free_AGMenuEvent;
    rb_define_module_function(mLibantargisgui, "disown_AGMenu", VALUEFUNC(_wrap_disown_AGMenu), -1);
    
    cAGMenu.klass = rb_define_class_under(mLibantargisgui, "AGMenu", ((swig_class *) SWIGTYPE_p_AGVTiler->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGMenu, (void *) &cAGMenu);
    rb_define_alloc_func(cAGMenu.klass, _wrap_AGMenu_allocate);
    rb_define_method(cAGMenu.klass, "initialize", VALUEFUNC(_wrap_new_AGMenu), -1);
    rb_define_method(cAGMenu.klass, "show", VALUEFUNC(_wrap_AGMenu_show), -1);
    rb_define_method(cAGMenu.klass, "addItem", VALUEFUNC(_wrap_AGMenu_addItem), -1);
    rb_define_method(cAGMenu.klass, "addMenu", VALUEFUNC(_wrap_AGMenu_addMenu), -1);
    rb_define_method(cAGMenu.klass, "draw", VALUEFUNC(_wrap_AGMenu_draw), -1);
    rb_define_method(cAGMenu.klass, "eventItemSelected", VALUEFUNC(_wrap_AGMenu_eventItemSelected), -1);
    rb_define_method(cAGMenu.klass, "eventItemClicked", VALUEFUNC(_wrap_AGMenu_eventItemClicked), -1);
    rb_define_method(cAGMenu.klass, "sigSelected=", VALUEFUNC(_wrap_AGMenu_sigSelected_set), -1);
    rb_define_method(cAGMenu.klass, "sigSelected", VALUEFUNC(_wrap_AGMenu_sigSelected_get), -1);
    cAGMenu.mark = 0;
    cAGMenu.destroy = (void (*)(void *)) free_AGMenu;
    rb_define_module_function(mLibantargisgui, "disown_AGScreenWidget", VALUEFUNC(_wrap_disown_AGScreenWidget), -1);
    
    cAGScreenWidget.klass = rb_define_class_under(mLibantargisgui, "AGScreenWidget", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGScreenWidget, (void *) &cAGScreenWidget);
    rb_define_alloc_func(cAGScreenWidget.klass, _wrap_AGScreenWidget_allocate);
    rb_define_method(cAGScreenWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGScreenWidget), -1);
    rb_define_method(cAGScreenWidget.klass, "draw", VALUEFUNC(_wrap_AGScreenWidget_draw), -1);
    cAGScreenWidget.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGScreenWidget.destroy = (void (*)(void *)) free_AGScreenWidget;
    rb_define_const(mLibantargisgui,"EDIT_LEFT", INT2NUM(EDIT_LEFT));
    rb_define_const(mLibantargisgui,"EDIT_RIGHT", INT2NUM(EDIT_RIGHT));
    rb_define_const(mLibantargisgui,"EDIT_JUSTIFY", INT2NUM(EDIT_JUSTIFY));
    rb_define_const(mLibantargisgui,"EDIT_CENTER", INT2NUM(EDIT_CENTER));
    rb_define_const(mLibantargisgui,"EDIT_TOP", INT2NUM(EDIT_TOP));
    rb_define_const(mLibantargisgui,"EDIT_BOTTOM", INT2NUM(EDIT_BOTTOM));
    rb_define_const(mLibantargisgui,"EDIT_VCENTER", INT2NUM(EDIT_VCENTER));
    rb_define_module_function(mLibantargisgui, "disown_AGEditLine", VALUEFUNC(_wrap_disown_AGEditLine), -1);
    
    cAGEditLine.klass = rb_define_class_under(mLibantargisgui, "AGEditLine", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGEditLine, (void *) &cAGEditLine);
    rb_define_alloc_func(cAGEditLine.klass, _wrap_AGEditLine_allocate);
    rb_define_method(cAGEditLine.klass, "initialize", VALUEFUNC(_wrap_new_AGEditLine), -1);
    rb_define_method(cAGEditLine.klass, "setAlign", VALUEFUNC(_wrap_AGEditLine_setAlign), -1);
    rb_define_method(cAGEditLine.klass, "setVAlign", VALUEFUNC(_wrap_AGEditLine_setVAlign), -1);
    rb_define_method(cAGEditLine.klass, "draw", VALUEFUNC(_wrap_AGEditLine_draw), -1);
    rb_define_method(cAGEditLine.klass, "drawCursor", VALUEFUNC(_wrap_AGEditLine_drawCursor), -1);
    rb_define_method(cAGEditLine.klass, "height", VALUEFUNC(_wrap_AGEditLine_height), -1);
    rb_define_method(cAGEditLine.klass, "width", VALUEFUNC(_wrap_AGEditLine_width), -1);
    rb_define_method(cAGEditLine.klass, "insert", VALUEFUNC(_wrap_AGEditLine_insert), -1);
    rb_define_method(cAGEditLine.klass, "doDelete", VALUEFUNC(_wrap_AGEditLine_doDelete), -1);
    rb_define_method(cAGEditLine.klass, "split", VALUEFUNC(_wrap_AGEditLine_split), -1);
    rb_define_method(cAGEditLine.klass, "length", VALUEFUNC(_wrap_AGEditLine_length), -1);
    rb_define_method(cAGEditLine.klass, "append", VALUEFUNC(_wrap_AGEditLine_append), -1);
    rb_define_method(cAGEditLine.klass, "prepend", VALUEFUNC(_wrap_AGEditLine_prepend), -1);
    rb_define_method(cAGEditLine.klass, "getText", VALUEFUNC(_wrap_AGEditLine_getText), -1);
    rb_define_method(cAGEditLine.klass, "getFont", VALUEFUNC(_wrap_AGEditLine_getFont), -1);
    rb_define_method(cAGEditLine.klass, "setText", VALUEFUNC(_wrap_AGEditLine_setText), -1);
    rb_define_method(cAGEditLine.klass, "hardEnd", VALUEFUNC(_wrap_AGEditLine_hardEnd), -1);
    rb_define_method(cAGEditLine.klass, "setHardEnd", VALUEFUNC(_wrap_AGEditLine_setHardEnd), -1);
    rb_define_method(cAGEditLine.klass, "checkUnwrap", VALUEFUNC(_wrap_AGEditLine_checkUnwrap), -1);
    rb_define_method(cAGEditLine.klass, "checkWrap", VALUEFUNC(_wrap_AGEditLine_checkWrap), -1);
    rb_define_method(cAGEditLine.klass, "setFont", VALUEFUNC(_wrap_AGEditLine_setFont), -1);
    cAGEditLine.mark = 0;
    cAGEditLine.destroy = (void (*)(void *)) free_AGEditLine;
    rb_define_module_function(mLibantargisgui, "disown_AGEdit", VALUEFUNC(_wrap_disown_AGEdit), -1);
    
    cAGEdit.klass = rb_define_class_under(mLibantargisgui, "AGEdit", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGEdit, (void *) &cAGEdit);
    rb_define_alloc_func(cAGEdit.klass, _wrap_AGEdit_allocate);
    rb_define_method(cAGEdit.klass, "initialize", VALUEFUNC(_wrap_new_AGEdit), -1);
    rb_define_method(cAGEdit.klass, "draw", VALUEFUNC(_wrap_AGEdit_draw), -1);
    rb_define_method(cAGEdit.klass, "drawBackground", VALUEFUNC(_wrap_AGEdit_drawBackground), -1);
    rb_define_method(cAGEdit.klass, "eventKeyDown", VALUEFUNC(_wrap_AGEdit_eventKeyDown), -1);
    rb_define_method(cAGEdit.klass, "eventKeyUp", VALUEFUNC(_wrap_AGEdit_eventKeyUp), -1);
    rb_define_method(cAGEdit.klass, "setMulti", VALUEFUNC(_wrap_AGEdit_setMulti), -1);
    rb_define_method(cAGEdit.klass, "insert", VALUEFUNC(_wrap_AGEdit_insert), -1);
    rb_define_method(cAGEdit.klass, "doDelete", VALUEFUNC(_wrap_AGEdit_doDelete), -1);
    rb_define_method(cAGEdit.klass, "setText", VALUEFUNC(_wrap_AGEdit_setText), -1);
    rb_define_method(cAGEdit.klass, "setFont", VALUEFUNC(_wrap_AGEdit_setFont), -1);
    rb_define_method(cAGEdit.klass, "clear", VALUEFUNC(_wrap_AGEdit_clear), -1);
    rb_define_method(cAGEdit.klass, "setMutable", VALUEFUNC(_wrap_AGEdit_setMutable), -1);
    rb_define_method(cAGEdit.klass, "setAlign", VALUEFUNC(_wrap_AGEdit_setAlign), -1);
    rb_define_method(cAGEdit.klass, "setVAlign", VALUEFUNC(_wrap_AGEdit_setVAlign), -1);
    rb_define_method(cAGEdit.klass, "setBackground", VALUEFUNC(_wrap_AGEdit_setBackground), -1);
    rb_define_method(cAGEdit.klass, "setTheme", VALUEFUNC(_wrap_AGEdit_setTheme), -1);
    rb_define_method(cAGEdit.klass, "canFocus", VALUEFUNC(_wrap_AGEdit_canFocus), -1);
    rb_define_method(cAGEdit.klass, "getText", VALUEFUNC(_wrap_AGEdit_getText), -1);
    cAGEdit.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGEdit.destroy = (void (*)(void *)) free_AGEdit;
    rb_define_module_function(mLibantargisgui, "toAGEdit", VALUEFUNC(_wrap_toAGEdit), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGCheckBox", VALUEFUNC(_wrap_disown_AGCheckBox), -1);
    
    cAGCheckBox.klass = rb_define_class_under(mLibantargisgui, "AGCheckBox", ((swig_class *) SWIGTYPE_p_AGButton->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGCheckBox, (void *) &cAGCheckBox);
    rb_define_alloc_func(cAGCheckBox.klass, _wrap_AGCheckBox_allocate);
    rb_define_method(cAGCheckBox.klass, "initialize", VALUEFUNC(_wrap_new_AGCheckBox), -1);
    rb_define_method(cAGCheckBox.klass, "eventMouseClick", VALUEFUNC(_wrap_AGCheckBox_eventMouseClick), -1);
    cAGCheckBox.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGCheckBox.destroy = (void (*)(void *)) free_AGCheckBox;
    rb_define_module_function(mLibantargisgui, "disown_AGRadioGroup", VALUEFUNC(_wrap_disown_AGRadioGroup), -1);
    
    cAGRadioGroup.klass = rb_define_class_under(mLibantargisgui, "AGRadioGroup", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGRadioGroup, (void *) &cAGRadioGroup);
    rb_define_alloc_func(cAGRadioGroup.klass, _wrap_AGRadioGroup_allocate);
    rb_define_method(cAGRadioGroup.klass, "initialize", VALUEFUNC(_wrap_new_AGRadioGroup), -1);
    rb_define_method(cAGRadioGroup.klass, "eventChange", VALUEFUNC(_wrap_AGRadioGroup_eventChange), -1);
    rb_define_method(cAGRadioGroup.klass, "add", VALUEFUNC(_wrap_AGRadioGroup_add), -1);
    rb_define_method(cAGRadioGroup.klass, "erase", VALUEFUNC(_wrap_AGRadioGroup_erase), -1);
    rb_define_method(cAGRadioGroup.klass, "sigChanged=", VALUEFUNC(_wrap_AGRadioGroup_sigChanged_set), -1);
    rb_define_method(cAGRadioGroup.klass, "sigChanged", VALUEFUNC(_wrap_AGRadioGroup_sigChanged_get), -1);
    cAGRadioGroup.mark = 0;
    cAGRadioGroup.destroy = (void (*)(void *)) free_AGRadioGroup;
    rb_define_module_function(mLibantargisgui, "disown_AGRadio", VALUEFUNC(_wrap_disown_AGRadio), -1);
    
    cAGRadio.klass = rb_define_class_under(mLibantargisgui, "AGRadio", ((swig_class *) SWIGTYPE_p_AGCheckBox->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGRadio, (void *) &cAGRadio);
    rb_define_alloc_func(cAGRadio.klass, _wrap_AGRadio_allocate);
    rb_define_method(cAGRadio.klass, "initialize", VALUEFUNC(_wrap_new_AGRadio), -1);
    rb_define_method(cAGRadio.klass, "setGroup", VALUEFUNC(_wrap_AGRadio_setGroup), -1);
    rb_define_method(cAGRadio.klass, "deselect", VALUEFUNC(_wrap_AGRadio_deselect), -1);
    rb_define_method(cAGRadio.klass, "setChecked", VALUEFUNC(_wrap_AGRadio_setChecked), -1);
    cAGRadio.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGRadio.destroy = (void (*)(void *)) free_AGRadio;
    rb_define_module_function(mLibantargisgui, "disown_AGTable", VALUEFUNC(_wrap_disown_AGTable), -1);
    
    cAGTable.klass = rb_define_class_under(mLibantargisgui, "AGTable", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGTable, (void *) &cAGTable);
    rb_define_alloc_func(cAGTable.klass, _wrap_AGTable_allocate);
    rb_define_method(cAGTable.klass, "initialize", VALUEFUNC(_wrap_new_AGTable), -1);
    rb_define_method(cAGTable.klass, "addFixedColumn", VALUEFUNC(_wrap_AGTable_addFixedColumn), -1);
    rb_define_method(cAGTable.klass, "addFixedRow", VALUEFUNC(_wrap_AGTable_addFixedRow), -1);
    rb_define_method(cAGTable.klass, "addColumn", VALUEFUNC(_wrap_AGTable_addColumn), -1);
    rb_define_method(cAGTable.klass, "addRow", VALUEFUNC(_wrap_AGTable_addRow), -1);
    rb_define_method(cAGTable.klass, "addChild", VALUEFUNC(_wrap_AGTable_addChild), -1);
    rb_define_method(cAGTable.klass, "getClientRect", VALUEFUNC(_wrap_AGTable_getClientRect), -1);
    rb_define_method(cAGTable.klass, "arrange", VALUEFUNC(_wrap_AGTable_arrange), -1);
    rb_define_method(cAGTable.klass, "setWidth", VALUEFUNC(_wrap_AGTable_setWidth), -1);
    rb_define_method(cAGTable.klass, "setHeight", VALUEFUNC(_wrap_AGTable_setHeight), -1);
    cAGTable.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGTable.destroy = (void (*)(void *)) free_AGTable;
    rb_define_module_function(mLibantargisgui, "disown_AGWindow", VALUEFUNC(_wrap_disown_AGWindow), -1);
    
    cAGWindow.klass = rb_define_class_under(mLibantargisgui, "AGWindow", ((swig_class *) SWIGTYPE_p_AGTable->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGWindow, (void *) &cAGWindow);
    rb_define_alloc_func(cAGWindow.klass, _wrap_AGWindow_allocate);
    rb_define_method(cAGWindow.klass, "initialize", VALUEFUNC(_wrap_new_AGWindow), -1);
    rb_define_method(cAGWindow.klass, "addChild", VALUEFUNC(_wrap_AGWindow_addChild), -1);
    rb_define_method(cAGWindow.klass, "getClient", VALUEFUNC(_wrap_AGWindow_getClient), -1);
    rb_define_method(cAGWindow.klass, "eventMouseButtonDown", VALUEFUNC(_wrap_AGWindow_eventMouseButtonDown), -1);
    rb_define_method(cAGWindow.klass, "eventDragBy", VALUEFUNC(_wrap_AGWindow_eventDragBy), -1);
    rb_define_method(cAGWindow.klass, "close", VALUEFUNC(_wrap_AGWindow_close), -1);
    rb_define_method(cAGWindow.klass, "tryClose", VALUEFUNC(_wrap_AGWindow_tryClose), -1);
    rb_define_method(cAGWindow.klass, "getClientRect", VALUEFUNC(_wrap_AGWindow_getClientRect), -1);
    rb_define_method(cAGWindow.klass, "sigClose=", VALUEFUNC(_wrap_AGWindow_sigClose_set), -1);
    rb_define_method(cAGWindow.klass, "sigClose", VALUEFUNC(_wrap_AGWindow_sigClose_get), -1);
    cAGWindow.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGWindow.destroy = (void (*)(void *)) free_AGWindow;
    rb_define_module_function(mLibantargisgui, "toAGWindow", VALUEFUNC(_wrap_toAGWindow), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGImage", VALUEFUNC(_wrap_disown_AGImage), -1);
    
    cAGImage.klass = rb_define_class_under(mLibantargisgui, "AGImage", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGImage, (void *) &cAGImage);
    rb_define_alloc_func(cAGImage.klass, _wrap_AGImage_allocate);
    rb_define_method(cAGImage.klass, "initialize", VALUEFUNC(_wrap_new_AGImage), -1);
    rb_define_method(cAGImage.klass, "draw", VALUEFUNC(_wrap_AGImage_draw), -1);
    rb_define_method(cAGImage.klass, "setSurface", VALUEFUNC(_wrap_AGImage_setSurface), -1);
    cAGImage.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGImage.destroy = (void (*)(void *)) free_AGImage;
    rb_define_module_function(mLibantargisgui, "disown_AGCaption", VALUEFUNC(_wrap_disown_AGCaption), -1);
    
    cAGCaption.klass = rb_define_class_under(mLibantargisgui, "AGCaption", ((swig_class *) SWIGTYPE_p_AGText->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGCaption, (void *) &cAGCaption);
    rb_define_alloc_func(cAGCaption.klass, _wrap_AGCaption_allocate);
    rb_define_method(cAGCaption.klass, "initialize", VALUEFUNC(_wrap_new_AGCaption), -1);
    rb_define_method(cAGCaption.klass, "draw", VALUEFUNC(_wrap_AGCaption_draw), -1);
    rb_define_method(cAGCaption.klass, "setBackground", VALUEFUNC(_wrap_AGCaption_setBackground), -1);
    cAGCaption.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGCaption.destroy = (void (*)(void *)) free_AGCaption;
    
    cAGBackground.klass = rb_define_class_under(mLibantargisgui, "AGBackground", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGBackground, (void *) &cAGBackground);
    rb_define_alloc_func(cAGBackground.klass, _wrap_AGBackground_allocate);
    rb_define_method(cAGBackground.klass, "initialize", VALUEFUNC(_wrap_new_AGBackground), -1);
    rb_define_method(cAGBackground.klass, "draw", VALUEFUNC(_wrap_AGBackground_draw), -1);
    cAGBackground.mark = 0;
    cAGBackground.destroy = (void (*)(void *)) free_AGBackground;
    rb_define_module_function(mLibantargisgui, "disown_AGLayout", VALUEFUNC(_wrap_disown_AGLayout), -1);
    
    cAGLayout.klass = rb_define_class_under(mLibantargisgui, "AGLayout", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayout, (void *) &cAGLayout);
    rb_define_alloc_func(cAGLayout.klass, _wrap_AGLayout_allocate);
    rb_define_method(cAGLayout.klass, "initialize", VALUEFUNC(_wrap_new_AGLayout), -1);
    rb_define_method(cAGLayout.klass, "addTabIndex", VALUEFUNC(_wrap_AGLayout_addTabIndex), -1);
    cAGLayout.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGLayout.destroy = (void (*)(void *)) free_AGLayout;
    rb_define_module_function(mLibantargisgui, "parseNode", VALUEFUNC(_wrap_parseNode), -1);
    rb_define_module_function(mLibantargisgui, "parseChildren", VALUEFUNC(_wrap_parseChildren), -1);
    rb_define_module_function(mLibantargisgui, "getLayoutGeometry", VALUEFUNC(_wrap_getLayoutGeometry), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGLayoutCreator", VALUEFUNC(_wrap_disown_AGLayoutCreator), -1);
    
    cAGLayoutCreator.klass = rb_define_class_under(mLibantargisgui, "AGLayoutCreator", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayoutCreator, (void *) &cAGLayoutCreator);
    rb_define_alloc_func(cAGLayoutCreator.klass, _wrap_AGLayoutCreator_allocate);
    rb_define_method(cAGLayoutCreator.klass, "initialize", VALUEFUNC(_wrap_new_AGLayoutCreator), -1);
    rb_define_method(cAGLayoutCreator.klass, "create", VALUEFUNC(_wrap_AGLayoutCreator_create), -1);
    cAGLayoutCreator.mark = 0;
    cAGLayoutCreator.destroy = (void (*)(void *)) free_AGLayoutCreator;
    rb_define_module_function(mLibantargisgui, "getLayoutFactory", VALUEFUNC(_wrap_getLayoutFactory), -1);
    
    cAGLayoutFactory.klass = rb_define_class_under(mLibantargisgui, "AGLayoutFactory", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGLayoutFactory, (void *) &cAGLayoutFactory);
    rb_undef_alloc_func(cAGLayoutFactory.klass);
    rb_define_method(cAGLayoutFactory.klass, "addCreator", VALUEFUNC(_wrap_AGLayoutFactory_addCreator), -1);
    rb_define_method(cAGLayoutFactory.klass, "create", VALUEFUNC(_wrap_AGLayoutFactory_create), -1);
    cAGLayoutFactory.mark = 0;
    cAGLayoutFactory.destroy = (void (*)(void *)) free_AGLayoutFactory;
    
    cNode.klass = rb_define_class_under(mLibantargisgui, "Node", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Node, (void *) &cNode);
    rb_define_alloc_func(cNode.klass, _wrap_Node_allocate);
    rb_define_method(cNode.klass, "initialize", VALUEFUNC(_wrap_new_Node), -1);
    rb_define_method(cNode.klass, "setName", VALUEFUNC(_wrap_Node_setName), -1);
    rb_define_method(cNode.klass, "get_children", VALUEFUNC(_wrap_Node_get_children), -1);
    rb_define_method(cNode.klass, "getName", VALUEFUNC(_wrap_Node_getName), -1);
    rb_define_method(cNode.klass, "get_name", VALUEFUNC(_wrap_Node_get_name), -1);
    rb_define_method(cNode.klass, "setAttributes", VALUEFUNC(_wrap_Node_setAttributes), -1);
    rb_define_method(cNode.klass, "newChild", VALUEFUNC(_wrap_Node_newChild), -1);
    rb_define_method(cNode.klass, "add_child", VALUEFUNC(_wrap_Node_add_child), -1);
    rb_define_method(cNode.klass, "remove_child", VALUEFUNC(_wrap_Node_remove_child), -1);
    rb_define_method(cNode.klass, "begin", VALUEFUNC(_wrap_Node_begin), -1);
    rb_define_method(cNode.klass, "end", VALUEFUNC(_wrap_Node_end), -1);
    rb_define_method(cNode.klass, "setContent", VALUEFUNC(_wrap_Node_setContent), -1);
    rb_define_method(cNode.klass, "set", VALUEFUNC(_wrap_Node_set), -1);
    rb_define_method(cNode.klass, "get", VALUEFUNC(_wrap_Node_get), -1);
    rb_define_method(cNode.klass, "clear", VALUEFUNC(_wrap_Node_clear), -1);
    rb_define_method(cNode.klass, "escape", VALUEFUNC(_wrap_Node_escape), -1);
    rb_define_method(cNode.klass, "unescape", VALUEFUNC(_wrap_Node_unescape), -1);
    rb_define_method(cNode.klass, "getStart", VALUEFUNC(_wrap_Node_getStart), -1);
    rb_define_method(cNode.klass, "getEnd", VALUEFUNC(_wrap_Node_getEnd), -1);
    rb_define_method(cNode.klass, "indent", VALUEFUNC(_wrap_Node_indent), -1);
    rb_define_method(cNode.klass, "getContent", VALUEFUNC(_wrap_Node_getContent), -1);
    rb_define_method(cNode.klass, "toString", VALUEFUNC(_wrap_Node_toString), -1);
    rb_define_method(cNode.klass, "isTextNode", VALUEFUNC(_wrap_Node_isTextNode), -1);
    rb_define_method(cNode.klass, "getText", VALUEFUNC(_wrap_Node_getText), -1);
    rb_define_method(cNode.klass, "hasTextNode", VALUEFUNC(_wrap_Node_hasTextNode), -1);
    rb_define_method(cNode.klass, "size", VALUEFUNC(_wrap_Node_size), -1);
    cNode.mark = 0;
    cNode.destroy = (void (*)(void *)) free_Node;
    
    cDocument.klass = rb_define_class_under(mLibantargisgui, "Document", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Document, (void *) &cDocument);
    rb_define_alloc_func(cDocument.klass, _wrap_Document_allocate);
    rb_define_method(cDocument.klass, "initialize", VALUEFUNC(_wrap_new_Document), -1);
    rb_define_method(cDocument.klass, "parseFile", VALUEFUNC(_wrap_Document_parseFile), -1);
    rb_define_method(cDocument.klass, "root", VALUEFUNC(_wrap_Document_root), -1);
    rb_define_method(cDocument.klass, "get_root_node", VALUEFUNC(_wrap_Document_get_root_node), -1);
    rb_define_method(cDocument.klass, "toString", VALUEFUNC(_wrap_Document_toString), -1);
    rb_define_method(cDocument.klass, "parse_memory", VALUEFUNC(_wrap_Document_parse_memory), -1);
    rb_define_method(cDocument.klass, "parseMemory", VALUEFUNC(_wrap_Document_parseMemory), -1);
    rb_define_method(cDocument.klass, "get_document", VALUEFUNC(_wrap_Document_get_document), -1);
    cDocument.mark = 0;
    cDocument.destroy = (void (*)(void *)) free_Document;
    rb_define_module_function(mLibantargisgui, "disown_Parser", VALUEFUNC(_wrap_disown_Parser), -1);
    
    cParser.klass = rb_define_class_under(mLibantargisgui, "Parser", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Parser, (void *) &cParser);
    rb_define_alloc_func(cParser.klass, _wrap_Parser_allocate);
    rb_define_method(cParser.klass, "initialize", VALUEFUNC(_wrap_new_Parser), -1);
    rb_define_method(cParser.klass, "parse", VALUEFUNC(_wrap_Parser_parse), -1);
    rb_define_method(cParser.klass, "getLine", VALUEFUNC(_wrap_Parser_getLine), -1);
    rb_define_method(cParser.klass, "simpleTag", VALUEFUNC(_wrap_Parser_simpleTag), -1);
    rb_define_method(cParser.klass, "startTag", VALUEFUNC(_wrap_Parser_startTag), -1);
    rb_define_method(cParser.klass, "endTag", VALUEFUNC(_wrap_Parser_endTag), -1);
    rb_define_method(cParser.klass, "text", VALUEFUNC(_wrap_Parser_text), -1);
    rb_define_method(cParser.klass, "comment", VALUEFUNC(_wrap_Parser_comment), -1);
    rb_define_method(cParser.klass, "header", VALUEFUNC(_wrap_Parser_header), -1);
    cParser.mark = 0;
    cParser.destroy = (void (*)(void *)) free_Parser;
    rb_define_module_function(mLibantargisgui, "disown_DomParser", VALUEFUNC(_wrap_disown_DomParser), -1);
    
    cDomParser.klass = rb_define_class_under(mLibantargisgui, "DomParser", ((swig_class *) SWIGTYPE_p_Parser->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_DomParser, (void *) &cDomParser);
    rb_define_alloc_func(cDomParser.klass, _wrap_DomParser_allocate);
    rb_define_method(cDomParser.klass, "initialize", VALUEFUNC(_wrap_new_DomParser), -1);
    rb_define_method(cDomParser.klass, "simpleTag", VALUEFUNC(_wrap_DomParser_simpleTag), -1);
    rb_define_method(cDomParser.klass, "startTag", VALUEFUNC(_wrap_DomParser_startTag), -1);
    rb_define_method(cDomParser.klass, "endTag", VALUEFUNC(_wrap_DomParser_endTag), -1);
    rb_define_method(cDomParser.klass, "text", VALUEFUNC(_wrap_DomParser_text), -1);
    rb_define_method(cDomParser.klass, "comment", VALUEFUNC(_wrap_DomParser_comment), -1);
    rb_define_method(cDomParser.klass, "header", VALUEFUNC(_wrap_DomParser_header), -1);
    rb_define_method(cDomParser.klass, "parse", VALUEFUNC(_wrap_DomParser_parse), -1);
    cDomParser.mark = 0;
    cDomParser.destroy = (void (*)(void *)) free_DomParser;
    rb_define_module_function(mLibantargisgui, "getSoundManager", VALUEFUNC(_wrap_getSoundManager), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGSound", VALUEFUNC(_wrap_disown_AGSound), -1);
    
    cAGSound.klass = rb_define_class_under(mLibantargisgui, "AGSound", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGSound, (void *) &cAGSound);
    rb_define_alloc_func(cAGSound.klass, _wrap_AGSound_allocate);
    rb_define_method(cAGSound.klass, "initialize", VALUEFUNC(_wrap_new_AGSound), -1);
    rb_define_method(cAGSound.klass, "playMp3", VALUEFUNC(_wrap_AGSound_playMp3), -1);
    rb_define_method(cAGSound.klass, "stopMp3", VALUEFUNC(_wrap_AGSound_stopMp3), -1);
    rb_define_method(cAGSound.klass, "checkFinished", VALUEFUNC(_wrap_AGSound_checkFinished), -1);
    rb_define_method(cAGSound.klass, "sigMp3Finished=", VALUEFUNC(_wrap_AGSound_sigMp3Finished_set), -1);
    rb_define_method(cAGSound.klass, "sigMp3Finished", VALUEFUNC(_wrap_AGSound_sigMp3Finished_get), -1);
    cAGSound.mark = 0;
    cAGSound.destroy = (void (*)(void *)) free_AGSound;
    rb_define_module_function(mLibantargisgui, "disown_AGGLWidget", VALUEFUNC(_wrap_disown_AGGLWidget), -1);
    
    cAGGLWidget.klass = rb_define_class_under(mLibantargisgui, "AGGLWidget", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGGLWidget, (void *) &cAGGLWidget);
    rb_define_alloc_func(cAGGLWidget.klass, _wrap_AGGLWidget_allocate);
    rb_define_method(cAGGLWidget.klass, "initialize", VALUEFUNC(_wrap_new_AGGLWidget), -1);
    rb_define_method(cAGGLWidget.klass, "drawGL", VALUEFUNC(_wrap_AGGLWidget_drawGL), -1);
    rb_define_method(cAGGLWidget.klass, "drawAll", VALUEFUNC(_wrap_AGGLWidget_drawAll), -1);
    rb_define_method(cAGGLWidget.klass, "getRatio", VALUEFUNC(_wrap_AGGLWidget_getRatio), -1);
    rb_define_method(cAGGLWidget.klass, "setPerspective", VALUEFUNC(_wrap_AGGLWidget_setPerspective), -1);
    cAGGLWidget.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGGLWidget.destroy = (void (*)(void *)) free_AGGLWidget;
    rb_define_module_function(mLibantargisgui, "disown_AGColorButton", VALUEFUNC(_wrap_disown_AGColorButton), -1);
    
    cAGColorButton.klass = rb_define_class_under(mLibantargisgui, "AGColorButton", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGColorButton, (void *) &cAGColorButton);
    rb_define_alloc_func(cAGColorButton.klass, _wrap_AGColorButton_allocate);
    rb_define_method(cAGColorButton.klass, "initialize", VALUEFUNC(_wrap_new_AGColorButton), -1);
    rb_define_method(cAGColorButton.klass, "draw", VALUEFUNC(_wrap_AGColorButton_draw), -1);
    rb_define_method(cAGColorButton.klass, "getColor", VALUEFUNC(_wrap_AGColorButton_getColor), -1);
    rb_define_method(cAGColorButton.klass, "setColor", VALUEFUNC(_wrap_AGColorButton_setColor), -1);
    rb_define_method(cAGColorButton.klass, "eventMouseClick", VALUEFUNC(_wrap_AGColorButton_eventMouseClick), -1);
    cAGColorButton.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGColorButton.destroy = (void (*)(void *)) free_AGColorButton;
    rb_define_module_function(mLibantargisgui, "toAGColorButton", VALUEFUNC(_wrap_toAGColorButton), -1);
    rb_define_module_function(mLibantargisgui, "disown_AGDialog", VALUEFUNC(_wrap_disown_AGDialog), -1);
    
    cAGDialog.klass = rb_define_class_under(mLibantargisgui, "AGDialog", ((swig_class *) SWIGTYPE_p_AGLayout->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGDialog, (void *) &cAGDialog);
    rb_define_alloc_func(cAGDialog.klass, _wrap_AGDialog_allocate);
    rb_define_method(cAGDialog.klass, "initialize", VALUEFUNC(_wrap_new_AGDialog), -1);
    rb_define_method(cAGDialog.klass, "eventOk", VALUEFUNC(_wrap_AGDialog_eventOk), -1);
    rb_define_method(cAGDialog.klass, "eventCancel", VALUEFUNC(_wrap_AGDialog_eventCancel), -1);
    rb_define_method(cAGDialog.klass, "eventClose", VALUEFUNC(_wrap_AGDialog_eventClose), -1);
    cAGDialog.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGDialog.destroy = (void (*)(void *)) free_AGDialog;
    rb_define_module_function(mLibantargisgui, "initFS", VALUEFUNC(_wrap_initFS), -1);
    rb_define_module_function(mLibantargisgui, "loadFile", VALUEFUNC(_wrap_loadFile), -1);
    rb_define_module_function(mLibantargisgui, "saveFile", VALUEFUNC(_wrap_saveFile), -1);
    rb_define_module_function(mLibantargisgui, "fileExists", VALUEFUNC(_wrap_fileExists), -1);
    rb_define_module_function(mLibantargisgui, "getDirectory", VALUEFUNC(_wrap_getDirectory), -1);
    
    cAGListBoxItem.klass = rb_define_class_under(mLibantargisgui, "AGListBoxItem", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGListBoxItem, (void *) &cAGListBoxItem);
    rb_define_alloc_func(cAGListBoxItem.klass, _wrap_AGListBoxItem_allocate);
    rb_define_method(cAGListBoxItem.klass, "initialize", VALUEFUNC(_wrap_new_AGListBoxItem), -1);
    rb_define_method(cAGListBoxItem.klass, "id=", VALUEFUNC(_wrap_AGListBoxItem_id_set), -1);
    rb_define_method(cAGListBoxItem.klass, "id", VALUEFUNC(_wrap_AGListBoxItem_id_get), -1);
    rb_define_method(cAGListBoxItem.klass, "value=", VALUEFUNC(_wrap_AGListBoxItem_value_set), -1);
    rb_define_method(cAGListBoxItem.klass, "value", VALUEFUNC(_wrap_AGListBoxItem_value_get), -1);
    cAGListBoxItem.mark = 0;
    cAGListBoxItem.destroy = (void (*)(void *)) free_AGListBoxItem;
    rb_define_module_function(mLibantargisgui, "disown_AGListBox", VALUEFUNC(_wrap_disown_AGListBox), -1);
    
    cAGListBox.klass = rb_define_class_under(mLibantargisgui, "AGListBox", ((swig_class *) SWIGTYPE_p_AGWidget->clientdata)->klass);
    SWIG_TypeClientData(SWIGTYPE_p_AGListBox, (void *) &cAGListBox);
    rb_define_alloc_func(cAGListBox.klass, _wrap_AGListBox_allocate);
    rb_define_method(cAGListBox.klass, "initialize", VALUEFUNC(_wrap_new_AGListBox), -1);
    rb_define_method(cAGListBox.klass, "insertItem", VALUEFUNC(_wrap_AGListBox_insertItem), -1);
    rb_define_method(cAGListBox.klass, "selectItem", VALUEFUNC(_wrap_AGListBox_selectItem), -1);
    rb_define_method(cAGListBox.klass, "getSelectedID", VALUEFUNC(_wrap_AGListBox_getSelectedID), -1);
    rb_define_method(cAGListBox.klass, "getSelectedValue", VALUEFUNC(_wrap_AGListBox_getSelectedValue), -1);
    rb_define_method(cAGListBox.klass, "eventKeyDown", VALUEFUNC(_wrap_AGListBox_eventKeyDown), -1);
    rb_define_method(cAGListBox.klass, "sigSelect=", VALUEFUNC(_wrap_AGListBox_sigSelect_set), -1);
    rb_define_method(cAGListBox.klass, "sigSelect", VALUEFUNC(_wrap_AGListBox_sigSelect_get), -1);
    rb_define_method(cAGListBox.klass, "sigDoubleClick=", VALUEFUNC(_wrap_AGListBox_sigDoubleClick_set), -1);
    rb_define_method(cAGListBox.klass, "sigDoubleClick", VALUEFUNC(_wrap_AGListBox_sigDoubleClick_get), -1);
    rb_define_method(cAGListBox.klass, "draw", VALUEFUNC(_wrap_AGListBox_draw), -1);
    rb_define_method(cAGListBox.klass, "eventMouseClick", VALUEFUNC(_wrap_AGListBox_eventMouseClick), -1);
    rb_define_method(cAGListBox.klass, "clearList", VALUEFUNC(_wrap_AGListBox_clearList), -1);
    cAGListBox.mark = (void (*)(void *)) AGWidget_markfunc;
    cAGListBox.destroy = (void (*)(void *)) free_AGListBox;
    rb_define_module_function(mLibantargisgui, "toAGListBox", VALUEFUNC(_wrap_toAGListBox), -1);
    rb_define_const(mLibantargisgui,"SDLK_UNKNOWN", INT2NUM(SDLK_UNKNOWN));
    rb_define_const(mLibantargisgui,"SDLK_FIRST", INT2NUM(SDLK_FIRST));
    rb_define_const(mLibantargisgui,"SDLK_BACKSPACE", INT2NUM(SDLK_BACKSPACE));
    rb_define_const(mLibantargisgui,"SDLK_TAB", INT2NUM(SDLK_TAB));
    rb_define_const(mLibantargisgui,"SDLK_CLEAR", INT2NUM(SDLK_CLEAR));
    rb_define_const(mLibantargisgui,"SDLK_RETURN", INT2NUM(SDLK_RETURN));
    rb_define_const(mLibantargisgui,"SDLK_PAUSE", INT2NUM(SDLK_PAUSE));
    rb_define_const(mLibantargisgui,"SDLK_ESCAPE", INT2NUM(SDLK_ESCAPE));
    rb_define_const(mLibantargisgui,"SDLK_SPACE", INT2NUM(SDLK_SPACE));
    rb_define_const(mLibantargisgui,"SDLK_EXCLAIM", INT2NUM(SDLK_EXCLAIM));
    rb_define_const(mLibantargisgui,"SDLK_QUOTEDBL", INT2NUM(SDLK_QUOTEDBL));
    rb_define_const(mLibantargisgui,"SDLK_HASH", INT2NUM(SDLK_HASH));
    rb_define_const(mLibantargisgui,"SDLK_DOLLAR", INT2NUM(SDLK_DOLLAR));
    rb_define_const(mLibantargisgui,"SDLK_AMPERSAND", INT2NUM(SDLK_AMPERSAND));
    rb_define_const(mLibantargisgui,"SDLK_QUOTE", INT2NUM(SDLK_QUOTE));
    rb_define_const(mLibantargisgui,"SDLK_LEFTPAREN", INT2NUM(SDLK_LEFTPAREN));
    rb_define_const(mLibantargisgui,"SDLK_RIGHTPAREN", INT2NUM(SDLK_RIGHTPAREN));
    rb_define_const(mLibantargisgui,"SDLK_ASTERISK", INT2NUM(SDLK_ASTERISK));
    rb_define_const(mLibantargisgui,"SDLK_PLUS", INT2NUM(SDLK_PLUS));
    rb_define_const(mLibantargisgui,"SDLK_COMMA", INT2NUM(SDLK_COMMA));
    rb_define_const(mLibantargisgui,"SDLK_MINUS", INT2NUM(SDLK_MINUS));
    rb_define_const(mLibantargisgui,"SDLK_PERIOD", INT2NUM(SDLK_PERIOD));
    rb_define_const(mLibantargisgui,"SDLK_SLASH", INT2NUM(SDLK_SLASH));
    rb_define_const(mLibantargisgui,"SDLK_0", INT2NUM(SDLK_0));
    rb_define_const(mLibantargisgui,"SDLK_1", INT2NUM(SDLK_1));
    rb_define_const(mLibantargisgui,"SDLK_2", INT2NUM(SDLK_2));
    rb_define_const(mLibantargisgui,"SDLK_3", INT2NUM(SDLK_3));
    rb_define_const(mLibantargisgui,"SDLK_4", INT2NUM(SDLK_4));
    rb_define_const(mLibantargisgui,"SDLK_5", INT2NUM(SDLK_5));
    rb_define_const(mLibantargisgui,"SDLK_6", INT2NUM(SDLK_6));
    rb_define_const(mLibantargisgui,"SDLK_7", INT2NUM(SDLK_7));
    rb_define_const(mLibantargisgui,"SDLK_8", INT2NUM(SDLK_8));
    rb_define_const(mLibantargisgui,"SDLK_9", INT2NUM(SDLK_9));
    rb_define_const(mLibantargisgui,"SDLK_COLON", INT2NUM(SDLK_COLON));
    rb_define_const(mLibantargisgui,"SDLK_SEMICOLON", INT2NUM(SDLK_SEMICOLON));
    rb_define_const(mLibantargisgui,"SDLK_LESS", INT2NUM(SDLK_LESS));
    rb_define_const(mLibantargisgui,"SDLK_EQUALS", INT2NUM(SDLK_EQUALS));
    rb_define_const(mLibantargisgui,"SDLK_GREATER", INT2NUM(SDLK_GREATER));
    rb_define_const(mLibantargisgui,"SDLK_QUESTION", INT2NUM(SDLK_QUESTION));
    rb_define_const(mLibantargisgui,"SDLK_AT", INT2NUM(SDLK_AT));
    rb_define_const(mLibantargisgui,"SDLK_LEFTBRACKET", INT2NUM(SDLK_LEFTBRACKET));
    rb_define_const(mLibantargisgui,"SDLK_BACKSLASH", INT2NUM(SDLK_BACKSLASH));
    rb_define_const(mLibantargisgui,"SDLK_RIGHTBRACKET", INT2NUM(SDLK_RIGHTBRACKET));
    rb_define_const(mLibantargisgui,"SDLK_CARET", INT2NUM(SDLK_CARET));
    rb_define_const(mLibantargisgui,"SDLK_UNDERSCORE", INT2NUM(SDLK_UNDERSCORE));
    rb_define_const(mLibantargisgui,"SDLK_BACKQUOTE", INT2NUM(SDLK_BACKQUOTE));
    rb_define_const(mLibantargisgui,"SDLK_a", INT2NUM(SDLK_a));
    rb_define_const(mLibantargisgui,"SDLK_b", INT2NUM(SDLK_b));
    rb_define_const(mLibantargisgui,"SDLK_c", INT2NUM(SDLK_c));
    rb_define_const(mLibantargisgui,"SDLK_d", INT2NUM(SDLK_d));
    rb_define_const(mLibantargisgui,"SDLK_e", INT2NUM(SDLK_e));
    rb_define_const(mLibantargisgui,"SDLK_f", INT2NUM(SDLK_f));
    rb_define_const(mLibantargisgui,"SDLK_g", INT2NUM(SDLK_g));
    rb_define_const(mLibantargisgui,"SDLK_h", INT2NUM(SDLK_h));
    rb_define_const(mLibantargisgui,"SDLK_i", INT2NUM(SDLK_i));
    rb_define_const(mLibantargisgui,"SDLK_j", INT2NUM(SDLK_j));
    rb_define_const(mLibantargisgui,"SDLK_k", INT2NUM(SDLK_k));
    rb_define_const(mLibantargisgui,"SDLK_l", INT2NUM(SDLK_l));
    rb_define_const(mLibantargisgui,"SDLK_m", INT2NUM(SDLK_m));
    rb_define_const(mLibantargisgui,"SDLK_n", INT2NUM(SDLK_n));
    rb_define_const(mLibantargisgui,"SDLK_o", INT2NUM(SDLK_o));
    rb_define_const(mLibantargisgui,"SDLK_p", INT2NUM(SDLK_p));
    rb_define_const(mLibantargisgui,"SDLK_q", INT2NUM(SDLK_q));
    rb_define_const(mLibantargisgui,"SDLK_r", INT2NUM(SDLK_r));
    rb_define_const(mLibantargisgui,"SDLK_s", INT2NUM(SDLK_s));
    rb_define_const(mLibantargisgui,"SDLK_t", INT2NUM(SDLK_t));
    rb_define_const(mLibantargisgui,"SDLK_u", INT2NUM(SDLK_u));
    rb_define_const(mLibantargisgui,"SDLK_v", INT2NUM(SDLK_v));
    rb_define_const(mLibantargisgui,"SDLK_w", INT2NUM(SDLK_w));
    rb_define_const(mLibantargisgui,"SDLK_x", INT2NUM(SDLK_x));
    rb_define_const(mLibantargisgui,"SDLK_y", INT2NUM(SDLK_y));
    rb_define_const(mLibantargisgui,"SDLK_z", INT2NUM(SDLK_z));
    rb_define_const(mLibantargisgui,"SDLK_DELETE", INT2NUM(SDLK_DELETE));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_0", INT2NUM(SDLK_WORLD_0));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_1", INT2NUM(SDLK_WORLD_1));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_2", INT2NUM(SDLK_WORLD_2));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_3", INT2NUM(SDLK_WORLD_3));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_4", INT2NUM(SDLK_WORLD_4));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_5", INT2NUM(SDLK_WORLD_5));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_6", INT2NUM(SDLK_WORLD_6));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_7", INT2NUM(SDLK_WORLD_7));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_8", INT2NUM(SDLK_WORLD_8));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_9", INT2NUM(SDLK_WORLD_9));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_10", INT2NUM(SDLK_WORLD_10));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_11", INT2NUM(SDLK_WORLD_11));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_12", INT2NUM(SDLK_WORLD_12));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_13", INT2NUM(SDLK_WORLD_13));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_14", INT2NUM(SDLK_WORLD_14));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_15", INT2NUM(SDLK_WORLD_15));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_16", INT2NUM(SDLK_WORLD_16));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_17", INT2NUM(SDLK_WORLD_17));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_18", INT2NUM(SDLK_WORLD_18));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_19", INT2NUM(SDLK_WORLD_19));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_20", INT2NUM(SDLK_WORLD_20));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_21", INT2NUM(SDLK_WORLD_21));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_22", INT2NUM(SDLK_WORLD_22));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_23", INT2NUM(SDLK_WORLD_23));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_24", INT2NUM(SDLK_WORLD_24));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_25", INT2NUM(SDLK_WORLD_25));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_26", INT2NUM(SDLK_WORLD_26));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_27", INT2NUM(SDLK_WORLD_27));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_28", INT2NUM(SDLK_WORLD_28));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_29", INT2NUM(SDLK_WORLD_29));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_30", INT2NUM(SDLK_WORLD_30));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_31", INT2NUM(SDLK_WORLD_31));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_32", INT2NUM(SDLK_WORLD_32));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_33", INT2NUM(SDLK_WORLD_33));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_34", INT2NUM(SDLK_WORLD_34));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_35", INT2NUM(SDLK_WORLD_35));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_36", INT2NUM(SDLK_WORLD_36));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_37", INT2NUM(SDLK_WORLD_37));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_38", INT2NUM(SDLK_WORLD_38));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_39", INT2NUM(SDLK_WORLD_39));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_40", INT2NUM(SDLK_WORLD_40));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_41", INT2NUM(SDLK_WORLD_41));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_42", INT2NUM(SDLK_WORLD_42));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_43", INT2NUM(SDLK_WORLD_43));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_44", INT2NUM(SDLK_WORLD_44));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_45", INT2NUM(SDLK_WORLD_45));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_46", INT2NUM(SDLK_WORLD_46));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_47", INT2NUM(SDLK_WORLD_47));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_48", INT2NUM(SDLK_WORLD_48));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_49", INT2NUM(SDLK_WORLD_49));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_50", INT2NUM(SDLK_WORLD_50));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_51", INT2NUM(SDLK_WORLD_51));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_52", INT2NUM(SDLK_WORLD_52));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_53", INT2NUM(SDLK_WORLD_53));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_54", INT2NUM(SDLK_WORLD_54));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_55", INT2NUM(SDLK_WORLD_55));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_56", INT2NUM(SDLK_WORLD_56));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_57", INT2NUM(SDLK_WORLD_57));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_58", INT2NUM(SDLK_WORLD_58));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_59", INT2NUM(SDLK_WORLD_59));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_60", INT2NUM(SDLK_WORLD_60));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_61", INT2NUM(SDLK_WORLD_61));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_62", INT2NUM(SDLK_WORLD_62));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_63", INT2NUM(SDLK_WORLD_63));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_64", INT2NUM(SDLK_WORLD_64));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_65", INT2NUM(SDLK_WORLD_65));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_66", INT2NUM(SDLK_WORLD_66));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_67", INT2NUM(SDLK_WORLD_67));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_68", INT2NUM(SDLK_WORLD_68));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_69", INT2NUM(SDLK_WORLD_69));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_70", INT2NUM(SDLK_WORLD_70));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_71", INT2NUM(SDLK_WORLD_71));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_72", INT2NUM(SDLK_WORLD_72));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_73", INT2NUM(SDLK_WORLD_73));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_74", INT2NUM(SDLK_WORLD_74));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_75", INT2NUM(SDLK_WORLD_75));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_76", INT2NUM(SDLK_WORLD_76));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_77", INT2NUM(SDLK_WORLD_77));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_78", INT2NUM(SDLK_WORLD_78));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_79", INT2NUM(SDLK_WORLD_79));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_80", INT2NUM(SDLK_WORLD_80));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_81", INT2NUM(SDLK_WORLD_81));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_82", INT2NUM(SDLK_WORLD_82));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_83", INT2NUM(SDLK_WORLD_83));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_84", INT2NUM(SDLK_WORLD_84));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_85", INT2NUM(SDLK_WORLD_85));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_86", INT2NUM(SDLK_WORLD_86));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_87", INT2NUM(SDLK_WORLD_87));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_88", INT2NUM(SDLK_WORLD_88));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_89", INT2NUM(SDLK_WORLD_89));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_90", INT2NUM(SDLK_WORLD_90));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_91", INT2NUM(SDLK_WORLD_91));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_92", INT2NUM(SDLK_WORLD_92));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_93", INT2NUM(SDLK_WORLD_93));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_94", INT2NUM(SDLK_WORLD_94));
    rb_define_const(mLibantargisgui,"SDLK_WORLD_95", INT2NUM(SDLK_WORLD_95));
    rb_define_const(mLibantargisgui,"SDLK_KP0", INT2NUM(SDLK_KP0));
    rb_define_const(mLibantargisgui,"SDLK_KP1", INT2NUM(SDLK_KP1));
    rb_define_const(mLibantargisgui,"SDLK_KP2", INT2NUM(SDLK_KP2));
    rb_define_const(mLibantargisgui,"SDLK_KP3", INT2NUM(SDLK_KP3));
    rb_define_const(mLibantargisgui,"SDLK_KP4", INT2NUM(SDLK_KP4));
    rb_define_const(mLibantargisgui,"SDLK_KP5", INT2NUM(SDLK_KP5));
    rb_define_const(mLibantargisgui,"SDLK_KP6", INT2NUM(SDLK_KP6));
    rb_define_const(mLibantargisgui,"SDLK_KP7", INT2NUM(SDLK_KP7));
    rb_define_const(mLibantargisgui,"SDLK_KP8", INT2NUM(SDLK_KP8));
    rb_define_const(mLibantargisgui,"SDLK_KP9", INT2NUM(SDLK_KP9));
    rb_define_const(mLibantargisgui,"SDLK_KP_PERIOD", INT2NUM(SDLK_KP_PERIOD));
    rb_define_const(mLibantargisgui,"SDLK_KP_DIVIDE", INT2NUM(SDLK_KP_DIVIDE));
    rb_define_const(mLibantargisgui,"SDLK_KP_MULTIPLY", INT2NUM(SDLK_KP_MULTIPLY));
    rb_define_const(mLibantargisgui,"SDLK_KP_MINUS", INT2NUM(SDLK_KP_MINUS));
    rb_define_const(mLibantargisgui,"SDLK_KP_PLUS", INT2NUM(SDLK_KP_PLUS));
    rb_define_const(mLibantargisgui,"SDLK_KP_ENTER", INT2NUM(SDLK_KP_ENTER));
    rb_define_const(mLibantargisgui,"SDLK_KP_EQUALS", INT2NUM(SDLK_KP_EQUALS));
    rb_define_const(mLibantargisgui,"SDLK_UP", INT2NUM(SDLK_UP));
    rb_define_const(mLibantargisgui,"SDLK_DOWN", INT2NUM(SDLK_DOWN));
    rb_define_const(mLibantargisgui,"SDLK_RIGHT", INT2NUM(SDLK_RIGHT));
    rb_define_const(mLibantargisgui,"SDLK_LEFT", INT2NUM(SDLK_LEFT));
    rb_define_const(mLibantargisgui,"SDLK_INSERT", INT2NUM(SDLK_INSERT));
    rb_define_const(mLibantargisgui,"SDLK_HOME", INT2NUM(SDLK_HOME));
    rb_define_const(mLibantargisgui,"SDLK_END", INT2NUM(SDLK_END));
    rb_define_const(mLibantargisgui,"SDLK_PAGEUP", INT2NUM(SDLK_PAGEUP));
    rb_define_const(mLibantargisgui,"SDLK_PAGEDOWN", INT2NUM(SDLK_PAGEDOWN));
    rb_define_const(mLibantargisgui,"SDLK_F1", INT2NUM(SDLK_F1));
    rb_define_const(mLibantargisgui,"SDLK_F2", INT2NUM(SDLK_F2));
    rb_define_const(mLibantargisgui,"SDLK_F3", INT2NUM(SDLK_F3));
    rb_define_const(mLibantargisgui,"SDLK_F4", INT2NUM(SDLK_F4));
    rb_define_const(mLibantargisgui,"SDLK_F5", INT2NUM(SDLK_F5));
    rb_define_const(mLibantargisgui,"SDLK_F6", INT2NUM(SDLK_F6));
    rb_define_const(mLibantargisgui,"SDLK_F7", INT2NUM(SDLK_F7));
    rb_define_const(mLibantargisgui,"SDLK_F8", INT2NUM(SDLK_F8));
    rb_define_const(mLibantargisgui,"SDLK_F9", INT2NUM(SDLK_F9));
    rb_define_const(mLibantargisgui,"SDLK_F10", INT2NUM(SDLK_F10));
    rb_define_const(mLibantargisgui,"SDLK_F11", INT2NUM(SDLK_F11));
    rb_define_const(mLibantargisgui,"SDLK_F12", INT2NUM(SDLK_F12));
    rb_define_const(mLibantargisgui,"SDLK_F13", INT2NUM(SDLK_F13));
    rb_define_const(mLibantargisgui,"SDLK_F14", INT2NUM(SDLK_F14));
    rb_define_const(mLibantargisgui,"SDLK_F15", INT2NUM(SDLK_F15));
    rb_define_const(mLibantargisgui,"SDLK_NUMLOCK", INT2NUM(SDLK_NUMLOCK));
    rb_define_const(mLibantargisgui,"SDLK_CAPSLOCK", INT2NUM(SDLK_CAPSLOCK));
    rb_define_const(mLibantargisgui,"SDLK_SCROLLOCK", INT2NUM(SDLK_SCROLLOCK));
    rb_define_const(mLibantargisgui,"SDLK_RSHIFT", INT2NUM(SDLK_RSHIFT));
    rb_define_const(mLibantargisgui,"SDLK_LSHIFT", INT2NUM(SDLK_LSHIFT));
    rb_define_const(mLibantargisgui,"SDLK_RCTRL", INT2NUM(SDLK_RCTRL));
    rb_define_const(mLibantargisgui,"SDLK_LCTRL", INT2NUM(SDLK_LCTRL));
    rb_define_const(mLibantargisgui,"SDLK_RALT", INT2NUM(SDLK_RALT));
    rb_define_const(mLibantargisgui,"SDLK_LALT", INT2NUM(SDLK_LALT));
    rb_define_const(mLibantargisgui,"SDLK_RMETA", INT2NUM(SDLK_RMETA));
    rb_define_const(mLibantargisgui,"SDLK_LMETA", INT2NUM(SDLK_LMETA));
    rb_define_const(mLibantargisgui,"SDLK_LSUPER", INT2NUM(SDLK_LSUPER));
    rb_define_const(mLibantargisgui,"SDLK_RSUPER", INT2NUM(SDLK_RSUPER));
    rb_define_const(mLibantargisgui,"SDLK_MODE", INT2NUM(SDLK_MODE));
    rb_define_const(mLibantargisgui,"SDLK_COMPOSE", INT2NUM(SDLK_COMPOSE));
    rb_define_const(mLibantargisgui,"SDLK_HELP", INT2NUM(SDLK_HELP));
    rb_define_const(mLibantargisgui,"SDLK_PRINT", INT2NUM(SDLK_PRINT));
    rb_define_const(mLibantargisgui,"SDLK_SYSREQ", INT2NUM(SDLK_SYSREQ));
    rb_define_const(mLibantargisgui,"SDLK_BREAK", INT2NUM(SDLK_BREAK));
    rb_define_const(mLibantargisgui,"SDLK_MENU", INT2NUM(SDLK_MENU));
    rb_define_const(mLibantargisgui,"SDLK_POWER", INT2NUM(SDLK_POWER));
    rb_define_const(mLibantargisgui,"SDLK_EURO", INT2NUM(SDLK_EURO));
    rb_define_const(mLibantargisgui,"SDLK_UNDO", INT2NUM(SDLK_UNDO));
    rb_define_const(mLibantargisgui,"SDLK_LAST", INT2NUM(SDLK_LAST));
    rb_define_const(mLibantargisgui,"KMOD_NONE", INT2NUM(KMOD_NONE));
    rb_define_const(mLibantargisgui,"KMOD_LSHIFT", INT2NUM(KMOD_LSHIFT));
    rb_define_const(mLibantargisgui,"KMOD_RSHIFT", INT2NUM(KMOD_RSHIFT));
    rb_define_const(mLibantargisgui,"KMOD_LCTRL", INT2NUM(KMOD_LCTRL));
    rb_define_const(mLibantargisgui,"KMOD_RCTRL", INT2NUM(KMOD_RCTRL));
    rb_define_const(mLibantargisgui,"KMOD_LALT", INT2NUM(KMOD_LALT));
    rb_define_const(mLibantargisgui,"KMOD_RALT", INT2NUM(KMOD_RALT));
    rb_define_const(mLibantargisgui,"KMOD_LMETA", INT2NUM(KMOD_LMETA));
    rb_define_const(mLibantargisgui,"KMOD_RMETA", INT2NUM(KMOD_RMETA));
    rb_define_const(mLibantargisgui,"KMOD_NUM", INT2NUM(KMOD_NUM));
    rb_define_const(mLibantargisgui,"KMOD_CAPS", INT2NUM(KMOD_CAPS));
    rb_define_const(mLibantargisgui,"KMOD_MODE", INT2NUM(KMOD_MODE));
    rb_define_const(mLibantargisgui,"KMOD_RESERVED", INT2NUM(KMOD_RESERVED));
    rb_define_module_function(mLibantargisgui, "disown_AGPainter", VALUEFUNC(_wrap_disown_AGPainter), -1);
    
    cAGPainter.klass = rb_define_class_under(mLibantargisgui, "AGPainter", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_AGPainter, (void *) &cAGPainter);
    rb_define_alloc_func(cAGPainter.klass, _wrap_AGPainter_allocate);
    rb_define_method(cAGPainter.klass, "initialize", VALUEFUNC(_wrap_new_AGPainter), -1);
    rb_define_method(cAGPainter.klass, "putPixel", VALUEFUNC(_wrap_AGPainter_putPixel), -1);
    rb_define_method(cAGPainter.klass, "getPixel", VALUEFUNC(_wrap_AGPainter_getPixel), -1);
    rb_define_method(cAGPainter.klass, "drawCircle", VALUEFUNC(_wrap_AGPainter_drawCircle), -1);
    rb_define_method(cAGPainter.klass, "blitTri", VALUEFUNC(_wrap_AGPainter_blitTri), -1);
    rb_define_method(cAGPainter.klass, "blit", VALUEFUNC(_wrap_AGPainter_blit), -1);
    rb_define_method(cAGPainter.klass, "tile", VALUEFUNC(_wrap_AGPainter_tile), -1);
    rb_define_method(cAGPainter.klass, "transform", VALUEFUNC(_wrap_AGPainter_transform), -1);
    rb_define_method(cAGPainter.klass, "setNull", VALUEFUNC(_wrap_AGPainter_setNull), -1);
    rb_define_method(cAGPainter.klass, "renderText", VALUEFUNC(_wrap_AGPainter_renderText), -1);
    rb_define_method(cAGPainter.klass, "getRect", VALUEFUNC(_wrap_AGPainter_getRect), -1);
    rb_define_method(cAGPainter.klass, "drawGradient", VALUEFUNC(_wrap_AGPainter_drawGradient), -1);
    rb_define_method(cAGPainter.klass, "drawBorder", VALUEFUNC(_wrap_AGPainter_drawBorder), -1);
    rb_define_method(cAGPainter.klass, "drawRect", VALUEFUNC(_wrap_AGPainter_drawRect), -1);
    rb_define_method(cAGPainter.klass, "drawLine", VALUEFUNC(_wrap_AGPainter_drawLine), -1);
    cAGPainter.mark = 0;
    cAGPainter.destroy = (void (*)(void *)) free_AGPainter;
    
    cAGNodeList.klass = rb_define_class_under(mLibantargisgui, "AGNodeList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTNode_t, (void *) &cAGNodeList);
    rb_include_module(cAGNodeList.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGNodeList.klass, _wrap_AGNodeList_allocate);
    rb_define_method(cAGNodeList.klass, "initialize", VALUEFUNC(_wrap_new_AGNodeList), -1);
    rb_define_method(cAGNodeList.klass, "length", VALUEFUNC(_wrap_AGNodeList___len__), -1);
    rb_define_method(cAGNodeList.klass, "empty?", VALUEFUNC(_wrap_AGNodeList_emptyq___), -1);
    rb_define_method(cAGNodeList.klass, "clear", VALUEFUNC(_wrap_AGNodeList_clear), -1);
    rb_define_method(cAGNodeList.klass, "push", VALUEFUNC(_wrap_AGNodeList_push), -1);
    rb_define_method(cAGNodeList.klass, "pop", VALUEFUNC(_wrap_AGNodeList_pop), -1);
    rb_define_method(cAGNodeList.klass, "[]", VALUEFUNC(_wrap_AGNodeList___getitem__), -1);
    rb_define_method(cAGNodeList.klass, "[]=", VALUEFUNC(_wrap_AGNodeList___setitem__), -1);
    rb_define_method(cAGNodeList.klass, "each", VALUEFUNC(_wrap_AGNodeList_each), -1);
    cAGNodeList.mark = 0;
    cAGNodeList.destroy = (void (*)(void *)) free_std_vector_Sl_Node_Sg_;
    
    cAGNodePList.klass = rb_define_class_under(mLibantargisgui, "AGNodePList", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTNode_p_t, (void *) &cAGNodePList);
    rb_include_module(cAGNodePList.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGNodePList.klass, _wrap_AGNodePList_allocate);
    rb_define_method(cAGNodePList.klass, "initialize", VALUEFUNC(_wrap_new_AGNodePList), -1);
    rb_define_method(cAGNodePList.klass, "length", VALUEFUNC(_wrap_AGNodePList___len__), -1);
    rb_define_method(cAGNodePList.klass, "empty?", VALUEFUNC(_wrap_AGNodePList_emptyq___), -1);
    rb_define_method(cAGNodePList.klass, "clear", VALUEFUNC(_wrap_AGNodePList_clear), -1);
    rb_define_method(cAGNodePList.klass, "push", VALUEFUNC(_wrap_AGNodePList_push), -1);
    rb_define_method(cAGNodePList.klass, "pop", VALUEFUNC(_wrap_AGNodePList_pop), -1);
    rb_define_method(cAGNodePList.klass, "[]", VALUEFUNC(_wrap_AGNodePList___getitem__), -1);
    rb_define_method(cAGNodePList.klass, "[]=", VALUEFUNC(_wrap_AGNodePList___setitem__), -1);
    rb_define_method(cAGNodePList.klass, "each", VALUEFUNC(_wrap_AGNodePList_each), -1);
    cAGNodePList.mark = 0;
    cAGNodePList.destroy = (void (*)(void *)) free_std_vector_Sl_Node_Sm__Sg_;
    
    cAGVector3List.klass = rb_define_class_under(mLibantargisgui, "AGVector3List", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTAGVector3_t, (void *) &cAGVector3List);
    rb_include_module(cAGVector3List.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGVector3List.klass, _wrap_AGVector3List_allocate);
    rb_define_method(cAGVector3List.klass, "initialize", VALUEFUNC(_wrap_new_AGVector3List), -1);
    rb_define_method(cAGVector3List.klass, "length", VALUEFUNC(_wrap_AGVector3List___len__), -1);
    rb_define_method(cAGVector3List.klass, "empty?", VALUEFUNC(_wrap_AGVector3List_emptyq___), -1);
    rb_define_method(cAGVector3List.klass, "clear", VALUEFUNC(_wrap_AGVector3List_clear), -1);
    rb_define_method(cAGVector3List.klass, "push", VALUEFUNC(_wrap_AGVector3List_push), -1);
    rb_define_method(cAGVector3List.klass, "pop", VALUEFUNC(_wrap_AGVector3List_pop), -1);
    rb_define_method(cAGVector3List.klass, "[]", VALUEFUNC(_wrap_AGVector3List___getitem__), -1);
    rb_define_method(cAGVector3List.klass, "[]=", VALUEFUNC(_wrap_AGVector3List___setitem__), -1);
    rb_define_method(cAGVector3List.klass, "each", VALUEFUNC(_wrap_AGVector3List_each), -1);
    cAGVector3List.mark = 0;
    cAGVector3List.destroy = (void (*)(void *)) free_std_vector_Sl_AGVector3_Sg_;
    
    cAGVector4List.klass = rb_define_class_under(mLibantargisgui, "AGVector4List", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTAGVector4_t, (void *) &cAGVector4List);
    rb_include_module(cAGVector4List.klass, rb_eval_string("Enumerable"));
    rb_define_alloc_func(cAGVector4List.klass, _wrap_AGVector4List_allocate);
    rb_define_method(cAGVector4List.klass, "initialize", VALUEFUNC(_wrap_new_AGVector4List), -1);
    rb_define_method(cAGVector4List.klass, "length", VALUEFUNC(_wrap_AGVector4List___len__), -1);
    rb_define_method(cAGVector4List.klass, "empty?", VALUEFUNC(_wrap_AGVector4List_emptyq___), -1);
    rb_define_method(cAGVector4List.klass, "clear", VALUEFUNC(_wrap_AGVector4List_clear), -1);
    rb_define_method(cAGVector4List.klass, "push", VALUEFUNC(_wrap_AGVector4List_push), -1);
    rb_define_method(cAGVector4List.klass, "pop", VALUEFUNC(_wrap_AGVector4List_pop), -1);
    rb_define_method(cAGVector4List.klass, "[]", VALUEFUNC(_wrap_AGVector4List___getitem__), -1);
    rb_define_method(cAGVector4List.klass, "[]=", VALUEFUNC(_wrap_AGVector4List___setitem__), -1);
    rb_define_method(cAGVector4List.klass, "each", VALUEFUNC(_wrap_AGVector4List_each), -1);
    cAGVector4List.mark = 0;
    cAGVector4List.destroy = (void (*)(void *)) free_std_vector_Sl_AGVector4_Sg_;
}

